(self["webpackChunkmezzio_inertia"] = self["webpackChunkmezzio_inertia"] || []).push([["app"],{

/***/ "./assets/js/pages lazy recursive ^\\.\\/.*$":
/*!*********************************************************!*\
  !*** ./assets/js/pages/ lazy ^\.\/.*$ namespace object ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./Home": [
		"./assets/js/pages/Home/index.js",
		"assets_js_pages_Home_index_js"
	],
	"./Home/": [
		"./assets/js/pages/Home/index.js",
		"assets_js_pages_Home_index_js"
	],
	"./Home/index": [
		"./assets/js/pages/Home/index.js",
		"assets_js_pages_Home_index_js"
	],
	"./Home/index.js": [
		"./assets/js/pages/Home/index.js",
		"assets_js_pages_Home_index_js"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./assets/js/pages lazy recursive ^\\.\\/.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./node_modules/@inertiajs/inertia/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var t=e(__webpack_require__(/*! axios */ "./node_modules/axios/index.js")),n=e(__webpack_require__(/*! qs */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/index.js")),i=e(__webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js"));function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}var r={modal:null,listener:null,show:function(e){var t=this;"object"==typeof e&&(e="All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>"+JSON.stringify(e));var n=document.createElement("html");n.innerHTML=e,n.querySelectorAll("a").forEach(function(e){return e.setAttribute("target","_top")}),this.modal=document.createElement("div"),this.modal.style.position="fixed",this.modal.style.width="100vw",this.modal.style.height="100vh",this.modal.style.padding="50px",this.modal.style.boxSizing="border-box",this.modal.style.backgroundColor="rgba(0, 0, 0, .6)",this.modal.style.zIndex=2e5,this.modal.addEventListener("click",function(){return t.hide()});var i=document.createElement("iframe");i.style.backgroundColor="white",i.style.borderRadius="5px",i.style.width="100%",i.style.height="100%",this.modal.appendChild(i),document.body.prepend(this.modal),document.body.style.overflow="hidden",i.contentWindow.document.open(),i.contentWindow.document.write(n.outerHTML),i.contentWindow.document.close(),this.listener=this.hideOnEscape.bind(this),document.addEventListener("keydown",this.listener)},hide:function(){this.modal.outerHTML="",this.modal=null,document.body.style.overflow="visible",document.removeEventListener("keydown",this.listener)},hideOnEscape:function(e){27===e.keyCode&&this.hide()}};function s(e,t){return document.dispatchEvent(new CustomEvent("inertia:"+e,t))}function a(e){return s("finish",{detail:{visit:e}})}function l(e){return s("navigate",{detail:{page:e}})}function c(e){return new URL(e,window.location)}function d(e,t,o){return"get"===e&&Object.keys(o).length&&(t.search=n.stringify(i(n.parse(t.search,{ignoreQueryPrefix:!0}),o),{encodeValuesOnly:!0,arrayFormat:"brackets"}),o={}),[t,o]}function u(e){return(e=new URL(e.href)).hash="",e}function h(e,t,n){if(void 0===t&&(t=new FormData),void 0===n&&(n=null),null===e||"undefined"===e||0===e.length)return t.append(n,e);for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&v(t,p(n,i),e[i]);return t}function p(e,t){return e?e+"["+t+"]":t}function v(e,t,n){return n instanceof Date?e.append(t,n.toISOString()):n instanceof File?e.append(t,n,n.name):n instanceof Blob?e.append(t,n):"boolean"==typeof n?e.append(t,n?"1":"0"):null===n?e.append(t,""):"object"!=typeof n?e.append(t,n):void h(n,e,t)}exports.Inertia={resolveComponent:null,resolveErrors:function(e){return e.props.errors||{}},swapComponent:null,transformProps:function(e){return e},activeVisit:null,visitId:null,page:null,init:function(e){var t=e.initialPage,n=e.resolveErrors,i=e.swapComponent,o=e.transformProps;this.resolveComponent=e.resolveComponent,this.resolveErrors=n||this.resolveErrors,this.swapComponent=i,this.transformProps=o||this.transformProps,this.handleInitialPageVisit(t),this.setupEventListeners()},handleInitialPageVisit:function(e){this.isBackForwardVisit()?this.handleBackForwardVisit(e):this.isLocationVisit()?this.handleLocationVisit(e):(e.url+=window.location.hash,this.setPage(e)),l(e)},setupEventListeners:function(){var e,t;window.addEventListener("popstate",this.handlePopstateEvent.bind(this)),document.addEventListener("scroll",(e=this.handleScrollEvent.bind(this),t=null,function(){var n=arguments,i=this;clearTimeout(t),t=setTimeout(function(){return e.apply(i,n)},100)}),!0)},scrollRegions:function(){return document.querySelectorAll("[scroll-region]")},handleScrollEvent:function(e){"function"==typeof e.target.hasAttribute&&e.target.hasAttribute("scroll-region")&&this.saveScrollPositions()},saveScrollPositions:function(){this.replaceState(o({},this.page,{scrollRegions:Array.prototype.slice.call(this.scrollRegions()).map(function(e){return{top:e.scrollTop,left:e.scrollLeft}})}))},resetScrollPositions:function(){var e;document.documentElement.scrollTop=0,document.documentElement.scrollLeft=0,this.scrollRegions().forEach(function(e){e.scrollTop=0,e.scrollLeft=0}),this.saveScrollPositions(),window.location.hash&&(null==(e=document.getElementById(window.location.hash.slice(1)))||e.scrollIntoView())},restoreScrollPositions:function(){var e=this;this.page.scrollRegions&&this.scrollRegions().forEach(function(t,n){t.scrollTop=e.page.scrollRegions[n].top,t.scrollLeft=e.page.scrollRegions[n].left})},isBackForwardVisit:function(){return window.history.state&&window.performance&&window.performance.getEntriesByType("navigation").length&&"back_forward"===window.performance.getEntriesByType("navigation")[0].type},handleBackForwardVisit:function(e){var t=this;window.history.state.version=e.version,this.setPage(window.history.state,{preserveScroll:!0}).then(function(){t.restoreScrollPositions()})},locationVisit:function(e,t){try{window.sessionStorage.setItem("inertiaLocationVisit",JSON.stringify({preserveScroll:t})),window.location.href=e.href,u(window.location).href===u(e).href&&window.location.reload()}catch(e){return!1}},isLocationVisit:function(){try{return null!==window.sessionStorage.getItem("inertiaLocationVisit")}catch(e){return!1}},handleLocationVisit:function(e){var t,n,i,o,r=this,s=JSON.parse(window.sessionStorage.getItem("inertiaLocationVisit"));window.sessionStorage.removeItem("inertiaLocationVisit"),e.url+=window.location.hash,e.rememberedState=null!=(t=null==(n=window.history.state)?void 0:n.rememberedState)?t:{},e.scrollRegions=null!=(i=null==(o=window.history.state)?void 0:o.scrollRegions)?i:[],this.setPage(e,{preserveScroll:s.preserveScroll}).then(function(){s.preserveScroll&&r.restoreScrollPositions()})},isLocationVisitResponse:function(e){return e&&409===e.status&&e.headers["x-inertia-location"]},isInertiaResponse:function(e){return null==e?void 0:e.headers["x-inertia"]},createVisitId:function(){return this.visitId={},this.visitId},cancelVisit:function(e,t){var n=t.cancelled,i=void 0!==n&&n,o=t.interrupted,r=void 0!==o&&o;!e||e.completed||e.cancelled||e.interrupted||(e.cancelToken.cancel(),e.onCancel(),e.completed=!1,e.cancelled=i,e.interrupted=r,a(e),e.onFinish(e))},finishVisit:function(e){e.cancelled||e.interrupted||(e.completed=!0,e.cancelled=!1,e.interrupted=!1,a(e),e.onFinish(e))},visit:function(e,n){var i=this,a=void 0===n?{}:n,l=a.method,p=void 0===l?"get":l,v=a.data,f=void 0===v?{}:v,m=a.replace,g=void 0!==m&&m,w=a.preserveScroll,y=void 0!==w&&w,S=a.preserveState,b=void 0!==S&&S,P=a.only,I=void 0===P?[]:P,E=a.headers,V=void 0===E?{}:E,L=a.errorBag,C=void 0===L?null:L,k=a.forceFormData,x=void 0!==k&&k,R=a.onCancelToken,T=void 0===R?function(){return{}}:R,O=a.onBefore,j=void 0===O?function(){return{}}:O,F=a.onStart,B=void 0===F?function(){return{}}:F,q=a.onProgress,A=void 0===q?function(){return{}}:q,D=a.onFinish,N=void 0===D?function(){return{}}:D,X=a.onCancel,J=void 0===X?function(){return{}}:X,H=a.onSuccess,M=void 0===H?function(){return{}}:H,W=a.onError,K=void 0===W?function(){return{}}:W,U=d(p=p.toLowerCase(),c(e),f);e=U[0];var z=function e(t){return t instanceof File||t instanceof Blob||t instanceof FileList||"object"==typeof t&&null!==t&&void 0!==Object.values(t).find(function(t){return e(t)})}(f=U[1]);"get"!==p&&(z||x)&&(f=h(f));var Q={url:e,method:p,data:f,replace:g,preserveScroll:y,preserveState:b,only:I,headers:V,errorBag:C,forceFormData:x,onCancelToken:T,onBefore:j,onStart:B,onProgress:A,onFinish:N,onCancel:J,onSuccess:M,onError:K};if(!1!==j(Q)&&function(e){return s("before",{cancelable:!0,detail:{visit:e}})}(Q)){this.cancelVisit(this.activeVisit,{interrupted:!0}),this.saveScrollPositions();var _=this.createVisitId();return this.activeVisit=Q,this.activeVisit.cancelToken=t.CancelToken.source(),T({cancel:function(){return i.cancelVisit(i.activeVisit,{cancelled:!0})}}),function(e){s("start",{detail:{visit:e}})}(Q),B(Q),new Proxy(t({method:p,url:u(e).href,data:"get"===p?{}:f,params:"get"===p?f:{},cancelToken:this.activeVisit.cancelToken.token,headers:o({},V,{Accept:"text/html, application/xhtml+xml","X-Requested-With":"XMLHttpRequest","X-Inertia":!0},I.length?{"X-Inertia-Partial-Component":this.page.component,"X-Inertia-Partial-Data":I.join(",")}:{},C?{"X-Inertia-Error-Bag":C}:{},this.page.version?{"X-Inertia-Version":this.page.version}:{}),onUploadProgress:function(e){z&&(e.percentage=Math.round(e.loaded/e.total*100),function(e){s("progress",{detail:{progress:e}})}(e),A(e))}}).then(function(t){var n;if(!i.isInertiaResponse(t))return Promise.reject({response:t});I.length&&t.data.component===i.page.component&&(t.data.props=o({},i.page.props,t.data.props)),b&&null!=(n=window.history.state)&&n.rememberedState&&t.data.component===i.page.component&&(t.data.rememberedState=window.history.state.rememberedState);var r=c(t.data.url);return e.hash&&!r.hash&&u(e).href===r.href&&(r.hash=e.hash,t.data.url=r.href),i.setPage(t.data,{visitId:_,replace:g,preserveScroll:y,preserveState:b})}).then(function(){var e=i.resolveErrors(i.page);return Object.keys(e).length>0?(function(e){s("error",{detail:{errors:e}})}(e[C]||e),K(e[C]||e)):(s("success",{detail:{page:i.page}}),M(i.page))}).catch(function(t){if(i.isInertiaResponse(t.response))return i.setPage(t.response.data,{visitId:_});if(i.isLocationVisitResponse(t.response)){var n=c(t.response.headers["x-inertia-location"]);e.hash&&!n.hash&&u(e).href===n.href&&(n.hash=e.hash),i.locationVisit(n,y)}else{if(!t.response)return Promise.reject(t);s("invalid",{cancelable:!0,detail:{response:t.response}})&&r.show(t.response.data)}}).then(function(){i.finishVisit(Q)}).catch(function(e){if(!t.isCancel(e)){var n=s("exception",{cancelable:!0,detail:{exception:e}});if(i.finishVisit(Q),n)return Promise.reject(e)}}),{get:function(e,t){return["then","catch","finally"].includes(t)&&console.warn("Inertia.js visit promises have been deprecated and will be removed in a future release. Please use the new visit event callbacks instead.\n\nLearn more at https://inertiajs.com/manual-visits#promise-deprecation"),"function"==typeof e[t]?e[t].bind(e):e[t]}})}},setPage:function(e,t){var n=this,i=void 0===t?{}:t,o=i.visitId,r=void 0===o?this.createVisitId():o,s=i.replace,a=void 0!==s&&s,d=i.preserveScroll,u=void 0!==d&&d,h=i.preserveState,p=void 0!==h&&h;return Promise.resolve(this.resolveComponent(e.component)).then(function(t){if(r===n.visitId){e.scrollRegions=e.scrollRegions||[],e.rememberedState=e.rememberedState||{},p="function"==typeof p?p(e):p,u="function"==typeof u?u(e):u,(a=a||c(e.url).href===window.location.href)?n.replaceState(e):n.pushState(e);var i=JSON.parse(JSON.stringify(e));i.props=n.transformProps(i.props),n.swapComponent({component:t,page:i,preserveState:p}).then(function(){u||n.resetScrollPositions(),a||l(e)})}})},pushState:function(e){this.page=e,window.history.pushState(e,"",e.url)},replaceState:function(e){this.page=e,window.history.replaceState(e,"",e.url)},handlePopstateEvent:function(e){var t=this;if(null!==e.state){var n=e.state,i=this.createVisitId();return Promise.resolve(this.resolveComponent(n.component)).then(function(e){i===t.visitId&&(t.page=n,t.swapComponent({component:e,page:n,preserveState:!1}).then(function(){t.restoreScrollPositions(),l(n)}))})}var r=c(this.page.url);r.hash=window.location.hash,this.replaceState(o({},this.page,{url:r.href})),this.resetScrollPositions()},get:function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,o({},n,{method:"get",data:t}))},reload:function(e){return void 0===e&&(e={}),this.visit(window.location.href,o({},e,{preserveScroll:!0,preserveState:!0}))},replace:function(e,t){var n;return void 0===t&&(t={}),console.warn("Inertia.replace() has been deprecated and will be removed in a future release. Please use Inertia."+(null!=(n=t.method)?n:"get")+"() instead."),this.visit(e,o({preserveState:!0},t,{replace:!0}))},post:function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,o({preserveState:!0},n,{method:"post",data:t}))},put:function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,o({preserveState:!0},n,{method:"put",data:t}))},patch:function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,o({preserveState:!0},n,{method:"patch",data:t}))},delete:function(e,t){return void 0===t&&(t={}),this.visit(e,o({preserveState:!0},t,{method:"delete"}))},remember:function(e,t){var n;void 0===t&&(t="default"),this.replaceState(o({},this.page,{rememberedState:o({},this.page.rememberedState,(n={},n[t]=e,n))}))},restore:function(e){var t,n;return void 0===e&&(e="default"),null==(t=window.history.state)||null==(n=t.rememberedState)?void 0:n[e]},on:function(e,t){var n=function(e){var n=t(e);e.cancelable&&!e.defaultPrevented&&!1===n&&e.preventDefault()};return document.addEventListener("inertia:"+e,n),function(){return document.removeEventListener("inertia:"+e,n)}}},exports.hrefToUrl=c,exports.mergeDataIntoQueryString=d,exports.shouldIntercept=function(e){var t="a"===e.currentTarget.tagName.toLowerCase();return!(e.target&&e.target.isContentEditable||e.defaultPrevented||t&&e.which>1||t&&e.altKey||t&&e.ctrlKey||t&&e.metaKey||t&&e.shiftKey)},exports.urlWithoutHash=u;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/formats.js":
/*!************************************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/node_modules/qs/lib/formats.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/node_modules/qs/lib/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/parse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/node_modules/qs/lib/parse.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/stringify.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/node_modules/qs/lib/stringify.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = typeof key === 'object' && key.value !== undefined ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
            : prefix + (allowDots ? '.' + key : '[' + key + ']');

        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/node_modules/qs/lib/utils.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/@inertiajs/inertia/node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/@inertiajs/progress/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@inertiajs/progress/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InertiaProgress": () => (/* reexport safe */ _progress__WEBPACK_IMPORTED_MODULE_0__.default)
/* harmony export */ });
/* harmony import */ var _progress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./progress */ "./node_modules/@inertiajs/progress/src/progress.js");



/***/ }),

/***/ "./node_modules/@inertiajs/progress/src/progress.js":
/*!**********************************************************!*\
  !*** ./node_modules/@inertiajs/progress/src/progress.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nprogress */ "./node_modules/nprogress/nprogress.js");
/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_0__);


let timeout = null

function addEventListeners(delay) {
  document.addEventListener('inertia:start', start.bind(null, delay))
  document.addEventListener('inertia:progress', progress)
  document.addEventListener('inertia:finish', finish)
}

function start(delay) {
  timeout = setTimeout(() => nprogress__WEBPACK_IMPORTED_MODULE_0___default().start(), delay)
}

function progress(event) {
  if (nprogress__WEBPACK_IMPORTED_MODULE_0___default().isStarted() && event.detail.progress.percentage) {
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().set(Math.max((nprogress__WEBPACK_IMPORTED_MODULE_0___default().status), event.detail.progress.percentage / 100 * 0.9))
  }
}

function finish(event) {
  clearTimeout(timeout)
  if (!nprogress__WEBPACK_IMPORTED_MODULE_0___default().isStarted()) {
    return
  } else if (event.detail.visit.completed) {
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().done()
  } else if (event.detail.visit.interrupted) {
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().set(0)
  } else if (event.detail.visit.cancelled) {
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().done()
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().remove()
  }
}

function injectCSS(color) {
  const element = document.createElement('style')
  element.type = 'text/css'
  element.textContent = `
    #nprogress {
      pointer-events: none;
    }

    #nprogress .bar {
      background: ${color};

      position: fixed;
      z-index: 1031;
      top: 0;
      left: 0;

      width: 100%;
      height: 2px;
    }

    #nprogress .peg {
      display: block;
      position: absolute;
      right: 0px;
      width: 100px;
      height: 100%;
      box-shadow: 0 0 10px ${color}, 0 0 5px ${color};
      opacity: 1.0;

      -webkit-transform: rotate(3deg) translate(0px, -4px);
          -ms-transform: rotate(3deg) translate(0px, -4px);
              transform: rotate(3deg) translate(0px, -4px);
    }

    #nprogress .spinner {
      display: block;
      position: fixed;
      z-index: 1031;
      top: 15px;
      right: 15px;
    }

    #nprogress .spinner-icon {
      width: 18px;
      height: 18px;
      box-sizing: border-box;

      border: solid 2px transparent;
      border-top-color: ${color};
      border-left-color: ${color};
      border-radius: 50%;

      -webkit-animation: nprogress-spinner 400ms linear infinite;
              animation: nprogress-spinner 400ms linear infinite;
    }

    .nprogress-custom-parent {
      overflow: hidden;
      position: relative;
    }

    .nprogress-custom-parent #nprogress .spinner,
    .nprogress-custom-parent #nprogress .bar {
      position: absolute;
    }

    @-webkit-keyframes nprogress-spinner {
      0%   { -webkit-transform: rotate(0deg); }
      100% { -webkit-transform: rotate(360deg); }
    }
    @keyframes nprogress-spinner {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `
  document.head.appendChild(element)
}

const Progress = {
  init({ delay = 250, color = '#29d', includeCSS = true, showSpinner = false } = {}) {
    addEventListeners(delay)
    nprogress__WEBPACK_IMPORTED_MODULE_0___default().configure({ showSpinner })
    if (includeCSS) {
      injectCSS(color)
    }
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Progress);


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var inertia_can__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! inertia-can */ "./node_modules/inertia-can/dist/cjs/index.js");
/* harmony import */ var _inertiajs_progress_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @inertiajs/progress/src */ "./node_modules/@inertiajs/progress/src/index.js");
/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css/app.css */ "./assets/css/app.css");




_inertiajs_progress_src__WEBPACK_IMPORTED_MODULE_2__.InertiaProgress.init();
var target = document.getElementById('app');
var app = new inertia_can__WEBPACK_IMPORTED_MODULE_1__.InertiaApp().initialize({
  initialPage: JSON.parse(target.dataset.page),
  resolveComponent: function resolveComponent(name) {
    return __webpack_require__("./assets/js/pages lazy recursive ^\\.\\/.*$")("./".concat(name)).then(function (module) {
      return module["default"];
    });
  }
});
app.initialize({
  target: target
});
target.appendChild(app);

/***/ }),

/***/ "./node_modules/can-ajax/can-ajax.js":
/*!*******************************************!*\
  !*** ./node_modules/can-ajax/can-ajax.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Global = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var parseURI = __webpack_require__(/*! can-parse-uri */ "./node_modules/can-parse-uri/can-parse-uri.js");
var param = __webpack_require__(/*! can-param */ "./node_modules/can-param/can-param.js");

/**
 * @module {function} can-ajax can-ajax
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 *
 * Make an asynchronous HTTP (AJAX) request.
 *
 * @signature `ajax( ajaxOptions )`
 *
 *    Is used to make an asynchronous HTTP (AJAX) request similar to [jQuery.ajax()](http://api.jquery.com/jQuery.ajax/).
 *
 *    ```js
 *    import { ajax } from "can";
 *
 *    ajax({
 *      url: "http://query.yahooapis.com/v1/public/yql",
 *      data: {
 *        format: "json",
 *        q: 'select * from geo.places where text="sunnyvale, ca"'
 *      }
 *    }).then(function(response){
 *      console.log( response.query.count ); // => 2
 *    });
 *    ```
 *
 *    @param {Object} ajaxOptions Configuration options for the AJAX request.
 *      - __url__ `{String}` The requested url.
 *      - __type__ `{String}` The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored. _Default is `GET`_.
 *      - __data__ `{Object}` The data of the request. If data needs to be urlencoded (e.g. for GET requests or for CORS) it is serialized with [can-param].
 *      - __dataType__ `{String}` Type of data. _Default is `json`_.
 *      - __crossDomain__ `{Boolean}` If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true. This allows, for example, server-side redirection to another domain. Default: `false` for same-domain requests, `true` for cross-domain requests.
 *      - __xhrFields__ `{Object}` Any fields to be set directly on the xhr request, [https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest] such as the withCredentials attribute that indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies or authorization headers.
 *      - __beforeSend__ `{callback}` A pre-request callback function that can be used to modify the XHR object before it is sent. Use this to set custom headers, etc. The XHR and settings objects are passed as arguments.
 *      - __success__ `{callback}` A callback passed the response body when the request completes without error.  Using the promise returned from ajax() should be preferred to passing a success callback
 *      - __error__ `{callback}` A callback passed the XHR object when the request fails to complete correctly.  Using the promise returned from ajax() should be preferred to passing an error callback
 *      - __async__ `{Boolean}` Set `async` to `false` to create a synchronous XHR that blocks the thread until the request completes. success() or error() is called synchronously on completion, but promise callbacks are still resolved asychronously.  Synchronous AJAX calls are **not recommended** and are only supported here for legacy reasons.
 * 
 *    @return {Promise} A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.
 *
 *
 * @signature `ajaxSetup( ajaxOptions )`
 *
 *    Is used to persist ajaxOptions across all ajax requests and they can be over-written in the ajaxOptions of the actual request.
 *    [https://api.jquery.com/jquery.ajaxsetup/]
 *
 *    ```js
 *    import { ajax } from "can";
 *
 *    ajax.ajaxSetup({xhrFields: {withCredentials: true}});
 *
 *    ajax({
 *      url: "http://query.yahooapis.com/v1/public/yql",
 *      data: {
 *        format: "json",
 *        q: 'select * from geo.places where text="sunnyvale, ca"'
 *      }
 *    }).then(function(response){
 *      console.log( response.query.count ); // => 2
 *    });
 *    ```
 */

// from https://gist.github.com/mythz/1334560
var xhrs = [
		function () { return new XMLHttpRequest(); },
		function () { return new ActiveXObject("Microsoft.XMLHTTP"); },
		function () { return new ActiveXObject("MSXML2.XMLHTTP.3.0"); },
		function () { return new ActiveXObject("MSXML2.XMLHTTP"); }
	],
	_xhrf = null;
// used to check for Cross Domain requests
var originUrl = parseURI(Global().location.href);

var globalSettings = {};

var makeXhr = function () {
	if (_xhrf != null) {
		return _xhrf();
	}
	for (var i = 0, l = xhrs.length; i < l; i++) {
		try {
			var f = xhrs[i], req = f();
			if (req != null) {
				_xhrf = f;
				return req;
			}
		} catch (e) {
			continue;
		}
	}
	return function () { };
};

var contentTypes = {
	json: "application/json",
	form: "application/x-www-form-urlencoded"
};

var _xhrResp = function (xhr, options) {
	try{
		var type = (options.dataType || xhr.getResponseHeader("Content-Type").split(";")[0]);
		
		if(type && (xhr.responseText || xhr.responseXML)){
			
			switch (type) {
				case "text/xml":
				case "xml":
					return xhr.responseXML;
				case "text/json":
				case "application/json":
				case "text/javascript":
				case "application/javascript":
				case "application/x-javascript":
				case "json":
					return xhr.responseText && JSON.parse(xhr.responseText);
				default:
					return xhr.responseText;
			}
		} else {
			return xhr;
		}
	} catch(e){
		return xhr;
	}
};

function ajax(o) {
	var xhr = makeXhr(), timer, n = 0;
	var deferred = {}, isFormData;
	var promise = new Promise(function(resolve,reject){
		deferred.resolve = resolve;
		deferred.reject = reject;
	});
	var requestUrl;
	var isAborted = false;

	promise.abort = function () {
		isAborted = true;
		xhr.abort();
	};

	o = [{
			userAgent: "XMLHttpRequest",
			lang: "en",
			type: "GET",
			data: null,
			dataType: "json"
	}, globalSettings, o].reduce(function(a,b,i) {
		return canReflect.assignDeep(a,b);
	});

	var async = o.async !== false;

	// Set the default contentType
	if(!o.contentType) {
		o.contentType = o.type.toUpperCase() === "GET" ?
			contentTypes.form : contentTypes.json;
	}

	//how jquery handles check for cross domain
	if(o.crossDomain == null){
		try {
			requestUrl = parseURI(o.url);
			o.crossDomain = !!((requestUrl.protocol && requestUrl.protocol !== originUrl.protocol) ||
				(requestUrl.host && requestUrl.host !== originUrl.host));

		} catch (e){
			o.crossDomain = true;
		}
	}
	if (o.timeout) {
		timer = setTimeout(function () {
			xhr.abort();
			if (o.timeoutFn) {
				o.timeoutFn(o.url);
			}
		}, o.timeout);
	}
	xhr.onreadystatechange = function () {
		try {
			if (xhr.readyState === 4) {
				if (timer) {
					clearTimeout(timer);
				}
				if (xhr.status < 300) {
					if (o.success) {
						o.success( _xhrResp(xhr, o) );
					}
				}
				else if (o.error) {
					o.error(xhr, xhr.status, xhr.statusText);
				}
				if (o.complete) {
					o.complete(xhr, xhr.statusText);
				}

				if (xhr.status >= 200 && xhr.status < 300) {
					deferred.resolve( _xhrResp(xhr, o) );
				} else {
					deferred.reject( _xhrResp(xhr, o) );
				}
			}
			else if (o.progress) {
				o.progress(++n);
			}
		} catch(e) {
			deferred.reject(e);
		}
	};
	var url = o.url, data = null, type = o.type.toUpperCase();
	var isJsonContentType = o.contentType === contentTypes.json;
	var isPost = type === "POST" || type === "PUT";
	if (!isPost && o.data) {
		url += "?" + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));
	}
	xhr.open(type, url, async);

	// For CORS to send a "simple" request (to avoid a preflight check), the following methods are allowed: GET/POST/HEAD,
	// see https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests

	var isSimpleCors = o.crossDomain && ['GET', 'POST', 'HEAD'].indexOf(type) !== -1;
	isFormData = typeof FormData !== "undefined" && o.data instanceof FormData;

	if (isPost) {
		if (isFormData) {
			// do not set "Content-Type" let the browser handle it
			// do not stringify FormData XHR handles it natively
			data = o.data;
		} else {
			if (isJsonContentType && !isSimpleCors) {
				data = typeof o.data === "object" ? JSON.stringify(o.data) : o.data;
				xhr.setRequestHeader("Content-Type", "application/json");
			} else {
				data = param(o.data);
				// CORS simple: `Content-Type` has to be `application/x-www-form-urlencoded`:
				xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			}
		}
	} else {
		xhr.setRequestHeader("Content-Type", o.contentType);
	}

	// CORS simple: no custom headers, so we don't add `X-Requested-With` header:
	if (!isSimpleCors){
		xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	}

	if (o.xhrFields) {
		for (var f in o.xhrFields) {
			xhr[f] = o.xhrFields[f];
		}
	}

	function send () {
		if(!isAborted) {
			xhr.send(data);
		}
	}

	if(o.beforeSend){
		var result = o.beforeSend.call( o, xhr, o );
		if(canReflect.isPromise(result)) {
			result.then(send).catch(deferred.reject);
			return promise;
		}
	}
	
	send();
	return promise;
}

module.exports = namespace.ajax = ajax;
module.exports.ajaxSetup = function (o) {
    globalSettings = o || {};
};


/***/ }),

/***/ "./node_modules/can-assign/can-assign.js":
/*!***********************************************!*\
  !*** ./node_modules/can-assign/can-assign.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

/**
 * @module {function} can-assign can-assign
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @signature `assign(target, source)`
 * @package ./package.json
 *
 * A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.
 *
 * ```js
 * var assign = require("can-assign");
 *
 * var obj = {};
 *
 * assign(obj, {
 *   foo: "bar"
 * });
 *
 * console.log(obj.foo); // -> "bar"
 * ```
 *
 * @param {Object} target The destination object. This object's properties will be mutated based on the object provided as `source`.
 * @param {Object} source The source object whose own properties will be applied to `target`.
 *
 * @return {Object} Returns the `target` argument.
 */

module.exports = namespace.assign = function (d, s) {
	for (var prop in s) {
		var desc = Object.getOwnPropertyDescriptor(d,prop);
		if(!desc || desc.writable !== false){
			d[prop] = s[prop];
		}
	}
	return d;
};


/***/ }),

/***/ "./node_modules/can-attribute-encoder/can-attribute-encoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-attribute-encoder/can-attribute-encoder.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

/**
 * @module {{}} can-attribute-encoder can-attribute-encoder
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 *
 * Encode and decode attribute names.
 *
 * @option {Object} An object with the methods:
 * [can-attribute-encoder.encode] and [can-attribute-encoder.decode].
 *
 */


function each(items, callback){
	for ( var i = 0; i < items.length; i++ ) {
		callback(items[i], i);
	}
}

function makeMap(str){
	var obj = {}, items = str.split(",");
	each(items, function(name){
		obj[name] = true;
	});
	return obj;
}

// Attributes for which the case matters - shouldn’t be lowercased.
var caseMattersAttributes = makeMap("allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector,controlsList");

function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
	return lowerCaseChar + "-" + upperCaseChar.toLowerCase();
}

function startsWith(allOfIt, startsWith) {
	return allOfIt.indexOf(startsWith) === 0;
}

function endsWith(allOfIt, endsWith) {
	return (allOfIt.length - allOfIt.lastIndexOf(endsWith)) === endsWith.length;
}

var regexes = {
	leftParens: /\(/g,
	rightParens: /\)/g,
	leftBrace: /\{/g,
	rightBrace: /\}/g,
	camelCase: /([a-z]|[0-9]|^)([A-Z])/g,
	forwardSlash: /\//g,
	space: /\s/g,
	uppercase: /[A-Z]/g,
	uppercaseDelimiterThenChar: /:u:([a-z])/g,
	caret: /\^/g,
	dollar: /\$/g,
	at: /@/g
};

var delimiters = {
	prependUppercase: ':u:',
	replaceSpace: ':s:',
	replaceForwardSlash: ':f:',
	replaceLeftParens: ':lp:',
	replaceRightParens: ':rp:',
	replaceLeftBrace: ':lb:',
	replaceRightBrace: ':rb:',
	replaceCaret: ':c:',
	replaceDollar: ':d:',
	replaceAt: ':at:'
};

var encoder = {};

/**
 * @function can-attribute-encoder.encode encode
 * @parent can-attribute-encoder
 * @description Encode an attribute name
 *
 * @signature `encoder.encode(attributeName)`
 *
 * Note: specific encoding may change, but encoded attributes
 * can always be decoded using [can-attribute-encoder.decode].
 *
 * @body
 *
 * ```js
 * var encodedAttributeName = encoder.encode("{(^$foo/bar baz)}");
 * div.setAttribute(encodedAttributeName, "attribute value");
 * ```
 *
 * @param {String} attributeName The attribute name.
 * @return {String} The encoded attribute name.
 *
 */
encoder.encode = function(name) {
	var encoded = name;

	// encode or convert camelCase attributes unless in list of attributes
	// where case matters
	if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
		// encode uppercase characters in new bindings
		// - on:fooBar, fooBar:to, fooBar:from, fooBar:bind
		if (
			startsWith(encoded, 'on:') ||
			endsWith(encoded, ':to') ||
			endsWith(encoded, ':from') ||
			endsWith(encoded, ':bind') ||
			endsWith(encoded, ':raw')
		) {
			encoded = encoded
				.replace(regexes.uppercase, function(char) {
					return delimiters.prependUppercase + char.toLowerCase();
				});
		} else if(startsWith(encoded, '(') || startsWith(encoded, '{')) {
			// convert uppercase characters in older bindings to kebab-case
			// - {fooBar}, (fooBar), {(fooBar)}
			encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
			//!steal-remove-start
			if(true) {
				dev.warn("can-attribute-encoder: Found attribute with name: " + name + ". Converting to: " + encoded + '.');
			}
			//!steal-remove-end
		}
	}

	//encode spaces
	encoded = encoded.replace(regexes.space, delimiters.replaceSpace)
		//encode forward slashes
		.replace(regexes.forwardSlash, delimiters.replaceForwardSlash)
		// encode left parentheses
		.replace(regexes.leftParens, delimiters.replaceLeftParens)
		// encode right parentheses
		.replace(regexes.rightParens, delimiters.replaceRightParens)
		// encode left braces
		.replace(regexes.leftBrace, delimiters.replaceLeftBrace)
		// encode left braces
		.replace(regexes.rightBrace, delimiters.replaceRightBrace)
		// encode ^
		.replace(regexes.caret, delimiters.replaceCaret)
		// encode $
		.replace(regexes.dollar, delimiters.replaceDollar)
		// encode @
		.replace(regexes.at, delimiters.replaceAt);

	return encoded;
};

/**
 * @function can-attribute-encoder.decode decode
 * @parent can-attribute-encoder
 * @description Decode an attribute name encoded by [can-attribute-encoder.encode]
 * @signature `encoder.decode(attributeName)`
 *
 * @body
 *
 * ```js
 * encoder.decode(attributeName); // -> "{(^$foo/bar baz)}"
 *
 * ```
 *
 * @param {String} attributeName The encoded attribute name.
 * @return {String} The decoded attribute name.
 *
 */
encoder.decode = function(name) {
	var decoded = name;

	// decode uppercase characters in new bindings
	if (!caseMattersAttributes[decoded] && regexes.uppercaseDelimiterThenChar.test(decoded)) {
		if (
			startsWith(decoded, 'on:') ||
			endsWith(decoded, ':to') ||
			endsWith(decoded, ':from') ||
			endsWith(decoded, ':bind') ||
			endsWith(decoded, ':raw')
		) {
			decoded = decoded
				.replace(regexes.uppercaseDelimiterThenChar, function(match, char) {
					return char.toUpperCase();
				});
		}
	}

	// decode left parentheses
	decoded = decoded.replace(delimiters.replaceLeftParens, '(')
		// decode right parentheses
		.replace(delimiters.replaceRightParens, ')')
		// decode left braces
		.replace(delimiters.replaceLeftBrace, '{')
		// decode left braces
		.replace(delimiters.replaceRightBrace, '}')
		// decode forward slashes
		.replace(delimiters.replaceForwardSlash, '/')
		// decode spaces
		.replace(delimiters.replaceSpace, ' ')
		// decode ^
		.replace(delimiters.replaceCaret, '^')
		//decode $
		.replace(delimiters.replaceDollar, '$')
		//decode @
		.replace(delimiters.replaceAt, '@');

	return decoded;
};

if (namespace.encoder) {
	throw new Error("You can't have two versions of can-attribute-encoder, check your dependencies");
} else {
	module.exports = namespace.encoder = encoder;
}


/***/ }),

/***/ "./node_modules/can-attribute-observable/behaviors.js":
/*!************************************************************!*\
  !*** ./node_modules/can-attribute-observable/behaviors.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var global = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js")();
var setData = __webpack_require__(/*! can-dom-data */ "./node_modules/can-dom-data/can-dom-data.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ "./node_modules/can-globals/mutation-observer/mutation-observer.js");
var diff = __webpack_require__(/*! can-diff/list/list */ "./node_modules/can-diff/list/list.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var xmlnsAttrNamespaceURI = "http://www.w3.org/2000/xmlns/";
var xlinkHrefAttrNamespaceURI =  "http://www.w3.org/1999/xlink";
var attrsNamespacesURI = {
	'xmlns': xmlnsAttrNamespaceURI,
	'xlink:href': xlinkHrefAttrNamespaceURI
};


var formElements = {"INPUT": true, "TEXTAREA": true, "SELECT": true, "BUTTON": true},
	// Used to convert values to strings.
	toString = function(value){
		if(value == null) {
			return "";
		} else {
			return ""+value;
		}
	},
	isSVG = function(el){
		return el.namespaceURI === "http://www.w3.org/2000/svg";
	},
	truthy = function() { return true; },
	getSpecialTest = function(special){
		return (special && special.test) || truthy;
	},
	propProp = function(prop, obj){
		obj = obj || {};
		obj.get = function(){
			return this[prop];
		};
		obj.set = function(value){
			if(this[prop] !== value) {
				this[prop] = value;
			}
		};
		return obj;
	},
	booleanProp = function(prop){
		return {
			isBoolean: true,
			set: function(value){
				if(prop in this) {
					this[prop] = value;
				} else {
					domMutateNode.setAttribute.call(this, prop, "");
				}
			},
			remove: function(){
				this[prop] = false;
			}
		};
	},
	setupMO = function(el, callback){
		var attrMO = setData.get(el, "attrMO");
		if(!attrMO) {
			var onMutation = function(){
				callback.call(el);
			};
			var MO = getMutationObserver();
			if(MO) {
				var observer = new MO(onMutation);
				observer.observe(el, {
					childList: true,
					subtree: true
				});
				setData.set(el, "attrMO", observer);
			} else {
				setData.set(el, "attrMO", true);
				setData.set(el, "canBindingCallback", {onMutation: onMutation});
			}
		}
	},
	_findOptionToSelect = function (parent, value) {
		var child = parent.firstChild;
		while (child) {
			if (child.nodeName === "OPTION" && value === child.value) {
				return child;
			}
			if (child.nodeName === "OPTGROUP") {
				var groupChild = _findOptionToSelect(child, value);
				if (groupChild) {
					return groupChild;
				}
			}
			child = child.nextSibling;
		}
	},
	setChildOptions = function(el, value){
		var option;
		if (value != null) {
			option = _findOptionToSelect(el, value);
		}
		if (option) {
			option.selected = true;
		} else {
			el.selectedIndex = -1;
		}
	},
	forEachOption = function (parent, fn) {
		var child = parent.firstChild;
		while (child) {
			if (child.nodeName === "OPTION") {
				fn(child);
			}
			if (child.nodeName === "OPTGROUP") {
				forEachOption(child, fn);
			}
			child = child.nextSibling;
		}
	},
	collectSelectedOptions = function (parent) {
		var selectedValues = [];
		forEachOption(parent, function (option) {
			if (option.selected) {
				selectedValues.push(option.value);
			}
		});
		return selectedValues;
	},
	markSelectedOptions = function (parent, values) {
		forEachOption(parent, function (option) {
			option.selected = values.indexOf(option.value) !== -1;
		});
	},
	// Create a handler, only once, that will set the child options any time
	// the select's value changes.
	setChildOptionsOnChange = function(select, aEL){
		var handler = setData.get(select, "attrSetChildOptions");
		if(handler) {
			return Function.prototype;
		}
		handler = function(){
			setChildOptions(select, select.value);
		};
		setData.set(select, "attrSetChildOptions", handler);
		aEL.call(select, "change", handler);
		return function(rEL){
			setData.clean(select, "attrSetChildOptions");
			rEL.call(select, "change", handler);
		};
	},
	// cache of rules already calculated by `attr.getRule`
	behaviorRules = new Map(),
	// # isPropWritable
	// check if a property is writable on an element by finding its property descriptor
	// on the element or its prototype chain
	isPropWritable = function(el, prop) {
		   var desc = Object.getOwnPropertyDescriptor(el, prop);

		   if (desc) {
				   return desc.writable || desc.set;
		   } else {
				   var proto = Object.getPrototypeOf(el);
				   if (proto) {
						   return isPropWritable(proto, prop);
				   }
		   }

		   return false;
	},
	// # cacheRule
	// add a rule to the rules Map so it does not need to be calculated more than once
	cacheRule = function(el, attrOrPropName, rule) {
		   var rulesForElementType;

		   rulesForElementType = behaviorRules.get(el.prototype);

		   if (!rulesForElementType) {
				   rulesForElementType = {};
				   behaviorRules.set(el.constructor, rulesForElementType);
		   }

		   rulesForElementType[attrOrPropName] = rule;

		   return rule;
	};

var specialAttributes = {
	checked: {
		get: function(){
			return this.checked;
		},
		set: function(val){
			// - `set( truthy )` => TRUE
			// - `set( "" )`     => TRUE
			// - `set()`         => TRUE
			// - `set(undefined)` => false.
			var notFalse = !!val || val === "" || arguments.length === 0;
			this.checked = notFalse;
			if(notFalse && this.type === "radio") {
				this.defaultChecked = true;
			}
		},
		remove: function(){
			this.checked = false;
		},
		test: function(){
			return this.nodeName === "INPUT";
		}
	},
	"class": {
		get: function(){
			if(isSVG(this)) {
				return this.getAttribute("class");
			}
			return this.className;
		},
		set: function(val){
			val = val || "";

			if(isSVG(this)) {
				domMutateNode.setAttribute.call(this, "class", "" + val);
			} else {
				this.className = val;
			}
		}
	},
	disabled: booleanProp("disabled"),
	focused: {
		get: function(){
			return this === document.activeElement;
		},
		set: function(val){
			var cur = attr.get(this, "focused");
			var docEl = this.ownerDocument.documentElement;
			var element = this;
			function focusTask() {
				if (val) {
					element.focus();
				} else {
					element.blur();
				}
			}
			if (cur !== val) {
				if (!docEl.contains(element)) {
					var connectionDisposal = domMutate.onNodeConnected(element, function () {
						connectionDisposal();
						focusTask();
					});
				} else {
					// THIS MIGHT NEED TO BE PUT IN THE MUTATE QUEUE
					queues.enqueueByQueue({
						mutate: [focusTask]
					}, null, []);
				}
			}
			return true;
		},
		addEventListener: function(eventName, handler, aEL){
			aEL.call(this, "focus", handler);
			aEL.call(this, "blur", handler);
			return function(rEL){
				rEL.call(this, "focus", handler);
				rEL.call(this, "blur", handler);
			};
		},
		test: function(){
			return this.nodeName === "INPUT";
		}
	},
	"for": propProp("htmlFor"),
	innertext: propProp("innerText"),
	innerhtml: propProp("innerHTML"),
	innerHTML: propProp("innerHTML", {
		addEventListener: function(eventName, handler, aEL){
			var handlers = [];
			var el = this;
			["change", "blur"].forEach(function(eventName){
				var localHandler = function(){
					handler.apply(this, arguments);
				};
				domEvents.addEventListener(el, eventName, localHandler);
				handlers.push([eventName, localHandler]);
			});

			return function(rEL){
				handlers.forEach( function(info){
					rEL.call(el, info[0], info[1]);
				});
			};
		}
	}),
	required: booleanProp("required"),
	readonly: booleanProp("readOnly"),
	selected: {
		get: function(){
			return this.selected;
		},
		set: function(val){
			val = !!val;
			setData.set(this, "lastSetValue", val);
			this.selected = val;
		},
		addEventListener: function(eventName, handler, aEL){
			var option = this;
			var select = this.parentNode;
			var lastVal = option.selected;
			var localHandler = function(changeEvent){
				var curVal = option.selected;
				lastVal = setData.get(option, "lastSetValue") || lastVal;
				if(curVal !== lastVal) {
					lastVal = curVal;

					domEvents.dispatch(option, eventName);
				}
			};

			var removeChangeHandler = setChildOptionsOnChange(select, aEL);
			domEvents.addEventListener(select, "change", localHandler);
			aEL.call(option, eventName, handler);

			return function(rEL){
				removeChangeHandler(rEL);
				domEvents.removeEventListener(select, "change", localHandler);
				rEL.call(option, eventName, handler);
			};
		},
		test: function(){
			return this.nodeName === "OPTION" && this.parentNode &&
				this.parentNode.nodeName === "SELECT";
		}
	},
	style: {
		set: (function () {
			var el = global.document && getDocument().createElement("div");
			if ( el && el.style && ("cssText" in el.style) ) {
				return function (val) {
					this.style.cssText = (val || "");
				};
			} else {
				return function (val) {
					domMutateNode.setAttribute.call(this, "style", val);
				};
			}
		})()
	},
	textcontent: propProp("textContent"),
	value: {
		get: function(){
			var value = this.value;
			if(this.nodeName === "SELECT") {
				if(("selectedIndex" in this) && this.selectedIndex === -1) {
					value = undefined;
				}
			}
			return value;
		},
		set: function(value){
			var providedValue = value;
			var nodeName = this.nodeName.toLowerCase();
			if(nodeName === "input" || nodeName === "textarea") {
				// Do some input types support non string values?
				value = toString(value);
			}
			if(this.value !== value || nodeName === "option") {
				this.value = value;
			}
			if (nodeName === "input" || nodeName === "textarea") {
				this.defaultValue = value;
			}
			if(nodeName === "select") {
				setData.set(this, "attrValueLastVal", value);
				//If it's null then special case
				setChildOptions(this, value === null ? value : this.value);

				// If not in the document reset the value when inserted.
				var docEl = this.ownerDocument.documentElement;
				if(!docEl.contains(this)) {
					var select = this;
					var connectionDisposal = domMutate.onNodeConnected(select, function () {
						connectionDisposal();
						setChildOptions(select, value === null ? value : select.value);
					});
				}

				// MO handler is only set up **ONCE**
				setupMO(this, function(){
					var value = setData.get(this, "attrValueLastVal");
					attr.set(this, "value", value);
					domEvents.dispatch(this, "change");
				});
			}

			// Warnings area
			//!steal-remove-start
			if(true) {
				var settingADateInputToADate = nodeName === "input" && this.type === "date" && (providedValue instanceof Date);
				if(settingADateInputToADate) {
					dev.warn("Binding a Date to the \"value\" property on an <input type=\"date\"> will not work as expected. Use valueAsDate:bind instead. See https://canjs.com/doc/guides/forms.html#Dateinput for more information.");
				}
			}
			//!steal-remove-end
		},
		test: function(){
			return formElements[this.nodeName];
		}
	},
	values: {
		get: function(){
			return collectSelectedOptions(this);
		},
		set: function(values){
			values = values || [];

			// set new DOM state
			markSelectedOptions(this, values);

			// store new DOM state
			setData.set(this, "stickyValues", attr.get(this,"values") );

			// MO handler is only set up **ONCE**
			// TODO: should this be moved into addEventListener?
			setupMO(this, function(){

				// Get the previous sticky state
				var previousValues = setData.get(this,
					"stickyValues");

				// Set DOM to previous sticky state
				attr.set(this, "values", previousValues);

				// Get the new result after trying to maintain the sticky state
				var currentValues = setData.get(this,
					"stickyValues");

				// If there are changes, trigger a `values` event.
				var changes = diff(previousValues.slice().sort(),
					currentValues.slice().sort());

				if (changes.length) {
					domEvents.dispatch(this, "values");
				}
			});
		},
		addEventListener: function(eventName, handler, aEL){
			var localHandler = function(){
				domEvents.dispatch(this, "values");
			};

			domEvents.addEventListener(this, "change", localHandler);
			aEL.call(this, eventName, handler);

			return function(rEL){
				domEvents.removeEventListener(this, "change", localHandler);
				rEL.call(this, eventName, handler);
			};
		}
	}
};

var attr = {
	// cached rules (stored on `attr` for testing purposes)
	rules: behaviorRules,

	// special attribute behaviors (stored on `attr` for testing purposes)
	specialAttributes: specialAttributes,

	// # attr.getRule
	//
	// get the behavior rule for an attribute or property on an element
	//
	// Rule precendence:
	//   1. "special" behaviors - use the special behavior getter/setter
	//   2. writable properties - read and write as a property
	//   3. all others - read and write as an attribute
	//
	// Once rule is determined it will be cached for all elements of the same type
	// so that it does not need to be calculated again
	getRule: function(el, attrOrPropName) {
		var special = specialAttributes[attrOrPropName];
		// always use "special" if available
		// these are not cached since they would have to be cached separately
		// for each element type and it is faster to just look up in the
		// specialAttributes object
		if (special) {
			return special;
		}

		// next use rules cached in a previous call to getRule
		var rulesForElementType = behaviorRules.get(el.constructor);
		var cached = rulesForElementType && rulesForElementType[attrOrPropName];

		if (cached) {
			return cached;
		}

		// if the element doesn't have a property of this name, it must be an attribute
		if (!(attrOrPropName in el)) {
			return this.attribute(attrOrPropName);
		}

		// if there is a property, check if it is writable
		var newRule = isPropWritable(el, attrOrPropName) ?
			this.property(attrOrPropName) :
			this.attribute(attrOrPropName);

		// cache the new rule and return it
		return cacheRule(el, attrOrPropName, newRule);
	},

	attribute: function(attrName) {
		return {
			get: function() {
				return this.getAttribute(attrName);
			},
			set: function(val) {
				if (attrsNamespacesURI[attrName]) {
					domMutateNode.setAttributeNS.call(this, attrsNamespacesURI[attrName], attrName, val);
				} else {
					domMutateNode.setAttribute.call(this, attrName, val);
				}
			}
		};
	},

	property: function(propName) {
		return {
			get: function() {
				return this[propName];
			},
			set: function(val) {
				this[propName] = val;
			}
		};
	},

	findSpecialListener: function(attributeName) {
		return specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;
	},

	setAttrOrProp: function(el, attrName, val){
		return this.set(el, attrName, val);
	},
	// ## attr.set
	// Set the value an attribute on an element.
	set: function (el, attrName, val) {
		var rule = this.getRule(el, attrName);
		var setter = rule && rule.set;

		if (setter) {
			return setter.call(el, val);
		}
	},
	// ## attr.get
	// Gets the value of an attribute or property.
	// First checks if the property is an `specialAttributes` and if so calls the special getter.
	// Then checks if the attribute or property is a property on the element.
	// Otherwise uses `getAttribute` to retrieve the value.
	get: function (el, attrName) {
		var rule = this.getRule(el, attrName);
		var getter = rule && rule.get;

		if (getter) {
			return rule.test ?
				rule.test.call(el) && getter.call(el) :
				getter.call(el);
		}
	},
	// ## attr.remove
	// Removes an attribute from an element. First checks specialAttributes to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.
	// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an "attributes" event.
	remove: function (el, attrName) {
		attrName = attrName.toLowerCase();
		var special = specialAttributes[attrName];
		var setter = special && special.set;
		var remover = special && special.remove;
		var test = getSpecialTest(special);

		if(typeof remover === "function" && test.call(el)) {
			remover.call(el);
		} else if(typeof setter === "function" && test.call(el)) {
			setter.call(el, undefined);
		} else {
			domMutateNode.removeAttribute.call(el, attrName);
		}
	}
};

module.exports = attr;


/***/ }),

/***/ "./node_modules/can-attribute-observable/can-attribute-observable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-attribute-observable/can-attribute-observable.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canEvent = __webpack_require__(/*! ./event */ "./node_modules/can-attribute-observable/event.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var attr = __webpack_require__(/*! ./behaviors */ "./node_modules/can-attribute-observable/behaviors.js");
var getEventName = __webpack_require__(/*! ./get-event-name */ "./node_modules/can-attribute-observable/get-event-name.js");
var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var canAssign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var onValueSymbol = canSymbol.for('can.onValue');
var offValueSymbol = canSymbol.for('can.offValue');
var onEmitSymbol = canSymbol.for('can.onEmit');
var offEmitSymbol = canSymbol.for('can.offEmit');

// We register a namespaced radiochange event with the global
// event registry so it does not interfere with user-defined events.
var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var radioChangeEvent = __webpack_require__(/*! can-event-dom-radiochange */ "./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js");
var internalRadioChangeEventType = "can-attribute-observable-radiochange";
domEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);

var isSelect = function isSelect(el) {
	return el.nodeName.toLowerCase() === "select";
};

var isMultipleSelect = function isMultipleSelect(el, prop) {
	return isSelect(el) && prop === "value" && el.multiple;
};

var slice = Array.prototype.slice;

function canUtilAEL () {
	var args = slice.call(arguments, 0);
	args.unshift(this);
	return domEvents.addEventListener.apply(null, args);
}

function canUtilREL () {
	var args = slice.call(arguments, 0);
	args.unshift(this);
	return domEvents.removeEventListener.apply(null, args);
}

function AttributeObservable(el, prop, bindingData, event) {
	if(typeof bindingData === "string") {
		event = bindingData;
		bindingData = undefined;
	}

	this.el = el;
	this.bound = false;
	this.prop = isMultipleSelect(el, prop) ? "values" : prop;
	this.event = event || getEventName(el, prop);
	this.handler = this.handler.bind(this);

	// If we have an event
	// remove onValue/offValue and add onEvent
	if (event !== undefined) {
		this[onValueSymbol] = null;
		this[offValueSymbol] = null;
		this[onEmitSymbol] = AttributeObservable.prototype.on;
		this[offEmitSymbol] = AttributeObservable.prototype.off;
	}


	//!steal-remove-start
	if(true) {
		// register what changes the element's attribute
		canReflectDeps.addMutatedBy(this.el, this.prop, this);

		canReflect.assignSymbols(this, {
			"can.getName": function getName() {
				return (
					"AttributeObservable<" +
					el.nodeName.toLowerCase() +
					"." +
					this.prop +
					">"
				);
			}
		});
	}
	//!steal-remove-end
}

AttributeObservable.prototype = Object.create(SettableObservable.prototype);

canAssign(AttributeObservable.prototype, {
	constructor: AttributeObservable,

	get: function get() {
		if (ObservationRecorder.isRecording()) {
			ObservationRecorder.add(this);
			if (!this.bound) {
				Observation.temporarilyBind(this);
			}
		}
		var value = attr.get(this.el, this.prop);
		if (typeof value === 'function') {
			value = value.bind(this.el);
		}
		return value;
	},

	set: function set(newVal) {
		var setterDispatchedEvents = attr.setAttrOrProp(this.el, this.prop, newVal);
		// update the observation internal value
		if(!setterDispatchedEvents) {
			this._value = newVal;
		}


		return newVal;
	},

	handler: function handler(newVal, event) {
		var old = this._value;
		var queuesArgs = [];
		this._value = attr.get(this.el, this.prop);

		// If we have an event then we want to enqueue on all changes
		// otherwise only enquue when there are changes to the value
		if (event !== undefined || this._value !== old) {
			//!steal-remove-start
			if(true) {
				if (typeof this._log === "function") {
					this._log(old, newVal);
				}
			}
			//!steal-remove-end


			queuesArgs = [
				this.handlers.getNode([]),
  			this,
  			[newVal, old]
  		];
			//!steal-remove-start
			if(true) {
				queuesArgs = [
					this.handlers.getNode([]),
					this,
					[newVal, old]
					/* jshint laxcomma: true */
					,null
					,[this.el,this.prop,"changed to", newVal, "from", old, "by", event]
					/* jshint laxcomma: false */
				];
			}
			//!steal-remove-end
			// adds callback handlers to be called w/i their respective queue.
			queues.enqueueByQueue.apply(queues, queuesArgs);
		}
	},

	onBound: function onBound() {
		var observable = this;

		observable.bound = true;

		// make sure `this.handler` gets the new value instead of
		// the event object passed to the event handler
		observable._handler = function(event) {
			observable.handler(attr.get(observable.el, observable.prop), event);
		};

		if (observable.event === internalRadioChangeEventType) {
			canEvent.on.call(observable.el, "change", observable._handler);
		}

		var specialBinding = attr.findSpecialListener(observable.prop);
		if (specialBinding) {
			observable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);
		}

		canEvent.on.call(observable.el, observable.event, observable._handler);

		// initial value
		this._value = attr.get(this.el, this.prop);
	},

	onUnbound: function onUnbound() {
		var observable = this;

		observable.bound = false;

		if (observable.event === internalRadioChangeEventType) {
			canEvent.off.call(observable.el, "change", observable._handler);
		}

		if (observable._specialDisposal) {
			observable._specialDisposal.call(observable.el, canUtilREL);
			observable._specialDisposal = null;
		}

		canEvent.off.call(observable.el, observable.event, observable._handler);
	},

	valueHasDependencies: function valueHasDependencies() {
		return true;
	},

	getValueDependencies: function getValueDependencies() {
		var m = new Map();
		var s = new Set();
		s.add(this.prop);
		m.set(this.el, s);
		return {
			keyDependencies: m
		};
	}
});

canReflect.assignSymbols(AttributeObservable.prototype, {
	"can.isMapLike": false,
	"can.getValue": AttributeObservable.prototype.get,
	"can.setValue": AttributeObservable.prototype.set,
	"can.onValue": AttributeObservable.prototype.on,
	"can.offValue": AttributeObservable.prototype.off,
	"can.valueHasDependencies": AttributeObservable.prototype.hasDependencies,
	"can.getValueDependencies": AttributeObservable.prototype.getValueDependencies
});

module.exports = AttributeObservable;


/***/ }),

/***/ "./node_modules/can-attribute-observable/event.js":
/*!********************************************************!*\
  !*** ./node_modules/can-attribute-observable/event.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ "./node_modules/can-dom-events/helpers/util.js").isDomEventTarget;

var canEvent = {
	on: function on(eventName, handler, queue) {
		if (isDomEventTarget(this)) {
			domEvents.addEventListener(this, eventName, handler, queue);
		} else {
			canReflect.onKeyValue(this, eventName, handler, queue);
		}
	},
	off: function off(eventName, handler, queue) {
		if (isDomEventTarget(this)) {
			domEvents.removeEventListener(this, eventName, handler, queue);
		} else {
			canReflect.offKeyValue(this, eventName, handler, queue);
		}
	},
	one: function one(event, handler, queue) {
		// Unbind the listener after it has been executed
		var one = function() {
			canEvent.off.call(this, event, one, queue);
			return handler.apply(this, arguments);
		};

		// Bind the altered listener
		canEvent.on.call(this, event, one, queue);
		return this;
	}
};

module.exports = canEvent;


/***/ }),

/***/ "./node_modules/can-attribute-observable/get-event-name.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-attribute-observable/get-event-name.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var attr = __webpack_require__(/*! ./behaviors */ "./node_modules/can-attribute-observable/behaviors.js");

var isRadioInput = function isRadioInput(el) {
	return el.nodeName.toLowerCase() === "input" && el.type === "radio";
};

// Determine the event or events we need to listen to when this value changes.
module.exports = function getEventName(el, prop) {
	var event = "change";

	if (isRadioInput(el) && prop === "checked" ) {
		event = "can-attribute-observable-radiochange";
	}

	if (attr.findSpecialListener(prop)) {
		event = prop;
	}

	return event;
};


/***/ }),

/***/ "./node_modules/can-bind/can-bind.js":
/*!*******************************************!*\
  !*** ./node_modules/can-bind/can-bind.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canAssign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

//!steal-remove-start
if(true) {
	var canLog = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
	var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
}
//!steal-remove-end

// Symbols
var getChangesSymbol = canSymbol.for("can.getChangesDependencyRecord");
var getValueSymbol = canSymbol.for("can.getValue");
var onValueSymbol = canSymbol.for("can.onValue");
var onEmitSymbol = canSymbol.for("can.onEmit");
var offEmitSymbol = canSymbol.for("can.offEmit");
var setValueSymbol = canSymbol.for("can.setValue");
var canElementSymbol = canSymbol.for("can.element");

// Default implementations for setting the child and parent values
function defaultSetValue(newValue, observable) {
	canReflect.setValue(observable, newValue);
}

// onEmit function
function onEmit (listenToObservable, updateFunction, queue) {
	return listenToObservable[onEmitSymbol](updateFunction, queue);
}

// offEmit function
function offEmit (listenToObservable, updateFunction, queue) {
	return listenToObservable[offEmitSymbol](updateFunction, queue);
}

// Given an observable, stop listening to it and tear down the mutation dependencies
function turnOffListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {
	var offValueOrOffEmitFn;

	// Use either offValue or offEmit depending on which Symbols are on the `observable`
	if (listenToObservable[onValueSymbol]) {
		offValueOrOffEmitFn = canReflect.offValue;
	} else if (listenToObservable[onEmitSymbol]) {
		offValueOrOffEmitFn = offEmit;
	}

	if (offValueOrOffEmitFn) {
		offValueOrOffEmitFn(listenToObservable, updateFunction, queue);

		//!steal-remove-start
		if(true) {

			// The updateObservable is no longer mutated by listenToObservable
			canReflectDeps.deleteMutatedBy(updateObservable, listenToObservable);

			// The updateFunction no longer mutates anything
			updateFunction[getChangesSymbol] = function getChangesDependencyRecord() {
			};

		}
		//!steal-remove-end
	}
}

// Given an observable, start listening to it and set up the mutation dependencies
function turnOnListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {
	var onValueOrOnEmitFn;

	// Use either onValue or onEmit depending on which Symbols are on the `observable`
	if (listenToObservable[onValueSymbol]) {
		onValueOrOnEmitFn = canReflect.onValue;
	} else if (listenToObservable[onEmitSymbol]) {
		onValueOrOnEmitFn = onEmit;
	}

	if (onValueOrOnEmitFn) {
		onValueOrOnEmitFn(listenToObservable, updateFunction, queue);

		//!steal-remove-start
		if(true) {

			// The updateObservable is mutated by listenToObservable
			canReflectDeps.addMutatedBy(updateObservable, listenToObservable);

			// The updateFunction mutates updateObservable
			updateFunction[getChangesSymbol] = function getChangesDependencyRecord() {
				var s = new Set();
				s.add(updateObservable);
				return {
					valueDependencies: s
				};
			};

		}

		//!steal-remove-end
	}
}

// Semaphores are used to keep track of updates to the child & parent
// For debugging purposes, Semaphore and Bind are highly coupled.
function Semaphore(binding, type) {
	this.value = 0;
	this._binding = binding;
	this._type = type;
}
canAssign(Semaphore.prototype, {
	decrement: function() {
		this.value -= 1;
	},
	increment: function(args) {
		this._incremented = true;
		this.value += 1;
		//!steal-remove-start
		if(true) {
			if(this.value === 1) {
				this._binding._debugSemaphores = [];
			}
			var semaphoreData = {
				type: this._type,
				action: "increment",
				observable: args.observable,
				newValue: args.newValue,
				value: this.value,
				lastTask: queues.lastTask()
			};
			this._binding._debugSemaphores.push(semaphoreData);
		}
		//!steal-remove-end
	}
});

function Bind(options) {
	this._options = options;

	// These parameters must be supplied
	//!steal-remove-start
	if(true) {
		if (options.child === undefined) {
			throw new TypeError("You must supply a child");
		}
		if (options.parent === undefined) {
			throw new TypeError("You must supply a parent");
		}
		if (options.queue && ["notify", "derive", "domUI","dom"].indexOf(options.queue) === -1) {
			throw new RangeError("Invalid queue; must be one of notify, derive, dom, or domUI");
		}
	}
	//!steal-remove-end

	// queue; by default, domUI
	if (options.queue === undefined) {
		if(options.element) {
			options.queue = "dom";
		} else {
			options.queue = "domUI";
		}

	}

	// cycles: when an observable is set in a two-way binding, it can update the
	// other bound observable, which can then update the original observable the
	// “cycles” number of times. For example, a child is set and updates the parent;
	// with cycles: 0, the parent could not update the child;
	// with cycles: 1, the parent could update the child, which can update the parent
	// with cycles: 2, the parent can update the child again, and so on and so forth…
	if (options.cycles > 0 === false) {
		options.cycles = 0;
	}

	// onInitDoNotUpdateChild is false by default
	options.onInitDoNotUpdateChild =
		typeof options.onInitDoNotUpdateChild === "boolean" ?
			options.onInitDoNotUpdateChild
			: false;

	// onInitDoNotUpdateParent is false by default
	options.onInitDoNotUpdateParent =
		typeof options.onInitDoNotUpdateParent === "boolean" ?
			options.onInitDoNotUpdateParent
			: false;

	// onInitSetUndefinedParentIfChildIsDefined is true by default
	options.onInitSetUndefinedParentIfChildIsDefined =
		typeof options.onInitSetUndefinedParentIfChildIsDefined === "boolean" ?
			options.onInitSetUndefinedParentIfChildIsDefined
			: true;

	// The way the cycles are tracked is through semaphores; currently, when
	// either the child or parent is updated, we increase their respective
	// semaphore so that if it’s two-way binding, then the “other” observable
	// will only update if the total count for both semaphores is less than or
	// equal to twice the number of cycles (because a cycle means two updates).
	var childSemaphore = new Semaphore(this,"child");
	var parentSemaphore = new Semaphore(this,"parent");

	// Determine if this is a one-way or two-way binding; by default, accept
	// whatever options are passed in, but if they’re not defined, then check for
	// the getValue and setValue symbols on the child and parent values.
	var childToParent = true;
	if (typeof options.childToParent === "boolean") {
		// Always let the option override any checks
		childToParent = options.childToParent;
	} else if (options.child[getValueSymbol] == null) {
		// Child to parent won’t work if we can’t get the child’s value
		childToParent = false;
	} else if (options.setParent === undefined && options.parent[setValueSymbol] == null) {
		// Child to parent won’t work if we can’t set the parent’s value
		childToParent = false;
	}
	var parentToChild = true;
	if (typeof options.parentToChild === "boolean") {
		// Always let the option override any checks
		parentToChild = options.parentToChild;
	} else if (options.parent[getValueSymbol] == null) {
		// Parent to child won’t work if we can’t get the parent’s value
		parentToChild = false;
	} else if (options.setChild === undefined && options.child[setValueSymbol] == null) {
		// Parent to child won’t work if we can’t set the child’s value
		parentToChild = false;
	}
	if (childToParent === false && parentToChild === false) {
		throw new Error("Neither the child nor parent will be updated; this is a no-way binding");
	}
	this._childToParent = childToParent;
	this._parentToChild = parentToChild;

	// Custom child & parent setters can be supplied; if they aren’t provided,
	// then create our own.
	if (options.setChild === undefined) {
		options.setChild = defaultSetValue;
	}
	if (options.setParent === undefined) {
		options.setParent = defaultSetValue;
	}

	// Set the observables’ priority
	if (options.priority !== undefined) {
		canReflect.setPriority(options.child, options.priority);
		canReflect.setPriority(options.parent, options.priority);
	}

	// These variables keep track of how many updates are allowed in a cycle.
	// cycles is multipled by two because one update is allowed for each side of
	// the binding, child and parent. One more update is allowed depending on the
	// sticky option; if it’s sticky, then one more update needs to be allowed.
	var allowedUpdates = options.cycles * 2;
	var allowedChildUpdates = allowedUpdates + (options.sticky === "childSticksToParent" ? 1 : 0);
	var allowedParentUpdates = allowedUpdates + (options.sticky === "parentSticksToChild" ? 1 : 0);

	// This keeps track of whether we’re bound to the child and/or parent; this
	// allows startParent() to be called first and on() can be called later to
	// finish setting up the child binding. This is also checked when updating
	// values; if stop() has been called but updateValue() is called, then we
	// ignore the update.
	this._bindingState = {
		child: false,
		parent: false
	};

	// This is the listener that’s called when the parent changes
	this._updateChild = function(newValue) {
		updateValue.call(this, {
			bindingState: this._bindingState,
			newValue: newValue,

			// Some options used for debugging
			debugObservableName: "child",
			debugPartnerName: "parent",

			// Main observable values
			observable: options.child,
			setValue: options.setChild,
			semaphore: childSemaphore,

			// If the sum of the semaphores is less than or equal to this number, then
			// it’s ok to update the child with the new value.
			allowedUpdates: allowedChildUpdates,

			// If options.sticky === "parentSticksToChild", then after the parent sets
			// the child, check to see if the child matches the parent; if not, then
			// set the parent to the child’s value. This is used in cases where the
			// child modifies its own value and the parent should be kept in sync with
			// the child.
			sticky: options.sticky === "parentSticksToChild",

			// Partner observable values
			partner: options.parent,
			setPartner: options.setParent,
			partnerSemaphore: parentSemaphore
		});
	}.bind(this);

	// This is the listener that’s called when the child changes
	this._updateParent = function(newValue) {
		updateValue.call(this, {
			bindingState: this._bindingState,
			newValue: newValue,

			// Some options used for debugging
			debugObservableName: "parent",
			debugPartnerName: "child",

			// Main observable values
			observable: options.parent,
			setValue: options.setParent,
			semaphore: parentSemaphore,

			// If the sum of the semaphores is less than or equal to this number, then
			// it’s ok to update the parent with the new value.
			allowedUpdates: allowedParentUpdates,

			// If options.sticky === "childSticksToParent", then after the child sets
			// the parent, check to see if the parent matches the child; if not, then
			// set the child to the parent’s value. This is used in cases where the
			// parent modifies its own value and the child should be kept in sync with
			// the parent.
			sticky: options.sticky === "childSticksToParent",

			// Partner observable values
			partner: options.child,
			setPartner: options.setChild,
			partnerSemaphore: childSemaphore
		});
	}.bind(this);

	if(options.element) {
		this._updateChild[canElementSymbol] = this._updateParent[canElementSymbol] = options.element;
	}

	//!steal-remove-start
	if(true) {

		Object.defineProperty(this._updateChild, "name", {
			value: options.updateChildName ? options.updateChildName : "update "+canReflect.getName(options.child),
			configurable: true
		});

		Object.defineProperty(this._updateParent, "name", {
			value: options.updateParentName ? options.updateParentName : "update "+canReflect.getName(options.parent),
			configurable: true
		});
	}
	//!steal-remove-end

}

Object.defineProperty(Bind.prototype, "parentValue", {
	get: function() {
		return canReflect.getValue(this._options.parent);
	}
});

canAssign(Bind.prototype, {

	// Turn on any bindings that haven’t already been enabled;
	// also update the child or parent if need be.
	start: function() {
		var childValue;
		var options = this._options;
		var parentValue;

		// The tests don’t show that it matters which is bound first, but we’ll
		// bind to the parent first to stay consistent with how
		// can-stache-bindings did things.
		this.startParent();
		this.startChild();

		// Initialize the child & parent values
		if (this._childToParent === true && this._parentToChild === true) {
			// Two-way binding
			parentValue = canReflect.getValue(options.parent);
			if (parentValue === undefined) {
				childValue = canReflect.getValue(options.child);
				if (childValue === undefined) {
					// Check if updating the child is allowed
					if (options.onInitDoNotUpdateChild === false) {
						this._updateChild(parentValue);
					}
				} else if (options.onInitDoNotUpdateParent === false && options.onInitSetUndefinedParentIfChildIsDefined === true) {
					this._updateParent(childValue);
				}
			} else {
				// Check if updating the child is allowed
				if (options.onInitDoNotUpdateChild === false) {
					this._updateChild(parentValue);
				}
			}

			//!steal-remove-start
			if(true){
				// Here we want to do a dev-mode check to see whether the child does type conversions on
				//  any two-way bindings.  This will be ignored and the child and parent will be desynched.
				var parentContext = options.parent.observation && options.parent.observation.func || options.parent;
				var childContext = options.child.observation && options.child.observation.func || options.child;
				parentValue = canReflect.getValue(options.parent);
				childValue = canReflect.getValue(options.child);
				if (options.sticky && childValue !== parentValue) {
					canLog.warn(
						"can-bind: The " +
						(options.sticky === "parentSticksToChild" ? "parent" : "child") +
						" of the sticky two-way binding " +
						(options.debugName || (canReflect.getName(parentContext) + "<->" + canReflect.getName(childContext))) +
						" is changing or converting its value when set. Conversions should only be done on the binding " +
						(options.sticky === "parentSticksToChild" ? "child" : "parent") +
						" to preserve synchronization. " +
						"See https://canjs.com/doc/can-stache-bindings.html#StickyBindings for more about sticky bindings"
					);
				}
			}
			//!steal-remove-end

		} else if (this._childToParent === true) {
			// One-way child -> parent, so update the parent
			// Check if we are to initialize the parent
			if (options.onInitDoNotUpdateParent === false) {
				childValue = canReflect.getValue(options.child);
				this._updateParent(childValue);
			}

		} else if (this._parentToChild === true) {
			// One-way parent -> child, so update the child
			// Check if updating the child is allowed
			if (options.onInitDoNotUpdateChild === false) {
				parentValue = canReflect.getValue(options.parent);
				this._updateChild(parentValue);
			}
		}
	},

	// Listen for changes to the child observable and update the parent
	startChild: function() {
		if (this._bindingState.child === false && this._childToParent === true) {
			var options = this._options;
			this._bindingState.child = true;
			turnOnListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);
		}
	},

	// Listen for changes to the parent observable and update the child
	startParent: function() {
		if (this._bindingState.parent === false && this._parentToChild === true) {
			var options = this._options;
			this._bindingState.parent = true;
			turnOnListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);
		}
	},

	// Turn off all the bindings
	stop: function() {
		var bindingState = this._bindingState;
		var options = this._options;

		// Turn off the parent listener
		if (bindingState.parent === true && this._parentToChild === true) {
			bindingState.parent = false;
			turnOffListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);
		}

		// Turn off the child listener
		if (bindingState.child === true && this._childToParent === true) {
			bindingState.child = false;
			turnOffListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);
		}
	}

});

["parent", "child"].forEach(function(property){
	Object.defineProperty(Bind.prototype, property, {
		get: function(){
			return this._options[property];
		}
	});
});



// updateValue is a helper function that’s used by updateChild and updateParent
function updateValue(args) {
	/* jshint validthis: true */
	// Check to see whether the binding is active; ignore updates if it isn’t active
	var bindingState = args.bindingState;
	if (bindingState.child === false && bindingState.parent === false) {
		// We don’t warn the user about this because it’s a common occurrence in
		// can-stache-bindings, e.g. {{#if value}}<input value:bind="value"/>{{/if}}
		return;
	}

	// Now check the semaphore; if this change is happening because the partner
	// observable was just updated, we only want to update this observable again
	// if the total count for both semaphores is less than or equal to the number
	// of allowed updates.
	var semaphore = args.semaphore;
	if ((semaphore.value + args.partnerSemaphore.value) <= args.allowedUpdates) {
		queues.batch.start();

		// Increase the semaphore so that when the batch ends, if an update to the
		// partner observable’s value is made, then it won’t update this observable
		// again unless cycles are allowed.
		semaphore.increment(args);

		// Update the observable’s value; this uses either a custom function passed
		// in when the binding was initialized or canReflect.setValue.
		args.setValue(args.newValue, args.observable);



		// Decrease the semaphore after all other updates have occurred
		queues.mutateQueue.enqueue(semaphore.decrement, semaphore, []);

		queues.batch.stop();

		// Stickiness is used in cases where the call to args.setValue above might
		// have resulted in the observable being set to a different value than what
		// was passed into this function (args.newValue). If sticky:true, then set
		// the partner observable’s value so they’re kept in sync.
		if (args.sticky) {
			var observableValue = canReflect.getValue(args.observable);
			if (observableValue !== canReflect.getValue(args.partner)) {
				args.setPartner(observableValue, args.partner);
			}
		}

	} else {
		// It’s natural for this “else” block to be hit in two-way bindings; as an
		// example, if a parent gets set and the child gets updated, the child’s
		// listener to update the parent will be called, but it’ll be ignored if we
		// don’t want cycles. HOWEVER, if this gets called and the parent is not the
		// same value as the child, then their values are going to be out of sync,
		// probably unintentionally. This is worth pointing out to developers
		// because it can cause unexpected behavior… some people call those bugs. :)

		//!steal-remove-start
		if(true){
			var currentValue = canReflect.getValue(args.observable);
			if (currentValue !== args.newValue) {
				var warningParts = [
					"can-bind: attempting to update " + args.debugObservableName + " " + canReflect.getName(args.observable) + " to new value: %o",
					"…but the " + args.debugObservableName + " semaphore is at " + semaphore.value + " and the " + args.debugPartnerName + " semaphore is at " + args.partnerSemaphore.value + ". The number of allowed updates is " + args.allowedUpdates + ".",
					"The " + args.debugObservableName + " value will remain unchanged; it’s currently: %o. ",
					"Read https://canjs.com/doc/can-bind.html#Warnings for more information. Printing mutation history:"
				];
				canLog.warn(warningParts.join("\n"), args.newValue, currentValue);
				if(console.groupCollapsed) {
					// stores the last stack we've seen so we only need to show what's happened since the
					// last increment.
					var lastStack = [];
					var getFromLastStack = function(stack){
						if(lastStack.length) {
							// walk backwards
							for(var i = lastStack.length - 1; i >= 0 ; i--) {
								var index = stack.indexOf(lastStack[i]);
								if(index !== - 1) {
									return stack.slice(i+1);
								}
							}
						}
						return stack;
					};
					// Loop through all the debug information
					// And print out what caused increments.
					this._debugSemaphores.forEach(function(semaphoreMutation){
						if(semaphoreMutation.action === "increment") {
							console.groupCollapsed(semaphoreMutation.type+" "+canReflect.getName(semaphoreMutation.observable)+" set.");
							var stack = queues.stack(semaphoreMutation.lastTask);
							var printStack = getFromLastStack(stack);
							lastStack = stack;
							// This steals how `logStack` logs information.
							queues.logStack.call({
								stack: function(){
									return printStack;
								}
							});
							console.log(semaphoreMutation.type+ " semaphore incremented to "+semaphoreMutation.value+".");
							console.log(canReflect.getName(semaphoreMutation.observable),semaphoreMutation.observable,"set to ", semaphoreMutation.newValue);
							console.groupEnd();
						}
					});
					console.groupCollapsed(args.debugObservableName+" "+canReflect.getName(args.observable)+" NOT set.");
					var stack = getFromLastStack(queues.stack());
					queues.logStack.call({
						stack: function(){
							return stack;
						}
					});
					console.log(args.debugObservableName+" semaphore ("+semaphore.value+
					 ") + "+args.debugPartnerName+" semaphore ("+args.partnerSemaphore.value+ ") IS NOT <= allowed updates ("+
					 args.allowedUpdates+")");
					console.log("Prevented from setting "+canReflect.getName(args.observable), args.observable, "to", args.newValue);
					console.groupEnd();
				}
			}
		}
		//!steal-remove-end
	}
}

module.exports = namespace.Bind = Bind;


/***/ }),

/***/ "./node_modules/can-child-nodes/can-child-nodes.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-child-nodes/can-child-nodes.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

/**
 * @module {function} can-child-nodes
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 * 
 * @signature `childNodes(node)`
 *
 * Get all of the childNodes of a given node.
 *
 * ```js
 * var stache = require("can-stache");
 * var childNodes = require("can-util/child-nodes/child-nodes");
 *
 * var html = "<div><h1><span></span></h1></div>";
 * var frag = stache(html)();
 *
 * console.log(childNodes(frag)[0].nodeName); // -> DIV
 * ```
 *
 * @param {Object} node The Node that you want child nodes for.
 */

function childNodes(node) {
	var childNodes = node.childNodes;
	if ("length" in childNodes) {
		return childNodes;
	} else {
		var cur = node.firstChild;
		var nodes = [];
		while (cur) {
			nodes.push(cur);
			cur = cur.nextSibling;
		}
		return nodes;
	}
}

module.exports = namespace.childNodes = childNodes;


/***/ }),

/***/ "./node_modules/can-cid/can-cid.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/can-cid.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
/**
 * @module {function} can-cid
 * @parent can-typed-data
 * @collection can-infrastructure
 * @package ./package.json
 * @description Utility for getting a unique identifier for an object.
 * @signature `cid(object, optionalObjectType)`
 *
 * Get a unique identifier for the object, optionally prefixed by a type name.
 *
 * Once set, the unique identifier does not change, even if the type name
 * changes on subsequent calls.
 *
 * ```js
 * var cid = require("can-cid");
 * var x = {};
 * var y = {};
 *
 * console.log(cid(x, "demo")); // -> "demo1"
 * console.log(cid(x, "prod")); // -> "demo1"
 * console.log(cid(y));         // -> "2"
 * ```
 *
 * @param {Object} object The object to uniquely identify.
 * @param {String} name   An optional type name with which to prefix the identifier
 *
 * @return {String} Returns the unique identifier
 */
var _cid = 0;
// DOM nodes shouldn't all use the same property
var domExpando = "can" + new Date();
var cid = function (object, name) {
	var propertyName = object.nodeName ? domExpando : "_cid";

	if (!object[propertyName]) {
		_cid++;
		object[propertyName] = (name || '') + _cid;
	}
	return object[propertyName];
};
cid.domExpando = domExpando;
cid.get = function(object){
	var type = typeof object;
	var isObject = type !== null && (type === "object" || type === "function");
	return isObject ? cid(object) : (type + ":" + object);
};

if (namespace.cid) {
	throw new Error("You can't have two versions of can-cid, check your dependencies");
} else {
	module.exports = namespace.cid = cid;
}


/***/ }),

/***/ "./node_modules/can-cid/helpers.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/helpers.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";

module.exports = {
    each: function(obj, cb, context) {
        for(var prop in obj) {
            cb.call(context, obj[prop], prop);
        }
        return obj;
    }
};


/***/ }),

/***/ "./node_modules/can-cid/map/map.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/map/map.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getCID = __webpack_require__(/*! ../can-cid */ "./node_modules/can-cid/can-cid.js").get;
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-cid/helpers.js");

var CIDMap;

if(typeof Map !== "undefined") {
	CIDMap = Map;
} else {
	var CIDMap = function(){
		this.values = {};
	};
	CIDMap.prototype.set = function(key, value){
		this.values[getCID(key)] = {key: key, value: value};
	};
	CIDMap.prototype["delete"] = function(key){
		var has = getCID(key) in this.values;
		if(has) {
			delete this.values[getCID(key)];
		}
		return has;
	};
	CIDMap.prototype.forEach = function(cb, thisArg) {
		helpers.each(this.values, function(pair){
			return cb.call(thisArg || this, pair.value, pair.key, this);
		}, this);
	};
	CIDMap.prototype.has = function(key) {
		return getCID(key) in this.values;
	};
	CIDMap.prototype.get = function(key) {
		var obj = this.values[getCID(key)];
		return obj && obj.value;
	};
	CIDMap.prototype.clear = function() {
		return this.values = {};
	};
	Object.defineProperty(CIDMap.prototype,"size",{
		get: function(){
			var size = 0;
			helpers.each(this.values, function(){
				size++;
			});
			return size;
		}
	});
}

module.exports = CIDMap;


/***/ }),

/***/ "./node_modules/can-cid/set/set.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/set/set.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getCID = __webpack_require__(/*! ../can-cid */ "./node_modules/can-cid/can-cid.js").get;
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-cid/helpers.js");

var CIDSet;

if(typeof Set !== "undefined") {
	CIDSet = Set;
} else {
	var CIDSet = function(){
		this.values = {};
	};
	CIDSet.prototype.add = function(value){
		this.values[getCID(value)] = value;
	};
	CIDSet.prototype["delete"] = function(key){
		var has = getCID(key) in this.values;
		if(has) {
			delete this.values[getCID(key)];
		}
		return has;
	};
	CIDSet.prototype.forEach = function(cb, thisArg) {
		helpers.each(this.values, cb, thisArg);
	};
	CIDSet.prototype.has = function(value) {
		return getCID(value) in this.values;
	};
	CIDSet.prototype.clear = function() {
		return this.values = {};
	};
	Object.defineProperty(CIDSet.prototype,"size",{
		get: function(){
			var size = 0;
			helpers.each(this.values, function(){
				size++;
			});
			return size;
		}
	});
}

module.exports = CIDSet;


/***/ }),

/***/ "./node_modules/can-component/can-component.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-component/can-component.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// # can-component.js
// This implements the `Component` which allows you to create widgets
// that use a view, a view-model, and custom tags.
//
// `Component` implements most of it's functionality in the `Component.setup`
// and the `Component.prototype.setup` functions.
//
// `Component.setup` prepares everything needed by the `Component.prototype.setup`
// to hookup the component.
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var Bind = __webpack_require__(/*! can-bind */ "./node_modules/can-bind/can-bind.js");
var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var stache = __webpack_require__(/*! can-stache */ "./node_modules/can-stache/can-stache.js");
var stacheBindings = __webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");
var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");
var viewCallbacks = __webpack_require__(/*! can-view-callbacks */ "./node_modules/can-view-callbacks/can-view-callbacks.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var SimpleMap = __webpack_require__(/*! can-simple-map */ "./node_modules/can-simple-map/can-simple-map.js");
var DefineMap = __webpack_require__(/*! can-define/map/map */ "./node_modules/can-define/map/map.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var domData = __webpack_require__(/*! can-dom-data */ "./node_modules/can-dom-data/can-dom-data.js");
var string = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var DOCUMENT = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");

var ComponentControl = __webpack_require__(/*! ./control/control */ "./node_modules/can-component/control/control.js");

// #### Side effects

__webpack_require__(/*! can-view-model */ "./node_modules/can-view-model/can-view-model.js");
// DefineList must be imported so Arrays on the ViewModel
// will be converted to DefineLists automatically
__webpack_require__(/*! can-define/list/list */ "./node_modules/can-define/list/list.js");

// Makes sure bindings are added simply by importing component.
stache.addBindings(stacheBindings);

// #### Symbols
var createdByCanComponentSymbol = canSymbol("can.createdByCanComponent");
var getValueSymbol = canSymbol.for("can.getValue");
var setValueSymbol = canSymbol.for("can.setValue");
var viewInsertSymbol = canSymbol.for("can.viewInsert");
var viewModelSymbol = canSymbol.for('can.viewModel');


// ## Helpers

// ### addContext
// For replacement elements like `<can-slot>` and `<context>`, this is used to
// figure out what data they should render with.  Slots can have bindings like
// `this:from="value"` or `x:from="y"`.
//
// If `this` is set, a compute is created for the context.
// If variables are set, a variable scope is created.
//
// Arguments:
//
// - el - the insertion element
// - tagData - the tagData the insertion element will be rendered with
// - insertionElementTagData - the tagData found at the insertion element.
//
// Returns: the tagData the template should be rendered with.
function addContext(el, tagData, insertionElementTagData) {
	var vm,
		newScope;

	// Prevent setting up bindings manually.
	domData.set(el, "preventDataBindings", true);

	var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData,
		// `createViewModel` is used to create the ViewModel that the
		// bindings will operate on.
		function createViewModel(initialData, hasDataBinding, bindingState) {

			if(bindingState && bindingState.isSettingOnViewModel === true) {
				// If we are setting a value like `x:from="y"`,
				// we need to make a variable scope.
				newScope = tagData.scope.addLetContext(initialData);
				return newScope._context;

			} else {
				// If we are setting the ViewModel itself, we
				// stick the value in an observable: `this:from="value"`.
				return vm = new SimpleObservable(initialData);
			}
		}, undefined, true);

	if(!teardown) {
		// If no teardown, there's no bindings, no need to change the scope.
		return tagData;
	} else {
		// Copy `tagData` and overwrite the scope.
		return assign( assign({}, tagData), {
			teardown: teardown,
			scope: newScope || tagData.scope.add(vm)
		});
	}
}

// ### makeReplacementTagCallback
// Returns a `viewCallbacks.tag` function for `<can-slot>` or `<content>`.
// The `replacementTag` function:
// - gets the proper tagData
// - renders it the template
// - adds the rendered result to the page using nodeLists
//
// Arguments:
// - `tagName` - the tagName being created (`"can-slot"`).
// - `componentTagData` - the component's tagData, including its scope.
// - `shadowTagData` - the tagData where the element was found.
// - `leakScope` - how scope is being leaked.
// - `getPrimaryTemplate(el)` - a function to call to get the template to be rendered.
function makeReplacementTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {

	var options = shadowTagData.options;

	// `replacementTag` is called when `<can-slot>` is found.
	// Arguments:
	// - `el` - the element
	// - `insertionElementTagData` - the tagData where the element was found.
	return function replacementTag(el, insertionElementTagData) {
		// If there's no template to be rendered, we'll render what's inside the
		// element. This is usually default content.
		var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate,
			// `true` if we are rendering something the user "passed" to this component.
			renderingLightContent = template !== insertionElementTagData.subtemplate;

		// If there's no template and no default content, we will do nothing. If
		// there is a template to render, lets render it!
		if (template) {

			// It's possible that rendering the contents of a `<can-slot>` will end up
			// rendering another `<can-slot>`.  We should make sure we can't render ourselves.
			delete options.tags[tagName];

			// First, lets figure out what we should be rendering
			// the template with.
			var tagData;

			// If we are rendering something the user passed.
			if( renderingLightContent ) {

				if(leakScope.toLightContent) {
					// We want to render with the same scope as the
					// `insertionElementTagData.scope`, but we don't want the
					// TemplateContext of the component's view included.
					tagData = addContext(el, {
						scope: insertionElementTagData.scope.cloneFromRef(),
						options: insertionElementTagData.options
					}, insertionElementTagData);
				}
				else {
					// render with the same scope the component was found within.
					tagData = addContext(el, componentTagData, insertionElementTagData);
				}
			} else {
				// We are rendering default content so this content should
				// use the same scope as the <content> tag was found within.
				tagData = addContext(el, insertionElementTagData, insertionElementTagData);
			}


			// Now we need to render the right template and insert its result in the page.
			// We need to teardown any bindings created too so we create a nodeList
			// to do this.
			var fragment = template(tagData.scope, tagData.options);
			if(tagData.teardown) {

				var placeholder = el.ownerDocument.createComment(tagName);
				fragment.insertBefore(placeholder, fragment.firstChild);
				domMutate.onNodeRemoved(placeholder, tagData.teardown);
			}

			el.parentNode.replaceChild(
				fragment,
				el
			);
			/*
			var nodeList = nodeLists.register([el], tagData.teardown || noop,
				insertionElementTagData.parentNodeList || true,
				insertionElementTagData.directlyNested);

			nodeList.expression = "<can-slot name='"+el.getAttribute('name')+"'/>";

			var frag = template(tagData.scope, tagData.options);


			var newNodes = canReflect.toArray( getChildNodes(frag) );
			var oldNodes = nodeLists.update(nodeList, newNodes);
			nodeLists.replace(oldNodes, frag);*/

			// Restore the proper tag function so it could potentially be used again (as in lists)
			options.tags[tagName] = replacementTag;
		}
	};
}
// ### getSetupFunctionForComponentVM
// This helper function is used to setup a Component when `new Component({viewModel})`
// is called.
// Arguments:
// - `componentInitVM` - The `viewModel` object used to initialize the actual viewModel.
// Returns: A component viewModel setup function.
function getSetupFunctionForComponentVM(componentInitVM) {


	return ObservationRecorder.ignore(function(el, componentTagData, makeViewModel, initialVMData) {

		var bindingContext = {
			element: el,
			scope: componentTagData.scope,
			parentNodeList: componentTagData.parentNodeList,
			viewModel: undefined
		};

		var bindingSettings = {};

		var bindings = [];

		// Loop through all viewModel props and create dataBindings.
		canReflect.eachKey(componentInitVM, function(parent, propName) {

			var canGetParentValue = parent != null && !!parent[getValueSymbol];
			var canSetParentValue = parent != null && !!parent[setValueSymbol];

			// If we can get or set the value, then we’ll create a binding
			if (canGetParentValue === true || canSetParentValue) {

				// Create an observable for reading/writing the viewModel
				// even though it doesn't exist yet.
				var child = stacheBindings.getObservableFrom.viewModel({
					name: propName,
				}, bindingContext, bindingSettings);

				// Create the binding similar to what’s in can-stache-bindings
				var canBinding = new Bind({
					child: child,
					parent: parent,
					queue: "dom",
					element: el,

					//!steal-remove-start
					// For debugging: the names that will be assigned to the updateChild
					// and updateParent functions within can-bind
					updateChildName: "update viewModel." + propName + " of <" + el.nodeName.toLowerCase() + ">",
					updateParentName: "update " + canReflect.getName(parent) + " of <" + el.nodeName.toLowerCase() + ">"
					//!steal-remove-end
				});

				bindings.push({
					binding: canBinding,
					siblingBindingData: {
						parent: {
							source: "scope",
							exports: canGetParentValue
						},
						child: {
							source: "viewModel",
							exports: canSetParentValue,
							name: propName
						}
					}
				});

			} else {
				// Can’t get or set the value, so assume it’s not an observable
				initialVMData[propName] = parent;
			}
		});

		// Initialize the viewModel.  Make sure you
		// save it so the observables can access it.
		var initializeData = stacheBindings.behaviors.initializeViewModel(bindings, initialVMData, function(properties){
			return bindingContext.viewModel = makeViewModel(properties);
		}, bindingContext);

		// Return a teardown function
		return function() {
			for (var attrName in initializeData.onTeardowns) {
				initializeData.onTeardowns[attrName]();
			}
		};
	});
}

var Component = Construct.extend(

	// ## Static
	{
		// ### setup
		//
		// When a component is extended, this sets up the component's internal constructor
		// functions and views for later fast initialization.
		// jshint maxdepth:6
		setup: function() {
			Construct.setup.apply(this, arguments);

			// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet
			// which ensures that the following code is ran only in constructors that extend `Component`.
			if (Component) {
				var self = this;

				// Define a control using the `events` prototype property.
				if(this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {
					this.Control = ComponentControl.extend(this.prototype.events);
				}

				//!steal-remove-start
				if (true) {
					// If a constructor is assigned to the viewModel, give a warning
					if (this.prototype.viewModel && canReflect.isConstructorLike(this.prototype.viewModel)) {
						canDev.warn("can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html");
					}
				}
				//!steal-remove-end

				// Look at viewModel, scope, and ViewModel properties and set one of:
				//  - this.viewModelHandler
				//  - this.ViewModel
				//  - this.viewModelInstance
				var protoViewModel = this.prototype.viewModel || this.prototype.scope;

				if(protoViewModel && this.prototype.ViewModel) {
					throw new Error("Cannot provide both a ViewModel and a viewModel property");
				}
				var vmName = string.capitalize( string.camelize(this.prototype.tag) )+"VM";
				if(this.prototype.ViewModel) {
					if(typeof this.prototype.ViewModel === "function") {
						this.ViewModel = this.prototype.ViewModel;
					} else {
						this.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);
					}
				} else {

					if(protoViewModel) {
						if(typeof protoViewModel === "function") {
							if(canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
								this.ViewModel = protoViewModel;
							} else {
								this.viewModelHandler = protoViewModel;
							}
						} else {
							if(canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
								//!steal-remove-start
								if (true) {
									canLog.warn("can-component: "+this.prototype.tag+" is sharing a single map across all component instances");
								}
								//!steal-remove-end
								this.viewModelInstance = protoViewModel;
							} else {
								canLog.warn("can-component: "+this.prototype.tag+" is extending the viewModel into a can-simple-map");
								this.ViewModel = SimpleMap.extend(vmName,{},protoViewModel);
							}
						}
					} else {
						this.ViewModel = SimpleMap.extend(vmName,{},{});
					}
				}

				// Convert the template into a renderer function.
				if (this.prototype.template) {
					//!steal-remove-start
					if (true) {
						canLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');
					}
					//!steal-remove-end
					this.view = this.prototype.template;
				}
				if (this.prototype.view) {
					this.view = this.prototype.view;
				}

				// default to stache if renderer is a string
				if (typeof this.view === "string") {
					var viewName = string.capitalize( string.camelize(this.prototype.tag) )+"View";
					this.view = stache(viewName, this.view);
				}

				// TODO: Remove in next release.
				this.renderer = this.view;

				var renderComponent = function(el, tagData) {
					// Check if a symbol already exists on the element; if it does, then
					// a new instance of the component has already been created
					if (el[createdByCanComponentSymbol] === undefined) {
						new self(el, tagData);
					}
				};

				//!steal-remove-start
				if (true) {
					Object.defineProperty(renderComponent, "name",{
						value: "render <"+this.prototype.tag+">",
						configurable: true
					});
					renderComponent = queues.runAsTask(renderComponent, function(el, tagData) {
						return ["Rendering", el, "with",tagData.scope];
					});
				}
				//!steal-remove-end

				// Register this component to be created when its `tag` is found.
				viewCallbacks.tag(this.prototype.tag, renderComponent);
			}
		}
	}, {
		// ## Prototype
		// ### setup
		// When a new component instance is created, setup bindings, render the view, etc.
		setup: function(el, componentTagData) {
			// Save arguments so if this component gets re-inserted,
			// we can setup again.
			this._initialArgs = [el,componentTagData];

			var component = this;

			var options = {
				helpers: {},
				tags: {}
			};

			// #### Clean up arguments

			// If componentTagData isn’t defined, check for el and use it if it’s defined;
			// otherwise, an empty object is needed for componentTagData.
			if (componentTagData === undefined) {
				if (el === undefined) {
					componentTagData = {};
				} else {
					componentTagData = el;
					el = undefined;
				}
			}

			// Create an element if it doesn’t exist and make it available outside of this
			if (el === undefined) {
				el = DOCUMENT().createElement(this.tag);
				el[createdByCanComponentSymbol] = true;
			}
			this.element = el;

			if(componentTagData.initializeBindings === false && !this._skippedSetup) {
				// Temporary, will be overridden.
				this._skippedSetup = this._torndown = true;
				this.viewModel = Object.create(null);
				return;
			}

			var componentContent = componentTagData.content;
			if (componentContent !== undefined) {
				// Check if it’s already a renderer function or
				// a string that needs to be parsed by stache
				if (typeof componentContent === "function") {
					componentTagData.subtemplate = componentContent;
				} else if (typeof componentContent === "string") {
					componentTagData.subtemplate = stache(componentContent);
				}
			}

			var componentScope = componentTagData.scope;
			if (componentScope !== undefined && componentScope instanceof Scope === false) {
				componentTagData.scope = new Scope(componentScope);
			}

			// Hook up any templates with which the component was instantiated
			var componentTemplates = componentTagData.templates;
			if (componentTemplates !== undefined) {
				canReflect.eachKey(componentTemplates, function(template, name) {
					// Check if it’s a string that needs to be parsed by stache
					if (typeof template === "string") {
						var debugName = name + " template";
						componentTemplates[name] = stache(debugName, template);
					}
				});
			}

			// #### Setup ViewModel
			var viewModel;
			var initialViewModelData = {};

			var preventDataBindings = domData.get(el, "preventDataBindings");

			var teardownBindings;
			if (preventDataBindings) {
				viewModel = el[viewModelSymbol];
			} else {
				// Set up the bindings
				var setupFn;
				if (componentTagData.setupBindings) {
					setupFn = function(el, componentTagData, callback, initialViewModelData){
						return componentTagData.setupBindings(el, callback, initialViewModelData);
					};
				} else if (componentTagData.viewModel) {
					// Component is being instantiated with a viewModel
					setupFn = getSetupFunctionForComponentVM(componentTagData.viewModel);

					//!steal-remove-start
					if (true) {
						setupFn = queues.runAsTask(setupFn, function(el, componentTagData) {
							return ["Constructing", el, "with viewModel",componentTagData.viewModel];
						});
					}
					//!steal-remove-end
				} else {
					setupFn = stacheBindings.behaviors.viewModel;
				}


				teardownBindings = setupFn(el, componentTagData, function(initialViewModelData) {

					var ViewModel = component.constructor.ViewModel,
						viewModelHandler = component.constructor.viewModelHandler,
						viewModelInstance = component.constructor.viewModelInstance;

					if(viewModelHandler) {
						var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
						if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult) ) {
							// If the function returns a can.Map, use that as the viewModel
							viewModelInstance = scopeResult;
						} else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
							// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`
							ViewModel = scopeResult;
						} else {
							// Otherwise extend `SimpleMap` with the `scopeResult` and initialize it with the `initialViewModelData`
							ViewModel = SimpleMap.extend(scopeResult);
						}
					}

					if(ViewModel) {
						viewModelInstance = new ViewModel(initialViewModelData);
					}
					viewModel = viewModelInstance;
					return viewModelInstance;
				}, initialViewModelData);
			}

			// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property
			this.viewModel = viewModel;
			el[viewModelSymbol] = viewModel;
			el.viewModel = viewModel;
			domData.set(el, "preventDataBindings", true);

			// TEARDOWN SETUP
			var removedDisposal,
				connectedDisposal,
				viewModelDisconnectedCallback;
			function teardownComponent(){
				if(removedDisposal) {
					removedDisposal();
					removedDisposal = null;
				}
				component._torndown = true;
				domEvents.dispatch(el, "beforeremove", false);
				if(teardownBindings) {
					teardownBindings();
				}
				if(viewModelDisconnectedCallback) {
					viewModelDisconnectedCallback(el);
				} else if(typeof viewModel.stopListening === "function"){
					viewModel.stopListening();
				}
				if(connectedDisposal) {
					connectedDisposal();
					connectedDisposal = null;
				}
			}

			// #### Helpers
			// TODO: remove in next release
			// Setup helpers to callback with `this` as the component
			if(this.helpers !== undefined) {
				canReflect.eachKey(this.helpers, function(val, prop) {
					if (typeof val === "function") {
						options.helpers[prop] = val.bind(viewModel);
					}
				});
			}

			// #### `events` control
			// TODO: remove in next release
			// Create a control to listen to events
			if(this.constructor.Control) {
				this._control = new this.constructor.Control(el, {
					// Pass the viewModel to the control so we can listen to it's changes from the controller.
					scope: this.viewModel,
					viewModel: this.viewModel
				});
			}

			removedDisposal = domMutate.onNodeRemoved(el, function () {
				var doc = el.ownerDocument;
				var rootNode = doc.contains ? doc : doc.documentElement;
				if (!rootNode || !rootNode.contains(el)) {
					teardownComponent();
				}
			});

			// #### Rendering

			var leakScope = {
				toLightContent: this.leakScope === true,
				intoShadowContent: this.leakScope === true
			};

			var hasShadowView = !!(this.constructor.view);
			var shadowFragment;

			// Get what we should render between the component tags
			// and the data for it.
			var betweenTagsView;
			var betweenTagsTagData;
			if( hasShadowView ) {
				var shadowTagData;
				if (leakScope.intoShadowContent) {
					// Give access to the component's data and the VM
					shadowTagData = {
						scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
						options: options
					};

				} else { // lexical
					// only give access to the VM
					shadowTagData = {
						scope: new Scope(this.viewModel, null, { viewModel: true }),
						options: options
					};
				}

				// Add a hookup for each <can-slot>
				options.tags['can-slot'] = makeReplacementTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function(el) {
					var templates = componentTagData.templates;
					if (templates) {// This is undefined if the component is <self-closing/>
						return templates[el.getAttribute("name")];
					}
				});

				// Add a hookup for <content>
				options.tags.content = makeReplacementTagCallback('content',  componentTagData, shadowTagData, leakScope, function() {
					return componentTagData.subtemplate;
				});

				betweenTagsView = this.constructor.view;
				betweenTagsTagData = shadowTagData;
			}
			else {
				// No shadow template.
				// Render light template with viewModel on top
				var lightTemplateTagData = {
					scope: componentTagData.scope.add(this.viewModel, {
						viewModel: true
					}),
					options: options
				};
				betweenTagsTagData = lightTemplateTagData;
				betweenTagsView = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
			}




			// Keep a nodeList so we can kill any directly nested nodeLists within this component



			shadowFragment = betweenTagsView(betweenTagsTagData.scope, betweenTagsTagData.options);

			// TODO: afterRender

			// Append the resulting document fragment to the element
			domMutateNode.appendChild.call(el, shadowFragment);

			// Call connectedCallback
			if(viewModel && viewModel.connectedCallback) {
				var body = DOCUMENT().body;
				var componentInPage = body && body.contains(el);

				if(componentInPage) {
					viewModelDisconnectedCallback = viewModel.connectedCallback(el);
				} else {
					connectedDisposal = domMutate.onNodeConnected(el, function () {
						connectedDisposal();
						connectedDisposal = null;
						viewModelDisconnectedCallback = viewModel.connectedCallback(el);
					});
				}

			}
			component._torndown = false;
		}
	});

// This adds support for components being rendered as values in stache templates
Component.prototype[viewInsertSymbol] = function(viewData) {
	if(this._torndown) {
		this.setup.apply(this,this._initialArgs);
	}
	return this.element;
};

module.exports = namespace.Component = Component;


/***/ }),

/***/ "./node_modules/can-component/control/control.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-component/control/control.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Control = __webpack_require__(/*! can-control */ "./node_modules/can-control/can-control.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// ## Helpers
// Attribute names to ignore for setting viewModel values.
var paramReplacer = /\{([^\}]+)\}/g;

var ComponentControl = Control.extend({
		// the lookup path - where templated keys will be looked up
		// change lookup to first look in the viewModel
		_lookup: function(options) {
			return [options.scope, options, window];
		},
		// strip strings that represent delegates from the key
		// viewModel.foo -> foo
		_removeDelegateFromKey: function (key) {
			return key.replace(/^(scope|^viewModel)\./, "");
		},
		// return whether the key is a delegate
		_isDelegate: function(options, key) {
			return key === 'scope' || key === 'viewModel';
		},
		// return the delegate object for a given key
		_getDelegate: function(options, key) {
			return options[key];
		},
		_action: function(methodName, options, controlInstance) {
			var hasObjectLookup;

			paramReplacer.lastIndex = 0;

			hasObjectLookup = paramReplacer.test(methodName);

			// If we don't have options (a `control` instance), we'll run this later.
			if (!controlInstance && hasObjectLookup) {
				return;
			} else {
				return Control._action.apply(this, arguments);
			}
		}
	},
	// Extend `events` with a setup method that listens to changes in `viewModel` and
	// rebinds all templated event handlers.
	{
		setup: function(el, options) {
			this.scope = options.scope;
			this.viewModel = options.viewModel;
			return Control.prototype.setup.call(this, el, options);
		},
		off: function() {
			// If `this._bindings` exists we need to go through it's `readyComputes` and manually
			// unbind `change` event listeners set by the controller.
			if (this._bindings) {
				canReflect.eachKey(this._bindings.readyComputes || {}, function(value) {
					canReflect.offValue(value.compute, value.handler);
				});
			}
			// Call `Control.prototype.off` function on this instance to cleanup the bindings.
			Control.prototype.off.apply(this, arguments);
			this._bindings.readyComputes = {};
		},
		destroy: function() {
			if (typeof this.options.destroy === 'function') {
				this.options.destroy.apply(this, arguments);
			}
			Control.prototype.destroy.apply(this, arguments);

		}
	});

module.exports = ComponentControl;


/***/ }),

/***/ "./node_modules/can-compute/can-compute.js":
/*!*************************************************!*\
  !*** ./node_modules/can-compute/can-compute.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint maxdepth:7*/

// # can.compute
//
// `can.compute` allows the creation of observable values in different forms.
// This module is now just a facade around [proto_compute.js](proto_compute.html).
// `proto_compute.js` provides `can.Compute` as a constructor function where this file,
// `compute.js` wraps an instance of a `can.Compute` with a function.
//
// Other files:
// - [get_value_and_bind.js](get_value_and_bind.js) provides the low-level utility for observing functions.
// - [read.js](read.html) provides a helper that read properties and values in an observable way.



var Compute = __webpack_require__(/*! ./proto-compute */ "./node_modules/can-compute/proto-compute.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var singleReference = __webpack_require__(/*! can-single-reference */ "./node_modules/can-single-reference/can-single-reference.js");

var canReflect = __webpack_require__(/*! can-reflect/reflections/get-set/get-set */ "./node_modules/can-reflect/reflections/get-set/get-set.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canOnValueSymbol = canSymbol.for("can.onValue"),
	canOffValueSymbol = canSymbol.for("can.offValue"),
	canGetValue = canSymbol.for("can.getValue"),
	canSetValue = canSymbol.for("can.setValue"),
	isValueLike = canSymbol.for("can.isValueLike"),
	isMapLike = canSymbol.for("can.isMapLike"),
	isListLike = canSymbol.for("can.isListLike"),
	isFunctionLike = canSymbol.for("can.isFunctionLike"),
	canValueHasDependencies = canSymbol.for("can.valueHasDependencies"),
	canGetValueDependencies = canSymbol.for("can.getValueDependencies");

// The `can.compute` generator function.
var addEventListener = function(ev, handler){
	var compute = this;
	var translationHandler;
	if(handler){
		translationHandler = function() {
		   handler.apply(compute, arguments);
	   };
	   singleReference.set(handler, this, translationHandler);
	}
	return compute.computeInstance.addEventListener(ev, translationHandler);
};

var removeEventListener = function(ev, handler){
		var args = [];
		if (typeof ev !== 'undefined') {
			args.push(ev);
			if (typeof handler !== 'undefined') {
				args.push(singleReference.getAndDelete(handler, this));
			}
		}
		return this.computeInstance.removeEventListener.apply(this.computeInstance, args);
};
var onValue = function(handler, queue){
		return this.computeInstance[canOnValueSymbol](handler, queue);
	},
	offValue = function(handler, queue){
		return this.computeInstance[canOffValueSymbol](handler, queue);
	},
	getValue = function(){
		return this.computeInstance.get();
	},
	setValue = function(value){
		return this.computeInstance.set(value);
	},
	hasDependencies = function(){
		return this.computeInstance.hasDependencies;
	},
	getDependencies = function() {
		return this.computeInstance[canGetValueDependencies]();
	};


var COMPUTE = function (getterSetter, context, eventName, bindOnce) {

	function compute(val) {
		if(arguments.length) {
			return compute.computeInstance.set(val);
		}

		return compute.computeInstance.get();
	}

	// Create an internal `can.Compute`.
	compute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);

	compute.on = compute.bind = compute.addEventListener = addEventListener;
	compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
	compute.isComputed = compute.computeInstance.isComputed;

	compute.clone = function(ctx) {
		if(typeof getterSetter === 'function') {
			context = ctx;
		}
		return COMPUTE(getterSetter, context, ctx, bindOnce);
	};

	// forward on and off to the computeInstance as this doesn't matter
	canReflect.set(compute, canOnValueSymbol, onValue);
	canReflect.set(compute, canOffValueSymbol, offValue);
	canReflect.set(compute, canGetValue, getValue);
	canReflect.set(compute, canSetValue, setValue);
	canReflect.set(compute, isValueLike, true);
	canReflect.set(compute, isMapLike, false);
	canReflect.set(compute, isListLike, false);
	canReflect.set(compute, isFunctionLike, false);
	canReflect.set(compute, canValueHasDependencies, hasDependencies);
	canReflect.set(compute, canGetValueDependencies, getDependencies);
	return compute;
};

// ## Helpers

// ### truthy
// Wraps a compute with another compute that only changes when
// the wrapped compute's `truthiness` changes.
COMPUTE.truthy = function (compute) {
	return COMPUTE(function () {
		var res = compute();
		return !!res;
	});
};

// ### async
// A simple helper that makes an async compute a bit easier.
COMPUTE.async = function(initialValue, asyncComputer, context){
	return COMPUTE(initialValue, {
		fn: asyncComputer,
		context: context
	});
};

// ### compatability
// Setting methods that should not be around in 3.0.
COMPUTE.temporarilyBind = Compute.temporarilyBind;

module.exports = namespace.compute = COMPUTE;


/***/ }),

/***/ "./node_modules/can-compute/proto-compute.js":
/*!***************************************************!*\
  !*** ./node_modules/can-compute/proto-compute.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

// # can/compute/proto_compute (aka can.Compute)
//
// Allows the creation of observablue values. This
// is a prototype based version of [can.compute](compute.html).
//
// can.Computes come in different flavors:
//
// - [Getter / Setter functional computes](#setup-getter-setter-functional-computes).
// - [Property computes](#setup-property-computes).
// - [Setter computes](#setup-setter-computes).
// - [Async computes](#setup-async-computes).
// - [Settings computes](#setup-settings-computes).
// - [Simple value computes](#setup-simple-value-computes).
//
//
// can.Computes have public `.get`, `.set`, `.on`, and `.off` methods that call
// internal methods that are configured differently depending on what flavor of
// compute is being created.  Those methods are:
//
// - `_on(updater)` - Called the first time the compute is bound. This should bind to
//    any source observables.  When any of the source observables have changed, it should call
//    `updater(newVal, oldVal, batchNum)`.
//
// - `_off(updater)` - Called when the compute has no more event handlers.  This should unbind to any source observables.
// - `_get` - Called to get the current value of the compute.
// - `_set` - Called to set the value of the compute.
//
//
//
// Other internal flags and values:
// - `value` - the cached value
// - `_setUpdates` - if calling `_set` will have updated the cached value itself so `_get` does not need to be called.
// - `_canObserve` - if this compute can be observed.
// - `hasDependencies` - if this compute has source observable values.
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var observeReader = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var getObject = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var singleReference = __webpack_require__(/*! can-single-reference */ "./node_modules/can-single-reference/can-single-reference.js");

// ## can.Compute
// Checks the arguments and calls different setup methods.
var Compute = function(getterSetter, context, eventName, bindOnce) {
	var args = [];

	for(var i = 0, arglen = arguments.length; i < arglen; i++) {
		args[i] = arguments[i];
	}

	var contextType = typeof args[1];

	if (typeof args[0] === 'function') {
		// Getter/Setter functional computes.
		// `new can.Compute(function(){ ... })`
		this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
	} else if (args[1] !== undefined) {
		if (contextType === 'string' || contextType === 'number') {
			// Property computes.
			// `new can.Compute(object, propertyName[, eventName])`
			var isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);
			var isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);
			if(isMapLike || isListLike) {
				var map = args[0];
				var propertyName = args[1];
				var mapGetterSetter = function(newValue){
					if(arguments.length) {
						observeReader.set(map,propertyName, newValue);
					} else {
						// forces length to be read
						if(isListLike) {
							observeReader.get(map,"length");
						}
						return observeReader.get(map,""+propertyName);
					}
				};
				this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
			} else {
				this._setupProperty(args[0], args[1], args[2]);
			}

		} else if(contextType === 'function') {
			// Setter computes.
			// `new can.Compute(initialValue, function(newValue){ ... })`
			this._setupSetter(args[0], args[1], args[2]);
		} else {

			if(args[1] && args[1].fn) {
				// Async computes.
				this._setupAsyncCompute(args[0], args[1]);
			} else {
				// Settings computes.
				//`new can.Compute(initialValue, {on, off, get, set})`
				this._setupSettings(args[0], args[1]);
			}

		}
	} else {
		// Simple value computes.
		// `new can.Compute(initialValue)`
		this._setupSimpleValue(args[0]);
	}

	this._args = args;
	this._primaryDepth = 0;

	this.isComputed = true;

};

// ## Helpers

// ## updateOnChange
// A helper to trigger an event when a value changes
var updateOnChange = function(compute, newValue, oldValue, batchNum){

	var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
	// Only trigger event when value has changed
	if (valueChanged) {
		compute.dispatch({type: "change", batchNum: batchNum}, [
			newValue,
			oldValue
		]);
	}
};

// ### setupComputeHandlers
// A helper that creates an `_on` and `_off` function that
// will bind on source observables and update the value of the compute.
var setupComputeHandlers = function(compute, func, context) {
	var observation = new Observation(func, context, compute);
	var updater = compute.updater.bind(compute);
	//!steal-remove-start
	if(true) {
		Object.defineProperty(updater,"name",{
			value: canReflect.getName(compute) + ".updater",
		});
	}
	//!steal-remove-end
	compute.observation = observation;
	return {
		// Call `onchanged` when any source observables change.
		_on: function() {
			canReflect.onValue( observation, updater,"notify");
			if (observation.hasOwnProperty("_value")) {// can-observation 4.1+
				compute.value = observation._value;
			} else {// can-observation < 4.1
				compute.value = observation.value;
			}
		},
		// Unbind `onchanged` from all source observables.
		_off: function() {
			canReflect.offValue( observation, updater,"notify");
		},
		getDepth: function() {
			return observation.getDepth();
		}
	};
};
eventQueue(Compute.prototype);
assign(Compute.prototype, {
	setPrimaryDepth: function(depth) {
		this._primaryDepth = depth;
	},

	// ## Setup getter / setter functional computes
	// Uses the function as both a getter and setter.
	_setupGetterSetterFn: function(getterSetter, context, eventName) {
		this._set = context ? getterSetter.bind(context) : getterSetter;
		this._get = context ? getterSetter.bind(context) : getterSetter;
		this._canObserve = eventName === false ? false : true;
		// The helper provides the on and off methods that use `getValueAndBind`.
		var handlers = setupComputeHandlers(this, getterSetter, context || this);

		assign(this, handlers);
	},
	// ## Setup property computes
	// Listen to a property changing on an object.
	_setupProperty: function(target, propertyName, eventName) {
		var self = this,
			handler;


		// This is objects that can be bound to with can.bind.
		handler = function () {
			self.updater(self._get(), self.value);
		};
		this._get = function() {
			return getObject(target, propertyName);
		};
		this._set = function(value) {
			// allow setting properties n levels deep, if separated with dot syntax
			var properties = propertyName.split("."),
				leafPropertyName = properties.pop();

			if(properties.length) {
				var targetProperty = getObject(target, properties.join('.'));
				targetProperty[leafPropertyName] = value;
			} else {
				target[propertyName] = value;
			}
		};

		this._on = function(update) {
			eventQueue.on.call(target, eventName || propertyName, handler);
			// Set the cached value
			this.value = this._get();
		};
		this._off = function() {
			return eventQueue.off.call( target, eventName || propertyName, handler);
		};
	},
	// ## Setup Setter Computes
	// Only a setter function is specified.
	_setupSetter: function(initialValue, setter, eventName) {
		this.value = initialValue;
		this._set = setter;
		assign(this, eventName);
	},
	// ## Setup settings computes
	// Use whatever `on`, `off`, `get`, `set` the users provided
	// as the internal methods.
	_setupSettings: function(initialValue, settings) {

		this.value = initialValue;

		this._set = settings.set || this._set;
		this._get = settings.get || this._get;

		// This allows updater to be called without any arguments.
		// selfUpdater flag can be set by things that want to call updater themselves.
		if(!settings.__selfUpdater) {
			var self = this,
				oldUpdater = this.updater;
			this.updater = function() {
				oldUpdater.call(self, self._get(), self.value);
			};
		}


		this._on = settings.on ? settings.on : this._on;
		this._off = settings.off ? settings.off : this._off;
	},
	// ## Setup async computes
	// This is a special, non-documented form of a compute
	// rhat can asynchronously update its value.
	_setupAsyncCompute: function(initialValue, settings){
		var self = this;
		// This is the async getter function.  Depending on how many arguments the function takes,
		// we setup bindings differently.
		var getter = settings.fn;
		var bindings;

		this.value = initialValue;

		// This compute will call update with the new value itself.
		this._setUpdates = true;

		// An "async" compute has a `lastSetValue` that represents
		// the last value `compute.set` was called with.
		// The following creates `lastSetValue` as a can.Compute so when
		//  `lastSetValue` is changed, the `getter` can see that change
		// and automatically update itself.
		this.lastSetValue = new Compute(initialValue);

		// Wires up setting this compute to set `lastSetValue`.
		// If the new value matches the last setValue, do nothing.
		this._set = function(newVal){
			if(newVal === self.lastSetValue.get()) {
				return this.value;
			}

			return self.lastSetValue.set(newVal);
		};

		// Wire up the get to pass the lastNewValue
		this._get = function() {
			return getter.call(settings.context, self.lastSetValue.get() );
		};

		if(getter.length === 0) {
			// If it takes no arguments, it should behave just like a Getter compute.
			bindings = setupComputeHandlers(this, getter, settings.context);
		} else if(getter.length === 1) {
			// If it has a single argument, pass it the last setValue.
			bindings = setupComputeHandlers(this, function() {
				return getter.call(settings.context, self.lastSetValue.get() );
			}, settings);

		} else {
			// If the function takes 2 arguments, the second argument is a function
			// that should update the value of the compute (`setValue`). To make this we need
			// the "normal" updater function because we are about to overwrite it.
			var oldUpdater = this.updater,
				resolve = ObservationRecorder.ignore(function(newVal) {
					oldUpdater.call(self, newVal, self.value);
				});

			// Because `setupComputeHandlers` calls `updater` internally with its
			// observation._value as `oldValue` and that might not be up to date,
			// we overwrite updater to always use self.value.
			this.updater = function(newVal) {
				oldUpdater.call(self, newVal, self.value);
			};


			bindings = setupComputeHandlers(this, function() {
				// Call getter, and get new value
				var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
				// If undefined is returned, don't update the value.
				return res !== undefined ? res : this.value;
			}, this);
		}

		assign(this, bindings);
	},
	// ## Setup simple value computes
	// Uses the default `_get`, `_set` behaviors.
	_setupSimpleValue: function(initialValue) {
		this.value = initialValue;
	},
	// ## _bindsetup
	// When a compute is first bound, call the internal `this._on` method.
	// `can.__notObserve` makes sure if `_on` is listening to any observables,
	// they will not be observed by any outer compute.
	_eventSetup: ObservationRecorder.ignore(function () {
		this.bound = true;
		this._on(this.updater);
	}),
	// ## _bindteardown
	// When a compute has no other bindings, call the internal `this._off` method.
	_eventTeardown: function () {
		this._off(this.updater);
		this.bound = false;
	},

	// ## clone
	// Copies this compute, but for a different context.
	// This is mostly used for computes on a map's prototype.
	clone: function(context) {
		if(context && typeof this._args[0] === 'function') {
			this._args[1] = context;
		} else if(context) {
			this._args[2] = context;
		}

		return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
	},
	// ## _on and _off
	// Default _on and _off do nothing.
	_on: function(){},
	_off: function(){},
	// ## get
	// Returns the cached value if `bound`, otherwise, returns
	// the _get value.
	get: function() {
		// If an external compute is tracking observables and
		// this compute can be listened to by "function" based computes ....
		var recordingObservation = ObservationRecorder.isRecording();
		if(recordingObservation && this._canObserve !== false) {

			// ... tell the tracking compute to listen to change on this computed.
			ObservationRecorder.add(this, 'change');
			// ... if we are not bound, we should bind so that
			// we don't have to re-read to get the value of this compute.
			if (!this.bound) {
				Compute.temporarilyBind(this);
			}
		}
		// If computed is bound, use the cached value.
		if (this.bound) {
			// if it has dependencies ... it should do some stuff ...
			if(this.observation) {
				return this.observation.get();
			} else {
				return this.value;
			}
		} else {
			return this._get();
		}
	},
	// ## _get
	// Returns the cached value.
	_get: function() {
		return this.value;
	},
	// ## set
	// Sets the value of the compute.
	// Depending on the type of the compute and what `_set` returns, it might need to call `_get` after
	// `_set` to get the final value.
	set: function(newVal) {

		var old = this.value;

		// Setter may return the value if setter
		// is for a value maintained exclusively by this compute.
		var setVal = this._set(newVal, old);

		// If the setter updated this.value, just return that.
		if(this._setUpdates) {
			return this.value;
		}

		// If the computed function has dependencies,
		// we should call the getter.
		if (this.hasDependencies) {
			return this._get();
		}

		// Setting may not fire a change event, in which case
		// the value must be read
		this.updater(setVal === undefined ? this._get() : setVal, old);

		return this.value;
	},
	// ## _set
	// Updates the cached value.
	_set: function(newVal) {
		return this.value = newVal;
	},
	// ## updater
	// Updates the cached value and fires an event if the value has changed.
	updater: function(newVal, oldVal, batchNum) {
		this.value = newVal;
		var observation = this.observation;
		if (observation) {
			// it's possible the observation doesn't actually
			// have any dependencies
			if (observation.hasOwnProperty("_value")) {// can-observation 4.1+
				observation._value = newVal;
			} else {// can-observation < 4.1
				observation.value = newVal;
			}
		}
		updateOnChange(this, newVal, oldVal, batchNum);
	},
	// ## toFunction
	// Returns a proxy form of this compute.
	toFunction: function() {
		return this._computeFn.bind( this);
	},
	_computeFn: function(newVal) {
		if(arguments.length) {
			return this.set(newVal);
		}

		return this.get();
	}
});

Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;

var hasDependencies = function hasDependencies() {
	return this.observation && this.observation.hasDependencies();
};
Object.defineProperty(Compute.prototype, "hasDependencies", {
	get: hasDependencies
});

// ### temporarilyBind
// Binds computes for a moment to cache their value and prevent re-calculating it.
Compute.temporarilyBind = Observation.temporarilyBind;

// ### async
// A simple helper that makes an async compute a bit easier.
Compute.async = function(initialValue, asyncComputer, context){
	return new Compute(initialValue, {
		fn: asyncComputer,
		context: context
	});
};

// ### truthy
// Wraps a compute with another compute that only changes when
// the wrapped compute's `truthiness` changes.
Compute.truthy = function(compute) {
	return new Compute(function() {
		var res = compute.get();
		if(typeof res === 'function') {
			res = res.get();
		}
		return !!res;
	});
};

canReflect.assignSymbols(Compute.prototype, {
	"can.isValueLike": true,
	"can.isMapLike": false,
	"can.isListLike": false,
	"can.setValue": Compute.prototype.set,
	"can.getValue": Compute.prototype.get,
	"can.valueHasDependencies": hasDependencies,
	"can.onValue": function onValue(handler, queue) {
		function translationHandler(ev, newValue, oldValue) {
			handler(newValue, oldValue);
		}
		singleReference.set(handler, this, translationHandler);
		//!steal-remove-start
		if(true) {
			Object.defineProperty(translationHandler, "name", {
				value: canReflect.getName(handler) + "::onValue"
			});
		}
		//!steal-remove-end
		this.addEventListener("change", translationHandler, queue);
	},
	"can.offValue": function offValue(handler, queue) {
		this.removeEventListener(
			"change",
			singleReference.getAndDelete(handler, this),
			queue
		);
	},
	"can.getValueDependencies": function getValueDependencies() {
		var ret;

		if (this.observation) {
			ret = {
				valueDependencies: new Set([this.observation])
			};
		}

		return ret;
	}
});

module.exports = exports = Compute;


/***/ }),

/***/ "./node_modules/can-connect-ndjson/can-connect-ndjson.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-connect-ndjson/can-connect-ndjson.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ReadableStream */
/* exported connectNdjson */
var connect = __webpack_require__(/*! can-connect */ "./node_modules/can-connect/can-connect.js");
var sortedSetJSON = __webpack_require__(/*! can-connect/helpers/sorted-set-json */ "./node_modules/can-connect/helpers/sorted-set-json.js");
var ndJSONStream = __webpack_require__(/*! can-ndjson-stream */ "./node_modules/can-ndjson-stream/can-ndjson-stream.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var connectNdjson = connect.behavior("data-ndjson", function(baseConnection) {
  //Feature detection and fallback if ReadableStream and fetch are not supported
  try {
    new ReadableStream();
		if(typeof window.fetch !== "function") {
			throw new Error("fetch not supported");
		}
  } catch (err) {
    return {};
  }
  return {
    hydrateList: function(listData, set) {
      set = set || this.listSet(listData);
      var id = sortedSetJSON(set);
      var list = baseConnection.hydrateList.call(this, listData, set);//instance of list constructor

      if (this._getHydrateListCallbacks[id]) {
        this._getHydrateListCallbacks[id].shift()(list);
        if (!this._getHydrateListCallbacks[id].length){
          delete this._getHydrateListCallbacks[id];
        }
      }
      return list;
    },
    _getHydrateListCallbacks: {},
    _getHydrateList: function(set, callback) {
      var id = sortedSetJSON(set);
      if (!this._getHydrateListCallbacks[id]) {
        this._getHydrateListCallbacks[id] = [];
      }
      this._getHydrateListCallbacks[id].push(callback);
    },
    getListData: function(set) {
      var fetchPromise = fetch(this.ndjson || this.url);
      this._getHydrateList(set, function(list) {
        function streamerr(e) {
          canReflect.setKeyValue(list,"isStreaming", false);
          canReflect.setKeyValue(list,"streamError", e);
        }

        fetchPromise.then(function(response) {
          canReflect.setKeyValue(list,"isStreaming", true);
          return ndJSONStream(response.body);
        }).then(function(itemStream) {
          var reader = itemStream.getReader();
          reader.read().then(function read(result) {
            if (result.done) {
              canReflect.setKeyValue(list,"isStreaming", false);
              return;
            }
            list.push(result.value);
            reader.read().then(read, streamerr);
          }, streamerr);
        });
      });

      return fetchPromise.then(function() {
        return {
          data: []
        };
      });
    }
  };
});

module.exports = namespace.connectNdjson = connectNdjson;


/***/ }),

/***/ "./node_modules/can-connect-tag/can-connect-tag.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect-tag/can-connect-tag.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




__webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var expression = __webpack_require__(/*! can-stache/src/expression */ "./node_modules/can-stache/src/expression.js");
var viewCallbacks = __webpack_require__(/*! can-view-callbacks */ "./node_modules/can-view-callbacks/can-view-callbacks.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var each = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").each;
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");


var convertToValue = function(arg){
	if(typeof arg === "function") {
		return convertToValue( arg() );
	} else {
		return arg;
	}
};

function connectTag(tagName, connection){

	var removeBrackets = function(value, open, close){
		open = open || "{";
		close = close || "}";

		if(value[0] === open && value[value.length-1] === close) {
			return value.substr(1, value.length - 2);
		}
		return value;
	};


	viewCallbacks.tag(tagName, function(el, tagData){
		var getList = el.getAttribute("getList") || el.getAttribute("get-list");
		var getInstance = el.getAttribute("get");

		var attrValue = getList || getInstance;
		var method = getList ? "getList" : "get";

		var attrInfo = expression.parse('tmp(' + removeBrackets(attrValue)+")", {baseMethodType: "Call"});
		// -> {hash: {foo: 'bar', zed: 5, abc: {get: 'myValue'}}}


		var addedToPageData = false;
		var addToPageData = ObservationRecorder.ignore(function(set, promise){
			if(!addedToPageData) {
				var root = tagData.scope.peek("%root") || tagData.scope.peek("@root");
				if( root && root.pageData ) {
					if(method === "get"){
						set = connection.id(set);
					}
					root.pageData(connection.name, set, promise);
				}
			}
			addedToPageData = true;
		});

		var request = new Observation(function(){
			var hash = {};
			if(typeof attrInfo.hash === "object") {
				// old expression data
				each(attrInfo.hash, function(val, key) {
					if (val && val.hasOwnProperty("get")) {
						hash[key] = tagData.scope.read(val.get, {}).value;
					} else {
						hash[key] = val;
					}
				});
			} else if(typeof attrInfo.hash === "function"){
				// new expression data
				var getHash = attrInfo.hash(tagData.scope, tagData.options, {});
				each(getHash(), function(val, key) {
					hash[key] = convertToValue(val);
				});
			} else {
				hash = attrInfo.argExprs.length ? canReflect.getValue(attrInfo.argExprs[0].value(tagData.scope, tagData.options))
					: {};
			}

			var promise = connection[method](hash);
			addToPageData(hash, promise);
			return promise;
		});

		el[canSymbol.for('can.viewModel')] = request;

		var frag = tagData.subtemplate ?
					tagData.subtemplate( tagData.scope.add(request), tagData.options ) :
					document.createDocumentFragment();

		// Append the resulting document fragment to the element
		domMutateNode.appendChild.call(el, frag);
	});
}

module.exports = namespace.connectTag = connectTag;


/***/ }),

/***/ "./node_modules/can-connect/all.js":
/*!*****************************************!*\
  !*** ./node_modules/can-connect/all.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var connect = __webpack_require__(/*! ./can-connect */ "./node_modules/can-connect/can-connect.js");

connect.cacheRequests = __webpack_require__(/*! ./cache-requests/cache-requests */ "./node_modules/can-connect/cache-requests/cache-requests.js");

connect.constructor = __webpack_require__(/*! ./constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
connect.constructorCallbacksOnce = __webpack_require__(/*! ./constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
connect.constructorStore = __webpack_require__(/*! ./constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
connect.dataCallbacks = __webpack_require__(/*! ./data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
connect.dataCallbacksCache = __webpack_require__(/*! ./data/callbacks-cache/callbacks-cache */ "./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js");
connect.dataCombineRequests = __webpack_require__(/*! ./data/combine-requests/combine-requests */ "./node_modules/can-connect/data/combine-requests/combine-requests.js");
connect.dataLocalStorageCache = __webpack_require__(/*! ./data/localstorage-cache/localstorage-cache */ "./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js");
connect.dataMemoryCache = __webpack_require__(/*! ./data/memory-cache/memory-cache */ "./node_modules/can-connect/data/memory-cache/memory-cache.js");
connect.dataParse = __webpack_require__(/*! ./data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
connect.dataUrl = __webpack_require__(/*! ./data/url/url */ "./node_modules/can-connect/data/url/url.js");
connect.fallThroughCache = __webpack_require__(/*! ./fall-through-cache/fall-through-cache */ "./node_modules/can-connect/fall-through-cache/fall-through-cache.js");
connect.realTime = __webpack_require__(/*! ./real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");

connect.canMap = __webpack_require__(/*! ./can/map/map */ "./node_modules/can-connect/can/map/map.js");

connect.superMap = __webpack_require__(/*! ./can/super-map/super-map */ "./node_modules/can-connect/can/super-map/super-map.js");
connect.baseMap = __webpack_require__(/*! ./can/base-map/base-map */ "./node_modules/can-connect/can/base-map/base-map.js");

module.exports = connect;


/***/ }),

/***/ "./node_modules/can-connect/base/base.js":
/*!***********************************************!*\
  !*** ./node_modules/can-connect/base/base.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var behavior = __webpack_require__(/*! ../behavior */ "./node_modules/can-connect/behavior.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
/**
 * @module can-connect/base/base base
 * @group can-connect/base/base.options 0 behavior options
 * @group can-connect/base/base.identifiers 1 identifiers
 * @parent can-connect.behaviors
 *
 * The first behavior added to every `can-connect` connection. Provides methods to uniquely identify instances and
 * lists.
 *
 * @signature `base(connectionOptions)`
 *
 * Provides instance and list identifiers. Added automatically to every connection created by the `connect` helper.
 * So even if we do:
 *
 * ```js
 * var connection = connect([],{});
 * ```
 *
 * The connection still has the identification functionality provided by `base`:
 *
 * ```js
 * connection.id({id: 1, ...}) //-> 1
 * ```
 *
 * `can-connect` connections are typically created by the `connect` helper rather than by calling the behaviors directly.
 * This ensures the behaviors are called in the required order and is more elegant than requiring the user to chain
 * together the calls to all the behaviors.
 *
 * See the [can-connect/base/base.id id] and [can-connect/base/base.listQuery listQuery] methods for more specifics on
 * how ids are determined.
 *
 * @param {Object} connectionOptions Object containing the configuration for the behaviors of the connection. Added to the
 * prototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.queryLogic] option since it
 * [can-connect/base/base.id defines how to read the identity properties] and the majority of behaviors also require the queryLogic.
 *
 * @return {Object} A `can-connect` connection containing the methods provided by `base`.
 */
module.exports = behavior("base",function(baseConnection){
	var setQueryLogic;
	return {
		/**
		 * @function can-connect/base/base.id id
		 * @parent can-connect/base/base.identifiers
		 *
		 * Uniquely identify an instance or raw instance data.
		 *
		 * @signature `connection.id(instance)`
		 *
		 *   Returns the instance id as determined by [can-connect/base/base.queryLogic]'s id values.
		 *
		 *   @param {Instance|Object} instance An instance or raw properties for an instance.
		 *
		 *   @return {String|Number} A string or number uniquely representing `instance`.
		 *
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for an
		 * instance or instance data.  This `connection.id` method should return that.
		 *
		 * Typically, an item's id is a simply property value on the object. For example, "Todo" data might look like:
		 *
		 * ```js
		 * {_id: 5, name: "do the dishes"}
		 * ```
		 *
		 * In this case, [can-connect/base/base.queryLogic]'s `id` property should be set to "_id":
		 *
		 * ```js
		 * import QueryLogic from "can-query-logic";
		 *
		 * var queryLogic = new QueryLogic({
		 *   identity: ["_id"]
	 	 * });
		 *
		 * connect([...],{queryLogic: queryLogic});
		 * ```
		 *
		 */
		id: function(instance){
			if(this.queryLogic) {
				return canReflect.getIdentity(instance, this.queryLogic.schema);
			} else if(this.idProp) {
				return instance[this.idProp];
			} else {
				throw new Error("can-connect/base/base - Please add a queryLogic option.");
			}
		},

		/**
		 * @function can-connect/base/base.listQuery listQuery
		 * @parent can-connect/base/base.identifiers
		 *
		 * Uniquely identify the set of data a list contains.
		 *
		 * @signature `connection.listQuery(list)`
		 *
		 *   Returns the value of the property referenced by [can-connect/base/base.listQueryProp] if it exists.
		 *   By default, this will return `list[Symbol.for("can.listQuery")]`.
		 *
		 *   @param {can-connect.List} list A list instance.
		 *
		 *   @return {can-query-logic/query} An object that can be passed to `JSON.stringify` to represent the list.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for a list.
		 * This `connection.listQuery` method should return that.
		 *
		 * Typically, a list's set identifier is a property on the list object.  As example, a list of Todos might look like
		 * the following:
		 *
		 * ```js
		 * var dueTodos = todoConnection.getList({filter: {due: "today"}});
		 * dueTodos; // [{_id: 5, name: "do dishes", due:"today"}, {_id: 6, name: "walk dog", due:"today"}, ...]
		 * dueTodos[Symbol.for("can.listQuery")]; //-> {filter: {due: "today"}}
		 * todoConnection.listQuery(dueTodos); //-> {filter: {due: "today"}}
		 * ```
		 *
		 * In the above example the [can-connect/base/base.listQueryProp] would be the default `@can.listQuery`.
		 */
		listQuery: function(list){
			return list[this.listQueryProp];
		},

		/**
		 * @property {Symbol} can-connect/base/base.listQueryProp listQueryProp
		 * @parent can-connect/base/base.identifiers
		 *
		 * Specifies the property that uniquely identifies a list.
		 *
		 * @option {Symbol} The property that uniquely identifies the list.
		 * Defaults to `Symbol.for("can.listQuery")`.
		 *
		 * ```js
		 * var dataUrl = require("can-connect/data/url/");
		 * var connection = connect([dataUrl], {
		 *   listQueryProp: "set"
		 * });
		 *
		 * var list = [{id: 1, ...}, {id: 2, ...}]
		 * list.set = {complete: true};
		 *
		 * connection.listQuery(list) //-> {complete: true}
		 * ```
		 *
		 */
		listQueryProp: canSymbol.for("can.listQuery"),

		init: function(){},


		/**
		 * @property {can-query-logic} can-connect/base/base.queryLogic queryLogic
		 * @parent can-connect/base/base.options
		 *
		 * Configuration for list comparison, instance identification and membership
		 * calculations. A way for the `can-connect` behaviors to understand what the properties of a request mean and act
		 * on them.
		 *
		 * @option {can-query-logic} A [can-query-logic queryLogic] that is used to perform calculations using set
		 * definition objects passed to [can-connect/connection.getListData] and [can-connect/connection.getList].
		 * Needed to enable [can-connect/fall-through-cache/fall-through-cache caching],
		 * [can-connect/data/combine-requests/combine-requests request combining], [can-connect/real-time/real-time] and other
		 * behaviors. By default no queryLogic is provided.
		 *
		 * An example of the types of calculations behaviors will make using the queryLogic:
		 * ```js
		 * var queryLogic = new QueryLogic({
		 *   identity: ['_uid'],
		 *   keys: {
		 *     _uid: Number
		 *   }
		 * });
		 *
		 * var todoConnection = connect([...behaviors...],{
		 *   queryLogic: queryLogic
		 * });
		 *
		 * todoConnection.queryLogic.memberIdentity({_uid: 5, ...}); //-> 5
		 * todoConnection.id({_uid: 5, ...}); //-> 5
		 * todoConnection.queryLogic.intersection(
		 *   {page: {first: 0, last: 10}},
		 *   {page: {first:  d5, last: 20}}); //-> {first:5, last:10}
		 * ```
		 */

		get queryLogic(){
			if(setQueryLogic) {
				return setQueryLogic;
			} else if(baseConnection.queryLogic) {
				return baseConnection.queryLogic;
			} else if(baseConnection.algebra) {
				return baseConnection.algebra;
			}
		},
		set queryLogic(newVal) {
			setQueryLogic = newVal;
		}

		/**
		 * @property {can-query-logic} can-connect/base/base.algebra algebra
		 * @parent can-connect/base/base.options
		 *
		 * @description Legacy configuration for [can-set-legacy]. Use [can-connect/base/base.queryLogic] instead.
		 */

		/**
		 * @property {can-connect/DataInterface} can-connect/base/base.cacheConnection cacheConnection
		 * @parent can-connect/base/base.options
		 *
		 * An underlying `can-connect` connection used when fetching data from a cache.
		 *
		 * @option {can-connect/DataInterface} A connection that provides access to a cache via [can-connect/DataInterface]
		 * requests. Several behaviors including [can-connect/fall-through-cache/fall-through-cache] expect this property.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * import {memoryStore, connect, QueryLogic} from "can";
		 *
		 * var cacheConnection = memoryStore({
		 *   queryLogic: new QueryLogic({identity: ["id"]})
		 * });
		 *
		 * var todoConnection = connect([...behaviors...],{
		 *   cacheConnection: cacheConnection
		 * });
		 * ```
		 */
	};
});


/***/ }),

/***/ "./node_modules/can-connect/behavior.js":
/*!**********************************************!*\
  !*** ./node_modules/can-connect/behavior.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

var behaviorsMap = {};

function behavior(name, behavior){
	if(typeof name !== "string") {
		behavior = name;
		name = undefined;
	}
	var behaviorMixin = function(base){
		// basically Object.create
		var Behavior = function(){};
		Object.defineProperty(Behavior,"name",{
			value: name,
			configurable: true
		});
		Behavior.prototype = base;
		var newBehavior = new Behavior();
		// allows behaviors to be a simple object, not always a function
		var res = typeof behavior === "function" ? behavior.apply(newBehavior, arguments) : behavior;
		for(var prop in res) {
			if(res.hasOwnProperty(prop)) {
				Object.defineProperty(newBehavior, prop, Object.getOwnPropertyDescriptor(res, prop));
			} else {
				// we only copy values from up the proto chain
				newBehavior[prop] = res[prop];
			}
		}
		newBehavior.__behaviorName = name;
		return newBehavior;
	};
	if(name) {
		behaviorMixin.behaviorName = name;
		behaviorsMap[name] = behaviorMixin;
	}
	behaviorMixin.isBehavior = true;
	return behaviorMixin;
}
behavior.map = behaviorsMap;
module.exports = behavior;


/***/ }),

/***/ "./node_modules/can-connect/cache-requests/cache-requests.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-connect/cache-requests/cache-requests.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! ../can-connect */ "./node_modules/can-connect/can-connect.js");
var getItems = __webpack_require__(/*! ../helpers/get-items */ "./node_modules/can-connect/helpers/get-items.js");
var forEach = Array.prototype.forEach;


/**
 * @module can-connect/cache-requests/cache-requests cache-requests
 * @parent can-connect.behaviors
 * @group can-connect/cache-requests/cache-requests.data data interface
 * @group can-connect/cache-requests/cache-requests.queryLogic queryLogic
 *
 * Cache response data and use it to prevent unnecessary future requests or make future requests smaller.
 *
 * @signature `cacheRequests( baseConnection )`
 *
 *   Provide an implementation of [can-connect/cache-requests/cache-requests.getListData] that uses [can-connect/base/base.queryLogic] to
 *   determine what data is already in the [can-connect/base/base.cacheConnection cache] and what data needs to be
 *   loaded from the base connection.
 *
 *   It then gets data from the cache and the base connection (if needed), merges it, and returns it. Any data returned
 *   from the base connection is added to the cache.
 *
 *   @param {{}} baseConnection `can-connect` connection object that is having the `cache-requests` behavior added
 *   on to it. Should already contain the behaviors that provide the [can-connect/DataInterface]
 *   (e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will
 *   automatically be ordered as required.
 *
 *   @return {Object} A `can-connect` connection containing the methods provided by `cache-requests`.
 *
 *
 * @body
 *
 * ## Use
 *
 * Use `cache-requests` in combination with a cache like [can-connect/data/memory-cache/memory-cache] or
 * [can-connect/data/localstorage-cache/localstorage-cache].  For example, to make it so response data is cached
 * in memory:
 *
 * ```js
 * var memoryStore = require("can-memory-store");
 * var dataUrl = require("can-connect/data/url/url");
 * var cacheRequests = require("can-connect/cache-requests/cache-requests");
 * var queryLogic = require("can-query-logic");
 *
 * var todoQueryLogic = new QueryLogic({});
 *
 * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});
 * var todoConnection = connect([dataUrl, cacheRequests],{
 *   cacheConnection: cacheConnection,
 *   url: "/todos",
 *   queryLogic: todoQueryLogic
 * });
 * ```
 *
 * Now if today's todos are loaded:
 *
 * ```js
 * todoConnection.getListData({filter: {due: "today"}});
 * ```
 *
 * And later, a subset of those todos are loaded:
 *
 * ```js
 * todoConnection.getListData({filter: {due: "today", status: "critical"}});
 * ```
 *
 * The second request will be created from the original request's data.
 *
 * ## QueryLogic Usage
 *
 * `cache-requests` will "fill-in" the `cacheConnection` using [can-query-logic queryLogic].
 *
 * For example, if you requested paginated data like:
 *
 * ```
 * todoConnection.getListData({filter: {status: "critical"}})
 * ```
 *
 * And then later requested:
 *
 * ```
 * todoConnection.getListData({})
 * ```
 *
 * `cache-requests` will only request `{filter: {status: ["low","medium"]}}`, merging
 * that response with the data already present in the cache.
 *
 * That configuration looks like:
 *
 * ```js
 * var memoryStore = require("can-memory-store");
 * var dataUrl = require("can-connect/data/url/url");
 * var cacheRequests = require("can-connect/cache-requests/cache-requests");
 * var queryLogic = require("can-query-logic");
 *
 * var todoQueryLogic = new QueryLogic({
 *   keys: {
 *     status: QueryLogic.makeEnum(["low","medium","critical"])
 *   }
 * });
 *
 * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});
 * var todoConnection = connect([dataUrl, cacheRequests], {
 *   cacheConnection: cacheConnection,
 *   url: "/todos",
 *   queryLogic: todoQueryLogic
 * })
 * ```
 *
 * **Note:** `cacheConnection` shares the same queryLogic configuration as the primary connection.
 */
var cacheRequestsBehaviour = connect.behavior("cache-requests",function(baseConnection){

	return {

		/**
		 * @function can-connect/cache-requests/cache-requests.getDiff getDiff
		 * @parent can-connect/cache-requests/cache-requests.queryLogic
		 *
		 * Compares the cached queries to the requested query and returns a description of what subset can be loaded from the
		 * cache and what subset must be loaded from the base connection.
		 *
		 * @signature `connection.getDiff( query, availableQueries )`
		 *
		 *   This determines the minimal amount of data that must be loaded from the base connection by going through each
		 *   cached query (`availableQueries`) and doing a [can-query-logic.prototype.isSubset isSubset] check and a
		 *   [can-query-logic.prototype.difference query difference] with the requested query (`query`).
		 *
		 *   If `query` is a subset of an `availableSet`, `{cached: query}` will be returned.
		 *
		 *   If `query` is neither a subset of, nor intersects with any `availableQueries`, `{needed: query}` is returned.
		 *
		 *   If `query` has an intersection with one or more `availableQueries`, a description of the difference that has the fewest
		 *   missing elements will be returned. An example diff description looks like:
		 *
		 *   ```
		 *   {
		 *     needed: {start: 50, end: 99}, // the difference, the query that is not cached
		 *     cached: {start: 0, end: 49}, // the intersection, the query that is cached
		 *     count: 49 // the size of the needed query
		 *   }
		 *   ```
		 *
		 *   @param {can-query-logic/query} query The query that is being requested.
		 *   @param {Array<can-query-logic/query>} availableQueries An array of [can-connect/connection.getSets available queries] in the
		 *     [can-connect/base/base.cacheConnection cache].
		 *   @return {Promise<{needed: can-query-logic/query, cached: can-query-logic/query, count: Integer}>} a difference description object. Described above.
		 *
		 */
		getDiff: function( params, availableQueries ){

			var minSets,
				self = this;

			forEach.call(availableQueries, function(query){
				var curSets;
				var difference = self.queryLogic.difference(params, query );
				if( self.queryLogic.isDefinedAndHasMembers(difference) ) {
					var intersection = self.queryLogic.intersection(params, query);
					curSets = {
						needed: difference,
						cached: self.queryLogic.isDefinedAndHasMembers(intersection) ? intersection : false,
						count: self.queryLogic.count(difference)
					};
				} else if( self.queryLogic.isSubset(params, query) ){
					curSets = {
						cached: params,
						count: 0
					};
				}
				if(curSets) {
					if(!minSets || curSets.count < minSets.count) {
						minSets = curSets;
					}
				}
			});

			if(!minSets) {
				return {
					needed: params
				};
			} else {
				return {
					needed: minSets.needed,
					cached: minSets.cached
				};
			}
		},

		/**
		 * @function can-connect/cache-requests/cache-requests.unionMembers unionMembers
		 * @parent can-connect/cache-requests/cache-requests.queryLogic
		 *
		 * Create the requested data set, a union of the cached and un-cached data.
		 *
		 * @signature `connection.unionMembers(set, diff, neededData, cachedData)`
		 *
		 *   Uses [can-query-logic.prototype.unionMembers] to merge the two queries of data (`neededData` & `cachedData`).
		 *
		 * @param {can-query-logic/query} query The parameters of the data set requested.
		 * @param {Object} diff The result of [can-connect/cache-requests/cache-requests.getDiff].
		 * @param {can-connect.listData} neededData The data loaded from the base connection.
		 * @param {can-connect.listData} cachedData The data loaded from the [can-connect/base/base.cacheConnection].
		 *
		 * @return {can-connect.listData} A merged [can-connect.listData] representation of the the cached and requested data.
		 */
		unionMembers: function(params, diff, neededItems, cachedItems){
			// using the diff, re-construct everything
			return {data: this.queryLogic.unionMembers(diff.needed, diff.cached, getItems(neededItems), getItems(cachedItems))};
		},

		/**
		 * @function can-connect/cache-requests/cache-requests.getListData getListData
		 * @parent can-connect/cache-requests/cache-requests.data
		 *
		 * Only request data that isn't already present in the [can-connect/base/base.cacheConnection cache].
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection cache]
		 *   whenever possible.  This works by [can-connect/connection.getSets getting the stored queries]
		 *   from the [can-connect/base/base.cacheConnection cache] and
		 *   doing a [can-connect/cache-requests/cache-requests.getDiff diff] to see what needs to be loaded from the base
		 *   connection and what can be loaded from the [can-connect/base/base.cacheConnection cache].
		 *
		 *   With that information, this `getListData` requests data from the cache or the base connection as needed.
		 *   Data loaded from different sources is combined via [can-connect/cache-requests/cache-requests.unionMembers].
		 *
		 * @param {can-query-logic/query} query the parameters of the list that is being requested.
		 * @return {Promise<can-connect.listData>} a promise that returns an object conforming to the [can-connect.listData] format.
		 */
		getListData: function(set){
			set = set || {};
			var self = this;

			return this.cacheConnection.getSets(set).then(function(queries){

				var diff = self.getDiff(set, queries);

				if(!diff.needed) {
					return self.cacheConnection.getListData(diff.cached);
				} else if(!diff.cached) {
					return baseConnection.getListData(diff.needed).then(function(data){

						return self.cacheConnection.updateListData(getItems(data), diff.needed ).then(function(){
							return data;
						});

					});
				} else {
					var cachedPromise = self.cacheConnection.getListData(diff.cached);
					var needsPromise = baseConnection.getListData(diff.needed);

					var savedPromise = needsPromise.then(function(data){
						return self.cacheConnection.updateListData(  getItems(data), diff.needed ).then(function(){
							return data;
						});
					});
					// start the combine while we might be saving param and adding to cache
					var combinedPromise = Promise.all([
						cachedPromise,
						needsPromise
					]).then(function(result){
						var cached = result[0],
							needed = result[1];
						return self.unionMembers( set, diff, needed, cached);
					});

					return Promise.all([combinedPromise, savedPromise]).then(function(data){
						return data[0];
					});
				}

			});
		}
	};

});

module.exports = cacheRequestsBehaviour;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(cacheRequestsBehaviour, ['getListData', 'cacheConnection']);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/can-connect.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can-connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var connect = __webpack_require__(/*! ./connect */ "./node_modules/can-connect/connect.js");
var base = __webpack_require__(/*! ./base/base */ "./node_modules/can-connect/base/base.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

connect.base = base;

module.exports = ns.connect = connect;


/***/ }),

/***/ "./node_modules/can-connect/can/base-map/base-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-connect/can/base-map/base-map.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");

var constructor = __webpack_require__(/*! ../../constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! ../map/map */ "./node_modules/can-connect/can/map/map.js");
var canRef = __webpack_require__(/*! ../ref/ref */ "./node_modules/can-connect/can/ref/ref.js");
var constructorStore = __webpack_require__(/*! ../../constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var dataCallbacks = __webpack_require__(/*! ../../data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
var dataParse = __webpack_require__(/*! ../../data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! ../../data/url/url */ "./node_modules/can-connect/data/url/url.js");
var realTime = __webpack_require__(/*! ../../real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");
var callbacksOnce = __webpack_require__(/*! ../../constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
var GLOBAL = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");


var $ = GLOBAL().$;

connect.baseMap = function(options){

	var behaviors = [
		constructor,
		canMap,
		canRef,
		constructorStore,
		dataCallbacks,
		dataParse,
		dataUrl,
		realTime,
		callbacksOnce
	];

	// Handles if jQuery isn't provided.
	if($ && $.ajax) {
		options.ajax = $.ajax;
	}

	return connect(behaviors,options);
};

module.exports = connect.baseMap;


/***/ }),

/***/ "./node_modules/can-connect/can/map/map.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can/map/map.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var each = canReflect.each;
var isPlainObject = canReflect.isPlainObject;

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var QueryLogic = __webpack_require__(/*! can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");

var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var behavior = __webpack_require__(/*! ../../behavior */ "./node_modules/can-connect/behavior.js");
var updateDeepExceptIdentity = __webpack_require__(/*! can-diff/update-deep-except-identity/update-deep-except-identity */ "./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js");
var assignDeepExceptIdentity = __webpack_require__(/*! can-diff/assign-deep-except-identity/assign-deep-except-identity */ "./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js");
var smartMerge = __webpack_require__(/*! can-diff/merge-deep/merge-deep */ "./node_modules/can-diff/merge-deep/merge-deep.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var getNameSymbol = canSymbol.for("can.getName");

function smartMergeExceptIdentity(dest, source, schema) {
	if(!schema) {
        schema = canReflect.getSchema(dest);
    }
    if(!schema) {
        throw new Error("can-connect/can/map/ is unable to update without a schema.");
    }
	schema.identity.forEach(function(key){
        var id = canReflect.getKeyValue(dest, key);
        if(id!== undefined) {
            canReflect.setKeyValue(source, key, id );
        }
    });
	smartMerge(dest, source);
}

var canMapBehavior = behavior("can/map",function(baseConnection){

	// overwrite
	var behavior = {
		init: function(){
			if(!this.Map) {
				if (this.ObjectType) {
					this.Map = this.ObjectType;
				} else {
					throw new Error("can-connect/can/map/map must be configured with a Map or ObjectType type");
				}
			}
			if(!this[getNameSymbol]) {
				this[getNameSymbol] = function(){
					if(this.name) {
						return "Connection{"+this.name+"}";
					} else if(this.Map) {
						return "Connection{"+canReflect.getName(this.Map)+"}";
					} else if(typeof this.url === "string") {
						return "Connection{"+this.url+"}";
					} else {
						return "Connection{}";
					}
				};
			}

			this.List = this.List || this.ArrayType || this.Map.List;
			var hasList = Boolean(this.List);

			if (!hasList) {
				Object.defineProperty(this, 'List', {
					get: function () {
						throw new Error("can-connect/can/map/map - "+canReflect.getName(this)+" should be configured with an ArrayType or List type.");
					}
				});
			}

			overwrite(this, this.Map, mapOverwrites);
			if (hasList) {
				overwrite(this, this.List, listOverwrites);
			}

			if(!this.queryLogic) {
				this.queryLogic = new QueryLogic(this.Map);
			}


			var connection = this;

			// ### Setup store updates
			if(this.Map[canSymbol.for("can.onInstanceBoundChange")]) {
				var canConnectMap_onMapBoundChange = function (instance, isBound){
					var method = isBound ? "addInstanceReference" : "deleteInstanceReference";
					if(connection[method]) {
						connection[method](instance);
					}
				};
				//!steal-remove-start
				Object.defineProperty(canConnectMap_onMapBoundChange, "name", {
					value: canReflect.getName(this.Map) + " boundChange",
					configurable: true
				});
				//!steal-remove-end
				this.Map[canSymbol.for("can.onInstanceBoundChange")](canConnectMap_onMapBoundChange);
			} else {
				console.warn("can-connect/can/map is unable to listen to onInstanceBoundChange on the Map type");
			}

			if (hasList) {
				if(this.List[canSymbol.for("can.onInstanceBoundChange")]) {
					var canConnectMap_onListBoundChange = function(list, isBound){
						var method = isBound ? "addListReference" : "deleteListReference";
						if(connection[method]) {
							connection[method](list);
						}
					};
					//!steal-remove-start
					Object.defineProperty(canConnectMap_onListBoundChange, "name", {
						value: canReflect.getName(this.List) + " boundChange",
						configurable: true
					});
					//!steal-remove-end
					this.List[canSymbol.for("can.onInstanceBoundChange")](canConnectMap_onListBoundChange);
				} else {
					console.warn("can-connect/can/map is unable to listen to onInstanceBoundChange on the List type");
				}
			}

			// Adds the instance when its `id` property is set
			if(this.Map[canSymbol.for("can.onInstancePatches")]) {
				this.Map[canSymbol.for("can.onInstancePatches")](function canConnectMap_onInstancePatches(instance, patches){
					patches.forEach(function(patch){
						if( (patch.type === "add" || patch.type === "set") &&
							patch.key === connection.idProp &&
							instance[canSymbol.for("can.isBound")]()) {
							connection.addInstanceReference(instance);
						}
					});
				});
			} else {
				console.warn("can-connect/can/map is unable to listen to onInstancePatches on the Map type");
			}
			baseConnection.init.apply(this, arguments);
		},
		/**
		 * @function can-connect/can/map/map.serializeInstance serializeInstance
		 * @parent can-connect/can/map/map.serializers
		 *
		 * Returns the properties of an instance that should be sent to the data source when saving. Done by calling
		 * [can-define/map/map.prototype.serialize `instance.serialize()`].
		 *
		 * @signature `connection.serializeInstance(instance)`
		 * Simply calls [can-define/map/map.prototype.serialize] on the `instance` argument.
		 *
		 * @param {can-connect/can/map/map._Map} instance the instance to serialize
		 * @return {Object} the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]
		 */
		serializeInstance: function(instance){
			return canReflect.serialize(instance);
		},
		/**
		 * @function can-connect/can/map/map.serializeList serializeList
		 * @parent can-connect/can/map/map.serializers
		 *
		 * Returns the properties of a list that should be sent to the data source when saving. Done by calling
		 * [can-define/list/list.prototype.serialize `list.serialize()`].
		 *
		 * @signature `connection.serializeList(list)`
		 * Simply calls [can-define/list/list.prototype.serialize] on the `list` argument.
		 *
		 * @param {can-connect/can/map/map._List} list the list to serialize
		 * @return {Object} the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]
		 */
		serializeList: function(list){
			return canReflect.serialize(list);
		},
		/**
		 * @property {Boolean} can-connect/can/map/map.updateInstanceWithAssignDeep updateInstanceWithAssignDeep
		 * @parent can-connect/can/map/map.options
		 *
		 * Use the response from `save()` and `destroy()` to assign properties, never delete them.
		 *
		 * @option {Boolean}
		 *
		 * Setting `updateInstanceWithAssignDeep` to `true` changes how instances get updated. Instead of using
		 * [can-diff/merge-deep/merge-deep], records will be updated with [can-reflect.assignDeep].
		 *
		 * The following example shows that the response from `.save()` only includes the `id`
		 * property. Normally, this would delete all other properties (`name`).  But setting `updateInstanceWithAssignDeep`
		 * to `true` prevents this:
		 *
		 * **Usage:**
		 *
		 * ```js
		 * import {DefineMap, restModel} from "can";
		 *
		 * var Todo = DefineMap.extend({
		 *   id: {type: "number", identity: true},
		 *   name: "string"
		 * });
		 *
		 * // restModel uses `can-connect/can/map/map`
		 * restModel({
		 *   Map: Todo,
		 *   url: "/todos",
		 *   updateInstanceWithAssignDeep: true
		 * });
		 *
		 *
		 * var todo = new Todo({name: "learn canjs"})
		 *
		 * var savePromise = todo.save()
		 * // SERVER SENDS
		 * // -> POST /todos {name: "learn canjs"}
		 *
		 * // SERVER RESPONDS WITH:
		 * // <- {id: 5}
		 *
		 * savePromise.then(function(){
		 *   // Name still exists even though the server did not
		 *   // respond with it.
		 *   todo.name //-> "learn canjs"
		 * })
		 * ```
		 *
		 * __NOTE__: [can-diff/merge-deep/merge-deep] is able to work _MUCH_ better with nested
		 * data than [can-reflect.assignDeep]. Specifically, it is able to better
		 * prevent overwriting one instance's data with another. The _Use_ section of [can-diff/merge-deep/merge-deep]
		 * goes over this ability. Make sure you understand its capabilities before turning it off.
		 */

		/**
		 * @property {connection.Map} can-connect/can/map/map._Map Map
		 * @parent can-connect/can/map/map.options
		 *
		 * Specify the type of the `[can-define/map/map DefineMap]` that should be instantiated by the connection.
		 *
		 * @option {connection.Map}
		 *
		 * **Usage:**
		 *
		 * ```js
		 * var DefineMap = require("can-define/map/map");
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * var Todo = DefineMap.extend({
		 *   completed: "boolean",
		 *   complete: function(){
		 *     this.completed = true
		 *   }
		 * });
		 *
		 * var todoConnection = connect([dataUrl, constructor, canMap], {
		 *   Map: Todo,
		 *   url: "/todos"
		 * });
		 *
		 * todoConnect.get({id:1}).then(function(item) {
		 *   item instanceof Todo // true
		 * });
		 * ```
		 */

		/**
		 * @property {connection.List} can-connect/can/map/map._List List
		 * @parent can-connect/can/map/map.options
		 *
		 * Specify the type of the `[can-define/list/list DefineList]` that should be instantiated by the connection.
		 *
		 * @option {connection.List} If this option is not specified it defaults to the [can-connect/can/map/map._Map Map].List
		 * property.
		 *
		 * **Usage:**
		 * ```js
		 * var DefineMap = require("can-define/map/map");
		 * var DefineList = require("can-define/list/list");
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * var Todo = DefineMap.extend({
		 *   completed: "boolean",
		 *   complete: function(){
		 *     this.completed = true
		 *   }
		 * });
		 *
		 * var Todo.List = DefineList.extend({
		 *   "#": Todo,
		 *   completed: function(){
		 *     this.filter(function(todo){
		 *       return todo.completed;
		 *     });
		 *   }
		 * });
		 *
		 * var todoConnection = connect([dataUrl, constructor, canMap],{
		 *   Map: Todo,
		 *   List: Todo.List,
		 *   url: "/todos"
		 * });
		 *
		 * todoConnection.getList({}).then(function(list) {
		 *   list instanceOf Todo.List // true
		 * })
		 * ```
		 *
		 */

		/**
		 * @function can-connect/can/map/map.instance instance
		 * @parent can-connect/can/map/map.hydrators
		 *
		 * Creates a [can-connect/can/map/map._Map] instance given raw data.
		 *
		 * @signature `connection.instance(props)`
		 *
		 *   Create an instance of [can-connect/can/map/map._Map].
		 *
		 *   @param {Object} props the raw instance data.
		 *   @return [can-connect/can/map/map._Map] a [can-connect/can/map/map._Map] instance containing the `props`.
		 */
		instance: function(props){
			var _Map = this.Map;
			return new _Map(props);
		},

		/**
		 * @function can-connect/can/map/map.list list
		 * @parent can-connect/can/map/map.hydrators
		 *
		 * Creates a [can-connect/can/map/map._List] instance given raw data.
		 *
		 * @signature `connection.list(listData, set)`
		 *
		 *   Creates an instance of [can-connect/can/map/map._List] if available, otherwise creates
		 *   [can-connect/can/map/map._Map].List if available.
		 *
		 *   This will add properties on the raw `listData` array to the created list instance. e.g:
		 *   ```js
		 *   var listData = [{id: 1, name:"do dishes"}, ...];
		 *   listData.loadedFrom; // "shard 5"
		 *
		 *   var todoList = todoConnection.list(listData, {});
		 *   todoList.loadedFrom; // "shard 5"
		 *   ```
		 *
		 *   @param {can-connect.listData} listData the raw list data.
		 *   @param {can-query-logic/query} query the set the data belongs to.
		 *   @return {can-connect.List} a [can-connect/can/map/map._List] instance containing instances of
		 *   [can-connect/can/map/map._Map] built from the list items in `listData`.
		 */
		list: function(listData, set){
			var _List = this.List || (this.Map && this.Map.List);
			var list = canReflect.new(_List, listData.data);
			canReflect.eachKey(listData, function (val, prop) {
				if (prop !== 'data') {
					canReflect.setKeyValue(list, prop, val);
				}
			});

			list[this.listQueryProp] = set;
			return list;
		},

		/**
		 * @function can-connect/can/map/map.updatedList updatedList
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.updatedList] callback so it updates the list and it's items
		 * during a single [can-event/batch/batch batched event].
		 *
		 * @signature `connection.updatedList(list, listData, set)`
		 *
		 *   Updates the list and the items within it during a single [can-event/batch/batch batched event].
		 *
		 *   @param {can-connect.List} list the list to be updated.
		 *   @param {can-connect.listData} listData raw list data.
		 *   @param {can-query-logic/query} query the set of the list being updated.
		 */
		updatedList: function(list, listData, set){
			queues.batch.start();
			var enqueueOptions = {};
			//!steal-remove-start
			if(true) {
				enqueueOptions = {
    				reasonLog: ["set", set,"list", list,"updated with", listData]
  				};
			}
			//!steal-remove-end

			queues.mutateQueue.enqueue(baseConnection.updatedList, this, arguments, enqueueOptions);
			queues.batch.stop();

		},
		save: function(instance){
			canReflect.setKeyValue(instance, "_saving", true);
			//canEvent.dispatch.call(instance, "_saving", [true, false]);
			var done = function(){
				canReflect.setKeyValue(instance, "_saving", false);
				//canEvent.dispatch.call(instance, "_saving", [false, true]);
			};
			var base = baseConnection.save.apply(this, arguments);
			base.then(done,done);
			return base;
		},
		destroy: function(instance){
			canReflect.setKeyValue(instance, "_destroying", true);
			//canEvent.dispatch.call(instance, "_destroying", [true, false]);
			var done = function(){
				canReflect.setKeyValue(instance, "_destroying", false);
				//canEvent.dispatch.call(instance, "_destroying", [false, true]);
			};
			var base = baseConnection.destroy.apply(this, arguments);
			base.then(done,done);
			return base;
		}
	};

	each([
		/**
		 * @function can-connect/can/map/map.createdInstance createdInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.createdInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.createdInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches a "created" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   Calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore] to ensure new instances
		 *   are moved into the [can-connect/constructor/store/store.instanceStore] after being saved.
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.createData]
		 */
		"created",
		/**
		 * @function can-connect/can/map/map.updatedInstance updatedInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.updatedInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.updatedInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches an "updated" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.updateData]
		 */
		"updated",
		/**
		 * @function can-connect/can/map/map.destroyedInstance destroyedInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.destroyedInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.destroyedInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches a "destroyed" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.destroyData]
		 */
		"destroyed"
	], function (funcName) {
		// Each of these is pretty much the same, except for the events they trigger.
		behavior[funcName+"Instance"] = function (instance, props) {

			// Update attributes if attributes have been passed
			if(props && typeof props === 'object') {

				if(funcName === "destroyed" && canReflect.size(props) === 0) {
					// If destroy is passed an empty object, ignore update
					// This isn't tested except by can-rest-model.
				} else {
					if(this.constructor.removeAttr) {
						updateDeepExceptIdentity(instance, props, this.queryLogic.schema);
					}
					// this is legacy
					else if(this.updateInstanceWithAssignDeep){
						assignDeepExceptIdentity(instance, props, this.queryLogic.schema);
					}
					else {
						smartMergeExceptIdentity( instance, props, this.queryLogic.schema);
					}
				}

			}
			// This happens in constructor/store, but we don't call base, so we have to do it ourselves.
			if(funcName === "created" && this.moveCreatedInstanceToInstanceStore) {
				this.moveCreatedInstanceToInstanceStore(instance);
			}

			canMapBehavior.callbackInstanceEvents(funcName, instance);
		};
	});


	return behavior;

});

/**
 * @function can-connect/can/map/map.callbackInstanceEvents callbackInstanceEvents
 * @parent can-connect/can/map/map.static
 *
 * Utility function to dispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].
 *
 * @signature `connection.callbackInstanceEvents(cbName, instance)`
 *
 *   Used to dispatch events as part of instance callbacks implementations. This method could be useful in other
 *   behaviors that implement instance callbacks. E.g. a behavior overriding the
 *   [can-connect/can/map/map.updatedInstance `updatedInstance`] callback:
 *
 *   ```
 *   connect([canMap, {
 *       updatedInstance: function(instance, props) {
 *           instance = smartMerge(instance, props);
 *           canMapBehavior.callbackInstanceEvents("updated", instance);
 *       }
 *   }], {})
 *   ```
 *
 *   @param {String} eventName name of the the event to be triggered
 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance.
 */
canMapBehavior.callbackInstanceEvents = function (funcName, instance) {
	var constructor = instance.constructor;

	// triggers change event that bubble's like
	// handler( 'change','1.destroyed' ). This is used
	// to remove items on destroyed from Model Lists.
	// but there should be a better way.
	queues.batch.start();
	eventQueue.dispatch.call(instance, {type: funcName, target: instance});

	//!steal-remove-start
	if(true) {
		if (this.id) {
			dev.log("can-connect/can/map/map.js - " + (constructor.shortName || this.name) + " " + this.id(instance) + " " + funcName);
		}
	}
	//!steal-remove-end

	// Call event on the instance's Class
	eventQueue.dispatch.call(constructor, funcName, [instance]);
	queues.batch.stop();
};


var mapOverwrites = {
	static: {
		/**
		 * @function can-connect/can/map/map.getList getList
		 * @parent can-connect/can/map/map.map-static
		 *
		 * Retrieve a list of instance.
		 *
		 * @signature `Map.getList(query)`
		 *
		 * `.getList` is added to the configured [can-connect/can/map/map._Map] type. Retrieves a [can-connect/can/map/map._List] of
		 * [can-connect/can/map/map._Map] instances via the connection.
		 *
		 * ```js
		 * // import connection plugins
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * // define connection types
		 * var Todo = DefineMap.extend({
		 *   id: "number",
		 *   complete: "boolean",
		 *   name: "string"
		 * });
		 *
		 * Todo.List = DefineList.extend({
		 *   completed: function() {
		 *     return this.filter(function(item) { return item.completed; });
		 *   }
		 * });
		 *
		 * // create connection
		 * connect([canMap, constructor, dataUrl],{
		 *   Map: Todo,
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve instances
		 * Todo.getList({filter: {due: "today"}}).then(function(todos){
		 *   ...
		 * });
		 * ```
		 *
		 * @param {can-query-logic/query} query Definition of the list being retrieved.
		 * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._List] of instances being retrieved
		 *
		 *
		 *
		 *
		 */
		getList: function (base, connection) {
			return function(set) {
				return connection.getList(set);
			};
		},
		/**
		 * @function can-connect/can/map/map.findAll findAll
		 * @parent can-connect/can/map/map.map-static
		 * @hide
		 *
		 * Alias of [can-connect/can/map/map.getList]. You should use `.getList()`.
		 */
		findAll: function (base, connection) {
			return function(set) {
				return connection.getList(set);
			};
		},
		/**
		 * @function can-connect/can/map/map.get get
		 * @parent can-connect/can/map/map.map-static
		 *
		 * Use it to get a single instance by id.
		 *
		 * @signature `Map.get(params)`
		 *
		 * `.get()` is added to the configured [can-connect/can/map/map._Map] type.
		 * Use it to get a single instance by the identity keys of the Map type.
		 *
		 * ```js
		 * // import connection plugins
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * // define connection type
		 * var Todo = DefineMap.extend({
		 *   id: "number",
		 *   complete: "boolean",
		 *   name: "string"
		 * });
		 *
		 * // create connection
		 * connect([canMap, constructor, dataUrl],{
		 *   Map: Todo,
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve instance
		 * Todo.get({id: 5}).then(function(todo){
		 *   ...
		 * });
		 * ```
		 *
		 * @param {Object} params Identifying parameters of the instance to retrieve. Typically, this is an object
		 * with the identity property and its value like: `{_id: 5}`.
		 * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._Map] instance being retrieved
		 *
		 * @body
		 *
		 * ## Get a single record by filtering non-identity keys
		 *
		 * Sometimes, you want a single record, but by filtering non-identity keys.  Instead of using
		 * `.get`, use `.getList` like:
		 *
		 * ```js
		 * var firstCompleteTodo = Todo.getList({
		 *   filter: {complete: false},
		 *   page: {start: 0, end: 0}
		 * }).then(function(list){
		 *   return list.length ? list[0] : Promise.reject({message: "reject message"});
		 * });
		 * ```
		 *
		 */
		get: function (base, connection) {
			return function(params) {
				// adds .then for compat
				return connection.get(params);
			};
		},
		/**
		 * @function can-connect/can/map/map.findOne findOne
		 * @parent can-connect/can/map/map.map-static
		 * @hide
		 *
		 * Alias of [can-connect/can/map/map.get]. You should use `.get()`.
		 */
		findOne: function (base, connection) {
			return function(params) {
				// adds .then for compat
				return connection.get(params);
			};
		}
	},
	prototype: {
		isNew: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isNew isNew
			 * @parent can-connect/can/map/map.map
			 *
			 * If the data is not in the dat
			 *
			 * @signature `instance.isNew()`
			 *
			 * Returns if the instance has not been loaded from or saved to the data source.
			 *
			 * ```js
			 * connect([...],{
			 *   Map: Todo
			 * });
			 *
			 * var todo = new Todo();
			 * todo.isNew()   //-> true
			 *
			 * todo.save().then(function(){
			 *   todo.isNew() //-> false
			 * })
			 * ```
			 *
			 * @return {Boolean} Returns `true` if [can-connect/base/base.id] is `null` or `undefined`.
			 */
			return function () {
				return connection.isNew(this);
			};
		},

		isSaving: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isSaving isSaving
			 * @parent can-connect/can/map/map.map
			 *
			 * Returns if the instance is currently being saved.
			 *
			 * @signature `instance.isSaving()`
			 *
			 * Observes if a promise returned by [can-connect/connection.save `connection.save`] is in progress for this
			 * instance.  This is often used in a template like:
			 *
			 * ```html
			 * <button on:click="todo.save()"
			 *    disabled:from="todo.isSaving()">
			 *   Save Changes
			 * </button>
			 * ```
			 *
			 *   @return {Boolean} Returns `true` if [can-connect/connection.save `connection.save`] has been called for this
			 *   instance but the returned promise has not yet resolved.
			 */
			return function () {
				return !!canReflect.getKeyValue(this,"_saving");
			};
		},

		isDestroying: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isDestroying isDestroying
			 * @parent can-connect/can/map/map.map
			 *
			 * Returns if the instance is currently being destroyed.
			 *
			 * @signature `instance.isDestroying()`
			 *
			 * Observes if a promise returned by [can-connect/connection.destroy `connection.destroy`] is in progress for this
			 * instance.  This is often used in a template like:
			 *
			 * ```html
			 * <button on:click="todo.destroy()"
			 *         disabled:from="todo.isDestroying()">
			 *   Delete
			 * </button>
			 * ```
			 *
			 *   @return {Boolean} `true` if [can-connect/connection.destroy `connection.destroy`] has been called for this
			 *   instance but the returned promise has not resolved.
			 */
			return function () {
				return !!canReflect.getKeyValue(this,"_destroying");
			};
		},

		save: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.save save
			 * @parent can-connect/can/map/map.map
			 *
			 * Save or update client data to the persisted data source.
			 *
			 * @signature `instance.save(success, error)`
			 *
			 * Calls [can-connect/connection.save].
			 *
			 * ```js
			 * // import connection plugins
			 * var canMap = require("can-connect/can/map/map");
			 * var constructor = require("can-connect/constructor/constructor");
			 * var dataUrl = require("can-connect/data/url/url");
			 *
			 * // define connection types
			 * var Todo = DefineMap.extend({
			 *   id: "number",
			 *   complete: "boolean",
			 *   name: "string"
			 * });
			 *
			 * // create connection
			 * connect([canMap, constructor, dataUrl], {
			 *   Map: Todo,
			 *   url: "/todos"
			 * })
			 *
			 * new Todo({name: "dishes"}).save();
			 * ```
			 *
			 *   @param {function} success A function that is called if the save is successful.
			 *   @param {function} error A function that is called if the save is rejected.
			 *   @return {Promise<Instance>} A promise that resolves to the instance if successful.
			 *
			 *
			 */
			return function(success, error){
				// return only one item for compatability
				var promise = connection.save(this);
				promise.then(success,error);
				return promise;
			};
		},
		destroy: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.destroy destroy
			 * @parent can-connect/can/map/map.map
			 *
			 * Delete an instance from the service via the connection.
			 *
			 * @signature `instance.destroy(success, error)`
			 *
			 * Calls [can-connect/connection.destroy] for the `instance`.
			 *
			 * ```js
			 * // import connection plugins
			 * var canMap = require("can-connect/can/map/map");
			 * var constructor = require("can-connect/constructor/constructor");
			 * var dataUrl = require("can-connect/data/url/url");
			 *
			 * // define connection types
			 * var Todo = DefineMap.extend({
			 *   id: "number",
			 *   complete: "boolean",
			 *   name: "string"
			 * });
			 *
			 * // create connection
			 * connect([canMap, constructor, dataUrl],{
			 *   Map: Todo,
			 *   url: "/todos"
			 * })
			 *
			 * // read instance
			 * Todo.get({id: 5}).then(function(todo){
			 *   if (todo.complete) {
			 *     // delete instance
			 *     todo.destroy();
			 *   }
			 * });
			 * ```
			 *
			 * @param {function} success a function that is called if the [can-connect/connection.destroy] call is successful.
			 * @param {function} error a function that is called if the [can-connect/connection.destroy] call is rejected.
			 * @return {Promise<Instance>} a promise that resolves to the instance if successful
			 *
			 *
			 */
			return function(success, error){
				var promise = connection.destroy(this);
				promise.then(success,error);
				return promise;
			};
		}
	},
	properties: {
		_saving: {enumerable: false, value: false, configurable: true, writable: true},
		_destroying: {enumerable: false, value: false, configurable: true, writable: true}
	}
};

var listOverwrites = {
	static:  {
		_bubbleRule: function(base, connection) {
			return function(eventName, list) {
				var bubbleRules = base(eventName, list);
				bubbleRules.push('destroyed');
				return bubbleRules;
			};
		}
	},
	prototype: {
		setup: function(base, connection){
			return function (params) {
				// If there was a plain object passed to the List constructor,
				// we use those as parameters for an initial getList.
				if (isPlainObject(params) && !Array.isArray(params)) {
					this[connection.listQueryProp] = params;
					base.apply(this);
					this.replace(canReflect.isPromise(params) ? params : connection.getList(params));
				} else {
					// Otherwise, set up the list like normal.
					base.apply(this, arguments);
				}
			};
		}
	},
	properties: {}
};

var overwrite = function( connection, Constructor, overwrites) {
	var prop;
	for(prop in overwrites.properties) {
		canReflect.defineInstanceKey(Constructor, prop, overwrites.properties[prop]);
	}
	for(prop in overwrites.prototype) {
		Constructor.prototype[prop] = overwrites.prototype[prop](Constructor.prototype[prop], connection);
	}
	if(overwrites.static) {
		for(prop in overwrites.static) {
			Constructor[prop] = overwrites.static[prop](Constructor[prop], connection);
		}
	}
};

module.exports = canMapBehavior;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");

	module.exports = validate(
		canMapBehavior,
		[
			'id', 'get', 'updatedList', 'destroy', 'save', 'getList'
		]
	);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/can/ref/ref.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can/ref/ref.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {connect.Behavior} can-connect/can/ref/ref can/ref
 * @parent can-connect.behaviors
 * @group can-connect/can/ref/ref.hydrators hydrators
 * @group can-connect/can/ref/ref.methods methods
 *
 * @description Handle references to instances in the data returned by the server. Allows several means of
 * loading referenced instances, determined on-the-fly.
 *
 * @signature `canRef( baseConnection )`
 *
 * Adds a reference type to [can-connect/can/map/map._Map `connection.Map`] that loads the related type or holds onto
 * an existing one. This handles circular references and loads relevant data as needed. The reference type can be loaded
 * by:
 * - it's data being included in the response for the referencing instance
 * - having an existing instance available in the [can-connect/constructor/store/store.instanceStore]
 * - lazy loading via the connection for the reference type
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `can/ref` behavior added on to it.
 * Expects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper
 * is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property
 * (`Map.Ref.type`) created by `can/ref`.
 *
 * @body
 *
 * ## Use
 *
 * `can/ref` is useful when the server might return either a reference to
 * a value or the value itself.  For example, in a MongoDB setup,
 * a request like `GET /game/5` might return:
 *
 * ```
 * {
 *   id: 5,
 *   teamRef: 7,
 *   score: 21
 * }
 * ```
 *
 * But a request like `GET /game/5?$populate=teamRef` might return:
 *
 * ```
 * {
 *   id: 5,
 *   teamRef: {id: 7, name: "Cubs"},
 *   score: 21
 * }
 * ```
 *
 * `can/ref` can handle this ambiguity and even make lazy loading possible.
 *
 * To use `can/ref`, first create a Map and a connection for the referenced type:
 *
 * ```
 * var Team = DefineMap.extend({
 *   id: 'string'
 * });
 *
 * connect([
 *   require("can-connect/constructor/constructor"),
 *   require("can-connect/constructor/store/store"),
 *   require("can-connect/can/map/map"),
 *   require("can-connect/can/ref/ref")
 * ],{
 *     Map: Team,
 *     List: Team.List,
 *     ...
 * })
 * ```
 *
 * The connection is necessary because it creates an instance store which will
 * hold instances of `Team` that the `Team.Ref` type will be able to access.
 *
 * Now we can create a reference to the Team within a Game map and the Game's connection:
 *
 * ```
 * var Game = DefineMap.extend({
 *   id: 'string',
 *   teamRef: {type: Team.Ref.type},
 *   score: "number"
 * });
 *
 * superMap({
 *   Map: Game,
 *   List: Game.List
 * })
 * ```
 *
 * Now, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will
 * house the id of the reference no matter how the server returns data, e.g.
 * `game.teamRef.id`.
 *
 * For example, without populating the team data:
 *
 * ```
 * Game.get({id: 5}).then(function(game){
 *   game.teamRef.id //-> 7
 * });
 * ```
 *
 * With populating the team data:
 *
 * ```
 * Game.get({id: 5, $populate: "teamRef"}).then(function(game){
 *   game.teamRef.id //-> 7
 * });
 * ```
 *
 * The values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type
 * are determined by if the reference was populated or the referenced item already exists
 * in the [can-connect/constructor/store/store.instanceStore].
 *
 * For example, `value`, which points to the referenced instance, will be populated if the reference was populated:
 *
 * ```
 * Game.get({id: 5, $populate: "teamRef"}).then(function(game){
 *   game.teamRef.value.name //-> 5
 * });
 * ```
 *
 * Or, it will be populated if that instance had been loaded through another means and
 * it’s in the instance store:
 *
 * ```
 * Team.get({id: 7}).then(function(team){
 *   // binding adds things to the store
 *   team.on("name", function(){})
 * }).then(function(){
 *   Game.get({id: 5}).then(function(game){
 *     game.teamRef.value.name //-> 5
 *   });
 * })
 * ```
 *
 * `value` is an [can-define.types.get asynchronous getter], which means that even if
 * the referenced value isn't populated or loaded through the store, it can be lazy loaded. This
 * is generally most useful in a template.
 *
 * The following will make an initial request for game `5`, but when the template
 * tried to read and listen to `game.teamRef.value.name`, a request for team `7`
 * will be made.
 *
 * ```
 * var template = stache("{{game.teamRef.value.name}} scored {{game.score}} points");
 * Game.get({id: 5}).then(function(game){
 *   template({game: game});
 * });
 * ```
 *
 *
 */
var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var WeakReferenceMap = __webpack_require__(/*! ../../helpers/weak-reference-map */ "./node_modules/can-connect/helpers/weak-reference-map.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var constructorStore = __webpack_require__(/*! ../../constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var define = __webpack_require__(/*! can-define */ "./node_modules/can-define/can-define.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var makeRef = function(connection) {
	var idProp = canReflect.getSchema(connection.queryLogic).identity[0];
	/**
	 * @property {constructor} can-connect/can/ref/ref.Map.Ref Map.Ref
	 * @parent can-connect/can/ref/ref.hydrators
	 * @group can-connect/can/ref/ref.Map.Ref.static static
	 * @group can-connect/can/ref/ref.Map.Ref.prototype prototype
	 *
	 * A reference type with `instanceRef.value` primed to return an existing instance of the
	 * [can-connect/can/map/map._Map] type, if available, or lazy load an instance upon accessing `instanceRef.value`.
	 *
	 * @signature `new Map.Ref(id, value)`
	 * @param  {string} id    string representing the record id
	 * @param  {Object} value properties to be loaded / hydrated
	 * @return {Map.Ref}       instance reference object for the id
	 */
	var Ref = (function(){
		return function(id, value) {
			if (typeof id === "object") {
				value = id;
				id = value[idProp];
			}
			// check if this is in the store
			var storeRef = Ref.store.get(id);
			if (storeRef) {
				if (value && !storeRef._value) {
					if (value instanceof connection.Map) {
						storeRef._value = value;
					} else {
						storeRef._value = connection.hydrateInstance(value);
					}
				}
				return storeRef;
			}
			// if not, create it
			this[idProp] = id;
			if (value) {
				// if the value is already an instance, use it.

				if (value instanceof connection.Map) {
					this._value = value;
				} else {
					this._value = connection.hydrateInstance(value);
				}
			}


			// check if this is being made during a request
			// if it is, save it
			if (constructorStore.requests.count() > 0) {
				if (!Ref._requestInstances[id]) {
					Ref.store.addReference(id, this);
					Ref._requestInstances[id] = this;
				}
			}
		};
	})();
	/**
	 * @property {can-connect/helpers/weak-reference-map} can-connect/can/ref/ref.Map.Ref.store store
	 * @parent can-connect/can/ref/ref.Map.Ref.static
	 * @hide // not something that needs to be documented for the average user
	 * A WeakReferenceMap that contains instances being created by their `._cid` property.
	 */
	Ref.store = new WeakReferenceMap();
	Ref._requestInstances = {};
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.type type
	 * @parent can-connect/can/ref/ref.Map.Ref.static
	 *
	 * Returns a new instance of `Map.Ref`.
	 *
	 * @signature `Map.Ref.type(reference)`
	 *
	 *   @param {Object|String|Number} reference either data or an id for an instance of [can-connect/can/map/map._Map].
	 *   @return {can-connect/can/ref/ref.Map.Ref} reference instance for the passed data or identifier.
	 */
	Ref.type = function(ref) {
		if (ref && typeof ref !== "object") {
			// get or make the existing reference from the store
			return new Ref(ref);
		} else {
			// get or make the reference in the store, update the instance too
			return new Ref(ref[idProp], ref);
		}
	};
	var defs = {
		/**
		 * @property {Promise} can-connect/can/ref/ref.Map.Ref.prototype.promise promise
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 * @hide // don't know if this is part of the public API
		 *
		 * Returns a resolved promise if the referenced instance is already available, if not, returns a new promise
		 * to retrieve the instance by the id.
		 *
		 * @signature `ref.promise`
		 * @return {Promise} Promise resolving the instance referenced
		 */
		promise: {
			get: function() {
				if (this._value) {
					return Promise.resolve(this._value);
				} else {
					var props = {};
					props[idProp] = this[idProp];
					return connection.Map.get(props);
				}
			}
		},

		_state: {
			get: function(lastSet, resolve) {
				if (resolve) {
					this.promise.then(function() {
						resolve("resolved");
					}, function() {
						resolve("rejected");
					});
				}

				return "pending";
			}
		},

		/**
		 * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.value value
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 *
		 * Returns the actual instance the reference points to. Returns `undefined` if the instance is still being loaded.
		 * Accessing this property will start lazy loading if the instance isn't already available.
		 *
		 * @signature `ref.value`
		 * @return {object} actual instance referenced or `undefined` if lazy loading ongoing
		 */
		value: {
			get: function(lastSet, resolve) {
				if (this._value) {
					return this._value;
				} else if (resolve) {
					this.promise.then(function(value) {
						resolve(value);
					});
				}
			}
		},

		/**
		 * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.reason reason
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 *
		 * Returns the failure message from the lazy loading promise. Returns `undefined` if the referenced instance is
		 * available or loading is ongoing.
		 *
		 * @signature `ref.reason`
		 * @return {Object} error message if the promise is rejected
		 */
		reason: {
			get: function(lastSet, resolve) {
				if (this._value) {
					return undefined;
				} else {
					this.promise.catch(function(value) {
						resolve(value);
					});
				}
			}
		}
	};
	defs[idProp] = {
		type: "*",
		set: function() {
			this._value = undefined;
		}
	};

	define(Ref.prototype, defs);

	Ref.prototype.unobservedId = ObservationRecorder.ignore(function() {
		return this[idProp];
	});
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isResolved isResolved
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading has succeeded.
	 *
	 * @signature `ref.isResolved`
	 * @return {boolean} `true` if the lazy loading promise was resolved.
	 */
	Ref.prototype.isResolved = function() {
		return !!this._value || this._state === "resolved";
	};
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isRejected isRejected
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading has failed.
	 *
	 * @signature `ref.isRejected`
	 * @return {boolean} `true` if the lazy loading promise was rejected.
	 */
	Ref.prototype.isRejected = function() {
		return this._state === "rejected";
	};

	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isPending isPending
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading is ongoing.
	 *
	 * @signature `ref.isPending`
	 * @return {boolean} `true` if the lazy loading promise state is not resolved or rejected.
	 */
	Ref.prototype.isPending = function() {
		return !this._value && (this._state !== "resolved" || this._state !== "rejected");
	};

	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.serialize serialize
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Return the id of the referenced instance when serializing. Prevents the referenced instance from
	 * being entirely serialized when serializing the referencing instance.
	 *
	 * @signature `ref.serialize`
	 * @return {string} id the id of the referenced instance
	 */
	Ref.prototype.serialize = function() {
		return this[idProp];
	};
	canReflect.assignSymbols(Ref.prototype, {
		"can.serialize": Ref.prototype.serialize,
		"can.getName": function(){
			return canReflect.getName(this.constructor)+"{"+this[idProp]+"}";
		}
	});

	var baseEventSetup = Ref.prototype._eventSetup;
	Ref.prototype._eventSetup = function() {
		Ref.store.addReference(this.unobservedId(), this);
		return baseEventSetup.apply(this, arguments);
	};
	var baseTeardown = Ref.prototype._eventTeardown;
	Ref.prototype._eventTeardown = function() {
		Ref.store.deleteReference(this.unobservedId(), this);
		return baseTeardown.apply(this, arguments);
	};


	constructorStore.requests.on("end", function() {
		for (var id in Ref._requestInstances) {
			Ref.store.deleteReference(id);
		}
		Ref._requestInstances = {};
	});

	//!steal-remove-start
	Object.defineProperty(Ref, "name", {
		value: canReflect.getName(connection.Map) + "Ref",
		configurable: true
	});
	//!steal-remove-end

	return Ref;
};


module.exports = connect.behavior("can/ref", function(baseConnection) {
	return {
		/**
		 * @can-connect/can/ref/ref.init init
		 * @parent can-connect/can/ref/ref.methods
		 *
		 * @signature `connection.init()`
		 *
		 * Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref].
		 * Typically called by the `connect` helper after the connection behaviors have been assembled.
		 *
		 * @return {undefined} no return value
		 **/
		init: function() {
			baseConnection.init.apply(this, arguments);
			this.Map.Ref = makeRef(this);
		}
	};
});


/***/ }),

/***/ "./node_modules/can-connect/can/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect/can/session/session.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var connect = __webpack_require__(/*! ../../connect */ "./node_modules/can-connect/connect.js");
var singleton = __webpack_require__(/*! can-define-connected-singleton */ "./node_modules/can-define-connected-singleton/can-define-connected-singleton.js");

module.exports = connect.behavior("can/session", function(higherBehaviors) {
	return {
		// return a dummy id when destroying, otherwise the constructor behavior will skip making a DELETE request
		id: function(instance) {
			if (instance.isDestroying()) {
				return reflect.getName(this.Map) + '-singleton';
			} else {
				return undefined;
			}
		},
		init: function() {
			higherBehaviors.init.apply(this, arguments);

			singleton(this.Map);
		},
		createdInstance: function(instance) {
			higherBehaviors.createdInstance.apply(this, arguments);

			this.Map.current = instance;
		},
		destroyedInstance: function() {
			higherBehaviors.destroyedInstance.apply(this, arguments);

			this.Map.current = undefined;
		},
	};
});

/***/ }),

/***/ "./node_modules/can-connect/can/super-map/super-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/can/super-map/super-map.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");

var constructor = __webpack_require__(/*! ../../constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! ../map/map */ "./node_modules/can-connect/can/map/map.js");
var canRef = __webpack_require__(/*! ../ref/ref */ "./node_modules/can-connect/can/ref/ref.js");
var constructorStore = __webpack_require__(/*! ../../constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var dataCallbacks = __webpack_require__(/*! ../../data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
var callbacksCache = __webpack_require__(/*! ../../data/callbacks-cache/callbacks-cache */ "./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js");
var combineRequests = __webpack_require__(/*! ../../data/combine-requests/combine-requests */ "./node_modules/can-connect/data/combine-requests/combine-requests.js");
var localCache = __webpack_require__(/*! ../../data/localstorage-cache/localstorage-cache */ "./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js");
var dataParse = __webpack_require__(/*! ../../data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! ../../data/url/url */ "./node_modules/can-connect/data/url/url.js");
var fallThroughCache = __webpack_require__(/*! ../../fall-through-cache/fall-through-cache */ "./node_modules/can-connect/fall-through-cache/fall-through-cache.js");
var realTime = __webpack_require__(/*! ../../real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");
var callbacksOnce = __webpack_require__(/*! ../../constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
var GLOBAL = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");

var $ = GLOBAL().$;

connect.superMap = function(options){

	var behaviors = [
		constructor,
		canMap,
		canRef,
		constructorStore,
		dataCallbacks,
		combineRequests,
		dataParse,
		dataUrl,
		realTime,
		callbacksOnce];

	if(typeof localStorage !== "undefined") {
		if(!options.cacheConnection) {
			options.cacheConnection = connect([localCache],{
				name: options.name+"Cache",
				idProp: options.idProp,
				queryLogic: options.queryLogic
			});
		}
		behaviors.push(callbacksCache,fallThroughCache);
	}
	// Handles if jQuery isn't provided.
	if($ && $.ajax) {
		options.ajax = $.ajax;
	}
	return connect(behaviors,options);
};

module.exports = connect.superMap;


/***/ }),

/***/ "./node_modules/can-connect/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/can-connect/connect.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var behavior = __webpack_require__(/*! ./behavior */ "./node_modules/can-connect/behavior.js");

/**
 *
 * @param {Array<String,Behavior,function>} behaviors - An array of behavior names or custom behaviors.
 * The order of named execution gets run in order.
 * @param {Object} options
 * @hide
 */
var connect = function(behaviors, options){

	behaviors = behaviors.map(function(behavior, index){
		var sortedIndex = -1;
		if(typeof behavior === "string") {
			sortedIndex = connect.order.indexOf(behavior);
			behavior = behavior.map[behavior];
		} else if(behavior.isBehavior) {
			sortedIndex = connect.order.indexOf(behavior.behaviorName);
		} else {
			behavior = connect.behavior(behavior);
		}

		return {
			originalIndex: index,
			sortedIndex: sortedIndex,
			behavior: behavior
		};
	});

	behaviors.sort(function(b1, b2){
		// if both have a sorted index
		if(~b1.sortedIndex && ~b2.sortedIndex) {
			return b1.sortedIndex - b2.sortedIndex;
		}
		return b1.originalIndex - b2.originalIndex;
	});

	behaviors = behaviors.map(function(b){
		return b.behavior;
	});

	var behavior = connect.base( connect.behavior("options",function(){return options; })() );

	behaviors.forEach(function(behave){
		behavior = behave(behavior);
	});
	if(behavior.init) {
		behavior.init();
	}
	return behavior;
};



connect.order = ["data/localstorage-cache","data/url","data/parse","cache-requests","data/combine-requests",

	"constructor","constructor/store","can/map","can/ref",
	"fall-through-cache",

	"data/worker","real-time",

	"data/callbacks-cache","data/callbacks","constructor/callbacks-once"
];

connect.behavior = behavior;



module.exports= connect;


/***/ }),

/***/ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {function} can-connect/constructor/callbacks-once/callbacks-once constructor/callbacks-once
 * @parent can-connect.behaviors
 *
 * Prevents duplicate calls to the instance callback methods.
 *
 * @signature `callbacksOnce( baseConnection )`
 *
 *   Prevents duplicate calls to the instance callback methods by tracking the last data the methods were called with.
 *   If called with the same data again, it does not call the base connection's instance callback.
 *
 *   @param {{}} baseConnection `can-connect` connection object that is having the `callbacks-once` behavior added
 *   on to it. Should already contain the behaviors that provide the Instance Callbacks
 *   (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the
 *   behaviors will automatically be ordered as required.
 *
 *   @return {Object} A `can-connect` connection containing the methods provided by `callbacks-once`.
 *
 */
var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var sortedSetJSON = __webpack_require__(/*! ../../helpers/sorted-set-json */ "./node_modules/can-connect/helpers/sorted-set-json.js");
var forEach = [].forEach;

// wires up the following methods
var callbacks = [
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.createdInstance createdInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `createdInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `createdInstance(instance, data)`
	 * Called with the instance created by [can-connect/constructor/constructor.save `connection.save`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `createdInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.save`
	 * @param {} data the response data returned during `connection.save`
	 */
	"createdInstance",
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.updatedInstance updatedInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `updatedInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `updatedInstance(instance, data)`
	 * Called with the instance updated by [can-connect/constructor/constructor.save`connection.save`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `updatedInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.save`
	 * @param {} data the response data returned during `connection.save`
	 */
	"updatedInstance",
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance destroyedInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `destroyedInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `destroyedInstance(instance, data)`
	 * Called with the instance created by [can-connect/constructor/constructor.destroy `connection.destroy`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `destroyedInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.destroy`
	 * @param {} data the response data returned during `connection.destroy`
	 */
	"destroyedInstance"
];



var callbacksOnceBehavior = connect.behavior("constructor/callbacks-once",function(baseConnection){

	var behavior = {};

	forEach.call(callbacks, function(name){
		behavior[name] = function(instance, data ){

			var lastSerialized = this.getInstanceMetaData(instance, "last-data-" + name);

			var serialize = sortedSetJSON(data);
			if(lastSerialized !== serialize) {
				var result =  baseConnection[name].apply(this, arguments);
				this.addInstanceMetaData(instance, "last-data-" + name, serialize);
				return result;
			}
		};

	});

	return behavior;
});

module.exports = callbacksOnceBehavior;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(callbacksOnceBehavior, callbacks);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/constructor/constructor.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/constructor/constructor.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";




/**
 * @module {connect.Behavior} can-connect/constructor/constructor constructor
 * @parent can-connect.behaviors
 * @group can-connect/constructor/constructor.options 1 behavior options
 * @group can-connect/constructor/constructor.crud 2 CRUD methods
 * @group can-connect/constructor/constructor.callbacks 3 CRUD callbacks
 * @group can-connect/constructor/constructor.hydrators 4 hydrators
 * @group can-connect/constructor/constructor.serializers 5 serializers
 * @group can-connect/constructor/constructor.helpers 6 helpers
 *
 * Adds an interface to interact with custom types via the connection instead of plain Objects and Arrays.
 *
 * @signature `constructor( baseConnection )`
 *
 * Adds an interface that allows the connection to operate on custom types. These fall into the categories:
 * - [can-connect/constructor/constructor#CRUDMethods CRUD Methods] - create, read, update and delete typed instances via the data source
 * - [can-connect/constructor/constructor#CRUDCallbacks CRUD Callbacks] - activities run on typed instances following data source operations
 * - [can-connect/constructor/constructor#Hydrator Hydrators] - conversion of raw data to typed data
 * - [can-connect/constructor/constructor#Serializers Serializers] - conversion of typed data to raw data
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `constructor` behavior added
 * on to it.
 *
 * @return {Object} A `can-connect` connection containing the method implementations provided by `constructor`.
 *
 * @body
 *
 * ## Use
 *
 * The `constructor` behavior allows you to instantiate the raw representation of the data source's data into a
 * custom typed representation with additional methods and behaviors.

 * An example might be loading data from a `"/todos"` service and being able to call `.timeLeft()`  on the todos that
 * you get back like:
 *
 * ```js
 * todoConnection.get({id: 6}).then(function(todo){
 *   todo.timeLeft() //-> 60000
 * })
 * ```
 *
 * The following creates a `todoConnection` that does exactly that:
 *
 * ```js
 * // require connection plugins
 * var constructor = require("can-connect/constructor/");
 * var dataUrl = require("can-connect/data/url/");
 *
 * // define type constructor function
 * var Todo = function(data){
 *   // add passed properties to new instance
 *   for(var prop in data) {
 *    this[prop] = data;
 *   }
 * };
 *
 * // add method to get time left before due, in milliseconds
 * Todo.prototype.timeLeft = function(){
 *   return new Date() - this.dueDate
 * };
 *
 * // create connection, passing function to instantiate new instances
 * var todoConnection = connect([constuctor, dataUrl], {
 *   url: "/todos",
 *   instance: function(data){
 *     return new Todo(data);
 *   }
 * });
 * ```
 *
 * The `constructor` behavior is still useful even if you want to keep your data as untyped objects (which is the
 * default behavior when no [can-connect/constructor/constructor.instance `instance`] implementation is provided).  The
 * behavior provides an interface to the data held by the client. For example,
 * [can-connect/constructor/constructor.updatedInstance] provides an extension point for logic that needs to be executed
 * after an instance held by the client finishes an update request. This is valuable whether that instance is typed or not.
 * Extensions like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache]
 * require this interface for advanced behavior.
 *
 * ## Interface
 *
 * `constructor` provides the following categories of methods to interact with typed data:
 *
 * ### <span id="CRUDMethods">CRUD Methods</span>
 *
 * Methods that create, read, update and delete (CRUD) typed representations of raw connection data:
 *
 * - [can-connect/constructor/constructor.get] - retrieve a single typed instance from the data source
 * - [can-connect/constructor/constructor.getList] - retrieve a typed list of instances from the data source
 * - [can-connect/constructor/constructor.save] - save a typed instance's data to the data source
 * - [can-connect/constructor/constructor.destroy] - delete a typed instance's data from the data source
 *
 * ### <span id="CRUDCallbacks">CRUD Callbacks</span>
 *
 * "CRUD Methods" call these methods with request response data and a related instance. Their implementation here
 * updates the related instance with that data:
 *
 * - [can-connect/constructor/constructor.createdInstance] - after [can-connect/constructor/constructor.save saving] new instance to data source, update that instance with response data
 * - [can-connect/constructor/constructor.updatedInstance] - after [can-connect/constructor/constructor.save saving] existing instance to data source, update that instance with response data
 * - [can-connect/constructor/constructor.destroyedInstance] - after [can-connect/constructor/constructor.destroy deleting] instance from data source, update that instance with response data
 * - [can-connect/constructor/constructor.updatedList] - after new data is read from the data source, update an existing list with instances created from that data
 *
 * ### <span id="CRUDMethods">Hydrators</span>
 *
 * These methods are used to create a typed instance or typed list given raw data objects:
 * - [can-connect/constructor/constructor.hydrateInstance] - create a typed instance given raw instance data
 * - [can-connect/constructor/constructor.hydrateList] - create a typed list of typed instances given given raw list data
 *
 * ### <span id="Serializers">Serializers</span>
 *
 * These methods convert a typed instance or typed list into a raw object:
 * - [can-connect/constructor/constructor.serializeInstance] - return raw data representing the state of the typed instance argument
 * - [can-connect/constructor/constructor.serializeList] - return raw data representing the state of the typed list argument
 *
 */
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var makeArray = canReflect.toArray;
var assign = canReflect.assignMap;
var WeakReferenceMap = __webpack_require__(/*! ../helpers/weak-reference-map */ "./node_modules/can-connect/helpers/weak-reference-map.js");
var updateDeepExceptIdentity = __webpack_require__(/*! can-diff/update-deep-except-identity/update-deep-except-identity */ "./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js");
var idMerge = __webpack_require__(/*! ../helpers/id-merge */ "./node_modules/can-connect/helpers/id-merge.js");
var behavior = __webpack_require__(/*! ../behavior */ "./node_modules/can-connect/behavior.js");

module.exports = behavior("constructor",function(baseConnection){

	var behavior = {
		// stores references to instances
		// for now, only during create
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/constructor.cidStore cidStore
		 * @parent can-connect/constructor/constructor.helpers
		 *
		 * Temporarily hold references to new instances via their [can-cid] while they are undergoing creation.
		 *
		 * @option {can-connect/helpers/weak-reference-map} Temporarily holds references to instances by
		 * [can-cid] when they are in the process of being created and don't yet have an `id`s. This is typically
		 * accessed in `createdData` handlers (e.g [can-connect/real-time/real-time.createdData real-time.createdData]) that
		 * need to lookup the instance that was being created during a particular request.
		 */
		cidStore: new WeakReferenceMap(),
		_cid: 0,

		/**
		 * @function can-connect/constructor/constructor.get get
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * Retrieve a single instance from the connection data source.
		 *
		 * @signature `connection.get(params)`
		 *
		 * Retrieves instance data from [can-connect/connection.getData], runs the resulting data through
		 * [can-connect/constructor/constructor.hydrateInstance], creating a typed instance with the retrieved data.
		 *
		 * @param {Object} params data specifying the instance to retrieve.  Normally, this is something like like:
		 * `{id: 5}`.
		 *
		 * @return {Promise<can-connect/Instance>} `Promise` resolving to the instance returned by
		 * [can-connect/constructor/constructor.hydrateInstance].
		 *
		 * ### Usage
		 *
		 * Call `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise
		 * that resolves to that instance:
		 * ```js
		 * todoConnection.get({id: 6}).then(function(todo){
		 *   todo.id; // 6
		 *   todo.name; // 'Take out the garbage'
		 * });
		 * ```
		 *
		 * `.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP GET request to `/todos/6`.
		 */
		get: function(params) {
			var self = this;
			return this.getData(params).then(function(data){
				return self.hydrateInstance(data);
			});
		},

		/**
		 * @function can-connect/constructor/constructor.getList getList
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * Retrieve a list of instances from the connection data source.
		 *
		 * @signature `connection.getList(set)`
		 *
		 * Retrieves list data from [can-connect/connection.getListData] and runs the resulting data through
		 * [can-connect/constructor/constructor.hydrateList], creating a typed list of typed instances from  the retrieved
		 * data.
		 *
		 * @param {can-query-logic/query} query data specifying the range of instances to retrieve. This might look something like:
		 * ```{start: 0, end: 50, due: 'today'}```
		 *
		 * @return {Promise<can-connect.List<can-connect/Instance>>} `Promise` resolving to the typed list returned by
		 * [can-connect/constructor/constructor.hydrateList].
		 *
		 * ### Usage
		 *
		 * Call `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return
		 * a promise that resolves to a [can-connect.List] created from that set.
		 *
		 * ```js
		 * todoConnection.getList({due: 'today'}).then(function(todos){
		 *   todos[0].name; // 'Take out the garbage'
		 *   todos[0].due > startOfDay && todos[0].due < endOfDay; // true
		 * })
		 * ```
		 *
		 */
		getList: function(set) {
			set = set ||  {};
			var self = this;
			return this.getListData( set ).then(function(data){
				return self.hydrateList(data, set);
			});
		},


		/**
		 * @function can-connect/constructor/constructor.hydrateList hydrateList
		 * @parent can-connect/constructor/constructor.hydrators
		 *
		 * Produce a typed list from the provided raw list data.
		 *
		 * @signature `connection.hydrateList(listData, set)`
		 *
		 *   Call [can-connect/constructor/constructor.hydrateInstance] for each item in the raw list data, and then call
		 *   [can-connect/constructor/constructor.list] with an array of the typed instances returned from
		 *   [can-connect/constructor/constructor.hydrateInstance] .  If [can-connect/constructor/constructor.list] is not
		 *   provided as an argument or implemented by another behavior, a normal array is created.
		 *
		 *   @param {can-connect.listData} listData the raw list data returned by the data source, often via [can-connect/connection.getListData]
		 *   @param {can-query-logic/query} query description of the set of data `listData` represents
		 *
		 *   @return {can-connect.List} a typed list containing typed instances generated from `listData`
		 */
		hydrateList: function(listData, set){
			if(Array.isArray(listData)) {
				listData = {data: listData};
			}

			var arr = [];
			for(var i = 0; i < listData.data.length; i++) {
				arr.push( this.hydrateInstance(listData.data[i]) );
			}
			listData.data = arr;
			if(this.list) {
				return this.list(listData, set);
			} else {
				var list = listData.data.slice(0);
				list[this.listQueryProp || "__listQuery"] = set;
				copyMetadata(listData, list);
				return list;
			}
		},

		/**
		 * @function can-connect/constructor/constructor.hydrateInstance hydrateInstance
		 * @parent can-connect/constructor/constructor.hydrators
		 *
		 * Produce a typed object containing the provided raw data.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 *
		 * If [can-connect/constructor/constructor.instance] has been passed as an option, or defined by another behavior,
		 * pass `props` to it and return the value. Otherwise, return a clone of `props`.
		 *
		 * @param {Object} props the raw instance data returned by the data source, often via [can-connect/connection.getData]
		 * @return {can-connect/Instance} a typed instance containing the data from `props`
		 */
		hydrateInstance: function(props){
			if(this.instance) {
				return this.instance(props);
			}  else {
				return assign({}, props);
			}
		},
		/**
		 * @function can-connect/constructor/constructor.save save
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * @description Create or update an instance on the connection data source
		 *
		 * @signature `connection.save( instance )`
		 *
		 *   First checks if the instance has an [can-connect/base/base.id] or not.  If it has an id, the instance will be
		 *   updated; otherwise, it will be created.
		 *
		 *   When creating an instance, the instance is added to the [can-connect/constructor/constructor.cidStore], and its
		 *   [can-connect/constructor/constructor.serializeInstance serialized data] is passed to
		 *   [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,
		 *   [can-connect/constructor/constructor.createdInstance] is called with that data.
		 *
		 *   When updating an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is
		 *   passed to [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than
		 *   `undefined`, [can-connect/constructor/constructor.updatedInstance] is called with that data.
		 *
		 *   @param {can-connect/Instance} instance the instance to create or save
		 *
		 *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `save`
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * To use `save` to create an instance, create a connection, then an instance, and call `.save()` on it:
		 *
		 * ```js
		 * // Create a connection
	     * var constructor = require('can-connect/constructor/');
		 * var dataUrl = require('can-connect/data/url/');
		 * var todoConnection = connect([dataUrl, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * // Create an instance
		 * var todo = {name: "do dishes"};
		 *
		 * // Call .save()
		 * todoConnection.save(todo)
		 * ```
		 *
		 * `.save(todo)` above will call [can-connect/data/url/url.createData `createData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP POST request to `/todos` with the serialized `todo` data.  The server response
		 * data may look something like:
		 *
		 * ```js
		 * {
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * That data will be passed to [can-connect/constructor/constructor.createdInstance] which by default
		 * adds those properties to `todo`, resulting in `todo` looking like:
		 *
		 * ```js
		 * {
		 *  name: "do dishes",
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * As an example of updating an instance, change a property on `todo` and call `.save()` again:
		 *
		 * ```js
		 * // Change a property
		 * todo.name = "Do dishes now!!";
		 *
		 * // Call .save()
		 * todoConnection.save(todo)
		 * ```
		 *
		 * The `.save(todo)` above will call [can-connect/data/url/url.updateData `updateData`] on the
		 * [can-connect/data/url/url] behavior, which will make an HTTP PUT request to `/todos` with the serialized `todo`
		 * data.
		 *
		 * A successful server response body should look something like:
		 *
		 * ```js
		 * {
		 *  name: "Do dishes now!!",
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * This data will be passed to [can-connect/constructor/constructor.updatedInstance] which by default sets
		 * all of `todo`'s properties to look like the response data, even removing properties that are missing from the
		 * response data.
		 */
		save: function(instance){
			var serialized = this.serializeInstance(instance);
			var id = this.id(instance);
			var self = this;
			if(id === undefined) {
				// If `id` is undefined, we are creating this instance.
				// It should be given a local id and temporarily added to the cidStore
				// so other hooks can get back the instance that's being created.
				var cid = this._cid++;
				// cid is really a token to be able to reference this transaction.
				this.cidStore.addReference(cid, instance);

				// Call the data layer.
				// If the data returned is undefined, don't call `createdInstance`
				return this.createData(serialized, cid).then(function(data){
					// if undefined is returned, this can't be created, or someone has taken care of it
					if(data !== undefined) {
						self.createdInstance(instance, data);
					}
					self.cidStore.deleteReference(cid, instance);
					return instance;
				});
			} else {
				return this.updateData(serialized).then(function(data){
					if(data !== undefined) {
						self.updatedInstance(instance, data);
					}
					return instance;
				});
			}
		},
		/**
		 * @function can-connect/constructor/constructor.destroy destroy
		 * @parent can-connect/constructor/constructor.crud
		 * @description Delete an instance from the connection data source
		 *
		 * @signature `connection.destroy( instance )`
		 *
		 *   To destroy an instance, it's [can-connect/constructor/constructor.serializeInstance serialized data] is passed
		 *   to [can-connect/connection.destroyData]. If [can-connect/connection.destroyData]'s promise resolves to anything
		 *   other than `undefined`, [can-connect/constructor/constructor.destroyedInstance] is called.
		 *
		 *   @param {can-connect/Instance} instance the instance being deleted from the data source
		 *
		 *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `destroy`
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * To use `destroy`, create a connection, retrieve an instance, and then call `.destroy()` with it.
		 *
		 * ```js
		 * // create a connection
		 * var constructor = require('can-connect/constructor/');
		 * var dataUrl = require('can-connect/data/url/');
		 * var todoConnection = connect([dataUrl, constructor], {
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve a todo instance
		 * todoConnection.get({id: 5}).then(function(todo){
		 *   // Call .destroy():
		 *   todoConnection.destroy(todo)
		 * });
		 * ```
		 *
		 * `.destroy()` above will call [can-connect/connection.destroyData `destroyData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP DELETE request to `/todos/5` with the serialized `todo` data.  The server
		 * response data may look something like:
		 *
		 * ```js
		 * {
		 *   deleted: true
		 * }
		 * ```
		 *
		 * That response data will be passed to [can-connect/constructor/constructor.destroyedInstance], which by default
		 * adds those properties to `todo`.
		 */
		// ## destroy
		// Calls the data interface `destroyData` and as long as it
		// returns something, uses that data to call `destroyedInstance`.
		destroy: function(instance){
			var serialized = this.serializeInstance(instance),
				self = this,
				id = this.id(instance);

			if (id !== undefined) {
				return this.destroyData(serialized).then(function (data) {
					if (data !== undefined) {
						self.destroyedInstance(instance, data);
					}
					return instance;
				});
			} else {
				this.destroyedInstance(instance, {});
				return Promise.resolve(instance);
			}
		},

		/**
		 * @function can-connect/constructor/constructor.createdInstance createdInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever a new instance has been saved to the data source. Updates the instance with response data.
		 *
		 * @signature `connection.createdInstance( instance, props )`
		 *
		 * `createdInstance` is run whenever a new instance is saved to the data source. This implementation updates the
		 * instance with the data returned by [can-connect/connection.createData] which made the request to save the raw
		 * instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was created
		 * @param {Object} props the data returned from [can-connect/connection.createData] that will update the properties of `instance`
		 */
		createdInstance: function(instance, props){
			assign(instance, props);
		},

		/**
		 * @function can-connect/constructor/constructor.updatedInstance updatedInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever an existing instance has been saved to the data source. Overwrites the instance with response
		 * data.
		 *
		 * @signature `connection.updatedInstance( instance, props )`
		 *
		 * `updatedInstance` is run whenever an existing instance is saved to the data source. This implementation overwrites
		 * the instance with the data returned bu [can-connect/connection.updatedData] which made the request to save the
		 * modified instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was updated
		 * @param {Object} props the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`
		 */
		updatedInstance: function(instance, data){
			updateDeepExceptIdentity(instance, data, this.queryLogic.schema);
		},

		/**
		 * @function can-connect/constructor/constructor.updatedList updatedList
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever new data for an existing list is retrieved from the data source. Updates the list to
		 * include the new data.
		 *
		 * @signature `connection.updatedList( list, listData, set )`
		 *
		 * [can-connect/constructor/constructor.hydrateInstance Hydrates instances] from `listData`'s data and attempts to
		 * merge them into `list`.  The merge is able to identify simple insertions and removals of elements instead of
		 * replacing the entire list.
		 *
		 * @param {can-connect/Instance} list an existing list
		 * @param {can-connect.listData} listData raw data that should be included as part of `list` after conversion to typed instances
		 * @param {can-query-logic/query} query description of the set of data `list` represents
		 */
		updatedList: function(list, listData, set) {
			var instanceList = [];
			for(var i = 0; i < listData.data.length; i++) {
				instanceList.push( this.hydrateInstance(listData.data[i]) );
			}
			// This only works with "referenced" instances because it will not
			// update and assume the instance is already updated
			// this could be overwritten so that if the ids match, then a merge of properties takes place
			idMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));

			copyMetadata(listData, list);
		},

		/**
		 * @function can-connect/constructor/constructor.destroyedInstance destroyedInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever an instance has been deleted from the data source. Overwrites the instance with response data.
		 *
		 * @signature `connection.destroyedInstance( instance, props )`
		 *
		 * `destroyedInstance` is run whenever an existing instance is deleted from the data source. This implementation
		 * overwrites the instance with the data returned by [can-connect/connection.destroyData] which made the request to
		 * delete the raw instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was deleted
		 * @param {Object} props the data returned from [can-connect/connection.destroyData] that will overwrite the
		 * properties of `instance`
		 */
		destroyedInstance: function(instance, data){
			updateDeepExceptIdentity(instance, data, this.queryLogic.schema);
		},

		/**
		 * @function can-connect/constructor/constructor.serializeInstance serializeInstance
		 * @parent can-connect/constructor/constructor.serializers
		 *
		 * @description Generate the serialized form of a typed instance.
		 *
		 * @signature `connection.serializeInstance( instance )`
		 *
		 *   Generate a raw object representation of a typed instance. This default implementation simply clones the
		 *   `instance` object, copying all the properties of the object (excluding properties of it's prototypes) to a new
		 *   object. This is equivalent to `Object.assign({}, instance)`.
		 *
		 * @param {can-connect/Instance} instance the instance to serialize
		 * @return {Object} a serialized representation of the instance
		 */
		serializeInstance: function(instance){
			return assign({}, instance);
		},

		/**
		 * @function can-connect/constructor/constructor.serializeList serializeList
		 * @parent can-connect/constructor/constructor.serializers
		 *
		 * @description Generate the serialized form of a typed list.
		 *
		 * @signature `connection.serializeList( list )`
		 *
		 *   Generate a raw array representation of a typed list. This default implementation simply returns a plain `Array`
		 *   containing the result of calling [can-connect/constructor/constructor.serializeInstance] on each item in the
		 *   typed list.
		 *
		 * @param {can-connect.List} list The instance to serialize.
		 * @return {Object|Array} A serialized representation of the list.
		 */
		serializeList: function(list){
			var self = this;
			return makeArray(list).map(function(instance){
				return self.serializeInstance(instance);
			});
		},

		/**
		 * @function can-connect/constructor/constructor.isNew isNew
		 * @parent can-connect/constructor/constructor.helpers
		 *
		 * Returns if the instance has not been loaded from or saved to the data source.
		 *
		 * @signature `connection.isNew(instance)`
		 * @param {Object} instance the instance to test
		 * @return {Boolean} `true` if [can-connect/base/base.id] is `null` or `undefined`
		 */
		isNew: function(instance){
			var id = this.id(instance);
			return !(id || id === 0);
		}

		/**
		 * @property can-connect/constructor/constructor.list list
		 * @parent can-connect/constructor/constructor.options
		 *
		 * Behavior option provided to create a typed list from a raw array.
		 *
		 * @signature `connection.list( listData, set )`
		 *
		 * Takes a `listData` argument with a `data` property, that is an array of typed instances, each produced by
		 * [can-connect/constructor/constructor.hydrateInstance], and returns a new typed list containing those typed
		 * instances.
		 * This method is passed as an option to the connection.
		 * Called by [can-connect/constructor/constructor.hydrateList].
		 *
		 * @param {can-connect.listData} listData an object with a `data` property, which is an array of instances.
		 * @param {can-query-logic/query} query the set description of this list
		 * @return {can-connect.List} a typed list type containing the typed instances
		 *
		 * ### Usage
		 *
		 * The following example makes the connection produce `MyList` typed lists including a `completed` method:
		 *
		 * ```js
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 *
		 * // define custom list type constructor
		 * var MyList = function(items) {
		 *  this.push.apply(this, items);
		 * }
		 * // inherit Array functionality
		 * MyList.prototype = Object.create(Array.prototype);
		 * // add custom methods to new list type
		 * MyList.prototype.completed = function(){
		 *  return this.filter(function(){ return this.completed });
		 * };
		 *
		 * // create connection
		 * var todosConnection = connect([constructor, dataUrl], {
		 *   url: "/todos",
		 *   list: function(listData, set){
		 *     // create custom list instance
		 *     var collection = new MyList(listData.data);
		 *     // add set info for use by other behaviors
		 *     collection.__listQuery = set;
		 *     return collection;
		 *   }
		 * });
		 *
		 * // use connection to get typed list & use custom method
		 * todosConnection.getList({}).then(function(todoList){
		 *   console.log("There are", todoList.completed().length, "completed todos");
		 * });
		 * ```
		 *
		 * **Note:** we added the [can-connect/base/base.listQueryProp] property (`Symbol.for("can.listQuery")` by default) on the list. This is
		 * expected by other behaviors.
		 */

		/**
		 * @property can-connect/constructor/constructor.instance instance
		 * @parent can-connect/constructor/constructor.options
		 *
		 * Behavior option provided to create a typed form of passed raw data.
		 *
		 * @signature `connection.instance( props )`
		 *
		 * Creates a typed instance for the passed raw data object. This method is passed as an option to the connection.
		 * Called by [can-connect/constructor/constructor.hydrateInstance].
		 *
		 * @param {Object} props a raw object containing the properties from the data source
		 * @return {can-connect/Instance} the typed instance created from the passed `props` object
		 *
		 * ### Usage
		 *
		 * The following example makes the connection produce `Todo` typed objects including a `complete` method:
		 *
		 * ```js
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 *
		 * // define type constructor
		 * var Todo = function(rawData){
		 *   // add raw data to new instance
		 *   Object.assign(this, rawData);
		 * };
		 *
		 * // add methods to custom type
		 * Todo.prototype.complete = function(){
		 *   this.completed = true;
		 * }
		 *
		 * // create connection
		 * var todosConnection = connect([constructor, dataUrl], {
		 *   url: "/todos",
		 *   instance: function(rawData) {
		 *     return new Todo(rawData);
		 *   }
		 * });
		 *
		 * // use connection to get typed instance & use custom method
		 * todosConnection.get({id: 5}).then(function(todo){
		 *   todo.completed; // false
		 *   todo.complete();
		 *   todo.completed; // true
		 * });
		 * ```
		 *
		 */
	};

	return behavior;

});

function copyMetadata(listData, list){
	for(var prop in listData) {
		if(prop !== "data") {
			// this is map infultrating constructor, but it's alright here.
			if(typeof list.set === "function") {
				list.set(prop, listData[prop]);
			} else if(typeof list.attr === "function") {
				list.attr(prop, listData[prop]);
			} else {
				list[prop] = listData[prop];
			}

		}
	}
}


/***/ }),

/***/ "./node_modules/can-connect/constructor/store/store.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/constructor/store/store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {connect.Behavior} can-connect/constructor/store/store constructor/store
 * @parent can-connect.behaviors
 * @group can-connect/constructor/store/store.stores 0 stores
 * @group can-connect/constructor/store/store.callbacks 1 CRUD callbacks
 * @group can-connect/constructor/store/store.crud 2 CRUD methods
 * @group can-connect/constructor/store/store.hydrators 3 hydrators
 *
 * Adds support for keeping references to active lists and instances. Prevents different copies of an instance from
 * being used by the application at once. Allows other behaviors to look up instances currently active in the
 * application.
 *
 *
 * @signature `constructorStore( baseConnection )`
 *
 * Overwrites `baseConnection` so it contains a store for instances and lists.  This behavior:
 * - extends the [can-connect/constructor/store/store.hydrateInstance] and
 * [can-connect/constructor/store/store.hydrateList] methods to return instances or lists from the store, if available
 * - overwrites "CRUD" methods to make sure that while requests are pending, new lists and instances have references
 * kept in the store. This prevents duplicated instances from being created during concurrent requests.
 * - provides methods to add and remove items in the store by counting references
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `constructor/store` behavior added
 * on to it. Should already contain a behavior that provides the InstanceInteface
 * (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors
 * will automatically be ordered as required.
 *
 * @return {Object} a `can-connect` connection containing the method implementations provided by `constructor/store`.
 *
 * @body
 *
 * ## Use
 *
 * The `constructor-store` behavior is used to:
 *  - provide a store of instances and lists in use by the client
 *  - prevent multiple instances from being generated for the same [can-connect/base/base.id] or multiple
 *    lists for the same [can-connect/base/base.listQuery].
 *
 * The store provides access to an instance by its [can-connect/base/base.id] or a list by its
 * [can-connect/base/base.listQuery]. This is used by other behaviors to lookup instances that should have changes applied.
 * Two examples, when there is a new instance that should be added to a list ([can-connect/real-time/real-time]) or
 * when newer data is available for a cached instance that is used in the page
 * ([can-connect/fall-through-cache/fall-through-cache]).
 *
 * Below you can see how `constructor-store`'s behavior be used to prevent multiple instances from being generated. This
 * example allows you to create multiple instances of a `todoEditor` that loads and edits a todo instance:
 *
 * @demo demos/can-connect/constructor-store.html
 *
 * You can see in this example that you can edit one todo and the other todos update.  This is because each `todoEditor`
 * is acting on same instance in memory. When it updates the todo's name here:
 *
 * ```
 * var updateData = function(newName) {
 *   todo.name = newName; // update name on todo instance
 *   ...
 * };
 * ```
 *
 * The other widgets update because they are bound to the same instance:
 *
 * ```
 * todo.on("name", updateElement); // when todo name changes update input element
 * todosConnection.addInstanceReference(todo); // previous line is a new usage of todo, so increase reference count
 * ```
 *
 * Each `todoEditor` receives the same instance because it was added to the
 * [can-connect/constructor/store/store.instanceStore connnection.instanceStore] by
 * [can-connect/constructor/store/store.addInstanceReference]. During all instance retrievals, a connection using the
 * `constructor/store` behavior checks the [can-connect/constructor/store/store.instanceStore] for an instance with a
 * matching `id` and return that if it exists. This example always requests `id: 5`, so all the `todoEditor`s use the
 * same instance held in the [can-connect/constructor/store/store.instanceStore].
 *
 * This widget cleans itself up when it is removed by removing the listener on the `todo` instance and
 * [can-connect/constructor/store/store.deleteInstanceReference reducing the instance reference count]:
 *
 * ```
 * todo.off("name", updateElement); // stop listening to todo name change
 * todosConnection.deleteInstanceReference(todo); // previous line removed a usage of todo, so reduce reference count
 * ```
 * This is done to prevent a memory leak produced by keeping instances in the `instanceStore` when they are no longer
 * needed by the application.
 *
 * **Note:** a hazard of sharing the same instance is that if new instance data is loaded from the server during
 * on-going editing of the instance, the new server data will replace the data that is edited but not yet saved.
 * This is because whenever data is loaded from the server, it is passed to
 * [can-connect/constructor/constructor.updatedInstance] which updates the shared instance properties with the new
 * server data.
 */
var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var WeakReferenceMap = __webpack_require__(/*! ../../helpers/weak-reference-map */ "./node_modules/can-connect/helpers/weak-reference-map.js");
var WeakReferenceSet = __webpack_require__(/*! ../../helpers/weak-reference-set */ "./node_modules/can-connect/helpers/weak-reference-set.js");
var sortedSetJSON = __webpack_require__(/*! ../../helpers/sorted-set-json */ "./node_modules/can-connect/helpers/sorted-set-json.js");
var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

// shared across all connections
var pendingRequests = 0;
var noRequestsTimer = null;
var requests = {
	increment: function(connection){
		pendingRequests++;
		clearTimeout(noRequestsTimer);
	},
	decrement: function(connection){
		pendingRequests--;
		if(pendingRequests === 0) {
			noRequestsTimer = setTimeout(function(){
				requests.dispatch("end");
			},module.exports.requestCleanupDelay);
		}
		if(pendingRequests < 0) {
			pendingRequests = 0;
		}
	},
	count: function(){
		return pendingRequests;
	}
};
eventQueue(requests);


var constructorStore = connect.behavior("constructor/store",function(baseConnection){

	var behavior = {
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.instanceStore instanceStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * A mapping of instances keyed by their [can-connect/base/base.id].
		 *
		 * @type {can-connect/helpers/weak-reference-map}
		 *
		 * Stores instances by their [can-connect/base/base.id]. Holds instances based on reference counts which
		 * are incremented by [can-connect/constructor/store/store.addInstanceReference] and decremented by
		 * [can-connect/constructor/store/store.deleteInstanceReference]. Once a reference count is 0, the instance is no
		 * longer held in the store. Once a reference count is greater than 0, the instance is added to the store.
		 *
		 * ```js
		 * connection.addInstanceReference(todo5);
		 * connection.instanceStore.get("5") //-> todo5
		 * ```
		 */
		instanceStore: new WeakReferenceMap(),
		// This really should be a set ... we just need it "weak" so we know how many references through binding
		// it has.
		newInstanceStore: new WeakReferenceSet(),
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.listStore listStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * A mapping of lists keyed by their [can-connect/base/base.listQuery].
		 *
		 * @type {can-connect/helpers/weak-reference-map}
		 *
		 * Stores lists by their [can-connect/base/base.listQuery]. Hold lists based on reference counts which are incremented
		 * by [can-connect/constructor/store/store.addListReference] and decremented by
		 * [can-connect/constructor/store/store.deleteListReference]. Once a reference count is 0, the list is no
		 * longer held in the store. Once a reference count is greater than 0, the list is added to the store.
		 *
		 * ```js
		 * connection.addInstanceReference(allTodos, {});
		 * connection.instanceStore.get({}) //-> allTodos
		 * ```
		 */
		listStore: new WeakReferenceMap(),
		 // Set up the plain objects for tracking requested lists and instances for this connection,
		 // and add a handler to the requests counter to flush list and instance references when all
		 // requests have completed
		 //
		 // This function is called automatically when connect() is called on this behavior,
		 // and should not need to be called manually.
		init: function() {
			if(baseConnection.init) {
				baseConnection.init.apply(this, arguments);
			}

			if(!this.hasOwnProperty("_requestInstances")) {
				this._requestInstances = {};
			}
			if(!this.hasOwnProperty("_requestLists")) {
				this._requestLists = {};
			}

			requests.on("end", function onRequestsEnd_deleteStoreReferences(){
				var id;
				for(id in this._requestInstances) {
					this.instanceStore.deleteReference(id);
				}
				this._requestInstances = {};
				for(id in this._requestLists) {
					this.listStore.deleteReference(id);
					this._requestLists[id].forEach(this.deleteInstanceReference.bind(this));
				}
				this._requestLists = {};
			}.bind(this));
		},
		_finishedRequest: function(){
			requests.decrement(this);
		},

		/**
		 * @function can-connect/constructor/store/store.addInstanceReference addInstanceReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Add a reference to the [can-connect/constructor/store/store.instanceStore] so an instance can be easily looked up.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Adds a reference to an instance by [can-connect/base/base.id] to the [can-connect/constructor/store/store.instanceStore].
		 * Keeps a count of the number of references, removing the instance from the store when the count reaches 0.
		 *
		 * @param {can-connect/Instance} instance the instance to add
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * The [can-connect/constructor/store/store.instanceStore] contains a mapping of instances keyed by their
		 * [can-connect/base/base.id]. The [can-connect/constructor/store/store.instanceStore] is used to prevent creating
		 * the same instance multiple times, and for finding active instance for a given id.  Instances need to be added to
		 * this store for this to work.  To do this, call `addInstanceReference`:
		 *
		 * ```
		 * // a basic connection
		 * var constructorStore = require("can-connect/constructor/store/");
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 * var todoConnection = connect([dataUrl, constructorStore, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * var originalTodo;
		 *
		 * // get a todo
		 * todoConnection.get({id: 5}).then(function( todo ){
		 *   // add it to the store
		 *   todoConnection.addInstanceReference(todo);
		 *   originalTodo = todo;
		 * });
		 * ```
		 *
		 * Now, if you were to retrieve the same data sometime later, it would be the same instance:
		 *
		 * ```
		 * todoConnection.get({id: 5}).then(function( todo ){
		 *   todo === originalTodo // true
		 * });
		 * ```
		 *
		 * The `.getData` response data (underlying the call to `todoConnection.get`) is passed, along with the existing todo
		 * instance (`originalTodo`) to [can-connect/constructor/constructor.updatedInstance]. That updates the shared
		 * instance with the newly retrieved data.
		 *
		 * All the referenced instances are held in memory.  Use
		 * [can-connect/constructor/store/store.deleteInstanceReference] to remove them.
		 *
		 * Typically, `addInstanceReference` is called when something expresses interest in the instance, such
		 * as an event binding, and `deleteInstanceReference` is called when the interest is removed.
		 */
		addInstanceReference: function(instance, id) {
			var ID = id || this.id(instance);
			if(ID === undefined) {
				// save in the newInstanceStore store temporarily.
				this.newInstanceStore.addReference(instance);
			} else {
				this.instanceStore.addReference( ID, instance );
			}

		},

		/**
		 * @function can-connect/constructor/store/store.callbacks.createdInstance createdInstance
		 * @parent can-connect/constructor/store/store.callbacks
		 *
		 * Calls `createdInstance` on the underlying behavior and moves the new instance from the `newInstanceStore` to
		 * `instanceStore` if needed.
		 *
		 * @signature `connection.createdInstance( instance, props )`
		 * Calls the base behavior. Then calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore]
		 * to move any pre-creation instance references to the standard instance reference store.
		 *
		 * @param {can-connect/Instance} instance the instance that was created
		 * @param {Object} props the data returned from [can-connect/connection.createData]
		 */
		createdInstance: function(instance, props){
			// when an instance is created, and it is in the newInstance store
			// transfer it to the instanceStore
			baseConnection.createdInstance.apply(this, arguments);
			this.moveCreatedInstanceToInstanceStore(instance);
		},

		/**
		 * @function can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore moveCreatedInstanceToInstanceStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Moves recently created instances into the [can-connect/constructor/store/store.instanceStore].
		 *
		 * @signature `moveCreatedInstanceToInstanceStore( instance )`
		 * Checks if an instance has an `id` and is in the `newInstanceStore`. If so, it adds it into the
		 * [can-connect/constructor/store/store.instanceStore] and removes it from the `newInstanceStore`.
		 *
		 * A new instances may have been added to the `newInstanceStore` if [can-connect/constructor/store/store.addInstanceReference]
		 * is called on is before the instance has been saved. This is done so we can keep track of references for unsaved
		 * instances and update the references to be keyed by `id` when one is available. Without this a request for a
		 * currently referenced instance that was just saved for the first time will erroneously result in a new instance.
		 *
		 * @param {can-connect/Instance} instance an instance.  If it was "referenced" (bound to) prior to
		 * being created, this will check for that condition and move this instance into the
		 * [can-connect/constructor/store/store.instanceStore].
		 */
		moveCreatedInstanceToInstanceStore: function(instance){
			var ID = this.id(instance);
			if(this.newInstanceStore.has(instance) && ID !== undefined) {
				var referenceCount = this.newInstanceStore.referenceCount(instance);
				this.newInstanceStore.delete(instance);
				this.instanceStore.addReference( ID, instance, referenceCount );
			}
		},
		addInstanceMetaData: function(instance, name, value){
			var data = this.instanceStore.set[this.id(instance)];
			if(data) {
				data[name] = value;
			}
		},
		getInstanceMetaData: function(instance, name){
			var data = this.instanceStore.set[this.id(instance)];
			if(data) {
				return data[name];
			}
		},
		deleteInstanceMetaData: function(instance, name){
			var data = this.instanceStore.set[this.id(instance)];

			delete data[name];
		},
		/**
		 * @function can-connect/constructor/store/store.deleteInstanceReference deleteInstanceReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Remove a reference from the [can-connect/constructor/store/store.instanceStore] so an instance can be garbage
		 * collected.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].
		 * Removes the instance if there are no longer any references.
		 *
		 * @param {can-connect/Instance} instance the instance to remove
		 *
		 * ### Usage
		 *
		 * `deleteInstanceReference` is called to remove references to instances in the
		 * [can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually
		 * called when the application or some part of the application no longer is interested in an instance.
		 *
		 * [can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.
		 * The following continues that example to remove the `originalTodo` instance from the store:
		 *
		 * ```
		 * todoConnection.deleteInstanceReference(originalTodo);
		 * ```
		 *
		 * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete
		 * example of the lifecycle of a reference.
		 */
		deleteInstanceReference: function(instance) {
			var ID = this.id(instance);
			if(ID === undefined) {
				// if there is no id, remove this from the newInstanceStore
				this.newInstanceStore.deleteReference(instance);
			} else {
				this.instanceStore.deleteReference( this.id(instance), instance );
			}

		},
		/**
		 * @property {WeakReferenceMap} can-connect/constructor/store/store.addListReference addListReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Add a reference to the [can-connect/constructor/store/store.listStore] so a list can be easily looked up.
		 *
		 * @signature `connection.addListReference( list[, set] )`
		 * Adds a reference to a list by `set` (or by [can-connect/base/base.listQuery]) to the
		 * [can-connect/constructor/store/store.listStore].  Keeps a count of the number of references, removing the list
		 * from the store when the count reaches 0.
		 *
		 * @param {can-connect.List} list The list to add.
		 * @param {can-query-logic/query} [query] The set this list represents if it can't be identified with [can-connect/base/base.listQuery].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * The [can-connect/constructor/store/store.listStore] contains a mapping of lists keyed by their `set`. The
		 * [can-connect/constructor/store/store.listStore] is used to prevent creating the same list multiple times and for
		 * identifying a list for a given set. Lists need to be added to this store for this to work.  To do this, call
		 * `addListReference`:
		 *
		 * ```
		 * // A basic connection:
		 * var constructorStore = require("can-connect/constructor/store/");
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 * var todoConnection = connect([dataUrl, constructorStore, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * var dueToday;
		 *
		 * // get a todo list
		 * todoConnection.getList({due: "today"}).then(function( todos ){
		 *   // add it to the store
		 *   todoConnection.addListReference(todos, {due: "today"});
		 *   dueToday = todos;
		 * });
		 * ```
		 *
		 * Now, if you were to retrieve the same set of data sometime later, it would be the same list instance:
		 *
		 * ```
		 * todoConnection.get({due: "today"}).then(function( todos ){
		 *   todos === dueToday //-> true
		 * });
		 * ```
		 *
		 * The `.getListData`  response data (underlying the call to `todoConnection.getList`) is passed, along with the
		 * existing list (`dueToday`) to [can-connect/constructor/constructor.updatedList]. That updates the shared list
		 * instance with the newly retrieved data.
		 *
		 * All the referenced lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]
		 * to remove them.
		 *
		 * Typically, `addListReference` is called when something expresses interest in the list, such
		 * as an event binding, and `deleteListReference` is called when interest is removed.
		 *
		 */
		addListReference: function(list, set) {
			var id = sortedSetJSON( set || this.listQuery(list) );
			if(id) {
				this.listStore.addReference( id, list );
				list.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			}
		},
		/**
		 * @function can-connect/constructor/store/store.deleteListReference deleteListReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Removes a reference from the [can-connect/constructor/store/store.listStore] so a list can can be garbage
		 * collected.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Decrements the number of references to a list in the [can-connect/constructor/store/store.listStore].
		 * Removes the list if there are no longer any references.
		 *
		 * @param {can-connect/Instance} list the list to remove
		 *
		 * ### Usage
		 *
		 * `deleteListReference` is called to remove references to instances in the
		 * [can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when
		 * the application or some part of the application no longer is interested in a list.
		 *
		 * [can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The
		 * following continues that example to remove the `dueToday` list from the store:
		 *
		 * ```
		 * todoConnection.deleteListReference(dueToday);
		 * ```
		 *
		 * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete
		 * example of the lifecycle of a reference.
		 */
		deleteListReference: function(list, set) {
			var id = sortedSetJSON( set || this.listQuery(list) );
			if(id) {
				this.listStore.deleteReference( id, list );
				list.forEach(this.deleteInstanceReference.bind(this));
			}
		},
		/**
		 * @function can-connect/constructor/store/store.hydratedInstance hydratedInstance
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Keeps new instances in the [can-connect/constructor/store/store.instanceStore] for the lifetime of any
		 * concurrent requests.
		 *
		 * @signature `hydratedInstance(instance)`
		 * Adds a reference for new instances for the lifetime of any concurrent requests. Called when a new instance is
		 * created during [can-connect/constructor/store/store.hydrateInstance hydration]. This prevents concurrent requests
		 * for the same data from returning different instances.
		 *
		 * @param {can-connect/Instance} instance the newly hydrated instance
		 */
		// ## hydratedInstance
		hydratedInstance: function(instance){
			if( requests.count() > 0) {
				var id = this.id(instance);
				if(! this._requestInstances[id] ) {
					this.addInstanceReference(instance);
					this._requestInstances[id] = instance;
				}

			}
		},

		/**
		 * @function can-connect/constructor/store/store.hydrateInstance hydrateInstance
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Returns an instance given raw data, returning it from the [can-connect/constructor/store/store.instanceStore] if
		 * available.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 * Overwrites the base `hydrateInstance` so that if a matching instance is in the
		 * [can-connect/constructor/store/store.instanceStore], that instance will be
		 * [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.  If there isn't a
		 * matching instance, the base `hydrateInstance` will be called.
		 *
		 * @param {Object} props the raw data used to create an instance
		 * @return {can-connect/Instance} a typed instance either created or updated with the data from `props`.
		 */
		hydrateInstance: function(props){
			var id = this.id(props);
			if((id || id === 0) && this.instanceStore.has(id) ) {
				var storeInstance = this.instanceStore.get(id);
				// TODO: find a way to prevent this from being called so many times.
				this.updatedInstance(storeInstance, props);
				return storeInstance;
			}
			var instance = baseConnection.hydrateInstance.call(this, props);
			this.hydratedInstance(instance);
			return instance;
		},

		/**
		 * @function can-connect/constructor/store/store.hydratedList hydratedList
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Keeps new lists in the [can-connect/constructor/store/store.listStore] for the lifetime of any concurrent
		 * requests.
		 *
		 * @signature `hydratedList(list)`
		 * Adds a reference for new lists for the lifetime of any concurrent requests. Called when a new list is
		 * created during [can-connect/constructor/store/store.hydrateList hydration]. This prevents concurrent requests
		 * for the same data from returning different instances.
		 *
		 * @param {can-connect.List} list the newly hydrated list
		 */
		hydratedList: function(list, set){
			if( requests.count() > 0) {
				var id = sortedSetJSON( set || this.listQuery(list) );
				if(id) {
					if(! this._requestLists[id] ) {
						this.addListReference(list, set);
						this._requestLists[id] = list;
					}
				}
			}
		},

		/**
		 * @function can-connect/constructor/store/store.hydrateList hydrateList
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Returns a list given raw data, returning it from the [can-connect/constructor/store/store.listStore] if
		 * available.
		 *
		 * @signature `connection.hydrateList( listData, set )`
		 *
		 *   Overwrites the base `hydrateList` so that if a matching list is in the
		 *   [can-connect/constructor/store/store.listStore], that list will be
		 *   [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.
		 *   If there isn't a matching list, the base `hydrateList` will be called.
		 *
		 *   @param {can-connect.listData} listData raw list data to hydrate into a list type
		 *   @param {can-query-logic/query} query the parameters that represent the set of data in `listData`
		 *   @return {List} a typed list from either created or updated with the data from `listData`
		 */
		hydrateList: function(listData, set){
			set = set || this.listQuery(listData);
			var id = sortedSetJSON( set );

			if( id && this.listStore.has(id) ) {
				var storeList = this.listStore.get(id);
				this.updatedList(storeList, listData, set);
				return storeList;
			}
			var list = baseConnection.hydrateList.call(this, listData, set);
			this.hydratedList(list, set);
			return list;
		},

		/**
		 * @function can-connect/constructor/store/store.getList getList
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.getList] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * or [can-connect/constructor/store/store.hydrateList lists hydrated] during this request are kept in the store until
		 * all the concurrent requests complete.
		 *
		 * @signature `connection.getList( set )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {can-query-logic/query} listQuery parameters specifying the list to retrieve
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.getList]
		 */
		getList: function(listQuery) {
			var self = this;
			requests.increment(this);
			var promise = baseConnection.getList.call(this, listQuery);

			promise.then(function(instances){
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;
		},

		/**
		 * @function can-connect/constructor/store/store.get get
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.get] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.get( params )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} params params used to specify which instance to retrieve.
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.get]
		 */
		get: function(params) {
			var self = this;
			requests.increment(this);
			var promise = baseConnection.get.call(this, params);

			promise.then(function(instance){
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;

		},
		/**
		 * @function can-connect/constructor/store/store.save save
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.save] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.save( instance )`
		 *
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} instance a typed instance being saved
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.save]
		 */
		save: function(instance) {
			var self = this;
			requests.increment(this);

			var updating = !this.isNew(instance);
			if(updating) {
				this.addInstanceReference(instance);
			}

			var promise = baseConnection.save.call(this, instance);

			promise.then(function(instances){
				if(updating) {
					self.deleteInstanceReference(instance);
				}
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;
		},
		/**
		 * @function can-connect/constructor/store/store.destroy destroy
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.destroy] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.destroy( instance )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} instance a typed instance being deleted
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.destroy]
		 */
		destroy: function(instance) {
			var self = this;
			// Add to instance store, for the duration of the
			// destroy callback
			this.addInstanceReference(instance);
			requests.increment(this);
			var promise = baseConnection.destroy.call(this, instance);

			promise.then(function(instance){
				self._finishedRequest();
				self.deleteInstanceReference(instance);
			}, function(){
				self._finishedRequest();
			});
			return promise;

		},
		/**
		 * @function can-connect/constructor/store/store.updatedList updatedList
		 * @parent can-connect/constructor/store/store.callbacks
		 *
		 * Extends the underlying [can-connect/connection.updatedList] so any instances that have been added or removed
		 * from the list have their reference counts updated accordingly.
		 *
		 * @signature `connection.updatedList( list, listData, set )`
		 * Increments an internal request counter so instances on this list during this request will be stored, and decrements
		 * the same counter for all items previously on the list (found in `listData.data`).
		 *
		 * @param {can-connect.List} list a typed list of instances being updated
		 * @param {Object} listData an object representing the previous state of the list
		 * @param {Object} set the retrieval set used to get the list
		 */
		updatedList: function(list, listData, set) {
			var oldList = list.slice(0);
			if(!listData.data && typeof listData.length === "number") {
				listData = { data: listData };
			}
			if(baseConnection.updatedList) {
				baseConnection.updatedList.call(this, list, listData, set);
				list.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			} else if(listData.data) {
				listData.data.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			}
			oldList.forEach(this.deleteInstanceReference.bind(this));
		}
	};

	return behavior;

});
constructorStore.requests = requests;
// The number of ms to wait after all known requests have finished,
//  before starting request cleanup.
// If a new request comes in before timeout, wait until that request
//  has finished (+ delay) before starting cleanup.
// This is configurable, for use cases where more waiting is desired,
//  or for the can-connect tests which expect everything to clean up
//  in 1ms.
constructorStore.requestCleanupDelay = 10;

module.exports = constructorStore;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(constructorStore, ['hydrateInstance', 'hydrateList', 'getList', 'get', 'save', 'destroy']);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache
 * @parent can-connect.behaviors
 *
 * Implements the data interface callbacks to call the [can-connect/base/base.cacheConnection]
 * [can-connect/DataInterface]. These calls keep the [can-connect/base/base.cacheConnection] contents
 * up to date.
 *
 * @signature `dataCallbacksCache( baseConnection )`
 * Implements the data interface callbacks so that a corresponding [can-connect/DataInterface] method is called on the
 * [can-connect/base/base.cacheConnection]. This updates the [can-connect/base/base.cacheConnection] contents whenever
 * data is updated on the primary connection.
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks-cache` behavior added
 * on to it.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.
 *
 * ### Example
 * Shows synchronization between primary connection and cacheConnection data when using this behavior:
 * ```
 * import dataUrl from "can-connect/data/url/";
 * import dataCallbacks from "can-connect/data/callbacks/";
 * import cacheCallbacks from "can-connect/data/callbacks-cache/";
 * import memoryCache from "can-connect/data/memory-cache/";
 *
 * var cacheConnection = connect([memoryCache], {});
 * var todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {
 *   cacheConnection,
 *   url: "/todo"
 * });
 *
 * todoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {
 *   todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {
 *     // data returned from connection and data returned from cache have the same contents
 *     data.id === cachedData.id; // true
 *     data.name === cachedData.name; // true
 *     data.completed === cachedData.completed; // true
 *     data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache
 *   })
 * });
 * ```
 */
var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var assign = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").assignMap;
var each = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").each;

// wires up the following methods
var pairs = {
	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.createdData createdData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a new data record is created.
	 *
	 * @signature `connection.createdData(responseData, requestData, cid)`
	 *
	 * Calls `createData` on the [can-connect/base/base.cacheConnection] to add a newly created data record to the cache.
	 * Calls and returns the response from any underlying behavior's `createdData` callback.
	 *
	 * @param {{}} responseData the data returned by the data creation request
	 * @param {{}} requestData the data that was passed to the data creation request
	 * @param {Number} cid the unique identifier for this data. Used before data has a [can-connect/base/base.id] added
	 * at creation time.
	 *
	 * @return {{}} the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	createdData: "createData",

	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.updatedData updatedData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is modified.
	 *
	 * @signature `connection.updatedData(responseData, requestData)`
	 *
	 * Calls `updateData` on the [can-connect/base/base.cacheConnection] to modify a data record stored in the cache.
	 * Calls and returns the response from any underlying behavior's `updatedData` callback.
	 *
	 * @param {{}} responseData the data returned by the data update request
	 * @param {{}} requestData the data that was passed to the data update request
	 *
	 * @return {{}} the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	updatedData: "updateData",

	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.destroyedData destroyedData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is deleted.
	 *
	 * @signature `connection.destroyedData(responseData, requestData)`
	 *
	 * Calls `destroyData` on the [can-connect/base/base.cacheConnection] to remove a data record stored in the cache.
	 * Calls and returns the response from any underlying behavior's `destroyedData` callback.
	 *
	 * @param {{}} responseData the data returned by the data destroy request
	 * @param {{}} requestData the data that was passed to the data destroy request
	 *
	 * @return {{}} the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	destroyedData: "destroyData"
};



var callbackCache = connect.behavior("data/callbacks-cache",function(baseConnection){
	var behavior = {};

	each(pairs, function(crudMethod, dataCallback){
		behavior[dataCallback] = function(data, params, cid){

			// update the data in the cache
			this.cacheConnection[crudMethod]( assign(assign({}, params), data) );

			// return underlying dataCallback implementation if one exists or return input data
			if (baseConnection[dataCallback]) {
				return baseConnection[dataCallback].call(this, data, params, cid);
			} else {
				return data;
			}
		};
	});

	return behavior;
});

module.exports = callbackCache;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(callbackCache, []);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/data/callbacks/callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-connect/data/callbacks/callbacks.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/data/callbacks/callbacks data/callbacks
 * @parent can-connect.behaviors
 *
 * Extend [can-connect/DataInterface] methods to call callbacks with the raw response data.
 *
 * @signature `dataCallbacks( baseConnection )`
 *
 * Extends the [can-connect/DataInterface] create, update, read & delete methods to call 'callback' methods following
 * their execution. Callbacks are called with the data returned from the underlying behavior's [can-connect/DataInterface]
 * implementation.
 *
 * For example:
 * ```
 * var dataUrl = require("can-connect/data/url/");
 * var dataCallbacks = require("can-connect/data/url");
 * var logging = {
 *   createdData: function(responseData) {
 *     console.log('New Todo Saved: ', responseData);
 *     return responseData;
 *   }
 * };
 * var todoConnection = connect([dataUrl, dataCallbacks, logging}],  {
 *   url: '/todos'
 * });
 *
 * // create a new todo
 * todoConnection.createData({name: "do the dishes", completed: false}).then(function(responseData) {
 *   responseData; // {id: 5}
 * });
 *
 * // after create request is completed, following is logged by the "logging" createdData callback:
 * // > New Todo Saved: {id: 5}
 * ```
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks` behavior added
 * on to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If
 * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks`.
 */
var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var each = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").each;

// wires up the following methods
var pairs = {
	/**
	 * @function can-connect/data/callbacks/callbacks.getListData getListData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `gotListData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.gotListData].
	 *
	 * @signature `getListData(listQuery)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.getListData] to call `gotListData` with the returned
	 *   response data. The result of the call to `gotListData` will be used as the new response data.
	 *
	 *   @param {Object} listQuery an object that represents the set of data to be loaded
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `gotListData`.
	 */
	getListData: "gotListData",

	/**
	 * @function can-connect/data/callbacks/callbacks.createData createData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `createdData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.createData].
	 *
	 * @signature `createData(instanceData, cid)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.createData] to call `createdData` with the returned
	 *   response data. The result of the call to `createdData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @param {Number} cid unique id that represents the instance that is being created
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `createdData`.
	 */
	createData: "createdData",

	/**
	 * @function can-connect/data/callbacks/callbacks.updateData updatedData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `updatedData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.updateData].
	 *
	 * @signature `updateData(instanceData)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.updateData] to call `updatedData` with the returned
	 *   response data. The result of the call to `updatedData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `updatedData`.
	 */
	updateData: "updatedData",

	/**
	 * @function can-connect/data/callbacks/callbacks.destroyData destroyData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `destroyedData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.destroyData].
	 *
	 * @signature `destroyData(params, cid)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.destroyData] to call `destroyedData` with the returned
	 *   response data. The result of the call to `destroyedData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `destroyedData`.
	 */
	destroyData: "destroyedData"
};

var dataCallbackBehavior = connect.behavior("data/callbacks",function(baseConnection){

	var behavior = {
	};

	// overwrites createData to createdData
	each(pairs, function(callbackName, name){

		behavior[name] = function(params, cid){
			var self = this;

			return baseConnection[name].call(this, params).then(function(data){
				if(self[callbackName]) {
					return self[callbackName].call(self,data, params, cid );
				} else {
					return data;
				}
			});
		};

	});
	return behavior;
});

module.exports = dataCallbackBehavior;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(dataCallbackBehavior, [
		"getListData", "createData", "updateData", "destroyData"
	]);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/data/combine-requests/combine-requests.js":
/*!****************************************************************************!*\
  !*** ./node_modules/can-connect/data/combine-requests/combine-requests.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! ../../can-connect */ "./node_modules/can-connect/can-connect.js");
var getItems = __webpack_require__(/*! ../../helpers/get-items */ "./node_modules/can-connect/helpers/get-items.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var makeDeferred = __webpack_require__(/*! ../../helpers/deferred */ "./node_modules/can-connect/helpers/deferred.js");
var forEach = [].forEach;
/**
 * @module can-connect/data/combine-requests/combine-requests combine-requests
 * @parent can-connect.behaviors
 * @group can-connect/data/combine-requests.options 1 behavior options
 * @group can-connect/data/combine-requests.types 2 types
 * @group can-connect/data/combine-requests.data-methods 3 data methods
 * @group can-connect/data/combine-requests.queryLogic 4 queryLogic methods
 *
 * Combines multiple incoming lists requests into a single list request when possible.
 *
 * @signature `combineRequests( baseConnection )`
 *
 * Implements [can-connect/data/combine-requests.getListData] to collect the requested sets for some
 * [can-connect/data/combine-requests.time].  Once the configured amount of time has passed, it tries to take the
 * [can-connect/data/combine-requests.unionPendingRequests union] of the requested sets. It then makes requests with
 * those unified sets. Once the unified set requests have returned, the original requests are resolved by taking
 * [can-connect/data/combine-requests.filterMembers subsets] of the unified response data.
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `combine-requests` behavior added
 * on to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If
 * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `combine-requests`.
 *
 * @body
 *
 * ## Use
 *
 * Create a connection with the `combine-requests` plugin:
 *
 * ```
 * var combineRequests = require("can-connect/data/combine-requests/");
 * var dataUrl = require("can-connect/data/url/");
 * var todosConnection = connect([dataUrl, combineRequests], {
 *   url: "/todos"
 * });
 * ```
 * Since the configuration above doesn't include the [can-connect/data/combine-requests.time] option, the following
 * will only make a single request if all requests are made during the same "thread of execution" (i.e. before the
 * browser takes a break from executing the current JavaScript):
 *
 * ```
 * todosConnection.getListData({})
 * todosConnection.getListData({filter: {userId: 5}});
 * todosConnection.getListData({filter: {userId: 5, type: "critical"}});
 * ```
 *
 * The above requests can all be joined since [can-set] intuitively knows that
 * `({filter: {userId: 5}}` and `{filter: {userId: 5, type: "critical"}}` are subsets of the complete set of todos, `{}`.
 *
 * For more advanced combining, a [can-query-logic queryLogic] must be configured. This allows `combine-requests` to understand
 * what certain parameters of a set mean, and how they might be combined.
 *
 *
 *
 */
var combineRequests = connect.behavior("data/combine-requests",function(baseConnection){
	var pendingRequests; //[{set, deferred}]

	return {
		/**
		 * @function can-connect/data/combine-requests.unionPendingRequests unionPendingRequests
		 * @parent can-connect/data/combine-requests.queryLogic
		 *
		 * Group pending requests by the request that they are a subset of.
		 *
		 * @signature `connection.unionPendingRequests( pendingRequests )`
		 *
		 * This is called by [can-connect/data/combine-requests.getListData] to determine which pending requests can be unified
		 * into a broader request. This produces a grouping of 'parent' sets to 'child' requests whose data will be
		 * derived from the data retrieved by the parent.
		 *
		 * After this grouping is returned, [can-connect/data/combine-requests.getListData] executes requests for the parent
		 * sets. After a parent request succeeds, the child requests will have their data calculated from the parent data.
		 *
		 * @param {Array<can-connect/data/combine-requests.PendingRequest>} pendingRequests
		 * an array of objects, each containing:
		 *   - `set` - the requested set
		 *   - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data
		 *
		 * @return {Array<{set: Set, pendingRequests: can-connect/data/combine-requests.PendingRequest}>}
		 * an array of each of the unified requests to be made.  Each unified request should have:
		 *   - `set` - the set to request
		 *   - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies
		 *
		 * ### Example
		 *
		 * This function converts something like:
		 *
		 * ```
		 * [
		 *   {set: {completed: false}, deferred: def1},
		 *   {set: {completed: true}, deferred: def2}
		 * ]
		 * ```
		 *
		 * to:
		 *
		 * ```
		 * [
		 *   {
		 *    set: {},
		 *    pendingRequests: [
		 *      {set: {completed: false}, deferred: def1},
		 *      {set: {completed: true}, deferred: def2}
		 *    ]
		 *   }
		 * ]
		 * ```
		 *
		 */
		unionPendingRequests: function(pendingRequests){
			// this should try to merge existing param requests, into an array of
			// others to send out
			// but this data structure keeps the original promises.


			// we need the "biggest" sets first so they can swallow up everything else
			// O(n log n)
			var self = this;

			pendingRequests.sort(function(pReq1, pReq2){

				if(self.queryLogic.isSubset(pReq1.set, pReq2.set)) {
					return 1;
				} else if( self.queryLogic.isSubset(pReq2.set, pReq1.set) ) {
					return -1;
				} else {
					return 0;
				}

			});

			// O(n^2).  This can probably be made faster, but there are rarely lots of pending requests.
			var combineData = [];
			var current;

			doubleLoop(pendingRequests, {
				start: function(pendingRequest){
					current = {
						set: pendingRequest.set,
						pendingRequests: [pendingRequest]
					};
					combineData.push(current);
				},
				iterate: function(pendingRequest){
					var combined = self.queryLogic.union(current.set, pendingRequest.set);
					if( self.queryLogic.isDefinedAndHasMembers(combined) ) {
						// add next
						current.set = combined;
						current.pendingRequests.push(pendingRequest);
						// removes this from iteration
						return true;
					}
				}
			});

			return Promise.resolve(combineData);
		},

		/**
		 * @property {Number} can-connect/data/combine-requests.time time
		 * @parent can-connect/data/combine-requests.options
		 *
		 * Specifies the amount of time to wait to combine requests.
		 *
		 * @option {Number} Defaults to `1`, meaning only requests made within the same "thread of execution" will be
		 * combined (i.e. requests made before the browser takes a break from the ongoing JavaScript execution).
		 *
		 * Increasing this number will mean that requests are delayed that length of time in case other requests
		 * are made. In general, we advise against increasing this amount of time except in cases where loads take a
		 * significant amount of time and the increased delay is unlikely to be noticed.
		 *
		 * ```
		 * var combineRequests = require("can-connect/data/combine-requests/");
		 * connect([... combineRequests, ...],{
		 *   time: 100
		 * })
		 * ```
		 */
		time:1,

		/**
		 * @function can-connect/data/combine-requests.getListData getListData
		 * @parent can-connect/data/combine-requests.data-methods
		 *
		 * Combines multiple list data requests into a single request, when possible.
		 *
		 * @signature `connection.getListData( set )`
		 *
		 * Extension of [can-connect/connection.getListData `getListData`] that tries to combine calls to it into a single
		 * call. The calls are fulfilled by an underlying behavior's `getListData` implementation.
		 *
		 * Waits for a configured [can-connect/data/combine-requests.time] then tries to unify the sets requested during it.
		 * After unification, calls for the unified sets are made to the underlying `getListData`. Once the unified
		 * data has returned, the individual calls to `getListData` are resolved with a
		 * [can-query-logic.prototype.filterMembers calculated subset] of the unified data.
		 *
		 * @param {can-query-logic/query} query the parameters of the requested set of data
		 * @return {Promise<can-connect.listData>} `Promise` resolving the data of the requested set
		 */
		getListData: function(set){
			set = set || {};
			var self = this;

			if(!pendingRequests) {

				pendingRequests = [];

				setTimeout(function(){

					var combineDataPromise = self.unionPendingRequests(pendingRequests);
					pendingRequests = null;
					combineDataPromise.then(function(combinedData){
						// farm out requests
						forEach.call(combinedData, function(combined){
							// clone combine.set to prevent mutations by baseConnection.getListData
							var combinedSet = canReflect.serialize(combined.set);

							baseConnection.getListData(combinedSet).then(function(data){
								if(combined.pendingRequests.length === 1) {
									combined.pendingRequests[0].deferred.resolve(data);
								} else {
									forEach.call(combined.pendingRequests, function(pending){
										// get the subset using the combine.set property before being passed down
										// to baseConnection.getListData which might mutate it causing combinedRequests
										// to resolve with an `undefined` value instead of an actual set
										// https://github.com/canjs/can-connect/issues/139
										pending.deferred.resolve( {data: self.queryLogic.filterMembers(pending.set, combined.set, getItems(data))} );
									});
								}
							}, function(err){
								if(combined.pendingRequests.length === 1) {
									combined.pendingRequests[0].deferred.reject(err);
								} else {
									forEach.call(combined.pendingRequests, function(pending){
										pending.deferred.reject(err);
									});
								}

							});
						});
					});


				}, this.time || 1);
			}
			var deferred = makeDeferred();

			pendingRequests.push({deferred: deferred, set: set});

			return deferred.promise;
		}
	};
});

module.exports = combineRequests;

//!steal-remove-start
var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
module.exports = validate(combineRequests, ['getListData']);
//!steal-remove-end

/**
 * @typedef {PendingRequest} can-connect/data/combine-requests.PendingRequest PendingRequest
 * @parent can-connect/data/combine-requests.types
 *
 * @description Type to keep track of the multiple requests that were unified into a single request.
 *
 * @type {PendingRequest} Record of an individual request that has been unified as part of the combined request. After
 * the unified request completes instances of these types are processed to complete the individual requests with the
 * subset of the unified data.
 *
 * @option {can-query-logic/query} query a requested [can-set/Set set] of data that has been unified into the combined request
 * @option {{}} deferred a type that keeps track of the individual [can-connect/data/combine-requests.getListData]
 * promise that will be resolved after the unified request completes
 */

// ### doubleLoop
var doubleLoop = function(arr, callbacks){
	var i = 0;
	while(i < arr.length) {
		callbacks.start(arr[i]);
		var j = i+1;
		while( j < arr.length ) {
			if(callbacks.iterate(arr[j]) === true) {
				arr.splice(j, 1);
			} else {
				j++;
			}
		}
		i++;
	}
};


/***/ }),

/***/ "./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/data/localstorage-cache/localstorage-cache localstorage-cache
 * @parent can-connect.deprecated
 * @group can-connect/data/localstorage-cache/localstorage-cache.identifiers 0 identifiers
 * @group can-connect/data/localstorage-cache/localstorage-cache.data-methods 1 data methods
 *
 * Saves raw data in localStorage.
 *
 * @deprecated {5.0} Use [can-local-store] instead.
 *
 * @signature `localStorage( baseConnection )`
 *
 *   Creates a cache of instances and a cache of sets of instances that is
 *   accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],
 *   [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].
 *   The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],
 *   and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].
 *
 *   [can-connect/data/localstorage-cache/localstorage-cache.createData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.updateData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out
 *   of sets.
 *
 * @body
 *
 * ## Use
 *
 * `data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or
 * [can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].
 *
 * ```
 * var cacheConnection = connect([
 *   require("can-connect/data/localstorage-cache/localstorage-cache")
 * ],{
 *   name: "todos"
 * });
 *
 * var todoConnection = connect([
 *   require("can-connect/data/url/url"),
 *   require("can-connect/fall-through-cache/fall-through-cache")
 * ],
 * {
 *   url: "/services/todos",
 *   cacheConnection: cacheConnection
 * });
 * ```
 *
 */
 
module.exports = __webpack_require__(/*! can-local-store */ "./node_modules/can-local-store/can-local-store.js");


/***/ }),

/***/ "./node_modules/can-connect/data/memory-cache/memory-cache.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-connect/data/memory-cache/memory-cache.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/data/memory-cache/memory-cache memory-cache
 * @parent can-connect.deprecated
 * @group can-connect/data/memory-cache/memory-cache.data-methods data methods
 *
 * Saves raw data in JavaScript memory that disappears when the page refreshes.
 *
 * @deprecated {5.0} Use [can-memory-store] instead.
 *
 * @signature `memoryCache( baseConnection )`
 *
 *   Creates a cache of instances and a cache of sets of instances that is
 *   accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],
 *   [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].
 *   The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],
 *   [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],
 *   and [can-connect/data/memory-cache/memory-cache.updateListData].
 *
 *   [can-connect/data/memory-cache/memory-cache.createData],
 *   [can-connect/data/memory-cache/memory-cache.updateData],
 *   [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out
 *   of sets.
 *
 * @body
 *
 * ## Use
 *
 * `data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or
 * [can-connect/cache-requests/cache-requests].
 *
 * ```js
 * var cacheConnection = connect([
 *   require("can-connect/data/memory-cache/memory-cache")
 * ],{});
 *
 * var todoConnection = connect([
 *   require("can-connect/data/url/url"),
 *   require("can-connect/fall-through-cache/fall-through-cache")
 * ],
 * {
 *   url: "/services/todos",
 *   cacheConnection: cacheConnection
 * });
 * ```
 */
var memoryStore = __webpack_require__(/*! can-memory-store */ "./node_modules/can-memory-store/can-memory-store.js");

module.exports = memoryStore;


/***/ }),

/***/ "./node_modules/can-connect/data/parse/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/data/parse/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {connect.Behavior} can-connect/data/parse/parse
 * @parent can-connect.behaviors
 *
 * Extract response data into a format needed for other extensions.
 *
 * @signature `dataParse( baseConnection )`
 *
 *   Overwrites the [can-connect/DataInterface] methods to run their results through
 *   either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].
 *
 *   @param {{}} baseConnection The base connection.
 *
 * @body
 *
 * ## Use
 *
 * `data/parse` is used to modify the response data of "data interface" methods to comply with what
 * is expected by "instance interface" methods.  For example, if a service was returning list data
 * at the `/services/todos` url like:
 *
 * ```
 * {
 *   todos: [
 *     {todo: {id: 0, name: "dishes"}},
 *     {todo: {id: 2, name: "lawn"}}
 *   ]
 * }
 * ```
 *
 * That service does not return [can-connect.listData] in the right format which should look like:
 *
 * ```
 * {
 *   data: [
 *     {id: 0, name: "dishes"},
 *     {id: 2, name: "lawn"}
 *   ]
 * }
 * ```
 *
 * To correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [can-connect/data/parse/parse.parseInstanceProp]
 * as follows:
 *
 * ```
 * connect([
 *   require("can-connect/data/parse/parse"),
 *   require("can-connect/data/url/url")
 * ],{
 *  parseListProp: "todos",
 *  parseInstanceProp: "todo"
 * })
 * ```
 *
 */
var each = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").each;
var getObject = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js");
var behavior = __webpack_require__(/*! ../../behavior */ "./node_modules/can-connect/behavior.js");

module.exports = behavior("data/parse",function(baseConnection){

	var behavior = {
    /**
     * @function can-connect/data/parse/parse.parseListData parseListData
     * @parent can-connect/data/parse/parse
     *
     * @description Given a response from [can-connect/connection.getListData] returns its data in the
     * proper [can-connect.listData] format.
     *
     * @signature `connection.parseListData(responseData)`
     *
     *   This function uses [can-connect/data/parse/parse.parseListProp] to find the array
     *   containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]
     *   on each item in the array  Finally, it returns data in the
     *   [can-connect.listData] format.
     *
     *   @param {Object} responseData The response data from the AJAX request.
     *
     *   @return {can-connect.listData} An object like `{data: [props, props, ...]}`.
     *
     * @body
     *
     * ## Use
     *
     * `parseListData` comes in handy when dealing with an irregular API
     * that can be improved with data transformation.
     *
     * Suppose an endpoint responds with a status of 200 OK, even when the
     * request generates an empty result set. Worse yet, instead of representing
     * an emtpy set with an empty list, it removes the property.
     *
     * A request to `/services/todos` may return:
     *
     * ```js
     * {
     *   todos: [
     *     {todo: {id: 0, name: "dishes"}},
     *     {todo: {id: 2, name: "lawn"}}
     *   ]
     * }
     * ```
     *
     * What if a request for `/services/todos?filterName=bank` responds with
     * 200 OK:
     *
     * ```
     * {
     * }
     * ```
     *
     * This response breaks its own schema. One way to bring it in line
     * with a format compatible with [can-connect.listData] is:
     *
     * ```js
     * connect([
     *   require("can-connect/data/parse/parse"),
     *   require("can-connect/data/url/url")
     * ],{
     *   parseListProp: "todos",
     *   parseListData(responseData) {
     *     if (responseData && !responseData.todos) {
     *       responseData = { todos: [] };
     *     }
     *
     *     return responseData;
     *   }
     * })
     * ```
     */
		parseListData: function( responseData ) {

			// call any base parseListData
			if(baseConnection.parseListData) {
			   responseData = baseConnection.parseListData.apply(this, arguments);
			}

			var result;
			if( Array.isArray(responseData) ) {
				result = {data: responseData};
			} else {
				var prop = this.parseListProp || 'data';

				responseData.data = getObject(responseData, prop);
				result = responseData;
				if(prop !== "data") {
					delete responseData[prop];
				}
				if(!Array.isArray(result.data)) {
					throw new Error('Could not get any raw data while converting using .parseListData');
				}

			}
			var arr = [];
			for(var i =0 ; i < result.data.length; i++) {
				arr.push( this.parseInstanceData(result.data[i]) );
			}
			result.data = arr;
			return result;
		},
    /**
     * @function can-connect/data/parse/parse.parseInstanceData parseInstanceData
     * @parent can-connect/data/parse/parse
     *
     * @description Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance]
     * given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],
     * and [can-connect/connection.destroyData].
     *
     * @signature `connection.parseInstanceData(responseData)`
     *
     *   This function will use [can-connect/data/parse/parse.parseInstanceProp] to find the data object
     *   representing the instance that will be created.
     *
     *   @param {Object} responseData The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].
     *
     *   @return {Object} The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].
     *
     * @body
     *
     * ## Use
     *
     * `parseInstanceData` comes in handy when dealing with an irregular API
     * that can be improved with data transformation.
     *
     * Suppose a request to `/services/todos` returns:
     * ```
     * {
     *   baseUrl: "/proxy/share",
     *   todo: {
     *     id: 0,
     *     name: "dishes",
     *     friendFaceUrl: "friendface?id=0",
     *     fiddlerUrl: "fiddler?id=0"
     *   }
     * }
     * ```
     *
     * The baseUrl property is meta-data that needs to be incorporated into the
     * instance data. One way to deal with this is:
     *
     * ```
     * connect([
     *   require("can-connect/data/parse/parse"),
     *   require("can-connect/data/url/url")
     * ],{
     *   parseInstanceProp: "todo",
     *   parseInstanceData(responseData) {
     *     ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {
     *       responseData.todo[urlProp] = [
     *         responseData.baseUrl,
     *         responseData.todo[urlProp]
     *       ].join('/');
     *     });
     *
     *     return responseData;
     *   }
     * })
     * ```
     *
     * This results in an object like:
     *
     * ```js
     * {
     *   id: 0,
     *   name: "dishes",
     *   friendFaceUrl: "/proxy/share/friendface?id=0",
     *   fiddlerUrl: "/proxy/share/fiddler?id=0"
     * }
     * ```
     */
		parseInstanceData: function( props ) {
			// call any base parseInstanceData
			if(baseConnection.parseInstanceData) {
				// It's possible this might be looking for a property that only exists in some
				// responses. So if it doesn't return anything, go back to using props.
			   props = baseConnection.parseInstanceData.apply(this, arguments) || props;
			}
			return this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;
		}
		/**
		 * @property {String} can-connect/data/parse/parse.parseListProp parseListProp
		 * @parent can-connect/data/parse/parse
		 *
		 * The property to find the array-like data that represents each instance item.
		 *
		 * @option {String} [can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture
		 * on the result of [can-connect/connection.getListData].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Set `parseListProp` if your response data does not look like: `{data: [props, props]}`.
		 *
		 * For example, if [can-connect/connection.getListData] returns data like:
		 *
		 * ```
		 * {
		 * 	  todos: [{id: 1, name: "dishes"}, {id: 2, name: "lawn"}]
		 * }
		 * ```
		 *
		 * Set `parseListProp` to `"todos"` like:
		 *
		 * ```
		 * connect([
         *   require("can-connect/data/parse/parse"),
         *   require("can-connect/data/url/url")
         * ],{
		 *   url : "/todos",
		 *   parseListProp: "todos"
		 * });
		 * ```
		 *
		 */
		/**
		 * @property {String} can-connect/data/parse/parse.parseInstanceProp parseInstanceProp
		 * @parent can-connect/data/parse/parse
		 *
		 * The property to find the data that represents an instance item.
		 *
		 * @option {String} [can-connect/data/parse/parse.parseInstanceData] uses this property's value to
		 * [can-connect/constructor/constructor.hydrateInstance make an instance].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Set `parseInstanceData` if your response data does not directly contain the data you would like to pass to
		 * [connection.hydrateInstance].
		 *
		 * For example, if [can-connect/connection.getData] returns data like:
		 *
		 * ```
		 * {
		 *   todo: {
		 * 	   id: 1,
		 *     name: "dishes"
		 *   }
		 * }
		 * ```
		 *
		 * Set `parseInstanceProp` to `"todo"` like:
		 *
		 * ```
		 * connect([
         *   require("can-connect/data/parse/parse"),
         *   require("can-connect/data/url/url")
         * ],{
		 *   url : "/todos",
		 *   parseInstanceProp: "todo"
		 * });
		 * ```
		 */

	};

	each(pairs, function(parseFunction, name){
		behavior[name] = function(params){
			var self = this;
			return baseConnection[name].call(this, params).then(function(){
				return self[parseFunction].apply(self, arguments);
			});
		};
	});

	return behavior;

});

var pairs = {
	getListData: "parseListData",
	getData: "parseInstanceData",
	createData: "parseInstanceData",
	updateData: "parseInstanceData",
	destroyData: "parseInstanceData"
};


/***/ }),

/***/ "./node_modules/can-connect/data/url/url.js":
/*!**************************************************!*\
  !*** ./node_modules/can-connect/data/url/url.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {connect.Behavior} can-connect/data/url/url data/url
 * @parent can-connect.behaviors
 * @group can-connect/data/url/url.data-methods data methods
 * @group can-connect/data/url/url.option options
 *
 * @option {connect.Behavior}
 *
 * Uses the [can-connect/data/url/url.url] option to implement the behavior of
 * [can-connect/connection.getListData],
 * [can-connect/connection.getData],
 * [can-connect/connection.createData],
 * [can-connect/connection.updateData], and
 * [can-connect/connection.destroyData] to make an AJAX request
 * to urls.
 *
 * @body
 *
 * ## Use
 *
 * The `data/url` behavior implements many of the [can-connect/DataInterface]
 * methods to send instance data to a URL.
 *
 * For example, the following `todoConnection`:
 *
 * ```js
 * var todoConnection = connect([
 *   require("can-connect/data/url/url")
 * ],{
 *   url: {
 *     getListData: "GET /todos",
 *     getData: "GET /todos/{id}",
 *     createData: "POST /todos",
 *     updateData: "PUT /todos/{id}",
 *     destroyData: "DELETE /todos/{id}"
 *   }
 * });
 * ```
 *
 * Will make the following request when the following
 * methods are called:
 *
 * ```
 * // GET /todos?due=today
 * todoConnection.getListData({due: "today"});
 *
 * // GET /todos/5
 * todosConnection.getData({id: 5})
 *
 * // POST /todos \
 * // name=take out trash
 * todosConnection.createData({
 *   name: "take out trash"
 * });
 *
 * // PUT /todos/5 \
 * // name=do the dishes
 * todosConnection.updateData({
 *   name: "do the dishes",
 *   id: 5
 * });
 *
 * // DELETE /todos/5
 * todosConnection.destroyData({
 *   id: 5
 * });
 * ```
 *
 * There's a few things to notice:
 *
 * 1. URL values can include simple templates like `{id}`
 *    that replace that part of the URL with values in the data
 *    passed to the method.
 * 2. GET and DELETE request data is put in the URL using [can-param].
 * 3. POST and PUT requests put data that is not templated in the URL in POST or PUT body
 *    as JSON-encoded data.  To use form-encoded requests instead, add the property
 *    `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].
 * 4. If a provided URL doesn't include the method, the following default methods are provided:
 *    - `getListData` - `GET`
 *    - `getData` - `GET`
 *    - `createData` - `POST`
 *    - `updateData` - `PUT`
 *    - `destroyData` - `DELETE`
 *
 * If [can-connect/data/url/url.url] is provided as a string like:
 *
 * ```js
 * var todoConnection = connect([
 *   require("can-connect/data/url/url")
 * ],{
 *   url: "/todos"
 * });
 * ```
 *
 * This does the same thing as the first `todoConnection` example.
 */
var ajax = __webpack_require__(/*! can-ajax */ "./node_modules/can-ajax/can-ajax.js");
var replaceWith = __webpack_require__(/*! can-key/replace-with/replace-with */ "./node_modules/can-key/replace-with/replace-with.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var behavior = __webpack_require__(/*! ../../behavior */ "./node_modules/can-connect/behavior.js");
var makeRest = __webpack_require__(/*! can-make-rest */ "./node_modules/can-make-rest/can-make-rest.js");

var defaultRest = makeRest("/resource/{id}");

var makePromise = __webpack_require__(/*! ../../helpers/make-promise */ "./node_modules/can-connect/helpers/make-promise.js");

// # can-connect/data/url/url
// For each pair, create a function that checks the url object
// and creates an ajax request.
var urlBehavior = behavior("data/url", function(baseConnection) {
	var behavior = {};
	canReflect.eachKey(defaultRest, function(defaultData, dataInterfaceName){
		behavior[dataInterfaceName] = function(params) {
			var meta = methodMetaData[dataInterfaceName];
			var defaultBeforeSend;

			if(typeof this.url === "object") {
				defaultBeforeSend = this.url.beforeSend;

				if(typeof this.url[dataInterfaceName] === "function") {

					return makePromise(this.url[dataInterfaceName](params));
				}
				else if(this.url[dataInterfaceName]) {
					var promise = makeAjax(
							this.url[dataInterfaceName],
							params,
							defaultData.method,
							this.ajax || ajax,
							findContentType(this.url, defaultData.method),
							meta,
							defaultBeforeSend
					);
					return makePromise(promise);
				}
			}

			var resource = typeof this.url === "string" ? this.url : this.url.resource;
			if( resource ) {
				var idProps = canReflect.getSchema(this.queryLogic).identity;
				var resourceWithoutTrailingSlashes = resource.replace(/\/+$/, "");
				var result = makeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];
				return makePromise(makeAjax(
					result.url,
					params,
					result.method,
					this.ajax || ajax,
					findContentType(this.url, result.method),
					meta,
					defaultBeforeSend
				));
			}

			return baseConnection[name].call(this, params);
		};
	});

	return behavior;
});
/**
 * @property {String|Object} can-connect/data/url/url.url url
 * @parent can-connect/data/url/url.option
 *
 * Specify the url and methods that should be used for the "Data Methods".
 *
 * @option {String} If a string is provided, it's assumed to be a RESTful interface. For example,
 * if the following is provided:
 *
 * ```
 * url: "/services/todos"
 * ```
 *
 * ... the following methods and requests are used:
 *
 *  - `getListData` - `GET /services/todos`
 *  - `getData` - `GET /services/todos/{id}`
 *  - `createData` - `POST /services/todos`
 *  - `updateData` - `PUT /services/todos/{id}`
 *  - `destroyData` - `DELETE /services/todos/{id}`
 *
 * @option {Object} If an object is provided, it can customize each method and URL directly
 * like:
 *
 * ```js
 * url: {
 *   getListData: "GET /services/todos",
 *   getData: "GET /services/todo/{id}",
 *   createData: "POST /services/todo",
 *   updateData: "PUT /services/todo/{id}",
 *   destroyData: "DELETE /services/todo/{id}"
 * }
 * ```
 *
 * You can provide a `resource` property that works like providing `url` as a string, but overwrite
 * other values like:
 *
 * ```js
 * url: {
 *   resource: "/services/todo",
 *   getListData: "GET /services/todos"
 * }
 * ```
 *
 * You can also customize per-method the parameters passed to the [can-connect/data/url/url.ajax ajax implementation], like:
 * ```js
 * url: {
 *   resource: "/services/todos",
 *   getListData: {
 *     url: "/services/todos",
 *     type: "GET",
 *     beforeSend: () => {
 *       return fetch('/services/context').then(processContext);
 *     }
 *   }
 * }
 * ```
 * This can be particularly useful for passing a handler for the [can-ajax <code>beforeSend</code>] hook.
 *
 * The [can-ajax <code>beforeSend</code>] hook can also be passed for all request methods. This can be useful when
 * attaching a session token header to a request:
 * 
 * ```js
 * url: {
 *   resource: "/services/todos",
 *   beforeSend: (xhr) => {
 *     xhr.setRequestHeader('Authorization', `Bearer: ${Session.current.token}`);
 *   }
 * }
 * ```
 *
 * Finally, you can provide your own method to totally control how the request is made:
 *
 * ```js
 * url: {
 *   resource: "/services/todo",
 *   getListData: "GET /services/todos",
 *   getData: function(param){
 *     return new Promise(function(resolve, reject){
 *       $.get("/services/todo", {identifier: param.id}).then(resolve, reject);
 *     });
 *   }
 * }
 * ```
 */


 /**
  * @property {function} can-connect/data/url/url.ajax ajax
  * @parent can-connect/data/url/url.option
  *
  * Specify the ajax functionality that should be used to make the request.
  *
  * @option {function} Provides an alternate function to be used to make
  * ajax requests.  By default [can-ajax] provides the ajax
  * functionality. jQuery's ajax method can be substituted as follows:
  *
  * ```js
  * connect([
  *   require("can-connect/data/url/url")
  * ],{
  *   url: "/things",
  *   ajax: $.ajax
  * });
  * ```
  *
  *   @param {Object} settings Configuration options for the AJAX request.
  *   @return {Promise} A Promise that resolves to the data.
  */

// ## methodMetaData
// Metadata on different methods that is passed to makeAjax
var methodMetaData = {
	/**
	 * @function can-connect/data/url/url.getListData getListData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `getListData(set)`
	 *
	 *   Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.
	 *   If `url.getListData` is a function, that function will be called.  If `url.getListData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to
	 *   `url`.
	 *
	 *   @param {can-query-logic/query} query A object that represents the set of data needed to be loaded.
	 *   @return {Promise<can-connect.listData>} A promise that resolves to the ListData format.
	 */
	getListData: {},
	/**
	 * @function can-connect/data/url/url.getData getData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `getData(params)`
	 *
	 *   Retrieves raw instance data given the [can-connect/data/url/url.url] settings.
	 *   If `url.getData` is a function, that function will be called.  If `url.getData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} params A object that represents the set of data needed to be loaded.
	 *   @return {Promise<Object>} A promise that resolves to the instance data.
	 */
	getData: {},
	/**
	 * @function can-connect/data/url/url.createData createData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `createData(instanceData, cid)`
	 *
	 *   Creates instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.createData` is a function, that function will be called.  If `url.createData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `POST` request is made to
	 *   `url`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @param {Number} cid A unique id that represents the instance that is being created.
	 *   @return {Promise<Object>} A promise that resolves to the newly created instance data.
	 */
	createData: {},
	/**
	 * @function can-connect/data/url/url.updateData updateData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `updateData(instanceData)`
	 *
	 * Updates instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.updateData` is a function, that function will be called.  If `url.updateData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `PUT` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @return {Promise<Object>} A promise that resolves to the updated instance data.
	 */
	updateData: {},
	/**
	 * @function can-connect/data/url/url.destroyData destroyData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `destroyData(instanceData)`
	 *
	 * Deletes instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @return {Promise<Object>} A promise that resolves to the deleted instance data.
	 */
	destroyData: {includeData: false}
};

var findContentType = function( url, method ) {
	if ( typeof url === 'object' && url.contentType ) {
		var acceptableType = url.contentType === 'application/x-www-form-urlencoded' ||
			url.contentType === 'application/json';
		if ( acceptableType ) {
			return url.contentType;
		} else {
			//!steal-remove-start
			if(true) {
				dev.warn("Unacceptable contentType on can-connect request. " +
					"Use 'application/json' or 'application/x-www-form-urlencoded'");
			}
			//!steal-remove-end
		}
	}
	return method === "GET" ? "application/x-www-form-urlencoded" : "application/json";
};

function urlParamEncoder (key, value) {
	return encodeURIComponent(value);
}

var makeAjax = function ( ajaxOb, data, type, ajax, contentType, reqOptions, defaultBeforeSend ) {

	var params = {};

	// A string here would be something like `"GET /endpoint"`.
	if (typeof ajaxOb === 'string') {
		// Split on spaces to separate the HTTP method and the URL.
		var parts = ajaxOb.split(/\s+/);
		params.url = parts.pop();
		if (parts.length) {
			params.type = parts.pop();
		}
	} else {
		// If the first argument is an object, just load it into `params`.
		canReflect.assignMap(params, ajaxOb);
	}

	// If the `data` argument is a plain object, copy it into `params`.
	params.data = typeof data === "object" && !Array.isArray(data) ?
		canReflect.assignMap(params.data || {}, data) : data;

	// Substitute in data for any templated parts of the URL.
	params.url = replaceWith(params.url, params.data, urlParamEncoder, true);
	params.contentType = contentType;

	if(reqOptions.includeData === false) {
		delete params.data;
	}

	return ajax(canReflect.assignMap({
		type: type || 'post',
		dataType: 'json',
		beforeSend: defaultBeforeSend,
	}, params));
};

module.exports = urlBehavior;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(urlBehavior, ['url']);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/fall-through-cache/fall-through-cache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-connect/fall-through-cache/fall-through-cache.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/fall-through-cache/fall-through-cache fall-through-cache
 * @parent can-connect.behaviors
 * @group can-connect/fall-through-cache/fall-through-cache.data data callbacks
 * @group can-connect/fall-through-cache/fall-through-cache.hydrators hydrators
 *
 * Add fall-through caching with the `cacheConnection`.
 *
 * @signature `fallThroughCache( baseConnection )`
 *
 *   Implements a `getData` and `getListData` that
 *   check their [can-connect/base/base.cacheConnection] for data. If there is data,
 *   this data will be immediately returned.
 *   In the background, the `baseConnection` method will be called and used to update the instance or list.
 *
 * @body
 *
 * ## Use
 *
 * To use the `fall-through-cache`, create a connection with a
 * [can-connect/base/base.cacheConnection] and a behavior that implements
 * [can-connect/connection.getData] and [can-connect/connection.getListData].
 *
 * ```js
 * var QueryLogic = require("can-query-logic");
 *
 * var queryLogic = new QueryLogic();
 *
 * var cache = connect([
 *   require("can-local-store")
 * ],{
 *   name: "todos",
 *   queryLogic: queryLogic
 * });
 *
 * var todoConnection = connect([
 *    require("can-connect/fall-through-cache/fall-through-cache"),
 *    require("can-connect/data/url/url"),
 *    require("can-connect/constructor/constructor"),
 *    require("can-connect/constructor/store/store")
 *   ], {
 *   url: "/todos",
 *   cacheConnection: cache,
 *   queryLogic: queryLogic
 * });
 * ```
 *
 * Then, make requests.  If the cache has the data,
 * it will be returned immediately, and then the item or list updated later
 * with the response from the base connection:
 *
 * ```js
 * todoConnection.getList({due: "today"}).then(function(todos){
 *
 * })
 * ```
 *
 * ## Demo
 *
 * The following shows the `fall-through-cache` behavior.
 *
 * @demo demos/can-connect/fall-through-cache.html
 *
 * Clicking
 * "Completed" or "Incomplete" will make one of the following requests and
 * display the results in the page:
 *
 * ```
 * todoConnection.getList({completed: true});
 * todoConnection.getList({completed: false});
 * ```
 *
 * If you click back and forth between "Completed" and "Incomplete" multiple times
 * you'll notice that the old data is displayed immediately and then
 * updated after about a second.
 *
 */
var connect = __webpack_require__(/*! ../can-connect */ "./node_modules/can-connect/can-connect.js");
var sortedSetJSON = __webpack_require__(/*! ../helpers/sorted-set-json */ "./node_modules/can-connect/helpers/sorted-set-json.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");

var fallThroughCache = connect.behavior("fall-through-cache",function(baseConnection){

	var behavior = {
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.hydrateList hydrateList
		 * @parent can-connect/fall-through-cache/fall-through-cache.hydrators
		 *
		 * Returns a List instance given raw data.
		 *
		 * @signature `connection.hydrateList(listData, set)`
		 *
		 *   Calls the base `hydrateList` to create a List for `listData`.
		 *
		 *   Then, Looks for registered hydrateList callbacks for a given `set` and
		 *   calls them.
		 *
		 *   @param {can-connect.listData} listData
		 *   @param {can-query-logic/query} query
		 *   @return {can-connect.List}
		 */
		hydrateList: function(listData, set){
			set = set || this.listQuery(listData);
			var id = sortedSetJSON( set );
			var list = baseConnection.hydrateList.call(this, listData, set);

			if(this._getHydrateListCallbacks[id]) {
				this._getHydrateListCallbacks[id].shift()(list);
				if(!this._getHydrateListCallbacks[id].length){
					delete this._getHydrateListCallbacks[id];
				}
			}
			return list;
		},
		_getHydrateListCallbacks: {},
		_getHydrateList: function(set, callback){
			var id = sortedSetJSON( set );
			if(!this._getHydrateListCallbacks[id]) {
				this._getHydrateListCallbacks[id]= [];
			}
			this._getHydrateListCallbacks[id].push(callback);
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.getListData getListData
		 * @parent can-connect/fall-through-cache/fall-through-cache.data
		 *
		 * Get raw data from the cache if available, and then update
		 * the list later with data from the base connection.
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Checks the [can-connect/base/base.cacheConnection] for `set`'s data.
		 *
		 *   If the cache connection has data, the cached data is returned. Prior to
		 *   returning the data, the [can-connect/constructor.hydrateList] method
		 *   is intercepted so we can get a handle on the list that's being created
		 *   for the returned data. Once the intercepted list is retrieved,
		 *   we use the base connection to get data and update the intercepted list and
		 *   the cacheConnection.
		 *
		 *   If the cache connection does not have data, the base connection
		 *   is used to load the data and the cached connection is updated with that
		 *   data.
		 *
		 *   @param {can-query-logic/query} query The set to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that returns the
		 *   raw data.
		 */
		// if we do getList, the cacheConnection runs on
		// if we do getListData, ... we need to register the list that is going to be created
		// so that when the data is returned, it updates this
		getListData: function(set){
			set = set || {};
			var self = this;
			return this.cacheConnection.getListData(set).then(function(data){

				// get the list that is going to be made
				// it might be possible that this never gets called, but not right now
				self._getHydrateList(set, function(list){
					self.addListReference(list, set);

					setTimeout(function(){
						baseConnection.getListData.call(self, set).then(function(listData){

							self.cacheConnection.updateListData(listData, set);
							self.updatedList(list, listData, set);
							self.deleteListReference(list, set);

						}, function(e){
							// what do we do here?  self.rejectedUpdatedList ?
							canLog.log("REJECTED", e);
						});
					},1);
				});
				// TODO: if we wired up all responses to updateListData, this one should not
				// updateListData with itself.
				// But, how would we do a bypass?
				return data;
			}, function(){

				var listData = baseConnection.getListData.call(self, set);
				listData.then(function(listData){

					self.cacheConnection.updateListData(listData, set);
				});

				return listData;
			});
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.hydrateInstance hydrateInstance
		 * @parent can-connect/fall-through-cache/fall-through-cache.hydrators
		 *
		 * Returns an instance given raw data.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 *
		 *   Calls the base `hydrateInstance` to create an Instance for `props`.
		 *
		 *   Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and
		 *   calls them.
		 *
		 *   @param {Object} props
		 *   @return {can-connect/Instance}
		 */
		hydrateInstance: function(props){

			var id = this.id( props );
			var instance = baseConnection.hydrateInstance.apply(this, arguments);

			if(this._getMakeInstanceCallbacks[id]) {
				this._getMakeInstanceCallbacks[id].shift()(instance);
				if(!this._getMakeInstanceCallbacks[id].length){
					delete this._getMakeInstanceCallbacks[id];
				}
			}
			return instance;
		},
		_getMakeInstanceCallbacks: {},
		_getMakeInstance: function(id, callback){
			if(!this._getMakeInstanceCallbacks[id]) {
				this._getMakeInstanceCallbacks[id]= [];
			}
			this._getMakeInstanceCallbacks[id].push(callback);
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.getData getData
		 * @parent can-connect/fall-through-cache/fall-through-cache.data
		 *
		 * Get raw data from the cache if available, and then update
		 * the instance later with data from the base connection.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Checks the [can-connect/base/base.cacheConnection] for `params`'s data.
		 *
		 *   If the cache connection has data, the cached data is returned. Prior to
		 *   returning the data, the [can-connect/constructor/constructor.hydrateInstance] method
		 *   is intercepted so we can get a handle on the instance that's being created
		 *   for the returned data. Once the intercepted instance is retrieved,
		 *   we use the base connection to get data and update the intercepted instance and
		 *   the cacheConnection.
		 *
		 *   If the cache connection does not have data, the base connection
		 *   is used to load the data and the cached connection is updated with that
		 *   data.
		 *
		 *   @param {Object} params The set to load.
		 *
		 *   @return {Promise<Object>} A promise that returns the
		 *   raw data.
		 */
		getData: function(params){
			// first, always check the cache connection
			var self = this;
			return this.cacheConnection.getData(params).then(function(instanceData){

				// get the list that is going to be made
				// it might be possible that this never gets called, but not right now
				self._getMakeInstance(self.id(instanceData) || self.id(params), function(instance){
					self.addInstanceReference(instance);

					setTimeout(function(){
						baseConnection.getData.call(self, params).then(function(instanceData2){

							self.cacheConnection.updateData(instanceData2);
							self.updatedInstance(instance, instanceData2);
							self.deleteInstanceReference(instance);

						}, function(e){
							// what do we do here?  self.rejectedUpdatedList ?
							canLog.log("REJECTED", e);
						});
					},1);
				});

				return instanceData;
			}, function(){
				var listData = baseConnection.getData.call(self, params);
				listData.then(function(instanceData){
					self.cacheConnection.updateData(instanceData);
				});

				return listData;
			});
		}

	};

	return behavior;

});

module.exports = fallThroughCache;

//!steal-remove-start
if(true) {
	var validate = __webpack_require__(/*! ../helpers/validate */ "./node_modules/can-connect/helpers/validate.js");
	module.exports = validate(fallThroughCache, ['hydrateList', 'hydrateInstance', 'getListData', 'getData']);
}
//!steal-remove-end


/***/ }),

/***/ "./node_modules/can-connect/helpers/deferred.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/deferred.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function(){
	var def = {};
	def.promise = new Promise(function(resolve, reject){
		def.resolve = resolve;
		def.reject = reject;
	});
	return def;
};


/***/ }),

/***/ "./node_modules/can-connect/helpers/get-items.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-connect/helpers/get-items.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

module.exports = function(data){
	if(Array.isArray(data)) {
		return data;
	} else {
		return data.data;
	}
};


/***/ }),

/***/ "./node_modules/can-connect/helpers/id-merge.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/id-merge.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var diffList = __webpack_require__(/*! can-diff/list/list */ "./node_modules/can-diff/list/list.js");

module.exports = function(list, update, id, make){

	var patches = diffList(list, update, function(a, b){
		return id(a) === id(b);
	});
	patches.forEach(function(patch){
		canReflect.splice(list, patch.index, patch.deleteCount, patch.insert.map(make));
	});
};


/***/ }),

/***/ "./node_modules/can-connect/helpers/make-promise.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-connect/helpers/make-promise.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
module.exports = function(obj){
	if (obj && typeof obj.then === "function" && !canReflect.isPromise(obj)) {
		return new Promise(function(resolve, reject) {
			obj.then(resolve, reject);
		});
	}
	else {
		return obj;
	}
};


/***/ }),

/***/ "./node_modules/can-connect/helpers/sorted-set-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/helpers/sorted-set-json.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function(set){
	if(set == null) {
		return set;
	} else {
		return JSON.stringify(canReflect.cloneKeySort(set));
	}

};


/***/ }),

/***/ "./node_modules/can-connect/helpers/validate.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/validate.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// return wrapped can-connect behavior mixin that validates interface of the input behavior being extended
// deprecate this and use can-validate-interface decorator once available

var makeInterfaceValidator = __webpack_require__(/*! can-validate-interface */ "./node_modules/can-validate-interface/index.js");

module.exports = function(extendingBehavior, interfaces){
	var validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function(errors, baseBehavior) {
		throw new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);
	});

	// copy properties on behavior to validator wrapped behavior
	Object.keys(extendingBehavior).forEach(function (k) {
		validatedBehaviour[k] = extendingBehavior[k];
	});
	// add interfaces for building behavior ordering
	validatedBehaviour.__interfaces = interfaces;

	return validatedBehaviour;
};

function validateArgumentInterface(func, argIndex, interfaces, errorHandler) {
	return function() {
		var errors = makeInterfaceValidator(interfaces)(arguments[argIndex]);
		if (errors && errorHandler) {
			errorHandler(errors, arguments[argIndex]);
		}

		return func.apply(this, arguments);
	};
}


// change to 'BehaviourInterfaceError extends Error' once we drop support for pre-ES2015
function BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {
	var extendingName = extendingBehavior.behaviorName || 'anonymous behavior',
		baseName = baseBehavior.__behaviorName || 'anonymous behavior',
		message = 'can-connect: Extending behavior "' + extendingName + '" found base behavior "' + baseName + '" was missing required properties: ' + JSON.stringify(missingProps.related),
		instance = new Error(message);

	if (Object.setPrototypeOf){
		Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
	}
	return instance;
}
BehaviorInterfaceError.prototype = Object.create(Error.prototype, {
	constructor: {value: Error}
});
if (Object.setPrototypeOf){
	Object.setPrototypeOf(BehaviorInterfaceError, Error);
} else {
	/* jshint proto: true */
	BehaviorInterfaceError.__proto__ = Error;
}


/***/ }),

/***/ "./node_modules/can-connect/helpers/weak-reference-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-connect/helpers/weak-reference-map.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var assign = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").assignMap;

/**
 * @module {function} can-connect/helpers/weak-reference-map WeakReferenceMap
 * @parent can-connect.modules
 *
 * Provides a map that only contains keys that are referenced.
 *
 * @signature `new WeakReferenceMap()`
 *
 *   Creates a new weak reference map.
 *
 * @body
 *
 * ## Use
 *
 * ```
 * var WeakReferenceMap = require("can-connect/helpers/weak-reference-map");
 * var wrm = new WeakReferenceMap();
 * var task1 = {id: 1, name: "do dishes"};
 *
 * wrm.addReference("1", task1);
 * wrm.has("1") //-> true
 * wrm.addReference("1", task1);
 * wrm.has("1") //-> true
 * wrm.deleteReference("1");
 * wrm.has("1") //-> true
 * wrm.deleteReference("1");
 * wrm.has("1") //-> false
 * ```
 */

var WeakReferenceMap = function(){
	this.set = {};
};

// if weakmap, we can add and never worry ...
// otherwise, we need to have a count ...

assign(WeakReferenceMap.prototype,
/**
 * @prototype
 */
	{
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.has has
	 * @signature `weakReferenceMap.has(key)`
	 *
	 *   Returns if key is in the set.
	 *
	 *   @param  {String} key A key to look for.
	 *   @return {Boolean} If the key exists.
	 */
	has: function(key){
		return !!this.set[key];
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.addReference addReference
	 * @signature `WeakReferenceMap.addReference(key, item)`
	 *
	 *   Adds a reference to item as key and increments the reference count. This should be called
	 *   when a value should be managed by something, typically the [can-connect/constructor/store/store].
	 *
	 *   @param  {String} key The key of the item in the store.
	 */
	addReference: function(key, item, referenceCount){
		// !steal-remove-start
		if (typeof key === 'undefined'){
			throw new Error("can-connect: You must provide a key to store a value in a WeakReferenceMap");
		}
		// !steal-remove-end
		var data = this.set[key];
		if(!data) {
			data = this.set[key] = {
				item: item,
				referenceCount: 0,
				key: key
			};
		}
		data.referenceCount += (referenceCount || 1);
	},
	referenceCount: function(key) {
		var data = this.set[key];
		if(data) {
			return data.referenceCount;
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.deleteReference deleteReference
	 * @signature `weakReferenceMap.deleteReference(key)`
	 *
	 *   Decrements the reference count for key and removes it if the reference count is `0`. This should be called
	 *   when a value should not be managed by something, typically the [can-connect/constructor/store/store].
	 *
	 *   @param  {String} key The key of the item in the store.
	 */
	deleteReference: function(key){
		var data = this.set[key];
		if(data){
			data.referenceCount--;
			if( data.referenceCount === 0 ) {
				delete this.set[key];
			}
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.get get
	 * @signature `weakReferenceMap.get(key)`
	 *
	 *   Returns the value stored at key if it's in the store.
	 *
	 *   @param  {String} key The key of the item in the store.
	 *   @return {*|undefined} The item if it's available.
	 */
	get: function(key){
		var data = this.set[key];
		if(data) {
			return data.item;
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach
	 * @signature `weakReferenceMap.forEach(callback)`
	 *
	 *   Calls `callback` for every value in the store.
	 *
	 *   @param  {function(*,String)} callback(item,key) A callback handler.
	 */
	forEach: function(cb){
		for(var id in this.set) {
			cb(this.set[id].item, id);
		}
	}
});

module.exports = WeakReferenceMap;


/***/ }),

/***/ "./node_modules/can-connect/helpers/weak-reference-set.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-connect/helpers/weak-reference-set.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assign = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js").assignMap;


var WeakReferenceSet = function(){
	this.set = [];
};

// if weakmap, we can add and never worry ...
// otherwise, we need to have a count ...

assign(WeakReferenceSet.prototype,{

	has: function(item){
		return this._getIndex(item) !== -1;
	},
	addReference: function(item, referenceCount){

		var index = this._getIndex(item);
		var data = this.set[index];

		if(!data) {
			data = {
				item: item,
				referenceCount: 0
			};
			this.set.push(data);
		}
		data.referenceCount += (referenceCount || 1);
	},
	deleteReference: function(item){
		var index = this._getIndex(item);
		var data = this.set[index];
		if(data){
			data.referenceCount--;
			if( data.referenceCount === 0 ) {
				this.set.splice(index,1);
			}
		}
	},
	delete: function(item){
		var index = this._getIndex(item);
		if(index !== -1) {
			this.set.splice(index,1);
		}
	},
	get: function(item){
		var data = this.set[this._getIndex(item)];
		if(data) {
			return data.item;
		}
	},
	referenceCount: function(item) {
		var data = this.set[this._getIndex(item)];
		if(data) {
			return data.referenceCount;
		}
	},
	_getIndex: function(item){
		var index;
		this.set.every(function(data, i){
			if(data.item === item) {

				index = i;
				return false;
			}
			return true;
		});
		return index !== undefined ? index : -1;
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach
	 * @signature `weakReferenceMap.forEach(callback)`
	 *
	 *   Calls `callback` for every value in the store.
	 *
	 *   @param  {function(*,String)} callback(item,key) A callback handler.
	 */
	forEach: function(cb){
		return this.set.forEach(cb);
	}
});

module.exports = WeakReferenceSet;


/***/ }),

/***/ "./node_modules/can-connect/real-time/real-time.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect/real-time/real-time.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module can-connect/real-time/real-time real-time
 * @parent can-connect.behaviors
 * @group can-connect/real-time/real-time.methods 0 methods
 * @group can-connect/real-time/real-time.callbacks 1 data callbacks
 *
 * Update lists to include or exclude instances based
 * on set logic.
 *
 * @signature `realTime( baseConnection )`
 *
 *   Overwrites the "data callback" methods and provides
 *   [can-connect/real-time/real-time.createInstance],
 *   [can-connect/real-time/real-time.updateInstance], and
 *   [can-connect/real-time/real-time.destroyInstance] methods
 *   that
 *   update lists to include or exclude a created,
 *   updated, or destroyed instance.
 *
 *   An instance is put in a list if it is a
 *   [can-query-logic/queryLogic.prototype.isSubset]
 *   of the [can-connect/base/base.listQuery].  The item is inserted using [can-query-logic.prototype.index].
 *
 * @body
 *
 * ## Use
 *
 * To use `real-time`, create a connection with its dependent
 * behaviors like:
 *
 * ```js
 * var todoConnection = connect(
 *    ["data/callbacks",
 *     "real-time",
 *     "constructor/callbacks-once",
 *     "constructor/store",
 *     "constructor",
 *     "data/url"],{
 *   url: "/todos"
 * });
 * ```
 *
 * Next, use the connection to load lists and save those lists in the
 * store:
 *
 * ```js
 * todoConnection.getList({complete: false}).then(function(todos){
 *   todoConnection.addListReference(todos);
 * })
 * ```
 *
 * Finally, use one of the  [can-connect/real-time/real-time.createInstance],
 * [can-connect/real-time/real-time.updateInstance], and
 * [can-connect/real-time/real-time.destroyInstance] methods to tell the connection
 * that data has changed.  The connection will update (by calling splice)
 * each list accordingly.
 *
 *
 * ## Example
 *
 * The following demo shows two lists that use this connection.  The
 * "Run Code" button sends the connection data changes which the
 * connection will then update lists accordingly:
 *
 *
 * @demo demos/can-connect/real-time.html
 *
 * This example creates a `todoList` function and `todoItem` function
 * that manage the behavior of a list of todos and a single todo respectfully.
 * It uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)
 * to observe changes in the todo list and individual todo data. Other
 * frameworks will typically provide their own observable system.
 *
 * ### todoList
 *
 * When `todoList` is created, it is passed the `set` of data to load.  It uses
 * this to get todos from the `todoConnection` like:
 *
 *
 * ```js
 * todosConnection.getList(set).then(function(retrievedTodos){
 * ```
 *
 * It then adds those `todos` to the [can-connect/constructor/store/store.listStore] so
 * they can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:
 *
 * ```js
 * todosConnection.addListReference(todos);
 * Object.observe(todos, update, ["add", "update", "delete"] );
 * ```
 *
 * The update function is able to inserted new `todoItem`s in the page when items are added
 * to or removed from `todos`.  We exploit that by calling `update` as if it just added
 * each todo in the list:
 *
 * ```js
 * update(todos.map(function(todo, i){
 *   return {
 *     type: "add",
 *     name: ""+i
 *   };
 * }));
 * ```
 *
 * ### todoItem
 *
 * The `todoItem` creates an element that updates with changes
 * in its `todo`.  It listens to changes in the `todo` and saves
 * the todo in the [can-connect/constructor/store/store.instanceStore] with the
 * following:
 *
 * ```js
 * Object.observe(todo, update, ["add", "update", "delete"] );
 * todosConnection.addInstanceReference(todo);
 * ```
 *
 * A `todoItem` needs to be able to stop listening on the `todo` and remove itself from the
 * `instanceStore` if the `todo` is removed from the page.  To provide this teardown
 * functionality, `todoItem` listens to a `"removed"` event on its element and
 * `unobserves` the todo and removes it from the `instanceStore`:
 *
 * ```js
 * $(li).bind("removed", function(){
 *   Object.unobserve(todo, update, ["add", "update", "delete"] );
 *   todosConnection.deleteInstanceReference(todo);
 * });
 * ```
 */
var connect = __webpack_require__(/*! ../can-connect */ "./node_modules/can-connect/can-connect.js");
var indexByIdentity = __webpack_require__(/*! can-diff/index-by-identity/index-by-identity */ "./node_modules/can-diff/index-by-identity/index-by-identity.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var spliceSymbol = canSymbol.for("can.splice");

function updateList(list, getRecord, currentIndex, newIndex) {
	if(currentIndex === -1) { // item is not in the list

		if(newIndex !== -1) { // item should be in the list
			canReflect.splice(list, newIndex, 0, [getRecord()]);
		}
	}
	else { // item is already in the list
		if(newIndex === -1) { // item should be removed from the lists
			canReflect.splice(list, currentIndex, 1, []);
		}
		else if(newIndex !== currentIndex){ // item needs to be moved

			if(currentIndex < newIndex) {
				canReflect.splice(list, newIndex, 0, [getRecord()]);
				canReflect.splice(list, currentIndex, 1, []);
			} else {
				canReflect.splice(list, currentIndex,1, []);
				canReflect.splice(list, newIndex, 0, [getRecord()]);
			}
		}
		else { // item in the same place

		}
	}
}


function updateListWithItem(list, recordData, currentIndex, newIndex, connection, set){
	// we are inserting right where we already are.
	if(currentIndex !== -1 && (newIndex === currentIndex + 1 || newIndex === currentIndex)) {
		return;
	}
	if(list[spliceSymbol] !== undefined) {
		updateList(list, function(){
			return connection.hydrateInstance(recordData);
		},currentIndex, newIndex);

	} else {
		var copy = connection.serializeList(list);
		updateList(copy, function(){
			return recordData;
		},currentIndex, newIndex);
		connection.updatedList(list,  { data: copy }, set);
	}
}


module.exports = connect.behavior("real-time",function(baseConnection){

	var createPromise = Promise.resolve();
	var behavior;

	behavior = {
		createData: function(){
			var promise = baseConnection.createData.apply(this, arguments);
			var cleanPromise = promise.catch(function () { return ''; });
			createPromise = Promise.all([createPromise, cleanPromise]);
			return promise;
		},
		/**
		 * @function can-connect/real-time/real-time.createInstance createInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been created.
		 *
		 * @signature `connection.createInstance(props)`
		 *
		 *   If there is no instance in the [can-connect/constructor/store/store.instanceStore]
		 *   for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],
		 *   added to the store, and then [can-connect/real-time/real-time.createdData] is called with
		 *   `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]
		 *   will add this instance to any lists the instance belongs to.
		 *
		 *   If this instance has already been created, calls
		 *   [can-connect/real-time/real-time.updateInstance] with `props`.
		 *
		 *   @param {Object} props The raw properties of the instance was created.
		 *
		 *   @return {Promise<Instance>} A promise that resolves to the created instance.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * With a `real-time` connection, call `createInstance` when an instance is created that
		 * the connection itself did not make.  For instance, the following might listen to
		 * [socket.io](http://socket.io/) for when a `todo` is created and update the connection
		 * accordingly:
		 *
		 * ```js
		 * socket.on('todo created', function(todo){
		 *   todoConnection.createInstance(todo);
		 * });
		 * ```
		 *
		 */
		createInstance: function(props){
			var self = this;
			return new Promise(function(resolve, reject){
				// Wait until all create promises are done
				// so that we can find data in the instance store
				createPromise.then(function(){
					// Allow time for the store to get hydrated
					setTimeout(function(){
						var id = self.id(props);
						var instance = self.instanceStore.get(id);
						var serialized;

						if( instance ) {
							// already created, lets update
							resolve(self.updateInstance(props));
						} else {
							instance = self.hydrateInstance(props);
							serialized = self.serializeInstance(instance);

							self.addInstanceReference(instance);

							Promise.resolve( self.createdData(props, serialized) ).then(function(){
								self.deleteInstanceReference(instance);
								resolve(instance);
							});
						}
					}, 1);
				});
			});
		},

		/**
		 * @function can-connect/real-time/real-time.createdData createdData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * Called whenever instance data is created.
		 *
		 * @signature `connection.createdData(props, params, [cid])`
		 *
		 *   Updates lists with the created instance.
		 *
		 *   Gets the instance created for this request. Then, updates the instance with
		 *   the response data `props`.
		 *
		 *   Next, it goes through every list in the [can-connect/constructor/store/store.listStore],
		 *   test if the instance's data belongs in that list.  If it does,
		 *   adds the instance's data to the serialized list data and
		 *   [can-connect/constructor/constructor.updatedList updates the list].
		 */
		createdData: function(props, params, cid){
			var instance;
			if(cid !== undefined) {
				instance = this.cidStore.get(cid);
			} else {
				instance = this.instanceStore.get( this.id(props) );
			}
			// pre-register so everything else finds this even if it doesn't have an id
			this.addInstanceReference(instance, this.id(props));
			this.createdInstance(instance, props);
			create.call(this, this.serializeInstance(instance));
			this.deleteInstanceReference(instance);
			return undefined;
		},

		/**
		 * @function can-connect/real-time/real-time.updatedData updatedData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * Called whenever instance data is updated.
		 *
		 * @signature `connection.updatedData(props, params)`
		 *
		 *   Gets the instance that is updated, updates
		 *   it with `props` and the adds or removes it to
		 *   lists it belongs in.
		 *
		 *   @return {undefined} Returns `undefined` to prevent `.save` from calling `updatedInstance`.
		 */
		// Go through each list in the listStore and see if there are lists that should have this,
		// or a list that shouldn't.
		updatedData: function(props, params){

			var instance = this.instanceStore.get( this.id(params) );
			this.updatedInstance(instance, props);
			update.call(this, this.serializeInstance(instance));

			// Returning undefined prevents other behaviors from running.
			return undefined;
		},
		/**
		 * @function can-connect/real-time/real-time.updateInstance updateInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been updated.
		 *
		 * @signature `connection.updateInstance(props)`
		 *
		 *   Calls [can-connect/real-time/real-time.updatedData] in the right way so
		 *   that the instance is updated and added to or removed from
		 *   any lists it belongs in.
		 *
		 *   @param {Object} props The properties of the instance that needs to be updated.
		 *
		 *   @return {Promise<Instance>} the updated instance.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * socket.on('todo updated', function(todo){
		 *   todoConnection.updateInstance(todo);
		 * });
		 * ```
		 */
		updateInstance: function(props){
			var id = this.id(props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			this.addInstanceReference(instance);

			var serialized = this.serializeInstance(instance),
				self = this;

			return Promise.resolve( this.updatedData(props, serialized) ).then(function(){

				self.deleteInstanceReference(instance);
				return instance;
			});
		},
		/**
		 * @function can-connect/real-time/real-time.destroyedData destroyedData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * @signature `connection.destroyedData(props, params)`
		 *
		 * Gets the instance for this request.  Then tests if the instance
		 * is in any list in the [can-connect/constructor/store/store.listStore].  If
		 * it is, removes the instance from the list.
		 *
		 * @param {Object} props The properties of the destroyed instance.
		 * @param {Object} [params] The parameters used to destroy the data.
		 */
		destroyedData: function(props, params){
			var id = this.id(params || props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			var serialized = this.serializeInstance(instance);
			this.destroyedInstance(instance, props);
			// we can pre-register it so everything else finds it
			destroy.call(this, serialized);
			return undefined;
		},
		/**
		 * @function can-connect/real-time/real-time.destroyInstance destroyInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been destroyed.
		 *
		 * @signature `connection.destroyInstance(props)`
		 *
		 *   Gets or creates an instance from `props` and uses
		 *   it to call [can-connect/real-time/real-time.destroyedData]
		 *   correctly.
		 *
		 * @param {Object} props The properties of the destroyed instance.
		 * @return {Promise<Instance>}  A promise with the destroyed instance.
		 *
		 * @body
		 * ## Use
		 *
		 * ```js
		 * socket.on('todo destroyed', function(todo){
		 *   todoConnection.destroyInstance(todo);
		 * });
		 * ```
		 */
		destroyInstance: function(props){
			var id = this.id(props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			this.addInstanceReference(instance);

			var serialized = this.serializeInstance(instance),
				self = this;

			return Promise.resolve( this.destroyedData(props, serialized) ).then(function(){

				self.deleteInstanceReference(instance);
				return instance;
			});
		}
	};

	//!steal-remove-start
	if(true) {
		behavior.gotListData = function(items, set) {
			var self = this;
			if (this.queryLogic) {
				if(Array.isArray(items)) {
					items = {data: items};
				}
				for(var item, i = 0, l = items.data.length; i < l; i++) {
					item = items.data[i];
					if( !self.queryLogic.isMember(set, item) ) {
						var msg = [
							"One or more items were retrieved which do not match the 'Set' parameters used to load them. ",
							"Read the docs for more information: https://canjs.com/doc/can-query-logic.html#TestingyourQueryLogic",
							"\n\nBelow are the 'query' parameters:",
							"\n" + canDev.stringify(set),
							"\n\nAnd below is an item which does not match those parameters:",
							"\n" + canDev.stringify(item)
						].join("");
						canDev.warn(msg);
						break;
					}
				}
			}

			return Promise.resolve(items);
		};
	}
	//!steal-remove-end

	return behavior;
});

var create = function(props){
	var self = this;
	// go through each list
	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.


		var index = indexByIdentity(list, props, self.queryLogic.schema);

		if(self.queryLogic.isMember(set, props)) {
			var newIndex = self.queryLogic.index(set, list, props);

			updateListWithItem(list, props, index, newIndex, self, set);
		}

	});
};

// ## update
// Goes through each list and sees if the list should be updated
// with the new.
var update = function(props) {
	var self = this;

	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.


		var currentIndex = indexByIdentity(list, props, self.queryLogic.schema);

		if(self.queryLogic.isMember( set, props )) {

			var newIndex = self.queryLogic.index(set, list, props);

			updateListWithItem(list, props, currentIndex, newIndex, self, set);

		}  else if(currentIndex !== -1){ // its still in the list
			// otherwise remove it
			updateListWithItem(list, props, currentIndex, -1, self, set);
		}

	});
};

var destroy = function(props) {
	var self = this;
	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.

		var currentIndex = indexByIdentity(list, props, self.queryLogic.schema);

		if(currentIndex !== -1){
			// otherwise remove it
			updateListWithItem(list, props, currentIndex, -1, self, set);
		}

	});
};


/***/ }),

/***/ "./node_modules/can-construct-super/can-construct-super.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-construct-super/can-construct-super.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global require, module */
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var hasOwnProperty = Object.prototype.hasOwnProperty;
// tests if we can get super in .toString()
var isFunction = function(val) {
	return typeof val === 'function';
},
	fnTest = /xyz/.test(function () {
		return this.xyz;
	}) ? /\b_super\b/ : /.*/,
	getset = ['get', 'set'],
	getSuper = function (base, name, fn) {
		return function () {
			var hasExistingValue = false;
			var existingValue;
			var prototype = getPrototypeOf(this);
			var existingPrototypeValue = prototype._super;

			/* We must delete the instance's _super so the lookup
					will reach the prototype. */
			if (hasOwnProperty.call(this, '_super')) {
				hasExistingValue = true;
				existingValue = this._super;
				/* NOTE: if the object is sealed this will not work.
						The '_super' key cannot be used on the instance
						in that rare case. */
				delete this._super;
			}

			/* Add a new ._super() method that is the same method
					but on the super-class. It must be set on the prototype
					because the instance may be sealed. */
			prototype._super = base[name];

			// The method only need to be bound temporarily, so we
			// remove it when we're done executing
			var ret = fn.apply(this, arguments);
			prototype._super = existingPrototypeValue;
			if (hasExistingValue) {
				this._super = existingValue;
			}
			return ret;
		};
	};

Construct._defineProperty = function(addTo, base, name, descriptor) {
	var _super = Object.getOwnPropertyDescriptor(base, name);
	if(_super) {
		canReflect.each(getset, function (method) {
			if(isFunction(_super[method]) && isFunction(descriptor[method])) {
				descriptor[method] = getSuper(_super, method, descriptor[method]);
			} else if(!isFunction(descriptor[method])) {
				descriptor[method] = _super[method];
			}
		});
	}

	Object.defineProperty(addTo, name, descriptor);
};

var getPrototypeOf = Object.getPrototypeOf || function(obj){
	return obj.__proto__; // jshint ignore:line
};

var getPropertyDescriptor = Object.getPropertyDescriptor || function(subject, name) {
	if(name in subject) {
		var pd = Object.getOwnPropertyDescriptor(subject, name);
		var proto = getPrototypeOf(subject);
		while (pd === undefined && proto !== null) {
			pd = Object.getOwnPropertyDescriptor(proto, name);
			proto = getPrototypeOf(proto);
		}
		return pd;
	}
};

// overwrites a single property so it can still call super
Construct._overwrite = function (addTo, base, name, val) {
	// Check if we're overwriting an existing function
	var baseDescriptor = getPropertyDescriptor(base, name);
	var baseValue = baseDescriptor && baseDescriptor.value;

	Object.defineProperty(addTo, name, {
		value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ?
				getSuper(base, name, val) : val,
		configurable: true,
		enumerable: true,
		writable: true
	});
};

module.exports = Construct;


/***/ }),

/***/ "./node_modules/can-construct/can-construct.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-construct/can-construct.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var inSetupSymbol = canSymbol.for("can.initializing");

//!steal-remove-start
if(true) {
	var CanString = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
	var reservedWords = {
		"abstract": true,
		"boolean": true,
		"break": true,
		"byte": true,
		"case": true,
		"catch": true,
		"char": true,
		"class": true,
		"const": true,
		"continue": true,
		"debugger": true,
		"default": true,
		"delete": true,
		"do": true,
		"double": true,
		"else": true,
		"enum": true,
		"export": true,
		"extends": true,
		"false": true,
		"final": true,
		"finally": true,
		"float": true,
		"for": true,
		"function": true,
		"goto": true,
		"if": true,
		"implements": true,
		"import": true,
		"in": true,
		"instanceof": true,
		"int": true,
		"interface": true,
		"let": true,
		"long": true,
		"native": true,
		"new": true,
		"null": true,
		"package": true,
		"private": true,
		"protected": true,
		"public": true,
		"return": true,
		"short": true,
		"static": true,
		"super": true,
		"switch": true,
		"synchronized": true,
		"this": true,
		"throw": true,
		"throws": true,
		"transient": true,
		"true": true,
		"try": true,
		"typeof": true,
		"var": true,
		"void": true,
		"volatile": true,
		"while": true,
		"with": true
	};
	var constructorNameRegex = /[^A-Z0-9_]/gi;
}
//!steal-remove-end

// ## construct.js
// `Construct`
// _This is a modified version of
// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).
// It provides class level inheritance and callbacks._
// A private flag used to initialize a new class instance without
// initializing it's bindings.
var initializing = 0;

//!steal-remove-start
if(true) {
	var namedCtor = (function(cache){
		return function(name, fn) {
			return ((name in cache) ? cache[name] : cache[name] = new Function(
				"__", "function "+name+"(){return __.apply(this,arguments)};return "+name
			))( fn );
		};
	}({}));
}
//!steal-remove-end

/**
 * @add can-construct
 */
var Construct = function () {
	if (arguments.length) {
		return Construct.extend.apply(Construct, arguments);
	}
};

var canGetDescriptor;
try {
	Object.getOwnPropertyDescriptor({});
	canGetDescriptor = true;
} catch(e) {
	canGetDescriptor = false;
}

var getDescriptor = function(newProps, name) {
		var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
		if(descriptor && (descriptor.get || descriptor.set)) {
			return descriptor;
		}
		return null;
	},
	inheritGetterSetter = function(newProps, oldProps, addTo) {
		addTo = addTo || newProps;
		var descriptor;

		for (var name in newProps) {
			if( (descriptor = getDescriptor(newProps, name)) ) {
				this._defineProperty(addTo, oldProps, name, descriptor);
			} else {
				Construct._overwrite(addTo, oldProps, name, newProps[name]);
			}
		}
	},
	simpleInherit = function (newProps, oldProps, addTo) {
		addTo = addTo || newProps;

		for (var name in newProps) {
			Construct._overwrite(addTo, oldProps, name, newProps[name]);
		}
	},
	defineNonEnumerable = function(obj, prop, value) {
		Object.defineProperty(obj, prop, {
			configurable: true,
			writable: true,
			enumerable: false,
			value: value
		});
	};
/**
 * @static
 */
canReflect.assignMap(Construct, {
	/**
	 * @property {Boolean} can-construct.constructorExtends constructorExtends
	 * @parent can-construct.static
	 *
	 * @description
	 * Toggles the behavior of a constructor function called
	 * without the `new` keyword to extend the constructor function or
	 * create a new instance.
	 *
	 * ```js
	 * var animal = Animal();
	 * // vs
	 * var animal = new Animal();
	 * ```
	 *
	 * @body
	 *
	 * If `constructorExtends` is:
	 *
	 *  - `true` - the constructor extends
	 *  - `false` - a new instance of the constructor is created
	 *
	 * This property defaults to false.
	 *
	 * Example of constructExtends as `true`:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   constructorExtends: true // the constructor extends
	 * },{
	 *   sayHi: function() {
	 *     console.log("hai!");
	 *   }
	 * });
	 *
	 * var Pony = Animal({
	 *   gallop: function () {
	 *      console.log("Galloping!!");
	 *   }
	 * }); // Pony is now a constructor function extended from Animal
	 *
	 * var frank = new Animal(); // frank is a new instance of Animal
	 *
	 * var gertrude = new Pony(); // gertrude is a new instance of Pony
	 * gertrude.sayHi(); // "hai!" - sayHi is "inherited" from Animal
	 * gertrude.gallop(); // "Galloping!!" - gallop is unique to instances of Pony
	 *```
	 *
	 * The default behavior is shown in the example below:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   constructorExtends: false // the constructor does NOT extend
	 * },{
	 *   sayHi: function() {
	 *     console.log("hai!");
	 *   }
	 * });
	 *
	 * var pony = Animal(); // pony is a new instance of Animal
	 * var frank = new Animal(); // frank is a new instance of Animal
	 *
	 * pony.sayHi() // "hai!"
	 * frank.sayHi() // "hai!"
	 *```
	 * By default to extend a constructor, you must use [can-construct.extend extend].
	 */
	constructorExtends: true,
	/**
	 * @function can-construct.newInstance newInstance
	 * @parent can-construct.static
	 *
	 * @description Returns an instance of `Construct`. This method
	 * can be overridden to return a cached instance.
	 *
	 * @signature `Construct.newInstance([...args])`
	 *
	 * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note
	 * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]
	 * instead.
	 * @return {class} instance of the class
	 *
	 * @body
	 * Creates a new instance of the constructor function. This method is useful for creating new instances
	 * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the
	 * __new__ operator.
	 *
	 * ## Example
	 *
	 * The following creates a `Person` Construct and overrides `newInstance` to cache all
	 * instances of Person to prevent duplication. If the properties of a new Person match an existing one it
	 * will return a reference to the previously created object, otherwise it returns a new object entirely.
	 *
	 * ```js
	 * // define and create the Person constructor
	 * var Person = Construct.extend({
	 *   init : function(first, middle, last) {
	 *     this.first = first;
	 *     this.middle = middle;
	 *     this.last = last;
	 *   }
	 * });
	 *
	 * // store a reference to the original newInstance function
	 * var _newInstance = Person.newInstance;
	 *
	 * // override Person's newInstance function
	 * Person.newInstance = function() {
	 *   // if cache does not exist make it an new object
	 *   this.__cache = this.__cache || {};
	 *   // id is a stingified version of the passed arguments
	 *   var id = JSON.stringify(arguments);
	 *
	 *   // look in the cache to see if the object already exists
	 *   var cachedInst = this.__cache[id];
	 *   if(cachedInst) {
	 *     return cachedInst;
	 *   }
	 *
	 *   //otherwise call the original newInstance function and return a new instance of Person.
	 *   var newInst = _newInstance.apply(this, arguments);
	 *   this.__cache[id] = newInst;
	 *   return newInst;
	 * };
	 *
	 * // create two instances with the same arguments
	 * var justin = new Person('Justin', 'Barry', 'Meyer'),
	 *		brian = new Person('Justin', 'Barry', 'Meyer');
	 *
	 * console.log(justin === brian); // true - both are references to the same instance
	 * ```
	 *
	 */
	newInstance: function () {
		// Get a raw instance object (`init` is not called).
		var inst = this.instance(),
			args;
		// Call `setup` if there is a `setup`
		if (inst.setup) {
			Object.defineProperty(inst,"__inSetup",{
				configurable: true,
				enumerable: false,
				value: true,
				writable: true
			});
			Object.defineProperty(inst, inSetupSymbol, {
				configurable: true,
				enumerable: false,
				value: true,
				writable: true
			});
			args = inst.setup.apply(inst, arguments);
			if (args instanceof Construct.ReturnValue){
				return args.value;
			}
			inst.__inSetup = false;
			inst[inSetupSymbol] = false;
		}
		// Call `init` if there is an `init`
		// If `setup` returned `args`, use those as the arguments
		if (inst.init) {
			inst.init.apply(inst, args || arguments);
		}
		return inst;
	},
	// Overwrites an object with methods. Used in the `super` plugin.
	// `newProps` - New properties to add.
	// `oldProps` - Where the old properties might be (used with `super`).
	// `addTo` - What we are adding to.
	_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,

	// Adds a `defineProperty` with the given name and descriptor
	// Will only ever be called if ES5 is supported
	_defineProperty: function(what, oldProps, propName, descriptor) {
		Object.defineProperty(what, propName, descriptor);
	},

	// used for overwriting a single property.
	// this should be used for patching other objects
	// the super plugin overwrites this
	_overwrite: function (what, oldProps, propName, val) {
		Object.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});
	},
	// Set `defaults` as the merger of the parent `defaults` and this
	// object's `defaults`. If you overwrite this method, make sure to
	// include option merging logic.
	/**
	 * @function can-construct.setup setup
	 * @parent can-construct.static
	 *
	 * @description Perform initialization logic for a constructor function.
	 *
	 * @signature `Construct.setup(base, fullName, staticProps, protoProps)`
	 *
	 * A static `setup` method provides inheritable setup functionality
	 * for a Constructor function. The following example
	 * creates a Group constructor function.  Any constructor
	 * functions that inherit from Group will be added to
	 * `Group.childGroups`.
	 *
	 * ```js
	 * Group = Construct.extend({
	 *   setup: function(Construct, fullName, staticProps, protoProps){
	 *     this.childGroups = [];
	 *     if(Construct !== Construct){
	 *       this.childGroups.push(Construct)
	 *     }
	 *     Construct.setup.apply(this, arguments)
	 *   }
	 * },{})
	 * var Flock = Group.extend(...)
	 * Group.childGroups[0] //-> Flock
	 * ```
	 * @param {constructor} base The base constructor that is being inherited from.
	 * @param {String} fullName The name of the new constructor.
	 * @param {Object} staticProps The static properties of the new constructor.
	 * @param {Object} protoProps The prototype properties of the new constructor.
	 *
	 * @body
	 * The static `setup` method is called immediately after a constructor
	 * function is created and
	 * set to inherit from its base constructor. It is useful for setting up
	 * additional inheritance work.
	 * Do not confuse this with the prototype `[can-construct::setup]` method.
	 *
	 * ## Example
	 *
	 * This `Parent` class adds a reference to its base class to itself, and
	 * so do all the classes that inherit from it.
	 *
	 * ```js
	 * Parent = Construct.extend({
	 *   setup : function(base, fullName, staticProps, protoProps){
	 *     this.base = base;
	 *
	 *     // call base functionality
	 *     Construct.setup.apply(this, arguments)
	 *   }
	 * },{});
	 *
	 * Parent.base; // Construct
	 *
	 * Child = Parent({});
	 *
	 * Child.base; // Parent
	 * ```
	 */
	setup: function (base) {
		var defaults = base.defaults ? canReflect.serialize(base.defaults) : {};
		this.defaults = canReflect.assignDeepMap(defaults,this.defaults);
	},
	// Create's a new `class` instance without initializing by setting the
	// `initializing` flag.
	instance: function () {
		// Prevents running `init`.
		initializing = 1;
		var inst = new this();
		// Allow running `init`.
		initializing = 0;
		return inst;
	},
	// Extends classes.
	/**
	 * @function can-construct.extend extend
	 * @parent can-construct.static
	 *
	 * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`
	 *
	 * Extends `Construct`, or constructor functions derived from `Construct`,
	 * to create a new constructor function. Example:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   sayHi: function(){
	 *     console.log("hi")
	 *   }
	 * });
	 *
	 * var animal = new Animal()
	 * animal.sayHi();
	 * ```
	 *
	 * @param {String} [name] Adds a name to the constructor function so
	 * it is nicely labeled in the developer tools. The following:
	 *
	 *     Construct.extend("ConstructorName",{})
	 *
	 * returns a constructur function that will show up as `ConstructorName`
	 * in the developer tools.
	 * It also sets "ConstructorName" as [can-construct.shortName shortName].
	 *
	 * @param {Object} [staticProperties] Properties that are added the constructor
	 * function directly. For example:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   findAll: function(){
	 *     return can.ajax({url: "/animals"})
	 *   }
	 * },{}); // need to pass an empty instanceProperties object
	 *
	 * Animal.findAll().then(function(json){ ... })
	 * ```
	 *
	 * The [can-construct.setup static setup] method can be used to
	 * specify inheritable behavior when a Constructor function is created.
	 *
	 * @param {Object} instanceProperties Properties that belong to
	 * instances made with the constructor. These properties are added to the
	 * constructor's `prototype` object. Example:
	 *
	 *     var Animal = Construct.extend({
	 *		  findAll: function() {
	 *			return can.ajax({url: "/animals"});
	 *		  }
	 *     },{
	 *       init: function(name) {
	 *         this.name = name;
	 *       },
	 *       sayHi: function() {
	 *         console.log(this.name," says hai!");
	 *       }
	 *     })
	 *     var pony = new Animal("Gertrude");
	 *     pony.sayHi(); // "Gertrude says hai!"
	 *
	 * The [can-construct::init init] and [can-construct::setup setup] properties
	 * are used for initialization.
	 *
	 * @return {function} The constructor function.
	 *
	 * ```js
	 *	var Animal = Construct.extend(...);
	 *	var pony = new Animal(); // Animal is a constructor function
	 * ```
	 * @body
	 * ## Inheritance
	 * Creating "subclasses" with `Construct` is simple. All you need to do is call the base constructor
	 * with the new function's static and instance properties. For example, we want our `Snake` to
	 * be an `Animal`, but there are some differences:
	 *
	 *
	 *     var Snake = Animal.extend({
	 *         legs: 0
	 *     }, {
	 *         init: function() {
	 *             Animal.prototype.init.call(this, 'ssssss');
	 *         },
	 *         slither: function() {
	 *             console.log('slithering...');
	 *         }
	 *     });
	 *
	 *     var baslisk = new Snake();
	 *     baslisk.speak();   // "ssssss"
	 *     baslisk.slither(); // "slithering..."
	 *     baslisk instanceof Snake;  // true
	 *     baslisk instanceof Animal; // true
	 *
	 *
	 * ## Static properties and inheritance
	 *
	 * If you pass all three arguments to Construct, the second one will be attached directy to the
	 * constructor, allowing you to imitate static properties and functions. You can access these
	 * properties through the `[can-construct::constructor this.constructor]` property.
	 *
	 * Static properties can get overridden through inheritance just like instance properties. In the example below,
	 * we override both the legs static property as well as the the init function for each instance:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *     legs: 4
	 * }, {
	 *     init: function(sound) {
	 *         this.sound = sound;
	 *     },
	 *     speak: function() {
	 *         console.log(this.sound);
	 *     }
	 * });
	 *
	 * var Snake = Animal.extend({
	 *     legs: 0
	 * }, {
	 *     init: function() {
	 *         this.sound = 'ssssss';
	 *     },
	 *     slither: function() {
	 *         console.log('slithering...');
	 *     }
	 * });
	 *
	 * Animal.legs; // 4
	 * Snake.legs; // 0
	 * var dog = new Animal('woof');
	 * var blackMamba = new Snake();
	 * dog.speak(); // 'woof'
	 * blackMamba.speak(); // 'ssssss'
	 * ```
	 *
	 * ## Alternative value for a new instance
	 *
	 * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.
	 * For example, you want your class to act as a singleton, or check whether an item with the given id was already
	 * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).
	 *
	 * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.
	 *
	 * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge
	 * the new data into the existing instance and return the updated instance.
	 *
	 * ```
	 * var myStore = {};
	 *
	 * var Item = Construct.extend({
	 *     setup: function(params){
	 *         if (myStore[params.id]){
	 *             var item = myStore[params.id];
	 *
	 *             // Merge new data to the existing instance:
	 *             Object.assign(item, params);
	 *
	 *             // Return the updated item:
	 *             return new Construct.ReturnValue( item );
	 *         } else {
	 *             // Save to cache store:
	 *             myStore[this.id] = this;
	 *
	 *             return [params];
	 *         }
	 *     },
	 *     init: function(params){
	 *         Object.assign(this, params);
	 *     }
	 * });
	 *
	 * var item_1  = new Item( {id: 1, name: "One"} );
	 * var item_1a = new Item( {id: 1, name: "OnePlus"} )
	 * ```
	 */
	extend: function (name, staticProperties, instanceProperties) {
		var shortName = name,
			klass = staticProperties,
			proto = instanceProperties;

		// Figure out what was passed and normalize it.
		if (typeof shortName !== 'string') {
			proto = klass;
			klass = shortName;
			shortName = null;
		}
		if (!proto) {
			proto = klass;
			klass = null;
		}
		proto = proto || {};
		var _super_class = this,
			_super = this.prototype,
			Constructor, prototype;
		// Instantiate a base class (but only create the instance,
		// don't run the init constructor).
		prototype = this.instance();
		// Copy the properties over onto the new prototype.
		Construct._inherit(proto, _super, prototype);

		if(shortName) {

		} else if(klass && klass.shortName) {
			shortName = klass.shortName;
		} else if(this.shortName) {
			shortName = this.shortName;
		}
		// We want constructor.name to be the same as shortName, within
		// the bounds of what the JS VM will allow (meaning no non-word characters).
		// new Function() is significantly faster than eval() here.

		// Strip semicolons
		//!steal-remove-start
		// wrapping this var will cause "used out of scope." when linting
		var constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';
		if(true) {
			if(reservedWords[constructorName]) {
				constructorName = CanString.capitalize(constructorName);
			}
		}
		//!steal-remove-end

		// The dummy class constructor.
		function init() {
			/* jshint validthis: true */
			// All construction is actually done in the init method.
			if (!initializing) {
				//!steal-remove-start
				if(true) {
					if(!this || (this.constructor !== Constructor) &&
					// We are being called without `new` or we are extending.
					arguments.length && Constructor.constructorExtends) {
						dev.warn('can/construct/construct.js: extending a Construct without calling extend');
					}
				}
				//!steal-remove-end

				return (!this || this.constructor !== Constructor) &&
				// We are being called without `new` or we are extending.
				arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :
				// We are being called with `new`.
				Constructor.newInstance.apply(Constructor, arguments);
			}
		}
		Constructor = typeof namedCtor === "function" ?
			namedCtor( constructorName, init ) :
			function() { return init.apply(this, arguments); };

		// Copy old stuff onto class (can probably be merged w/ inherit)
		for (var propName in _super_class) {
			if (_super_class.hasOwnProperty(propName)) {
				Constructor[propName] = _super_class[propName];
			}
		}
		// Copy new static properties on class.
		Construct._inherit(klass, _super_class, Constructor);

		// Set things that shouldn't be overwritten.
		canReflect.assignMap(Constructor, {
			constructor: Constructor,
			prototype: prototype
			/**
			 * @property {String} can-construct.shortName shortName
			 * @parent can-construct.static
			 *
			 * If you pass a name when creating a Construct, the `shortName` property will be set to the
			 * name.
			 *
			 * ```js
			 * var MyConstructor = Construct.extend("MyConstructor",{},{});
			 * MyConstructor.shortName // "MyConstructor"
			 * ```
			 */
		});

		if (shortName !== undefined) {
			if (Object.getOwnPropertyDescriptor) {
				var desc = Object.getOwnPropertyDescriptor(Constructor, 'name');
				if (!desc || desc.configurable) {
					Object.defineProperty(
						Constructor,
						'name',
						{ writable: true, value: shortName, configurable: true }
					);
				}
			}
			Constructor.shortName = shortName;
		}
		// Make sure our prototype looks nice.
		defineNonEnumerable(Constructor.prototype, "constructor", Constructor);
		// Call the class `setup` and `init`
		var t = [_super_class].concat(Array.prototype.slice.call(arguments)),
			args = Constructor.setup.apply(Constructor, t);
		if (Constructor.init) {
			Constructor.init.apply(Constructor, args || t);
		}
		/**
		 * @prototype
		 */
		return Constructor; //
		/**
		 * @property {Object} can-construct.prototype.constructor constructor
		 * @parent can-construct.prototype
		 *
		 * A reference to the constructor function that created the instance. This allows you to access
		 * the constructor's static properties from an instance.
		 *
		 * @body
		 * ## Example
		 *
		 * This Construct has a static counter that counts how many instances have been created:
		 *
		 * ```js
		 * var Counter = Construct.extend({
		 *     count: 0
		 * }, {
		 *     init: function() {
		 *         this.constructor.count++;
		 *     }
		 * });
		 *
		 * var childCounter = new Counter();
		 * console.log(childCounter.constructor.count); // 1
		 * console.log(Counter.count); // 1
		 * ```
		 */
	},
	/**
	 * @function can-construct.ReturnValue ReturnValue
	 * @parent can-construct.static
	 *
	 * Use to overwrite the return value of new Construct(...).
	 *
	 * @signature `new Construct.ReturnValue( value )`
	 *
	 *   This constructor function can be used for creating a return value of the `setup` method.
	 *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.
	 *   If it is then its `value` will be used as the new instance.
	 *
	 *   @param {Object} value A value to be used for a new instance instead of a new object.
	 *
	 *   ```js
	 *   var Student = function( name, school ){
	 *       this.name = name;
	 *       this.school = school;
	 *   }
	 *
	 *   var Person = Construct.extend({
	 *       setup: function( options ){
	 *           if (options.school){
	 *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );
	 *           } else {
	 *               return [options];
	 *           }
	 *       }
	 *   });
	 *
	 *   var myPerson = new Person( {name: "Ilya", school: "PetrSU"} );
	 *
	 *   myPerson instanceof Student // => true
	 *   ```
   */
	ReturnValue: function(value){
		this.value = value;
	}
});
/**
 * @function can-construct.prototype.setup setup
 * @parent can-construct.prototype
 *
 * @signature `construct.setup(...args)`
 *
 * A setup function for the instantiation of a constructor function.
 *
 * @param {*} args The arguments passed to the constructor.
 *
 * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as
 * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue
 * instance's value will be returned as the result of calling new Construct(). The following example always makes
 * sure that init is called with a jQuery wrapped element:
 *
 * ```js
 * 	WidgetFactory = Construct.extend({
 * 			setup: function(element){
 * 					return [$(element)]
 * 			}
 * 	});
 *
 * 	MyWidget = WidgetFactory.extend({
 * 			init: function($el){
 * 					$el.html("My Widget!!")
 * 			}
 * 	});
 *  ```
 *
 * Otherwise, the arguments to the
 * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.
 *
 * @body
 *
 * ## Deciding between `setup` and `init`
 *
 *
 * Usually, you should use [can-construct::init init] to do your constructor function's initialization.
 * You should, instead, use `setup` when:
 *
 *   - there is initialization code that you want to run before the inheriting constructor's
 *     `init` method is called.
 *   - there is initialization code that should run whether or not inheriting constructors
 *     call their base's `init` methods.
 *   - you want to modify the arguments that will get passed to `init`.
 *
 */
defineNonEnumerable(Construct.prototype, "setup", function () {});
/**
 * @function can-construct.prototype.init init
 * @parent can-construct.prototype
 *
 * @description Called when a new instance of a Construct is created.
 *
 * @signature `construct.init(...args)`
 * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])
 *
 * @body
 * If a prototype `init` method is provided, `init` is called when a new Construct is created---
 * after [can-construct::setup]. The `init` method is where the bulk of your initialization code
 * should go. A common thing to do in `init` is save the arguments passed into the constructor.
 *
 * ## Examples
 *
 * First, we'll make a Person constructor that has a first and last name:
 *
 * ```js
 * var Person = Construct.extend({
 *     init: function(first, last) {
 *         this.first = first;
 *         this.last  = last;
 *     }
 * });
 *
 * var justin = new Person("Justin", "Meyer");
 * justin.first; // "Justin"
 * justin.last; // "Meyer"
 * ```
 *
 * Then, we'll extend Person into Programmer, and add a favorite language:
 *
 * ```js
 * var Programmer = Person.extend({
 *     init: function(first, last, language) {
 *         // call base's init
 *         Person.prototype.init.apply(this, arguments);
 *
 *         // other initialization code
 *         this.language = language;
 *     },
 *     bio: function() {
 *         return "Hi! I'm " + this.first + " " + this.last +
 *             " and I write " + this.language + ".";
 *     }
 * });
 *
 * var brian = new Programmer("Brian", "Moschel", 'ECMAScript');
 * brian.bio(); // "Hi! I'm Brian Moschel and I write ECMAScript.";
 * ```
 *
 * ## Modified Arguments
 *
 * [can-construct::setup] is able to modify the arguments passed to `init`.
 * If you aren't receiving the arguments you passed to `new Construct(args)`,
 * check that they aren't being changed by `setup` along
 * the inheritance chain.
 */
defineNonEnumerable(Construct.prototype, "init", function () {});

module.exports = namespace.Construct = Construct;


/***/ }),

/***/ "./node_modules/can-control/can-control.js":
/*!*************************************************!*\
  !*** ./node_modules/can-control/can-control.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # can/control/control.js
//
// Create organized, memory-leak free, rapidly performing, stateful
// controls with declarative eventing binding. Used when creating UI
// controls with behaviors, bound to elements on the page.
// ## helpers

var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var observeReader = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var canEvent = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var string = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
var get = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var controlsSymbol = canSymbol.for("can.controls");


var processors;


// ### bind
// this helper binds to one element and returns a function that unbinds from that element.
var bind = function (el, ev, callback, queue) {

    canEvent.on.call(el, ev, callback, queue);

	return function () {
        canEvent.off.call(el, ev, callback, queue);
	};
},
	slice = [].slice,
	paramReplacer = /\{([^\}]+)\}/g,

	// ### delegate
	//
	// this helper binds to elements based on a selector and returns a
	// function that unbinds.
	delegate = function (el, selector, ev, callback) {
        canEvent.on.call(el, ev, selector, callback);

		return function () {
            canEvent.off.call(el, ev, selector, callback);
		};
	},

	// ### binder
	//
	// Calls bind or unbind depending if there is a selector.
	binder = function (el, ev, callback, selector) {
		return selector ?
			delegate(el, selector.trim(), ev, callback) :
			bind(el, ev, callback);
	},

	basicProcessor;

var Control = Construct.extend("Control",
	// ## *static functions*
	/**
	 * @static
	 */
	{
		// ## can.Control.setup
		//
		// This function pre-processes which methods are event listeners and which are methods of
		// the control. It has a mechanism to allow controllers to inherit default values from super
		// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)
		// or functions with an underscored name.
		setup: function () {
			Construct.setup.apply(this, arguments);

			if (Control) {
				var control = this,
					funcName;

				control.actions = {};
				for (funcName in control.prototype) {
					if (control._isAction(funcName)) {
						control.actions[funcName] = control._action(funcName);
					}
				}
			}
		},
		// ## can.Control._shifter
		//
		// Moves `this` to the first argument, wraps it with `jQuery` if it's
		// an element.
		_shifter: function (context, name) {
			var method = typeof name === "string" ? context[name] : name;

			if (typeof method !== "function") {
				method = context[method];
			}
            var Control = this;
			function controlMethod() {
				var wrapped = Control.wrapElement(this);
				context.called = name;
				return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
			}
      //!steal-remove-start
      if(true) {
	      Object.defineProperty(controlMethod, "name", {
	      	value: canReflect.getName(this) + "["+name+"]",
	      });
	     }
      //!steal-remove-end
      return controlMethod;
		},

		// ## can.Control._isAction
		//
		// Return `true` if `methodName` refers to an action. An action is a `methodName` value that
		// is not the constructor, and is either a function or string that refers to a function, or is
		// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.
		_isAction: function (methodName) {
			var val = this.prototype[methodName],
				type = typeof val;

			return (methodName !== 'constructor') &&
			(type === "function" || (type === "string" && (typeof this.prototype[val] === "function") )) &&
			!! (Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
		},
		// ## can.Control._action
		//
		// Takes a method name and the options passed to a control and tries to return the data
		// necessary to pass to a processor (something that binds things).
		//
		// For performance reasons, `_action` is called twice:
		// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.
		// * It is called wehn a control instance is created, but only for templated actions.
		_action: function(methodName, options, controlInstance) {
			var readyCompute,
                unableToBind;

			// If we don't have options (a `control` instance), we'll run this later. If we have
			// options, run `can.sub` to replace the action template `{}` with values from the `options`
			// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.
			// In that case, the event name we want will be the last item in that array.
			paramReplacer.lastIndex = 0;
			if (options || !paramReplacer.test(methodName)) {
                var controlActionData = function() {
					var delegate;

					// Set the delegate target and get the name of the event we're listening to.
					var name = methodName.replace(paramReplacer, function(matched, key) {
						var value, parent;

						// If listening directly to a delegate target, set it
						if (this._isDelegate(options, key)) {
							delegate = this._getDelegate(options, key);
							return "";
						}

						// If key contains part of the lookup path, remove it.
						// This is needed for bindings like {viewModel.foo} in can-component's Control.
						key = this._removeDelegateFromKey(key);

						// set the parent (where the key will be read from)
						parent = this._lookup(options)[0];

						value = observeReader.read(parent, observeReader.reads(key), {
							// if we find a compute, we should bind on that and not read it
							readCompute: false
						}).value;

						// If `value` is undefined try to get the value from the window.
						if (value === undefined && typeof window !== 'undefined') {
							value = get(window, key);
						}

						// if the parent is not an observable and we don't have a value, show a warning
						// in this situation, it is not possible for the event handler to be triggered
						if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            unableToBind = true;
							return null;
						}

						// If `value` is a string we just return it, otherwise we set it as a delegate target.
						if (typeof value === "string") {
							return value;
						} else {
							delegate = value;
							return "";
						}
					}.bind(this));

					// removing spaces that get added when converting
					// `{element} click` -> ` click`
					name = name.trim();

					// Get the name of the `event` we're listening to.
					var parts = name.split(/\s+/g),
						event = parts.pop();

					// Return everything needed to handle the event we're listening to.
					return {
						processor: this.processors[event] || basicProcessor,
						parts: [name, parts.join(" "), event],
						delegate: delegate || undefined
					};
				};

        //!steal-remove-start
        if(true) {
		    	Object.defineProperty(controlActionData, "name", {
		      	value: canReflect.getName(controlInstance || this.prototype) + "["+methodName+"].actionData",
		      });
	      }
        //!steal-remove-end

				readyCompute = new Observation(controlActionData, this);


				if (controlInstance) {
					// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.
					var handler = function(actionData) {
						// unbinds the old binding
						if(controlInstance._bindings.control[methodName]) {
							controlInstance._bindings.control[methodName](controlInstance.element);
						}
						// binds the new
						controlInstance._bindings.control[methodName] = actionData.processor(
							actionData.delegate || controlInstance.element,
							actionData.parts[2], actionData.parts[1], methodName, controlInstance);
					};

          //!steal-remove-start
          if(true) {
          	Object.defineProperty(handler, "name", {
            	value: canReflect.getName(controlInstance) + "["+methodName+"].handler",
            });
          }
					//!steal-remove-end


					canReflect.onValue(readyCompute, handler, "mutate");
          //!steal-remove-start
          if(true) {
	          if(unableToBind) {
	          	dev.log('can-control: No property found for handling ' + methodName);
						}
					}
					//!steal-remove-end

					controlInstance._bindings.readyComputes[methodName] = {
						compute: readyCompute,
						handler: handler
					};
				}

				return readyCompute.get();
			}
		},
		// the lookup path - where templated keys will be looked up
		_lookup: function (options) {
			return [options, window];
		},
		// strip strings that represent delegates from the key
		_removeDelegateFromKey: function (key) {
			return key;
		},
		// return whether the key is a delegate
		_isDelegate: function(options, key) {
			return key === 'element';
		},
		// return the delegate object for a given key
		_getDelegate: function(options, key) {
			return undefined;
		},
		// ## can.Control.processors
		//
		// An object of `{eventName : function}` pairs that Control uses to
		// hook up events automatically.
		processors: {},
		// ## can.Control.defaults
		// A object of name-value pairs that act as default values for a control instance
		defaults: {},
        // should be used to overwrite to make nodeLists on this
        convertElement: function(element) {
            element = typeof element === "string" ?
							document.querySelector(element) : element;

						return this.wrapElement(element);
        },
        wrapElement: function(el){
            return el;
        },
        unwrapElement: function(el){
            return el;
        },
        // should be overwritten to look in jquery special events
        isSpecial: function(eventName){
            return eventName === "inserted" || eventName === "removed";
        }
	}, {
		// ## *prototype functions*
		/**
		 * @prototype
		 */
		// ## setup
		//
		// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:
		// - Sets `this.element`
		// - Adds the Control's name to the element's className
		// - Saves the Control in `$.data`
		// - Merges Options
		// - Binds event handlers using `delegate`
		// The final step is to return pass the element and prepareed options, to be used in `init`.
		setup: function (element, options) {

			var cls = this.constructor,
				pluginname = cls.pluginName || cls.shortName,
				arr;

			if (!element) {
				throw new Error('Creating an instance of a named control without passing an element');
			}
			// Retrieve the raw element, then set the plugin name as a class there.
            this.element = cls.convertElement(element);

			if (pluginname && pluginname !== 'Control' && this.element.classList) {
                this.element.classList.add(pluginname);
			}

			// Set up the 'controls' data on the element. If it does not exist, initialize
			// it to an empty array.
			arr = this.element[controlsSymbol];
			if (!arr) {
				arr = [];
				this.element[controlsSymbol] = arr;
			}
			arr.push(this);

			// The `this.options` property is an Object that contains configuration data
			// passed to a control when it is created (`new can.Control(element, options)`)
			//
			// The `options` argument passed when creating the control is merged with `can.Control.defaults`
			// in [can.Control.prototype.setup setup].
			//
			// If no `options` value is used during creation, the value in `defaults` is used instead
			if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
				for (var prop in cls.defaults) {
					if (!options.hasOwnProperty(prop)) {
						observeReader.set(options, prop, cls.defaults[prop]);
					}
				}
				this.options = options;
			} else {
				this.options = assign( assign({}, cls.defaults), options);
			}

			this.on();

			return [this.element, this.options];
		},
		// ## on
		//
		// This binds an event handler for an event to a selector under the scope of `this.element`
		// If no options are specified, all events are rebound to their respective elements. The actions,
		// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.
		on: function (el, selector, eventName, func) {
			if (!el) {
				this.off();

				var cls = this.constructor,
					bindings = this._bindings,
					actions = cls.actions,
					element = this.constructor.unwrapElement(this.element),
					destroyCB = Control._shifter(this, "destroy"),
					funcName, ready;

				for (funcName in actions) {
					// Only push if we have the action and no option is `undefined`
					if ( actions.hasOwnProperty(funcName) ) {
						ready = actions[funcName] || cls._action(funcName, this.options, this);
						if( ready ) {
							bindings.control[funcName]  = ready.processor(ready.delegate || element,
								ready.parts[2], ready.parts[1], funcName, this);
						}
					}
				}

				// Set up the ability to `destroy` the control later.
				var removalDisposal = domMutate.onNodeDisconnected(element, function () {
					var doc = element.ownerDocument;
					var ownerNode = doc.contains ? doc : doc.documentElement;
					if (!ownerNode || ownerNode.contains(element) === false) {
						// if the teardown is happening while the dom queue is flushing,
						// there may have been a rebinding of _action handlers queued
						// in the mutate queue already, so do the teardown later.
						if(queues.domQueue.isFlushing) {
							queues.mutateQueue.enqueue(destroyCB);
						} else {
							destroyCB();
						}
					}
				});
				bindings.user.push(function () {
					if (removalDisposal) {
						removalDisposal();
						removalDisposal = undefined;
					}
				});
				return bindings.user.length;
			}

			// if `el` is a string, use that as `selector` and re-set it to this control's element...
			if (typeof el === 'string') {
				func = eventName;
				eventName = selector;
				selector = el;
				el = this.element;
			}

			// ...otherwise, set `selector` to null
			if (func === undefined) {
				func = eventName;
				eventName = selector;
				selector = null;
			}

			if (typeof func === 'string') {
				func = Control._shifter(this, func);
			}

			this._bindings.user.push(binder(el, eventName, func, selector));

			return this._bindings.user.length;
		},
		// ## off
		//
		// Unbinds all event handlers on the controller.
		// This should _only_ be called in combination with .on()
		off: function () {
			var el = this.constructor.unwrapElement(this.element),
				bindings = this._bindings;
			if( bindings ) {
				(bindings.user || []).forEach(function (value) {
					value(el);
				});
				canReflect.eachKey(bindings.control || {}, function (value) {
					value(el);
				});
				canReflect.eachKey(bindings.readyComputes || {}, function(value) {
					canReflect.offValue(value.compute, value.handler, "mutate");
				});
			}
			// Adds bindings.
			this._bindings = {user: [], control: {}, readyComputes: {}};
		},
		// ## destroy
		//
		// Prepares a `control` for garbage collection.
		// First checks if it has already been removed. Then, removes all the bindings, data, and
		// the element from the Control instance.
		destroy: function () {
			if (this.element === null) {
				//!steal-remove-start
				if(true) {
					dev.warn("can-control: Control already destroyed");
				}
				//!steal-remove-end
				return;
			}
			var Class = this.constructor,
				pluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),
				controls;

			this.off();

			if (pluginName && pluginName !== 'can_control' && this.element.classList) {
                this.element.classList.remove(pluginName);
			}

			controls = this.element[controlsSymbol];
			if (controls) {
				controls.splice(controls.indexOf(this), 1);
			}

			//canEvent.dispatch.call(this, "destroyed");

			this.element = null;
		}
	});

// ## Processors
//
// Processors do the binding. This basic processor binds events. Each returns a function that unbinds
// when called.
processors = Control.processors;
basicProcessor = function (el, event, selector, methodName, control) {
	return binder(el, event, Control._shifter(control, methodName), selector);
};

// Set common events to be processed as a `basicProcessor`
["beforeremove", "change", "click", "contextmenu", "dblclick", "keydown", "keyup",
	"keypress", "mousedown", "mousemove", "mouseout", "mouseover",
	"mouseup", "reset", "resize", "scroll", "select", "submit", "focusin",
	"focusout", "mouseenter", "mouseleave",
	"touchstart", "touchmove", "touchcancel", "touchend", "touchleave",
	"inserted","removed",
	"dragstart", "dragenter", "dragover", "dragleave", "drag", "drop", "dragend"
].forEach(function (v) {
	processors[v] = basicProcessor;
});

module.exports = namespace.Control = Control;


/***/ }),

/***/ "./node_modules/can-data-types/maybe-boolean/maybe-boolean.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-boolean/maybe-boolean.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function toBoolean(val) {
	if(val == null) {
		return val;
	}
	if (val === 'false' || val === '0' || !val) {
		return false;
	}
	return true;
}

module.exports = canReflect.assignSymbols(toBoolean,{
	"can.new": toBoolean,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [true, false, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeBoolean";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "boolean";
	}
});


/***/ }),

/***/ "./node_modules/can-data-types/maybe-date/maybe-date.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-date/maybe-date.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function toDate(str) {
	var type = typeof str;
	if (type === 'string') {
		str = Date.parse(str);
		return isNaN(str) ? null : new Date(str);
	} else if (type === 'number') {
		return new Date(str);
	} else {
		return str;
	}
}

function DateStringSet(dateStr){
	this.setValue = dateStr;
	var date = toDate(dateStr);
	this.value = date == null ? date : date.getTime();
}
DateStringSet.prototype.valueOf = function(){
	return this.value;
};
canReflect.assignSymbols(DateStringSet.prototype,{
	"can.serialize": function(){
		return this.setValue;
	}
});

module.exports = canReflect.assignSymbols(toDate,{
	"can.new": toDate,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [Date, undefined, null]
		};
	},
	"can.ComparisonSetType": DateStringSet,
    "can.getName": function(){
        return "MaybeDate";
    },
	"can.isMember": function(value) {
		return value == null || (value instanceof Date);
	}
});


/***/ }),

/***/ "./node_modules/can-data-types/maybe-number/maybe-number.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-number/maybe-number.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function toNumber(val) {
	if (val == null) {
		return val;
	}
	return +(val);
}

module.exports = canReflect.assignSymbols(toNumber,{
	"can.new": toNumber,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [Number, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeNumber";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "number";
	}
});


/***/ }),

/***/ "./node_modules/can-data-types/maybe-string/maybe-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-string/maybe-string.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function toString(val) {
	if (val == null) {
		return val;
	}
	return '' + val;
}

module.exports = canReflect.assignSymbols(toString,{
	"can.new": toString,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [String, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeString";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "string";
	}
});


/***/ }),

/***/ "./node_modules/can-debug/can-debug.js":
/*!*********************************************!*\
  !*** ./node_modules/can-debug/can-debug.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var globals = __webpack_require__(/*! can-globals */ "./node_modules/can-globals/can-globals.js");
var proxyNamespace = __webpack_require__(/*! ./src/proxy-namespace */ "./node_modules/can-debug/src/proxy-namespace.js");
var temporarilyBind = __webpack_require__(/*! ./src/temporarily-bind */ "./node_modules/can-debug/src/temporarily-bind.js");

var getGraph = __webpack_require__(/*! ./src/get-graph/get-graph */ "./node_modules/can-debug/src/get-graph/get-graph.js");
var formatGraph = __webpack_require__(/*! ./src/format-graph/format-graph */ "./node_modules/can-debug/src/format-graph/format-graph.js");
var logWhatIChange = __webpack_require__(/*! ./src/what-i-change/what-i-change */ "./node_modules/can-debug/src/what-i-change/what-i-change.js");
var logWhatChangesMe = __webpack_require__(/*! ./src/what-changes-me/what-changes-me */ "./node_modules/can-debug/src/what-changes-me/what-changes-me.js");
var getWhatIChange = __webpack_require__(/*! ./src/get-what-i-change/get-what-i-change */ "./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js");
var getWhatChangesMe = __webpack_require__(/*! ./src/get-what-changes-me/get-what-changes-me */ "./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js");

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canQueues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var mergeDeep = __webpack_require__(/*! can-diff/merge-deep/merge-deep */ "./node_modules/can-diff/merge-deep/merge-deep.js");

var global = globals.getKeyValue("global");

var devtoolsRegistrationComplete = false;
function registerWithDevtools() {
	if (devtoolsRegistrationComplete) {
		return;
	}

	var devtoolsGlobalName =  "__CANJS_DEVTOOLS__";
	var devtoolsCanModules = {
		Observation: Observation,
		Reflect: canReflect,
		Symbol: canSymbol,
		formatGraph: namespace.debug.formatGraph,
		getGraph: namespace.debug.getGraph,
		mergeDeep: mergeDeep,
		queues: canQueues
	};

	if (global[devtoolsGlobalName]) {
		global[devtoolsGlobalName].register(devtoolsCanModules);
	} else {
		Object.defineProperty(global, devtoolsGlobalName, {
			set: function(devtoolsGlobal) {
				Object.defineProperty(global, devtoolsGlobalName, {
					value: devtoolsGlobal
				});

				devtoolsGlobal.register(devtoolsCanModules);
			},
			configurable: true
		});
	}

	devtoolsRegistrationComplete = true;
}

module.exports = function() {
	namespace.debug = {
		formatGraph: temporarilyBind(formatGraph),
		getGraph: temporarilyBind(getGraph),
		getWhatIChange: temporarilyBind(getWhatIChange),
		getWhatChangesMe: temporarilyBind(getWhatChangesMe),
		logWhatIChange: temporarilyBind(logWhatIChange),
		logWhatChangesMe: temporarilyBind(logWhatChangesMe)
	};

	registerWithDevtools();

	global.can = typeof Proxy !== "undefined" ? proxyNamespace(namespace) : namespace;

	return namespace.debug;
};


/***/ }),

/***/ "./node_modules/can-debug/src/format-graph/format-graph.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-debug/src/format-graph/format-graph.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canAssign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

// Converts the graph into a data structure that vis.js requires to draw the graph
module.exports = function formatGraph(graph) {
	// { [node]: Number }
	var nodeIdMap = new Map();
	graph.nodes.forEach(function(node, index) {
		nodeIdMap.set(node, index + 1);
	});

	// collects nodes in the shape of { id: Number, label: String }
	var nodesDataSet = graph.nodes.map(function(node) {
		return {
			shape: "box",
			id: nodeIdMap.get(node),
			label:
				canReflect.getName(node.obj) +
				(node.key ? "." + node.key : "")
		};
	});

	var getArrowData = function getArrowData(meta) {
		var regular = { arrows: "to" };
		var withDashes = { arrows: "to", dashes: true };

		var map = {
			derive: regular,
			mutate: withDashes
		};

		return map[meta.kind];
	};

	// collect edges in the shape of { from: Id, to: Id }
	var visited = new Map();
	var arrowsDataSet = [];
	graph.nodes.forEach(function(node) {
		var visit = function(node) {
			if (!visited.has(node)) {
				visited.set(node, true);
				var arrows = graph.arrows.get(node);
				var headId = nodeIdMap.get(node);

				arrows.forEach(function(neighbor) {
					var tailId = nodeIdMap.get(neighbor);
					var meta = graph.arrowsMeta.get(node).get(neighbor);

					arrowsDataSet.push(
						canAssign(
							{ from: headId, to: tailId },
							getArrowData(meta)
						)
					);

					visit(neighbor);
				});
			}
		};

		visit(node);
	});
	
	return {
		nodes: nodesDataSet,
		edges: arrowsDataSet
	};
};


/***/ }),

/***/ "./node_modules/can-debug/src/get-data/get-data.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-debug/src/get-data/get-data.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var labelCycles = __webpack_require__(/*! ../label-cycles/label-cycles */ "./node_modules/can-debug/src/label-cycles/label-cycles.js");

var isDisconnected = function isDisconnected(data) {
	return (
		!data.derive.length &&
		!data.mutations.length &&
		!data.twoWay.length
	);
};

// Returns a deeply nested object from the graph
module.exports = function getDebugData(inputGraph, direction) {
	var visited = new Map();

	var graph = labelCycles(
		direction === "whatChangesMe" ? inputGraph.reverse() : inputGraph
	);

	var visit = function visit(node) {
		var data = { node: node, derive: [], mutations: [], twoWay: [] };

		visited.set(node, true);

		graph.getNeighbors(node).forEach(function(adj) {
			var meta = graph.getArrowMeta(node, adj);

			if (!visited.has(adj)) {
				switch (meta.kind) {
					case "twoWay":
						data.twoWay.push(visit(adj));
						break;

					case "derive":
						data.derive.push(visit(adj));
						break;

					case "mutate":
						data.mutations.push(visit(adj));
						break;

					default:
						throw new Error("Unknow meta.kind value: ", meta.kind);
				}
			}
		});

		return data;
	};

	// discard data if there are no arrows registered, this happens when
	// [direction] is passed in and no arrow metadada matches its value
	var result = visit(graph.nodes[0]);
	return isDisconnected(result) ? null : result;
};


/***/ }),

/***/ "./node_modules/can-debug/src/get-graph/get-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-debug/src/get-graph/get-graph.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Graph = __webpack_require__(/*! ../graph/graph */ "./node_modules/can-debug/src/graph/graph.js");
var makeNode = __webpack_require__(/*! ./make-node */ "./node_modules/can-debug/src/get-graph/make-node.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var mutateDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");

// Returns a directed graph of the dependencies of obj (key is optional)
//
// Signature:
//	getDirectedGraph(obj)
//	getDirectedGraph(obj, key)
module.exports = function getGraph(obj, key) {
	var order = 0;
	var graph = new Graph();
	var gotKey = arguments.length === 2;

	var addArrow = function addArrow(direction, parent, child, meta) {
		switch (direction) {
			case "whatIChange":
				graph.addArrow(parent, child, meta); break;
			case "whatChangesMe":
				graph.addArrow(child, parent, meta); break;
			default:
				throw new Error("Unknown direction value: ", meta.direction);
		}
	};

	// keyDependencies :: Map<obj, Set<key>>
	var visitKeyDependencies = function visitKeyDependencies(source, meta, cb) {
		canReflect.eachKey(source.keyDependencies || {}, function(keys, obj) {
			canReflect.each(keys, function(key) {
				cb(obj, meta, key);
			});
		});
	};

	// valueDependencies :: Set<obj>
	var visitValueDependencies = function visitValueDependencies(source, meta, cb) {
		canReflect.eachIndex(source.valueDependencies || [], function(obj) {
			cb(obj, meta);
		});
	};

	var visit = function visit(obj, meta, key) {
		var gotKey = arguments.length === 3;

		var node = graph.findNode(function(node) {
			return gotKey ?
				node.obj === obj && node.key === key :
				node.obj === obj;
		});

		// if there is a node already in the graph, add the arrow and prevent
		// infinite calls to `visit` by returning early
		if (node) {
			if (meta.parent) {
				addArrow(meta.direction, meta.parent, node, {
					kind: meta.kind,
					direction: meta.direction
				});
			}
			return graph;
		}

		// create and add a node to the graph
		order += 1;
		node = gotKey ? makeNode(obj, key) : makeNode(obj);
		node.order = order;
		graph.addNode(node);

		// if there is a known parent node, add the arrow in the given direction
		if (meta.parent) {
			addArrow(meta.direction, meta.parent, node, {
				kind: meta.kind,
				direction: meta.direction
			});
		}

		// get the dependencies of the new node and recursively visit those
		var nextMeta;
		var data = gotKey ?
			mutateDeps.getDependencyDataOf(obj, key) :
			mutateDeps.getDependencyDataOf(obj);

		if (data && data.whatIChange) {
			nextMeta = { direction: "whatIChange", parent: node };

			// kind :: derive | mutate
			canReflect.eachKey(data.whatIChange, function(dependencyRecord, kind) {
				nextMeta.kind = kind;
				visitKeyDependencies(dependencyRecord, nextMeta, visit);
				visitValueDependencies(dependencyRecord, nextMeta, visit);
			});
		}

		if (data && data.whatChangesMe) {
			nextMeta = { direction: "whatChangesMe", parent: node };

			// kind :: derive | mutate
			canReflect.eachKey(data.whatChangesMe, function(dependencyRecord, kind) {
				nextMeta.kind = kind;
				visitKeyDependencies(dependencyRecord, nextMeta, visit);
				visitValueDependencies(dependencyRecord, nextMeta, visit);
			});
		}

		return graph;
	};

	return gotKey ? visit(obj, {}, key) : visit(obj, {});
};


/***/ }),

/***/ "./node_modules/can-debug/src/get-graph/make-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-debug/src/get-graph/make-node.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function makeNode(obj, key) {
	var gotKey = arguments.length === 2;

	var node = {
		obj: obj,
		name: canReflect.getName(obj),
		value: gotKey ? canReflect.getKeyValue(obj, key) : canReflect.getValue(obj)
	};

	if (gotKey) {
		node.key = key;
	}

	return node;
};


/***/ }),

/***/ "./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getData = __webpack_require__(/*! ../get-data/get-data */ "./node_modules/can-debug/src/get-data/get-data.js");
var getGraph = __webpack_require__(/*! ../get-graph/get-graph */ "./node_modules/can-debug/src/get-graph/get-graph.js");

module.exports = function getWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	return getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatChangesMe"
	);
};


/***/ }),

/***/ "./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getData = __webpack_require__(/*! ../get-data/get-data */ "./node_modules/can-debug/src/get-data/get-data.js");
var getGraph = __webpack_require__(/*! ../get-graph/get-graph */ "./node_modules/can-debug/src/get-graph/get-graph.js");

module.exports = function getWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	return getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatIChange"
	);
};


/***/ }),

/***/ "./node_modules/can-debug/src/graph/graph.js":
/*!***************************************************!*\
  !*** ./node_modules/can-debug/src/graph/graph.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canAssign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

function Graph() {
	this.nodes = [];
	this.arrows = new Map();
	this.arrowsMeta = new Map();
}

// Adds the node, but it does not check if the node exists, callers will have
// to check that through [findNode]
Graph.prototype.addNode = function addNode(node) {
	this.nodes.push(node);
	this.arrows.set(node, new Set());
};

// Adds an arrow from head to tail with optional metadata
// The method does not check whether head and tail are already
// nodes in the graph, this should be done by the caller.
Graph.prototype.addArrow = function addArrow(head, tail, meta) {
	var graph = this;

	graph.arrows.get(head).add(tail);

	// optional
	if (meta) {
		addArrowMeta(graph, head, tail, meta);
	}
};

// Tests whether there is an arrow from head to tail
Graph.prototype.hasArrow = function hasArrow(head, tail) {
	return this.getNeighbors(head).has(tail);
};

// Returns the metadata associated to the head -> tail arrow
Graph.prototype.getArrowMeta = function getArrowMeta(head, tail) {
	return this.arrowsMeta.get(head) && this.arrowsMeta.get(head).get(tail);
};

// Sets metadata about the arrow from head to tail
// Merges the passed object into existing metadata
Graph.prototype.setArrowMeta = function setArrowMeta(head, tail, meta) {
	addArrowMeta(this, head, tail, meta);
};

// Returns a Set of all nodes 'y' such that there is an arrow
// from the node 'x' to the node 'y'.
Graph.prototype.getNeighbors = function getNeighbors(node) {
	return this.arrows.get(node);
};

// Returns the first node that satisfies the provided testing function.
// The Graph is traversed using depth first search
Graph.prototype.findNode = function findNode(cb) {
	var found = null;
	var graph = this;
	var i, node;

	for (i=0; i<graph.nodes.length; i++) {
		node = graph.nodes[i];
		if (cb(node)) {
			found = node;
			break;
		}
	}

	return found;
};

Graph.prototype.bfs = function bfs(visit) {
	var graph = this;

	var node = graph.nodes[0];
	var queue = [node];
	var visited = new Map();
	visited.set(node, true);

	while (queue.length) {
		node = queue.shift();

		visit(node);

		graph.arrows.get(node).forEach(function(adj) {
			if (!visited.has(adj)) {
				queue.push(adj);
				visited.set(adj, true);
			}
		});
	}
};

Graph.prototype.dfs = function dfs(visit) {
	var graph = this;

	var node = graph.nodes[0];
	var stack = [node];
	var visited = new Map();

	while (stack.length) {
		node = stack.pop();

		visit(node);

		if (!visited.has(node)) {
			visited.set(node, true);
			graph.arrows.get(node).forEach(function(adj) {
				stack.push(adj);
			});
		}
	}
};

// Returns a new graph where the arrows point to the opposite direction, that is:
// For each arrow (u, v) in [this], there will be a (v, u) in the returned graph
// This is also called Transpose or Converse a graph
Graph.prototype.reverse = function reverse() {
	var graph = this;
	var reversed = new Graph();

	// copy over the nodes
	graph.nodes.forEach(reversed.addNode.bind(reversed));

	graph.nodes.forEach(function(node) {
		graph.getNeighbors(node).forEach(function(adj) {
			// add the arrow in the opposite direction, copy over metadata
			var meta = graph.getArrowMeta(node, adj);
			reversed.addArrow(adj, node, meta);
		});
	});

	return reversed;
};

// Helpers
function addArrowMeta(graph, head, tail, meta) {
	var entry = graph.arrowsMeta.get(head);

	if (entry) {
		var arrowMeta = entry.get(tail);
		if (!arrowMeta) {
			arrowMeta = {};
		}
		entry.set(tail, canAssign(arrowMeta, meta));
	} else {
		entry = new Map();
		entry.set(tail, meta);
		graph.arrowsMeta.set(head, entry);
	}
}

module.exports = Graph;


/***/ }),

/***/ "./node_modules/can-debug/src/label-cycles/label-cycles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-debug/src/label-cycles/label-cycles.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Graph = __webpack_require__(/*! ../graph/graph */ "./node_modules/can-debug/src/graph/graph.js");

// Returns a new graph with all the arrows not involved in a circuit
module.exports = function labelCycles(graph) {
	var visited = new Map();
	var result = new Graph();

	// copy over all nodes
	graph.nodes.forEach(function(node) {
		result.addNode(node);
	});

	var visit = function visit(node) {
		visited.set(node, true);

		graph.getNeighbors(node).forEach(function(adj) {
			// back arrow found
			if (visited.has(adj)) {
				// if isTwoWay is false it means the cycle involves more than 2 nodes,
				// e.g: A -> B -> C -> A
				// what to do in these cases? (currently ignoring these)
				var isTwoWay = graph.hasArrow(node, adj);

				if (isTwoWay) {
					result.addArrow(adj, node, { kind: "twoWay" });
				}
			// copy over arrows not involved in a cycle
			} else {
				result.addArrow(node, adj, graph.getArrowMeta(node, adj));
				visit(adj);
			}
		});
	};

	visit(graph.nodes[0]);
	return result;
};


/***/ }),

/***/ "./node_modules/can-debug/src/log-data/log-data.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-debug/src/log-data/log-data.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var quoteString = function quoteString(x) {
	return typeof x === "string" ? JSON.stringify(x) : x;
};

module.exports = function log(data) {
	var node = data.node;
	var nameParts = [node.name, "key" in node ? "." + node.key : ""];

	console.group(nameParts.join(""));
	console.log("value  ", quoteString(node.value));
	console.log("object ", node.obj);

	if (data.derive.length) {
		console.group("DERIVED FROM");
		canReflect.eachIndex(data.derive, log);
		console.groupEnd();
	}

	if (data.mutations.length) {
		console.group("MUTATED BY");
		canReflect.eachIndex(data.mutations, log);
		console.groupEnd();
	}

	if (data.twoWay.length) {
		console.group("TWO WAY");
		canReflect.eachIndex(data.twoWay, log);
		console.groupEnd();
	}

	console.groupEnd();
};


/***/ }),

/***/ "./node_modules/can-debug/src/proxy-namespace.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-debug/src/proxy-namespace.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

var warned = false;

module.exports = function proxyNamespace(namespace) {
	return new Proxy(namespace, {
		get: function get(target, name) {
			if (!warned) {
				console.warn("Warning: use of 'can' global should be for debugging purposes only.");
				warned = true;
			}
			return target[name];
		}
	});
};


/***/ }),

/***/ "./node_modules/can-debug/src/temporarily-bind.js":
/*!********************************************************!*\
  !*** ./node_modules/can-debug/src/temporarily-bind.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var onValueSymbol = canSymbol.for("can.onValue");
var offValueSymbol = canSymbol.for("can.offValue");
var onKeyValueSymbol = canSymbol.for("can.onKeyValue");
var offKeyValueSymbol = canSymbol.for("can.offKeyValue");

var noop = function noop() {};

function isFunction(value) {
	return typeof value === "function";
}

function withKey(obj, key, fn) {
	var result;

	if (isFunction(obj[onKeyValueSymbol])) {
		canReflect.onKeyValue(obj, key, noop);
	}

	result = fn(obj, key);

	if (isFunction(obj[offKeyValueSymbol])) {
		canReflect.offKeyValue(obj, key, noop);
	}

	return result;
}

function withoutKey(obj, fn) {
	var result;

	if (isFunction(obj[onValueSymbol])) {
		canReflect.onValue(obj, noop);
	}

	result = fn(obj);

	if (isFunction(obj[offValueSymbol])) {
		canReflect.offValue(obj, noop);
	}

	return result;
}

// Takes a function with signature `fn(obj, [key])`
// Makes sure that the argument is bound before calling 
// the function and unbinds it after the call is done.
module.exports = function temporarilyBind(fn) {
	return function(obj, key) {
		var gotKey = arguments.length === 2;
		return gotKey ? withKey(obj, key, fn) : withoutKey(obj, fn);
	};
};


/***/ }),

/***/ "./node_modules/can-debug/src/what-changes-me/what-changes-me.js":
/*!***********************************************************************!*\
  !*** ./node_modules/can-debug/src/what-changes-me/what-changes-me.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var log = __webpack_require__(/*! ../log-data/log-data */ "./node_modules/can-debug/src/log-data/log-data.js");
var getData = __webpack_require__(/*! ../get-data/get-data */ "./node_modules/can-debug/src/get-data/get-data.js");
var getGraph = __webpack_require__(/*! ../get-graph/get-graph */ "./node_modules/can-debug/src/get-graph/get-graph.js");

// key :: string | number | null | undefined
module.exports = function logWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	var data = getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatChangesMe"
	);

	if (data) {
		log(data);
	}
};


/***/ }),

/***/ "./node_modules/can-debug/src/what-i-change/what-i-change.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-debug/src/what-i-change/what-i-change.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var log = __webpack_require__(/*! ../log-data/log-data */ "./node_modules/can-debug/src/log-data/log-data.js");
var getData = __webpack_require__(/*! ../get-data/get-data */ "./node_modules/can-debug/src/get-data/get-data.js");
var getGraph = __webpack_require__(/*! ../get-graph/get-graph */ "./node_modules/can-debug/src/get-graph/get-graph.js");

// key :: string | number | null | undefined
module.exports = function logWhatIChange(obj, key) {
	var gotKey = arguments.length === 2;

	var data = getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatIChange"
	);

	if (data) {
		log(data);
	}
};


/***/ }),

/***/ "./node_modules/can-deep-observable/can-deep-observable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-deep-observable/can-deep-observable.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ObservableArray = __webpack_require__(/*! can-observable-array */ "./node_modules/can-observable-array/dist/can-observable-array.js");
const ObservableObject = __webpack_require__(/*! can-observable-object */ "./node_modules/can-observable-object/dist/can-observable-object.js");
const namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
const canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
const type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

class DeepObservableObject extends ObservableObject {
	static get propertyDefaults() {
		return type.maybeConvert(DeepObservable);
	}
}

class DeepObservableArray extends ObservableArray {
	static get items() {
		return type.maybeConvert(DeepObservable);
	}
}

function isPlainArray(array) {
	return Array.isArray(array) && array.constructor === Array;
}

function DeepObservable() {}

canReflect.assignSymbols(DeepObservable, {
	"can.new": function(value) {
		if(isPlainArray(value)) {
			return new DeepObservableArray(value);
		}
		else if(canReflect.isPlainObject(value)) {
			return new DeepObservableObject(value);
		} else {
			return value;
		}
	}
});

module.exports = namespace.DeepObservable = type.maybeConvert(DeepObservable);


/***/ }),

/***/ "./node_modules/can-define-backup/can-define-backup.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-define-backup/can-define-backup.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

//allows you to backup and restore a map instance
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var diffDeep = __webpack_require__(/*! can-diff/deep/deep */ "./node_modules/can-diff/deep/deep.js");
var diffMap = __webpack_require__(/*! can-diff/map/map */ "./node_modules/can-diff/map/map.js");

var flatProps = function (a, cur) {
	var obj = {};
	for (var prop in a) {
		if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
			obj[prop] = a[prop];
		} else {
			obj[prop] = cur[prop];//cur.attr(prop);
		}
	}
	return obj;
};

var assignNonEnumerable = function(base, props) {
	for(var prop in props) {
		Object.defineProperty(base, prop, {
			enumerable: false,
			configurable: true,
			writable: true,
			value: props[prop]
		});
	}
};

var observables = new WeakMap();

function getBackup(map) {
	var obs = observables.get(map);
	if(!obs) {
		obs = new SimpleObservable();
		observables.set(map, obs);
	}
	return obs;
}

function defineBackup(Map) {
	assignNonEnumerable(Map.prototype, {

		backup: function () {
			var store = getBackup(this);
			canReflect.setValue(store, this.serialize());
			return this;
		},

		isDirty: function (checkAssociations) {
			var store = getBackup(this);
			var backupStore = canReflect.getValue(store);
			if(!backupStore){
				return false;
			}
			var currentValue = this.serialize();
			var patches;
			if(!! checkAssociations) {
				patches = diffDeep(currentValue, backupStore);
			} else {
				patches = diffMap(currentValue, backupStore).filter(function(patch){
					// only keep those that are not a set of deep object
					if(patch.type !== "set") {
						return true;
					} else {
						// check values .. if both objects ... we are not dirty ...
						var curVal = currentValue[patch.key],
							backupVal = backupStore[patch.key];
						var twoObjectsCompared = curVal && backupVal && typeof curVal === "object" && typeof backupVal === "object";
						return !twoObjectsCompared;
					}
				});
			}
			return patches.length;
		},

		restore: function (restoreAssociations) {
			var store = getBackup(this);
			var curVal = canReflect.getValue(store);
			var props = restoreAssociations ? curVal : flatProps(curVal, this);
			if (this.isDirty(restoreAssociations)) {
				for(var prop in props) {
					this[prop] = props[prop];
				}
			}
			return this;
		}
	});

	return Map;
}

module.exports = exports = defineBackup;


/***/ }),

/***/ "./node_modules/can-define-connected-singleton/can-define-connected-singleton.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/can-define-connected-singleton.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var reflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var DefineMap = __webpack_require__(/*! can-define/map/map */ "./node_modules/can-define/map/map.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var zoneStorage = __webpack_require__(/*! ./util/zone-storage */ "./node_modules/can-define-connected-singleton/util/zone-storage.js");
var helpers = __webpack_require__(/*! ./util/helpers */ "./node_modules/can-define-connected-singleton/util/helpers.js");

var defaults = {
	storagePrefix: 'can-define-connected-singleton',
	currentPropertyName: 'current',
	savingPropertyName: 'saving',
	fetchMethodName: 'get',
	createMethodName: 'save',
	destroyMethodName: 'destroy',
};

function isDefineMapConstructor(Obj) {
	return Obj && (Obj.prototype instanceof DefineMap);
}

// wrap the createMethod so it updates .current, .currentPromise & .saving during the course of a singleton model being persisted
function wrapCreateMethod(Ctor, options) {
	var baseCreate = Ctor.prototype[options.createMethodName];

	Ctor.prototype[options.createMethodName] = function wrappedCreate() {
		var ret = baseCreate.apply(this, arguments);

		// set Ctor.saving & Ctor.currentPromise
		zoneStorage.setItem(options.storageKeys.savingProperty, this);
		Ctor.dispatch(options.savingPropertyName, [this]);
		zoneStorage.setItem(options.storageKeys.currentPropertyPromise, ret);
		Ctor.dispatch(options.currentPropertyPromiseName, [ret]);

		ret.then(
			(instance) => {
				// clear Ctor.saving, set Ctor.current
				zoneStorage.setItem(options.storageKeys.savingProperty, undefined);
				Ctor.dispatch(options.savingPropertyName, [undefined]);
				zoneStorage.setItem(options.storageKeys.currentProperty, instance);
				Ctor.dispatch(options.currentPropertyName, [instance]);
			},
			() => {
				// clear saving
				zoneStorage.setItem(options.storageKeys.savingProperty, undefined);
				Ctor.dispatch(options.savingPropertyName, [undefined]);
			}
		);

		return ret;
	};
}

// wrap the destroyMethod so it updates .current & .currentPromise during the course of a singleton model being removed from persistence
function wrapDestroyMethod(Ctor, options) {
	var baseDestroy = Ctor.prototype[options.destroyMethodName];

	Ctor.prototype[options.destroyMethodName] = function wrappedDestroy() {
		var ret = baseDestroy.apply(this, arguments);

		// return modified promise to ensure that storedPromise check runs before consumer of returned promise
		return ret.then((value) => {
			// clear current, reject currentPromise
			zoneStorage.setItem(options.storageKeys.currentProperty, undefined);
			Ctor.dispatch(options.currentPropertyName, [undefined]);

			// avoid setting promise a second time if can/session behavior callback handler has already set it to a rejected promise
			const storedPromise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);
			storedPromise.then(
				() => {
					var promise = Promise.reject(undefined);
					zoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);
					Ctor.dispatch(options.currentPropertyPromiseName, [promise]);
				},
				() => {} // promise is already rejected by can/session destroyedInstance callback
			);

			return value;
		});
	};
}

function checkForExistingKeys(options) {
	if (zoneStorage.getItem(options.storageKeys.currentProperty) ||
		zoneStorage.getItem(options.storageKeys.currentPropertyPromise) ||
		zoneStorage.getItem(options.storageKeys.savingProperty)) {
		console.warn('can-define-connected-singleton: Removing existing values from zone storage. You are likely configuring a singleton twice.');
		zoneStorage.removeItem(options.storageKeys.currentProperty);
		zoneStorage.removeItem(options.storageKeys.currentPropertyPromise);
		zoneStorage.removeItem(options.storageKeys.savingProperty);
	}
}

// get stored current & promise values, initializing them if they're not yet set
function getCurrentAndPromise(Ctor, options) {
	var current = zoneStorage.getItem(options.storageKeys.currentProperty);
	var promise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);

	if (promise == null) {
		promise = Ctor[options.fetchMethodName]();
		zoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);
		Ctor.dispatch(options.currentPropertyPromiseName, [promise]);

		promise.then(function (value) {
			zoneStorage.setItem(options.storageKeys.currentProperty, value);
			Ctor.dispatch(options.currentPropertyName, [value]);
		})
		.catch(function () {
			zoneStorage.setItem(options.storageKeys.currentProperty, null);
			Ctor.dispatch(options.currentPropertyName, [null]);
		});
	}

	return {
		current: current,
		promise: promise
	};
}


function makeSingleton(Ctor, input_options){
	var helpURL = 'https://canjs.com/doc/can-define-connected-singleton';

	if(!isDefineMapConstructor(Ctor)) {
		throw new Error('The singleton decorator/mixin can only be used for DefineMaps: ' + helpURL);
	}

	var savingPropertyName = input_options.savingPropertyName;
	var currentPropertyName = input_options.currentPropertyName;
	var currentPropertyPromiseName = currentPropertyName + 'Promise';
	var currentPropertyKey = input_options.storagePrefix + '-' + Ctor.name + '-' + currentPropertyName;
	var storageKeys = {
		savingProperty: input_options.storagePrefix + '-' + Ctor.name + '-' + savingPropertyName,
		currentProperty: currentPropertyKey,
		currentPropertyPromise: currentPropertyKey + '-promise'
	};
	var options = Object.assign({}, input_options, {
		currentPropertyPromiseName, storageKeys
	});

	checkForExistingKeys(options);

	Object.defineProperty(Ctor, options.currentPropertyPromiseName, {
		get: function () {
			ObservationRecorder.add(Ctor, options.currentPropertyPromiseName);
			return getCurrentAndPromise(Ctor, options).promise;
		}
	});

	Object.defineProperty(Ctor, options.currentPropertyName, {
		get: function () {
			ObservationRecorder.add(Ctor, options.currentPropertyName);
			return getCurrentAndPromise(Ctor, options).current;
		},
		// The "current" property is not typically set via this setter, typically it will be set by the destroyMethod & createMethod wrappers, and getCurrentAndPromise. This setter is used when a user of this module wishes to force a state.
		set: function(instance) {
			if (!(instance instanceof Ctor) && instance !== undefined) {
				throw new TypeError('Attempted to set singleton to an unexpected type. Expected an instance of the constructor "' + reflect.getName(Ctor) + '"');
			}

			let promise = instance ?
				Promise.resolve(instance) :
				Promise.reject(undefined);

			zoneStorage.setItem(options.storageKeys.currentProperty, instance);
			Ctor.dispatch(options.currentPropertyName, [instance]);
			zoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);
			Ctor.dispatch(options.currentPropertyPromiseName, [promise]);
		}
	});

	Object.defineProperty(Ctor, options.savingPropertyName, {
		get: function () {
			ObservationRecorder.add(Ctor, options.savingPropertyName);
			return zoneStorage.getItem(options.storageKeys.savingProperty);
		}
	});

	wrapCreateMethod(Ctor, options);
	wrapDestroyMethod(Ctor, options);

	return Ctor;
}

function singleton(Obj) {
	var opts = helpers.assign({}, defaults);

	// @singleton
	if(isDefineMapConstructor(Obj)) {
		return makeSingleton(Obj, opts);
	}

	// @singleton(options)
	return function(Ctor) {
		return makeSingleton(Ctor, helpers.assign(opts, Obj));
	};
}

module.exports = singleton;


/***/ }),

/***/ "./node_modules/can-define-connected-singleton/util/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/util/helpers.js ***!
  \*********************************************************************/
/***/ ((module) => {

var assign = function(obj) {
	var to = Object(obj);

	for (var i = 1, l = arguments.length; i < l ; i++) {
		var next = arguments[i];

		if (next != null) {
			for (var key in next) {
				if (Object.prototype.hasOwnProperty.call(next, key)) {
					to[key] = next[key];
				}
			}
		}
	}

	return to;
}


module.exports = {
	assign: assign
};


/***/ }),

/***/ "./node_modules/can-define-connected-singleton/util/zone-storage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/util/zone-storage.js ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = {
	data: {},

	getStore: function () {
		if (window.doneSsr) {
			var CanZone = window.CanZone || undefined;
			return typeof CanZone === 'undefined' ? this.data : CanZone.current.data;
		}
		return this.data;
	},

	setItem: function (prop, value) {
		var store = this.getStore();
		store[prop] = value;
	},

	getItem: function (prop) {
		var store = this.getStore();
		return store[prop];
	},

	removeItem: function (prop) {
		var store = this.getStore();
		delete store[prop];
	}
};


/***/ }),

/***/ "./node_modules/can-define-lazy-value/define-lazy-value.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-define-lazy-value/define-lazy-value.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";

/**
 * @module {function} can-define-lazy-value
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @package ./package.json
 * @signature `defineLazyValue(obj, prop, fn, writable)`
 *
 * Use Object.defineProperty to define properties whose values will be created lazily when they are first read.
 *
 * ```js
 * var _id = 1;
 * function getId() {
 *     return _id++;
 * }
 *
 * function MyObj(name) {
 *     this.name = name;
 * }
 *
 * defineLazyValue(MyObj.prototype, 'id', getId);
 *
 * var obj1 = new MyObj('obj1');
 * var obj2 = new MyObj('obj2');
 *
 * console.log( obj2 ); // -> { name: "obj2" }
 * console.log( obj1 ); // -> { name: "obj1" }
 *
 * // the first `id` read will get id `1`
 * console( obj2.id ); // -> 1
 * console( obj1.id ); // -> 2
 *
 * console.log( obj2 ); // -> { name: "obj2", id: 1 }
 * console.log( obj1 ); // -> { name: "obj1", id: 2 }
 *
 * ```
 *
 * @param {Object} object The object to add the property to.
 * @param {String} prop   The name of the property.
 * @param {Function} fn   A function to get the value the property should be set to.
 * @param {boolean} writable   Whether the field should be writable (false by default).
 */
module.exports = function defineLazyValue(obj, prop, initializer, writable) {
	Object.defineProperty(obj, prop, {
		configurable: true,
		get: function() {
			// make the property writable
			Object.defineProperty(this, prop, {
				value: undefined,
				writable: true
			});

			// get the value from the initializer function
			var value = initializer.call(this, obj, prop);

			// redefine the property to the value property
			// and reset the writable flag
			Object.defineProperty(this, prop, {
				value: value,
				writable: !!writable
			});

			// return the value
			return value;
		},
		set: function(value){
			Object.defineProperty(this, prop, {
				value: value,
				writable: !!writable
			});

			return value;
		}
	});
};


/***/ }),

/***/ "./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! can-connect */ "./node_modules/can-connect/can-connect.js");

var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! can-connect/can/map/map */ "./node_modules/can-connect/can/map/map.js");
var constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
var dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! can-connect/data/url/url */ "./node_modules/can-connect/data/url/url.js");
var DefineList = __webpack_require__(/*! can-define/list/list */ "./node_modules/can-define/list/list.js");
var DefineMap = __webpack_require__(/*! can-define/map/map */ "./node_modules/can-define/map/map.js");
var realTime = __webpack_require__(/*! can-connect/real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");
var callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

function defineRealtimeRestModel(optionsOrUrl) {

	// If optionsOrUrl is a string, make options = {url: optionsOrUrl}
	var options = (typeof optionsOrUrl === "string") ? {url: optionsOrUrl} : optionsOrUrl;

	// If options.Map or .List aren’t provided, define them
	if (typeof options.Map === "undefined") {
		options.Map = DefineMap.extend({seal: false}, {});
	}
	if (typeof options.List === "undefined") {
		options.List = options.Map.List || DefineList.extend({"#": options.Map});
	}

	var behaviors = [
		constructor,
		canMap,
		constructorStore,
		dataCallbacks,
		dataParse,
		dataUrl,
		realTime,
		callbacksOnce
	];

	return connect(behaviors,options);
}

module.exports = namespace.defineRealtimeRestModel = defineRealtimeRestModel;


/***/ }),

/***/ "./node_modules/can-define-rest-model/can-define-rest-model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-define-rest-model/can-define-rest-model.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! can-connect/can/map/map */ "./node_modules/can-connect/can/map/map.js");
var dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! can-connect/data/url/url */ "./node_modules/can-connect/data/url/url.js");
var DefineList = __webpack_require__(/*! can-define/list/list */ "./node_modules/can-define/list/list.js");
var DefineMap = __webpack_require__(/*! can-define/map/map */ "./node_modules/can-define/map/map.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var base = __webpack_require__(/*! can-connect/base/base */ "./node_modules/can-connect/base/base.js");

function defineRestModel(optionsOrUrl) {

	// If optionsOrUrl is a string, make options = {url: optionsOrUrl}
	var options = (typeof optionsOrUrl === "string") ? {url: optionsOrUrl} : optionsOrUrl;

	// If options.Map or .List aren’t provided, define them
	if (typeof options.Map === "undefined") {
		options.Map = DefineMap.extend({seal: false}, {});
	}
	if (typeof options.List === "undefined") {
		options.List = options.Map.List || DefineList.extend({"#": options.Map});
	}

	var connection = [base,dataUrl, dataParse, constructor, canMap].reduce(function(prev, behavior){
		return behavior(prev);
	}, options);
	connection.init();
	return connection;
}

module.exports = namespace.defineRestModel = defineRestModel;


/***/ }),

/***/ "./node_modules/can-define-stream-kefir/can-define-stream-kefir.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-define-stream-kefir/can-define-stream-kefir.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canDefineStream = __webpack_require__(/*! can-define-stream */ "./node_modules/can-define-stream/can-define-stream.js");
var canStreamKefir = __webpack_require__(/*! can-stream-kefir */ "./node_modules/can-stream-kefir/can-stream-kefir.js");

module.exports = namespace.defineStreamKefir = canDefineStream(canStreamKefir);


/***/ }),

/***/ "./node_modules/can-define-stream/can-define-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-define-stream/can-define-stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var define = __webpack_require__(/*! can-define */ "./node_modules/can-define/can-define.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function(canStream) {
	return function(DefineMapType) {
		["toStream","toStreamFromProperty","toStreamFromEvent"] .forEach(function(name){
			DefineMapType.prototype[name] = function(){
				return canStream[name].apply(canStream, [this].concat( [].slice.call(arguments) ));
			};
		});

		DefineMapType.prototype.stream = DefineMapType.prototype.toStream;

		// figure out how to rebuild definitions.
		var definitions = DefineMapType.prototype._define.definitions,
			dataInitializers = DefineMapType.prototype._define.dataInitializers,
			computedInitializers = DefineMapType.prototype._define.computedInitializers;

		canReflect.eachKey(definitions, function(definition, property) {
			var streamDefinition = definition.stream;
			if(streamDefinition) {
				var newDefinition = assign({
					default: function() {
						return canStream.toCompute(streamDefinition, this);
					}
				}, define.types.compute);
				define.property(
					DefineMapType.prototype,
					property,
					newDefinition,
					dataInitializers,
					computedInitializers
				);
			}
		});
	};
};


/***/ }),

/***/ "./node_modules/can-define/can-define.js":
/*!***********************************************!*\
  !*** ./node_modules/can-define/can-define.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

"format cjs";

var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ "./node_modules/can-simple-observable/async/async.js");
var SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ "./node_modules/can-simple-observable/resolver/resolver.js");

var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var stringToAny = __webpack_require__(/*! can-string-to-any */ "./node_modules/can-string-to-any/can-string-to-any.js");
var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");

var MaybeBoolean = __webpack_require__(/*! can-data-types/maybe-boolean/maybe-boolean */ "./node_modules/can-data-types/maybe-boolean/maybe-boolean.js"),
    MaybeDate = __webpack_require__(/*! can-data-types/maybe-date/maybe-date */ "./node_modules/can-data-types/maybe-date/maybe-date.js"),
    MaybeNumber = __webpack_require__(/*! can-data-types/maybe-number/maybe-number */ "./node_modules/can-data-types/maybe-number/maybe-number.js"),
    MaybeString = __webpack_require__(/*! can-data-types/maybe-string/maybe-string */ "./node_modules/can-data-types/maybe-string/maybe-string.js");

var newSymbol = canSymbol.for("can.new"),
	serializeSymbol = canSymbol.for("can.serialize"),
	inSetupSymbol = canSymbol.for("can.initializing");

var eventsProto, define,
	make, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;

// UTILITIES
function isDefineType(func){
	return func && (func.canDefineType === true || func[newSymbol] );
}

var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));

var Object_defineNamedPrototypeProperty = Object.defineProperty;
//!steal-remove-start
if(true) {
	Object_defineNamedPrototypeProperty = function(obj, prop, definition) {
		if (definition.get) {
			Object.defineProperty(definition.get, "name", {
				value: "get "+canReflect.getName(obj) + "."+prop,
				writable: true,
				configurable: true
			});
		}
		if (definition.set) {
			Object.defineProperty(definition.set, "name", {
				value:  "set "+canReflect.getName(obj) + "."+prop,
				configurable: true
			});
		}
		return Object.defineProperty(obj, prop, definition);
	};
}
//!steal-remove-end


function defineConfigurableAndNotEnumerable(obj, prop, value) {
	Object.defineProperty(obj, prop, {
		configurable: true,
		enumerable: false,
		writable: true,
		value: value
	});
}

function eachPropertyDescriptor(map, cb){
	for(var prop in map) {
		if(map.hasOwnProperty(prop)) {
			cb.call(map, prop, Object.getOwnPropertyDescriptor(map,prop));
		}
	}
}

function getEveryPropertyAndSymbol(obj) {
	var props = Object.getOwnPropertyNames(obj);
	var symbols = ("getOwnPropertySymbols" in Object) ?
	  Object.getOwnPropertySymbols(obj) : [];
	return props.concat(symbols);
}

function cleanUpDefinition(prop, definition, shouldWarn, typePrototype){
	// cleanup `value` -> `default`
	if(definition.value !== undefined && ( typeof definition.value !== "function" || definition.value.length === 0) ){

		//!steal-remove-start
		if(true) {
			if(shouldWarn) {
				canLogDev.warn(
					"can-define: Change the 'value' definition for " + canReflect.getName(typePrototype)+"."+prop + " to 'default'."
				);
			}
		}
		//!steal-remove-end

		definition.default = definition.value;
		delete definition.value;
	}
	// cleanup `Value` -> `DEFAULT`
	if(definition.Value !== undefined  ){
		//!steal-remove-start
		if(true) {
			if(shouldWarn) {
				canLogDev.warn(
					"can-define: Change the 'Value' definition for " + canReflect.getName(typePrototype)+"."+prop + " to 'Default'."
				);
			}
		}
		//!steal-remove-end
		definition.Default = definition.Value;
		delete definition.Value;
	}
}

function isValueResolver(definition) {
	// there's a function and it has one argument
	return typeof definition.value === "function" && definition.value.length;
}

module.exports = define = ns.define = function(typePrototype, defines, baseDefine) {
	// default property definitions on _data
	var prop,
		dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),
		// computed property definitions on _computed
		computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);

	var result = getDefinitionsAndMethods(defines, baseDefine, typePrototype);
	result.dataInitializers = dataInitializers;
	result.computedInitializers = computedInitializers;


	// Goes through each property definition and creates
	// a `getter` and `setter` function for `Object.defineProperty`.
	canReflect.eachKey(result.definitions, function(definition, property){
		define.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);
	});

	// Places a `_data` on the prototype that when first called replaces itself
	// with a `_data` object local to the instance.  It also defines getters
	// for any value that has a default value.
	if(typePrototype.hasOwnProperty("_data")) {
		for (prop in dataInitializers) {
			defineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);
		}
	} else {
		defineLazyValue(typePrototype, "_data", function() {
			var map = this;
			var data = {};
			for (var prop in dataInitializers) {
				defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
			}
			return data;
		});
	}

	// Places a `_computed` on the prototype that when first called replaces itself
	// with a `_computed` object local to the instance.  It also defines getters
	// that will create the property's compute when read.
	if(typePrototype.hasOwnProperty("_computed")) {
		for (prop in computedInitializers) {
			defineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));
		}
	} else {
		defineLazyValue(typePrototype, "_computed", function() {
			var map = this;
			var data = Object.create(null);
			for (var prop in computedInitializers) {
				defineLazyValue(data, prop, computedInitializers[prop].bind(map));
			}
			return data;
		});
	}

	// Add necessary event methods to this object.
	getEveryPropertyAndSymbol(eventsProto).forEach(function(prop){
		Object.defineProperty(typePrototype, prop, {
			enumerable: false,
			value: eventsProto[prop],
			configurable: true,
			writable: true
		});
	});
	// also add any symbols
	// add so instance defs can be dynamically added
	Object.defineProperty(typePrototype,"_define",{
		enumerable: false,
		value: result,
		configurable: true,
		writable: true
	});

	// Places Symbol.iterator or @@iterator on the prototype
	// so that this can be iterated with for/of and canReflect.eachIndex
	var iteratorSymbol = canSymbol.iterator || canSymbol.for("iterator");
	if(!typePrototype[iteratorSymbol]) {
		defineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function(){
			return new define.Iterator(this);
		});
	}

	return result;
};

var onlyType = function(obj){
	for(var prop in obj) {
		if(prop !== "type") {
			return false;
		}
	}
	return true;
};

define.extensions = function () {};

// typePrototype - the prototype of the type we are defining `prop` on.
// `definition` - the user provided definition
define.property = function(typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {
	var propertyDefinition = define.extensions.apply(this, arguments);

	if (propertyDefinition) {
		definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);
	}

	var type = definition.type;

	//!steal-remove-start
	if(true) {
		var hasZeroArgGetter = definition.get && definition.get.length === 0;
		var noSetter = !definition.set;
		var defaultInDefinition = ( "default" in definition || "Default" in definition );
		var typeInDefinition = (definition.type && defaultDefinition && definition.type !== defaultDefinition.type) ||
			(definition.Type && defaultDefinition && definition.Type !== defaultDefinition.Type);

		if(hasZeroArgGetter && noSetter && defaultInDefinition) {
			var defaultOrDefault = "default" in definition ? "default" : "Default";
				canLogDev.warn("can-define: " + defaultOrDefault + " value for property " +
						canReflect.getName(typePrototype)+"."+ prop +
						" ignored, as its definition has a zero-argument getter");
		}

		if(hasZeroArgGetter && noSetter && typeInDefinition) {
			var typeOrType = definition.type ? "type" : "Type";
			canLogDev.warn("can-define: " + typeOrType + " value for property " +
					canReflect.getName(typePrototype)+"."+ prop +
					" ignored, as its definition has a zero-argument getter");
		}

		if (type && canReflect.isConstructorLike(type) && !isDefineType(type)) {
			canLogDev.warn(
				"can-define: the definition for " + canReflect.getName(typePrototype) + "."+
                prop +
				" uses a constructor for \"type\". Did you mean \"Type\"?"
			);
		}
	}
	//!steal-remove-end

	// Special case definitions that have only `type: "*"`.
	if (type && onlyType(definition) && type === define.types["*"]) {
		Object_defineNamedPrototypeProperty(typePrototype, prop, {
			get: make.get.data(prop),
			set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
			enumerable: true,
			configurable: true
		});
		return;
	}
	definition.type = type;

	// Where the value is stored.  If there is a `get` the source of the value
	// will be a compute in `this._computed[prop]`.  If not, the source of the
	// value will be in `this._data[prop]`.
	var dataProperty = definition.get || isValueResolver(definition) ? "computed" : "data",

		// simple functions that all read/get/set to the right place.
		// - reader - reads the value but does not observe.
		// - getter - reads the value and notifies observers.
		// - setter - sets the value.
		reader = make.read[dataProperty](prop),
		getter = make.get[dataProperty](prop),
		setter = make.set[dataProperty](prop),
		getInitialValue;

	//!steal-remove-start
	if(true) {
		if (definition.get) {
			Object.defineProperty(definition.get, "name", {
				value: canReflect.getName(typePrototype) + "'s " + prop + " getter",
				configurable: true
			});
		}
		if (definition.set) {
			Object.defineProperty(definition.set, "name", {
				value: canReflect.getName(typePrototype) + "'s " + prop + " setter",
				configurable: true
			});
		}
		if(isValueResolver(definition)) {
			Object.defineProperty(definition.value, "name", {
				value: canReflect.getName(typePrototype) + "'s " + prop + " value",
				configurable: true
			});
		}
	}
	//!steal-remove-end

	// Determine the type converter
	var typeConvert = function(val) {
		return val;
	};

	if (definition.Type) {
		typeConvert = make.set.Type(prop, definition.Type, typeConvert);
	}
	if (type) {
		typeConvert = make.set.type(prop, type, typeConvert);
	}

	// make a setter that's going to fire of events
	var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
	if(isValueResolver(definition)) {
		computedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);
	}
	// Determine a function that will provide the initial property value.
	else if ((definition.default !== undefined || definition.Default !== undefined)) {

		//!steal-remove-start
		if (true) {
			// If value is an object or array, give a warning
			if (definition.default !== null && typeof definition.default === 'object') {
				canLogDev.warn("can-define: The default value for " + canReflect.getName(typePrototype)+"."+prop + " is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.");
			}
			// If value is a constructor, give a warning
			if (definition.default && canReflect.isConstructorLike(definition.default)) {
				canLogDev.warn("can-define: The \"default\" for " + canReflect.getName(typePrototype)+"."+prop + " is set to a constructor. Did you mean \"Default\" instead?");
			}
		}
		//!steal-remove-end

		getInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
	}

	// If property has a getter, create the compute that stores its data.
	if (definition.get) {
		computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
	}
	// If the property isn't a getter, but has an initial value, setup a
	// default value on `this._data[prop]`.
	else if (getInitialValue) {
		dataInitializers[prop] = getInitialValue;
	}


	// Define setter behavior.

	// If there's a `get` and `set`, make the setter get the `lastSetValue` on the
	// `get`'s compute.
	if (definition.get && definition.set) {
		// the compute will set off events, so we can use the basic setter
		setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);

        // If there's zero-arg `get`, warn on all sets in dev mode
        if (definition.get.length === 0 ) {
            //!steal-remove-start
            if(true) {
                canLogDev.warn("can-define: Set value for property " +
                    canReflect.getName(typePrototype)+"."+ prop +
                    " ignored, as its definition has a zero-argument getter");
            }
            //!steal-remove-end
        }
	}
	// If there's a `set` and no `get`,
	else if (definition.set) {
		// Add `set` functionality to the eventSetter.
		setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
	}
	// If there's neither `set` or `get` or `value` (resolver)
	else if (dataProperty === "data") {
		// make a set that produces events.
		setter = eventsSetter;
	}
	// If there's zero-arg `get` but not `set`, warn on all sets in dev mode
	else if (definition.get && definition.get.length < 1) {
		setter = function() {
			//!steal-remove-start
			if(true) {
				canLogDev.warn("can-define: Set value for property " +
					canReflect.getName(typePrototype)+"."+ prop +
					" ignored, as its definition has a zero-argument getter and no setter");
			}
			//!steal-remove-end
		};
	}

	// Add type behavior to the setter.
	if (type) {
		setter = make.set.type(prop, type, setter);
	}
	if (definition.Type) {
		setter = make.set.Type(prop, definition.Type, setter);
	}

	// Define the property.
	Object_defineNamedPrototypeProperty(typePrototype, prop, {
		get: getter,
		set: setter,
		enumerable: "serialize" in definition ? !!definition.serialize : !definition.get,
		configurable: true
	});
};
define.makeDefineInstanceKey = function(constructor) {
	constructor[canSymbol.for("can.defineInstanceKey")] = function(property, value) {
		var defineResult = this.prototype._define;
		if(typeof value === "object") {
			// change `value` to default.
			cleanUpDefinition(property, value, false, this);
		}
		var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);
		if(definition && typeof definition === "object") {
			define.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);
			defineResult.definitions[property] = definition;
		} else {
			defineResult.methods[property] = definition;
		}

		this.prototype.dispatch({
			action: "can.keys",
			type: "can.keys", // TODO: Remove in 6.0
			target: this.prototype
		});
	};
};

// Makes a simple constructor function.
define.Constructor = function(defines, sealed) {
	var constructor = function DefineConstructor(props) {
		Object.defineProperty(this, inSetupSymbol, {
			configurable: true,
			enumerable: false,
			value: true,
			writable: true
		});
		define.setup.call(this, props, sealed);
		this[inSetupSymbol] = false;
	};
	var result = define(constructor.prototype, defines);
	addTypeEvents(constructor);
	define.makeDefineInstanceKey(constructor, result);
	return constructor;
};

// A bunch of helper functions that are used to create various behaviors.
make = {

	computeObj: function(map, prop, observable) {
		var computeObj = {
			oldValue: undefined,
			compute: observable,
			count: 0,
			handler: function(newVal) {
				var oldValue = computeObj.oldValue;
				computeObj.oldValue = newVal;

				map.dispatch({
					action: "set",
					key: "prop",
					target: map,
					value: newVal,
					oldValue: oldValue,
					type: prop, // TODO: Remove in 6.0
				}, [newVal, oldValue]);
			}
		};
		return computeObj;
	},
	valueResolver: function(prop, definition, typeConvert) {
		var getDefault = make.get.defaultValue(prop, definition, typeConvert);
		return function(){
			var map = this;
			var defaultValue = getDefault.call(this);
			var computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue));
			//!steal-remove-start
			if(true) {
				Object.defineProperty(computeObj.handler, "name", {
					value: canReflect.getName(definition.value).replace('value', 'event emitter')
				});
			}
			//!steal-remove-end
			return computeObj;
		};
	},
	// Returns a function that creates the `_computed` prop.
	compute: function(prop, get, defaultValueFn) {

		return function() {
			var map = this,
				defaultValue = defaultValueFn && defaultValueFn.call(this),
				observable, computeObj;

			if(get.length === 0) {
				observable = new Observation(get, map);
			} else if(get.length === 1) {
				observable = new SettableObservable(get, map, defaultValue);
			} else {
				observable = new AsyncObservable(get, map, defaultValue);
			}

			computeObj = make.computeObj(map, prop, observable);

			//!steal-remove-start
			if(true) {
				Object.defineProperty(computeObj.handler, "name", {
					value: canReflect.getName(get).replace('getter', 'event emitter')
				});
			}
			//!steal-remove-end

			return computeObj;
		};
	},
	// Set related helpers.
	set: {
		data: function(prop) {
			return function(newVal) {
				this._data[prop] = newVal;
			};
		},
		computed: function(prop) {
			return function(val) {
				canReflect.setValue( this._computed[prop].compute, val );
			};
		},
		events: function(prop, getCurrent, setData, eventType) {
			return function(newVal) {
				if (this[inSetupSymbol]) {
					setData.call(this, newVal);
				}
				else {
					var current = getCurrent.call(this);
					if (newVal === current) {
						return;
					}
					var dispatched;
					setData.call(this, newVal);

						dispatched = {
							patches: [{type: "set", key: prop, value: newVal}],
							target: this,
							action: "set",
							value: newVal,
							oldValue: current,
							key: prop,
							type: prop // TODO: Remove in 6.0
						};

					//!steal-remove-start
					if(true) {
						var lastItem, lastFn;
						dispatched.reasonLog = [ canReflect.getName(this) + "'s", prop, "changed to", newVal, "from", current ];

						// If there are observations currently recording, this isn't a good time to
						//   mutate values: it's likely a cycle, and even if it doesn't cycle infinitely,
						//   it will likely cause unnecessary recomputation of derived values.  Warn the user.
						if(ObservationRecorder.isRecording() && queues.stack().length && !this[inSetupSymbol]) {
							lastItem = queues.stack()[queues.stack().length - 1];
							lastFn = lastItem.context instanceof Observation ? lastItem.context.func : lastItem.fn;
							var mutationWarning = "can-define: The " + prop + " property on " +
								canReflect.getName(this) +
								" is being set in " +
								(canReflect.getName(lastFn) || canReflect.getName(lastItem.fn)) +
								". This can cause infinite loops and performance issues. " +
								"Use the value() behavior for " +
								prop +
								" instead, and listen to other properties and observables with listenTo(). https://canjs.com/doc/can-define.types.value.html";
							canLogDev.warn(mutationWarning);
							queues.logStack();
						}
					}
					//!steal-remove-end

					this.dispatch(dispatched, [newVal, current]);
				}
			};
		},
		setter: function(prop, setter, getCurrent, setEvents, hasGetter) {
			return function(value) {
				//!steal-remove-start
				var asyncTimer;
				//!steal-remove-end

				var self = this;

				// call the setter, if returned value is undefined,
				// this means the setter is async so we
				// do not call update property and return right away

				queues.batch.start();
				var setterCalled = false,
					current = getCurrent.call(this),
					setValue = setter.call(this, value, function(value) {
						setEvents.call(self, value);

						setterCalled = true;
						//!steal-remove-start
						if(true) {
							clearTimeout(asyncTimer);
						}
						//!steal-remove-end
					}, current);

				if (setterCalled) {
					queues.batch.stop();
				} else {
					if (hasGetter) {
						// we got a return value
						if (setValue !== undefined) {
							// if the current `set` value is returned, don't set
							// because current might be the `lastSetVal` of the internal compute.
							if (current !== setValue) {
								setEvents.call(this, setValue);
							}
							queues.batch.stop();
						}
						// this is a side effect, it didn't take a value
						// so use the original set value
						else if (setter.length === 0) {
							setEvents.call(this, value);
							queues.batch.stop();
							return;
						}
						// it took a value
						else if (setter.length === 1) {
							// if we have a getter, and undefined was returned,
							// we should assume this is setting the getters properties
							// and we shouldn't do anything.
							queues.batch.stop();
						}
						// we are expecting something
						else {
							//!steal-remove-start
							if(true) {
								asyncTimer = setTimeout(function() {
									canLogDev.warn('can-define: Setter "' + canReflect.getName(self)+"."+prop + '" did not return a value or call the setter callback.');
								}, canLogDev.warnTimeout);
							}
							//!steal-remove-end
							queues.batch.stop();
							return;
						}
					} else {
						// we got a return value
						if (setValue !== undefined) {
							// if the current `set` value is returned, don't set
							// because current might be the `lastSetVal` of the internal compute.
							setEvents.call(this, setValue);
							queues.batch.stop();
						}
						// this is a side effect, it didn't take a value
						// so use the original set value
						else if (setter.length === 0) {
							setEvents.call(this, value);
							queues.batch.stop();
							return;
						}
						// it took a value
						else if (setter.length === 1) {
							// if we don't have a getter, we should probably be setting the
							// value to undefined
							setEvents.call(this, undefined);
							queues.batch.stop();
						}
						// we are expecting something
						else {
							//!steal-remove-start
							if(true) {
								asyncTimer = setTimeout(function() {
									canLogDev.warn('can/map/setter.js: Setter "' + canReflect.getName(self)+"."+prop + '" did not return a value or call the setter callback.');
								}, canLogDev.warnTimeout);
							}
							//!steal-remove-end
							queues.batch.stop();
							return;
						}
					}


				}
			};
		},
		type: function(prop, type, set) {
			function setter(newValue) {
				return set.call(this, type.call(this, newValue, prop));
			}
			if(isDefineType(type)) {
				// TODO: remove this `canDefineType` check in a future release.
				if(type.canDefineType) {
					return setter;
				} else {
					return function setter(newValue){
						return set.call(this, canReflect.convert(newValue, type));
					};
				}
			}
			// If type is a nested object: `type: {foo: "string", bar: "number"}`
			if (typeof type === "object") {
				return make.set.Type(prop, type, set);
			} else {
				return setter;
			}
		},
		Type: function(prop, Type, set) {
			// `type`: {foo: "string"}
			if(Array.isArray(Type) && define.DefineList) {
				Type = define.DefineList.extend({
					"#": Type[0]
				});
			} else if (typeof Type === "object") {
				if(define.DefineMap) {
					Type = define.DefineMap.extend(Type);
				} else {
					Type = define.Constructor(Type);
				}
			}
			return function(newValue) {
				if (newValue instanceof Type || newValue == null) {
					return set.call(this, newValue);
				} else {
					return set.call(this, new Type(newValue));
				}
			};
		}
	},
	// Helpes that indicate what the event type should be.  These probably aren't needed.
	eventType: {
		data: function(prop) {
			return function(newVal, oldVal) {
				return oldVal !== undefined || this._data.hasOwnProperty(prop) ? "set" : "add";
			};
		},
		computed: function() {
			return function() {
				return "set";
			};
		}
	},
	// Helpers that read the data in a non-observable way.
	read: {
		data: function(prop) {
			return function() {
				return this._data[prop];
			};
		},
		computed: function(prop) {
			// might want to protect this
			return function() {
				return canReflect.getValue( this._computed[prop].compute );
			};
		},
		lastSet: function(prop) {
			return function() {
				var observable = this._computed[prop].compute;
				if(observable.lastSetValue) {
					return canReflect.getValue(observable.lastSetValue);
				}
			};
		}
	},
	// Helpers that read the data in an observable way.
	get: {
		// uses the default value
		defaultValue: function(prop, definition, typeConvert, callSetter) {
			return function() {
				var value = definition.default;
				if (value !== undefined) {
					if (typeof value === "function") {
						value = value.call(this);
					}
					value = typeConvert.call(this, value);
				}
				else {
					var Default = definition.Default;
					if (Default) {
						value = typeConvert.call(this,new Default());
					}
				}
				if(definition.set) {
					// TODO: there's almost certainly a faster way of making this happen
					// But this is maintainable.

					var VALUE;
					var sync = true;

					var setter = make.set.setter(prop, definition.set, function(){}, function(value){
						if(sync) {
							VALUE = value;
						} else {
							callSetter.call(this, value);
						}
					}, definition.get);

					setter.call(this,value);
					sync= false;

					// VALUE will be undefined if the callback is never called.
					return VALUE;


				}
				return value;
			};
		},
		data: function(prop) {
			return function() {
				if (!this[inSetupSymbol]) {
					ObservationRecorder.add(this, prop);
				}

				return this._data[prop];
			};
		},
		computed: function(prop) {
			return function(val) {
				var compute = this._computed[prop].compute;
				if (ObservationRecorder.isRecording()) {
					ObservationRecorder.add(this, prop);
					if (!canReflect.isBound(compute)) {
						Observation.temporarilyBind(compute);
					}
				}

				return peek(compute);
			};
		}
	}
};

define.behaviors = ["get", "set", "value", "Value", "type", "Type", "serialize"];

// This cleans up a particular behavior and adds it to the definition
var addBehaviorToDefinition = function(definition, behavior, value) {
	if(behavior === "enumerable") {
		// treat enumerable like serialize
		definition.serialize = !!value;
	}
	else if(behavior === "type") {
		var behaviorDef = value;
		if(typeof behaviorDef === "string") {
			behaviorDef = define.types[behaviorDef];
			if(typeof behaviorDef === "object" && !isDefineType(behaviorDef)) {
				assign(definition, behaviorDef);
				behaviorDef = behaviorDef[behavior];
			}
		}
		if (typeof behaviorDef !== 'undefined') {
			definition[behavior] = behaviorDef;
		}
	}
	else {
		definition[behavior] = value;
	}
};

// This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)
// Currently, this is adding default behavior
// copying `type` over, and even cleaning up the final definition object
makeDefinition = function(prop, def, defaultDefinition, typePrototype) {

	var definition = {};

	canReflect.eachKey(def, function(value, behavior) {
		addBehaviorToDefinition(definition, behavior, value);
	});
	// only add default if it doesn't exist
	canReflect.eachKey(defaultDefinition, function(value, prop){
		if(definition[prop] === undefined) {
			if(prop !== "type" && prop !== "Type") {
				definition[prop] = value;
			}
		}
	});

	// normalize Type that implements can.new
	if(def.Type) {
		var value = def.Type;

		var serialize = value[serializeSymbol];
		if(serialize) {
			definition.serialize = function(val){
				return serialize.call(val);
			};
		}
		if(value[newSymbol]) {
			definition.type = value;
			delete definition.Type;
		}
	}

	// We only want to add a defaultDefinition if def.type is not a string
	// if def.type is a string it is handled in addDefinition
	if(typeof def.type !== 'string') {
		// if there's no type definition, take it from the defaultDefinition
		if(!definition.type && !definition.Type) {
            var defaultsCopy = canReflect.assignMap({},defaultDefinition);
            definition = canReflect.assignMap(defaultsCopy, definition);
		}

		if( canReflect.size(definition) === 0 ) {
			definition.type = define.types["*"];
		}
	}
	cleanUpDefinition(prop, definition, true, typePrototype);
	return definition;
};

// called by `can.defineInstanceKey` and `getDefinitionsAndMethods`
// returns the value or the definition object.
// calls makeDefinition
// This is dealing with a string value
getDefinitionOrMethod = function(prop, value, defaultDefinition, typePrototype){
	// Clean up the value to make it a definition-like object
	var definition;
	if(typeof value === "string") {
		definition = {type: value};
	}
    // copies a `Type`'s methods over
	else if(value && (value[serializeSymbol] || value[newSymbol]) ) {
		definition = { Type: value };
	}
	else if(typeof value === "function") {
		if(canReflect.isConstructorLike(value)) {
			definition = {Type: value};
		}
		// or leaves as a function
	} else if( Array.isArray(value) ) {
		definition = {Type: value};
	} else if( canReflect.isPlainObject(value) ){
		definition = value;
	}

	if(definition) {
		return makeDefinition(prop, definition, defaultDefinition, typePrototype);
	}
	else {
		return value;
	}
};
// called by can.define
getDefinitionsAndMethods = function(defines, baseDefines, typePrototype) {
	// make it so the definitions include base definitions on the proto
	var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
	var methods = {};
	// first lets get a default if it exists
	var defaults = defines["*"],
		defaultDefinition;
	if(defaults) {
		delete defines["*"];
		defaultDefinition = getDefinitionOrMethod("*", defaults, {});
	} else {
		defaultDefinition = Object.create(null);
	}

	eachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {

		var value;
		if(propertyDescriptor.get || propertyDescriptor.set) {
			value = {get: propertyDescriptor.get, set: propertyDescriptor.set};
		} else {
			value = propertyDescriptor.value;
		}

		if(prop === "constructor") {
			methods[prop] = value;
			return;
		} else {
			var result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);
			if(result && typeof result === "object" && canReflect.size(result) > 0) {
				definitions[prop] = result;
			}
			else {
				// Removed adding raw values that are not functions
				if (typeof result === 'function') {
					methods[prop] = result;
				}
				//!steal-remove-start
				else if (typeof result !== 'undefined') {
					if(true) {
                    	// Ex: {prop: 0}
						canLogDev.error(canReflect.getName(typePrototype)+"."+prop + " does not match a supported propDefinition. See: https://canjs.com/doc/can-define.types.propDefinition.html");
					}
				}
				//!steal-remove-end
			}
		}
	});
	if(defaults) {
		// we should move this property off the prototype.
		defineConfigurableAndNotEnumerable(defines,"*", defaults);
	}
	return {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};
};

eventsProto = eventQueue({});

function setupComputed(instance, eventName) {
	var computedBinding = instance._computed && instance._computed[eventName];
	if (computedBinding && computedBinding.compute) {
		if (!computedBinding.count) {
			computedBinding.count = 1;
			canReflect.onValue(computedBinding.compute, computedBinding.handler, "notify");
			computedBinding.oldValue = peek(computedBinding.compute);
		} else {
			computedBinding.count++;
		}

	}
}
function teardownComputed(instance, eventName){
	var computedBinding = instance._computed && instance._computed[eventName];
	if (computedBinding) {
		if (computedBinding.count === 1) {
			computedBinding.count = 0;
			canReflect.offValue(computedBinding.compute, computedBinding.handler,"notify");
		} else {
			computedBinding.count--;
		}
	}
}

var canMetaSymbol = canSymbol.for("can.meta");
assign(eventsProto, {
	_eventSetup: function() {},
	_eventTeardown: function() {},
	addEventListener: function(eventName, handler, queue) {
		setupComputed(this, eventName);
		return eventQueue.addEventListener.apply(this, arguments);
	},

	// ### unbind
	// Stops listening to an event.
	// If this is the last listener of a computed property,
	// stop forwarding events of the computed property to this map.
	removeEventListener: function(eventName, handler) {
		teardownComputed(this, eventName);
		return eventQueue.removeEventListener.apply(this, arguments);

	}
});
eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;


var onKeyValueSymbol = canSymbol.for("can.onKeyValue");
var offKeyValueSymbol = canSymbol.for("can.offKeyValue");

canReflect.assignSymbols(eventsProto,{
	"can.onKeyValue": function(key){
		setupComputed(this, key);
		return eventQueue[onKeyValueSymbol].apply(this, arguments);
	},
	"can.offKeyValue": function(key){
		teardownComputed(this, key);
		return eventQueue[offKeyValueSymbol].apply(this, arguments);
	}
});

delete eventsProto.one;

define.setup = function(props, sealed) {
	Object.defineProperty(this,"constructor", {value: this.constructor, enumerable: false, writable: false});
	Object.defineProperty(this,canMetaSymbol, {value: Object.create(null), enumerable: false, writable: false});

	/* jshint -W030 */

	var definitions = this._define.definitions;
	var instanceDefinitions = Object.create(null);
	var map = this;
	canReflect.eachKey(props, function(value, prop){
		if(definitions[prop] !== undefined) {
			map[prop] = value;
		} else {
			define.expando(map, prop, value);
		}
	});
	if(canReflect.size(instanceDefinitions) > 0) {
		defineConfigurableAndNotEnumerable(this, "_instanceDefinitions", instanceDefinitions);
	}
	// only seal in dev mode for performance reasons.
	//!steal-remove-start
	if(true) {
		this._data;
		this._computed;
		if(sealed !== false) {
			Object.seal(this);
		}
	}
	//!steal-remove-end
};


var returnFirstArg = function(arg){
	return arg;
};

define.expando = function(map, prop, value) {
	if(define._specialKeys[prop]) {
		// ignores _data and _computed
		return true;
	}
	// first check if it's already a constructor define
	var constructorDefines = map._define.definitions;
	if(constructorDefines && constructorDefines[prop]) {
		return;
	}
	// next if it's already on this instances
	var instanceDefines = map._instanceDefinitions;
	if(!instanceDefines) {
		if(Object.isSealed(map)) {
			return;
		}
		Object.defineProperty(map, "_instanceDefinitions", {
			configurable: true,
			enumerable: false,
			writable: true,
			value: {}
		});
		instanceDefines = map._instanceDefinitions;
	}
	if(!instanceDefines[prop]) {
		var defaultDefinition = map._define.defaultDefinition || {type: define.types.observable};
		define.property(map, prop, defaultDefinition, {},{});
		// possibly convert value to List or DefineMap
		if(defaultDefinition.type) {
			map._data[prop] = define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);
		} else if (defaultDefinition.Type && canReflect.isConstructorLike(defaultDefinition.Type)) {
			map._data[prop] = define.make.set.Type(prop, defaultDefinition.Type, returnFirstArg).call(map, value);
		} else {
			map._data[prop] = define.types.observable(value);
		}

		instanceDefines[prop] = defaultDefinition;
		if(!map[inSetupSymbol]) {
			queues.batch.start();
			map.dispatch({
				action: "can.keys",
				target: map,
				type: "can.keys" // TODO: Remove in 6.0
			});
			if(Object.prototype.hasOwnProperty.call(map._data, prop)) {
				map.dispatch({
					action: "add",
					target: map,
					value:  map._data[prop],
					oldValue: undefined,
					key: prop,
					type: prop, // TODO: Remove in 6.0
					patches: [{type: "add", key: prop, value: map._data[prop]}],
				},[map._data[prop], undefined]);
			} else {
				map.dispatch({
					type: "set",
					target: map,
					patches: [{type: "add", key: prop, value: map._data[prop]}],
				},[map._data[prop], undefined]);
			}
			queues.batch.stop();
		}
		return true;
	}
};
define.replaceWith = defineLazyValue;
define.eventsProto = eventsProto;
define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
define.make = make;
define.getDefinitionOrMethod = getDefinitionOrMethod;
define._specialKeys = {_data: true, _computed: true};
var simpleGetterSetters = {};
define.makeSimpleGetterSetter = function(prop){
	if(simpleGetterSetters[prop] === undefined) {

		var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );

		simpleGetterSetters[prop] = {
			get: make.get.data(prop),
			set: function(newVal){
				return setter.call(this, define.types.observable(newVal));
			},
			enumerable: true,
            configurable: true
		};
	}
	return simpleGetterSetters[prop];
};

define.Iterator = function(obj){
	this.obj = obj;
	this.definitions = Object.keys(obj._define.definitions);
	this.instanceDefinitions = obj._instanceDefinitions ?
		Object.keys(obj._instanceDefinitions) :
		Object.keys(obj);
	this.hasGet = typeof obj.get === "function";
};

define.Iterator.prototype.next = function(){
	var key;
	if(this.definitions.length) {
		key = this.definitions.shift();

		// Getters should not be enumerable
		var def = this.obj._define.definitions[key];
		if(def.get) {
			return this.next();
		}
	} else if(this.instanceDefinitions.length) {
		key = this.instanceDefinitions.shift();
	} else {
		return {
			value: undefined,
			done: true
		};
	}

	return {
		value: [
			key,
			this.hasGet ? this.obj.get(key) : this.obj[key]
		],
		done: false
	};
};



function isObservableValue(obj){
	return canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);
}

define.types = {
	// To be made into a type ... this is both lazy {time: '123-456'}
	'date': MaybeDate,
	'number': MaybeNumber,
	'boolean': MaybeBoolean,
	'observable': function(newVal) {
			if(Array.isArray(newVal) && define.DefineList) {
					newVal = new define.DefineList(newVal);
			}
			else if(canReflect.isPlainObject(newVal) &&  define.DefineMap) {
					newVal = new define.DefineMap(newVal);
			}
			return newVal;
	},
	'stringOrObservable': function(newVal) {
		if(Array.isArray(newVal)) {
			return new define.DefaultList(newVal);
		}
		else if(canReflect.isPlainObject(newVal)) {
			return new define.DefaultMap(newVal);
		}
		else {
			return canReflect.convert( newVal, define.types.string);
		}
	},
	/**
	 * Implements HTML-style boolean logic for attribute strings, where
	 * any string, including "", is truthy.
	 */
	'htmlbool': function(val) {
		if (val === '') {
			return true;
		}
		return !!stringToAny(val);
	},
	'*': function(val) {
		return val;
	},
	'any': function(val) {
		return val;
	},
	'string': MaybeString,

	'compute': {
		set: function(newValue, setVal, setErr, oldValue) {
			if (isObservableValue(newValue) ) {
				return newValue;
			}
			if (isObservableValue(oldValue)) {
				canReflect.setValue(oldValue,newValue);
				return oldValue;
			}
			return newValue;
		},
		get: function(value) {
			return isObservableValue(value) ? canReflect.getValue(value) : value;
		}
	}
};

define.updateSchemaKeys = function(schema, definitions) {
	for(var prop in definitions) {
		var definition = definitions[prop];
		if(definition.serialize !== false ) {
			if(definition.Type) {
				schema.keys[prop] = definition.Type;
			} else if(definition.type) {
				schema.keys[prop] = definition.type;
			} else {
				schema.keys[prop] = function(val){ return val; };
			}
			 // some unknown type
			if(definitions[prop].identity === true) {
				schema.identity.push(prop);
			}
		}
	}
	return schema;
};


/***/ }),

/***/ "./node_modules/can-define/define-helpers/define-helpers.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-define/define-helpers/define-helpers.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var define = __webpack_require__(/*! can-define */ "./node_modules/can-define/can-define.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var ensureMeta = __webpack_require__(/*! ../ensure-meta */ "./node_modules/can-define/ensure-meta.js");

var defineHelpers = {
	// returns `true` if the value was defined and set
	defineExpando: define.expando,
	reflectSerialize: function(unwrapped){
		var constructorDefinitions = this._define.definitions;
		var defaultDefinition = this._define.defaultDefinition;
		this.forEach(function(val, name){
			var propDef = constructorDefinitions[name];

			if(propDef && typeof propDef.serialize === "function") {
				val = propDef.serialize.call(this, val, name);
			}
			else if(defaultDefinition && typeof defaultDefinition.serialize === "function") {
				val =  defaultDefinition.serialize.call(this, val, name);
			} else {
				val = canReflect.serialize(val);
			}
			if(val !== undefined) {
				unwrapped[name] = val;
			}
		}, this);
		return unwrapped;
	},
	reflectUnwrap: function(unwrapped){
		this.forEach(function(value, key){
			if(value !== undefined) {
				unwrapped[key] = canReflect.unwrap(value);
			}
		});
		return unwrapped;
	},
	log: function(key) {
		var instance = this;

		var quoteString = function quoteString(x) {
			return typeof x === "string" ? JSON.stringify(x) : x;
		};

		var meta = ensureMeta(instance);
		var allowed = meta.allowedLogKeysSet || new Set();
		meta.allowedLogKeysSet = allowed;

		if (key) {
			allowed.add(key);
		}

		meta._log = function(event, data) {
			var type = event.type;

			if (
				type === "can.onPatches" || (key && !allowed.has(type)) ||
				type === "can.keys" || (key && !allowed.has(type))
				) {
				return;
			}

			if (type === "add" || type === "remove") {
				dev.log(
					canReflect.getName(instance),
					"\n how   ", quoteString(type),
					"\n what  ", quoteString(data[0]),
					"\n index ", quoteString(data[1])
				);
			} else {
				// log `length` and `propertyName` events
				dev.log(
					canReflect.getName(instance),
					"\n key ", quoteString(type),
					"\n is  ", quoteString(data[0]),
					"\n was ", quoteString(data[1])
				);
			}
		};
	},
	deleteKey: function(prop){
		var instanceDefines = this._instanceDefinitions;
		if(instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {
			delete instanceDefines[prop];
			queues.batch.start();
			this.dispatch({
				action: "can.keys",
				type: "can.keys", // TODO: Remove in 6.0
				target: this
			});
			var oldValue = this._data[prop];
			if(oldValue !== undefined) {
				delete this._data[prop];
				//delete this[prop];
				this.dispatch({
					action: "delete",
					key: prop,
					value: undefined,
					oldValue: oldValue,
					type: prop, // TODO: Remove in 6.0
					target: this,
					patches: [{type: "delete", key: prop}],
				},[undefined,oldValue]);
			}
			queues.batch.stop();
		} else {
			this.set(prop, undefined);
		}
		return this;
	}
};
module.exports = defineHelpers;


/***/ }),

/***/ "./node_modules/can-define/ensure-meta.js":
/*!************************************************!*\
  !*** ./node_modules/can-define/ensure-meta.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// Ensure the "obj" passed as an argument has an object on @@can.meta
module.exports = function ensureMeta(obj) {
	var metaSymbol = canSymbol.for("can.meta");
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect.setKeyValue(obj, metaSymbol, meta);
	}

	return meta;
};


/***/ }),

/***/ "./node_modules/can-define/list/list.js":
/*!**********************************************!*\
  !*** ./node_modules/can-define/list/list.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var define = __webpack_require__(/*! can-define */ "./node_modules/can-define/can-define.js");
var make = define.make;
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");
var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ "./node_modules/can-define/define-helpers/define-helpers.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var diff = __webpack_require__(/*! can-diff/list/list */ "./node_modules/can-diff/list/list.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var singleReference = __webpack_require__(/*! can-single-reference */ "./node_modules/can-single-reference/can-single-reference.js");

var splice = [].splice;
var runningNative = false;

var identity = function(x) {
	return x;
};

// symbols aren't enumerable ... we'd need a version of Object that treats them that way
var localOnPatchesSymbol = "can.patches";

var makeFilterCallback = function(props) {
	return function(item) {
		for (var prop in props) {
			if (item[prop] !== props[prop]) {
				return false;
			}
		}
		return true;
	};
};

var onKeyValue = define.eventsProto[canSymbol.for("can.onKeyValue")];
var offKeyValue = define.eventsProto[canSymbol.for("can.offKeyValue")];
var getSchemaSymbol = canSymbol.for("can.getSchema");
var inSetupSymbol = canSymbol.for("can.initializing");

function getSchema() {
	var definitions = this.prototype._define.definitions;
	var schema = {
		type: "list",
		keys: {}
	};
	schema = define.updateSchemaKeys(schema, definitions);
	if(schema.keys["#"]) {
		schema.values = definitions["#"].Type;
		delete schema.keys["#"];
	}

	return schema;
}

/** @add can-define/list/list */
var DefineList = Construct.extend("DefineList",
	/** @static */
	{
		setup: function(base) {
			if (DefineList) {
				addTypeEvents(this);
				var prototype = this.prototype;
				var result = define(prototype, prototype, base.prototype._define);
				define.makeDefineInstanceKey(this, result);

				var itemsDefinition = result.definitions["#"] || result.defaultDefinition;

				if (itemsDefinition) {
					if (itemsDefinition.Type) {
						this.prototype.__type = make.set.Type("*", itemsDefinition.Type, identity);
					} else if (itemsDefinition.type) {
						this.prototype.__type = make.set.type("*", itemsDefinition.type, identity);
					}
				}
				this[getSchemaSymbol] = getSchema;
			}
		}
	},
	/** @prototype */
	{
		// setup for only dynamic DefineMap instances
		setup: function(items) {
			if (!this._define) {
				Object.defineProperty(this, "_define", {
					enumerable: false,
					value: {
						definitions: {
							length: { type: "number" },
							_length: { type: "number" }
						}
					}
				});
				Object.defineProperty(this, "_data", {
					enumerable: false,
					value: {}
				});
			}
			define.setup.call(this, {}, false);
			Object.defineProperty(this, "_length", {
				enumerable: false,
				configurable: true,
				writable: true,
				value: 0
			});
			if (items) {
				this.splice.apply(this, [ 0, 0 ].concat(canReflect.toArray(items)));
			}
		},
		__type: define.types.observable,
		_triggerChange: function(attr, how, newVal, oldVal) {

			var index = +attr;
			// `batchTrigger` direct add and remove events...

			// Make sure this is not nested and not an expando
			if ( !isNaN(index)) {
				var itemsDefinition = this._define.definitions["#"];
				var patches, dispatched;
				if (how === 'add') {
					if (itemsDefinition && typeof itemsDefinition.added === 'function') {
						ObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);
					}

					patches = [{type: "splice", insert: newVal, index: index, deleteCount: 0}];
					dispatched = {
						type: how,
						action: "splice",
						insert: newVal,
						index: index,
						deleteCount: 0,
						patches: patches
					};

					//!steal-remove-start
					if(true) {
						dispatched.reasonLog = [ canReflect.getName(this), "added", newVal, "at", index ];
					}
					//!steal-remove-end
					this.dispatch(dispatched, [ newVal, index ]);

				} else if (how === 'remove') {
					if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
						ObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);
					}

					patches = [{type: "splice", index: index, deleteCount: oldVal.length}];
					dispatched = {
						type: how,
						patches: patches,
						action: "splice",
						index: index, deleteCount: oldVal.length,
						target: this
					};
					//!steal-remove-start
					if(true) {
						dispatched.reasonLog = [ canReflect.getName(this), "remove", oldVal, "at", index ];
					}
					//!steal-remove-end
					this.dispatch(dispatched, [ oldVal, index ]);

				} else {
					this.dispatch(how, [ newVal, index ]);
				}
			} else {
				this.dispatch({
					type: "" + attr,
					target: this
				}, [ newVal, oldVal ]);
			}
		},
		get: function(index) {
			if (arguments.length) {
				if(isNaN(index)) {
					ObservationRecorder.add(this, index);
				} else {
					ObservationRecorder.add(this, "length");
				}
				return this[index];
			} else {
				return canReflect.unwrap(this, Map);
			}
		},
		set: function(prop, value) {
			// if we are setting a single value
			if (typeof prop !== "object") {
				// We want change events to notify using integers if we're
				// setting an integer index. Note that <float> % 1 !== 0;
				prop = isNaN(+prop) || (prop % 1) ? prop : +prop;
				if (typeof prop === "number") {
					// Check to see if we're doing a .attr() on an out of
					// bounds index property.
					if (typeof prop === "number" &&
						prop > this._length - 1) {
						var newArr = new Array((prop + 1) - this._length);
						newArr[newArr.length - 1] = value;
						this.push.apply(this, newArr);
						return newArr;
					}
					this.splice(prop, 1, value);
				} else {
					var defined = defineHelpers.defineExpando(this, prop, value);
					if (!defined) {
						this[prop] = value;
					}
				}

			}
			// otherwise we are setting multiple
			else {
				//!steal-remove-start
				if(true) {
					canLogDev.warn('can-define/list/list.prototype.set is deprecated; please use can-define/list/list.prototype.assign or can-define/list/list.prototype.update instead');
				}
				//!steal-remove-end

				//we are deprecating this in #245
				if (canReflect.isListLike(prop)) {
					if (value) {
						this.replace(prop);
					} else {
						canReflect.assignList(this, prop);
					}
				} else {
					canReflect.assignMap(this, prop);
				}
			}
			return this;
		},
		assign: function(prop) {
			if (canReflect.isListLike(prop)) {
				canReflect.assignList(this, prop);
			} else {
				canReflect.assignMap(this, prop);
			}
			return this;
		},
		update: function(prop) {
			if (canReflect.isListLike(prop)) {
				canReflect.updateList(this, prop);
			} else {
				canReflect.updateMap(this, prop);
			}
			return this;
		},
		assignDeep: function(prop) {
			if (canReflect.isListLike(prop)) {
				canReflect.assignDeepList(this, prop);
			} else {
				canReflect.assignDeepMap(this, prop);
			}
			return this;
		},
		updateDeep: function(prop) {
			if (canReflect.isListLike(prop)) {
				canReflect.updateDeepList(this, prop);
			} else {
				canReflect.updateDeepMap(this, prop);
			}
			return this;
		},
		_items: function() {
			var arr = [];
			this._each(function(item) {
				arr.push(item);
			});
			return arr;
		},
		_each: function(callback) {
			for (var i = 0, len = this._length; i < len; i++) {
				callback(this[i], i);
			}
		},
		splice: function(index, howMany) {
			var args = canReflect.toArray(arguments),
				added = [],
				i, len, listIndex,
				allSame = args.length > 2,
				oldLength = this._length;

			index = index || 0;

			// converting the arguments to the right type
			for (i = 0, len = args.length - 2; i < len; i++) {
				listIndex = i + 2;
				args[listIndex] = this.__type(args[listIndex], listIndex);
				added.push(args[listIndex]);

				// Now lets check if anything will change
				if (this[i + index] !== args[listIndex]) {
					allSame = false;
				}
			}

			// if nothing has changed, then return
			if (allSame && this._length <= added.length) {
				return added;
			}

			// default howMany if not provided
			if (howMany === undefined) {
				howMany = args[1] = this._length - index;
			}

			runningNative = true;
			var removed = splice.apply(this, args);
			runningNative = false;

			queues.batch.start();
			if (howMany > 0) {
				// tears down bubbling
				this._triggerChange("" + index, "remove", undefined, removed);
			}
			if (args.length > 2) {
				this._triggerChange("" + index, "add", added, removed);
			}

			this.dispatch('length', [ this._length, oldLength ]);

			queues.batch.stop();
			return removed;
		},

		/**
		 */
		serialize: function() {
			return canReflect.serialize(this, Map);
		}
	}
);

for(var prop in define.eventsProto) {
	Object.defineProperty(DefineList.prototype, prop, {
		enumerable:false,
		value: define.eventsProto[prop],
		writable: true
	});
}

var eventsProtoSymbols = ("getOwnPropertySymbols" in Object) ?
  Object.getOwnPropertySymbols(define.eventsProto) :
  [canSymbol.for("can.onKeyValue"), canSymbol.for("can.offKeyValue")];

eventsProtoSymbols.forEach(function(sym) {
  Object.defineProperty(DefineList.prototype, sym, {
  	configurable: true,
    enumerable:false,
    value: define.eventsProto[sym],
    writable: true
  });
});

// Converts to an `array` of arguments.
var getArgs = function(args) {
	return args[0] && Array.isArray(args[0]) ?
		args[0] :
		canReflect.toArray(args);
};
// Create `push`, `pop`, `shift`, and `unshift`
canReflect.eachKey({
	push: "length",
	unshift: 0
},
	// Adds a method
	// `name` - The method name.
	// `where` - Where items in the `array` should be added.
	function(where, name) {
		var orig = [][name];
		DefineList.prototype[name] = function() {
			// Get the items being added.
			var args = [],
				// Where we are going to add items.
				len = where ? this._length : 0,
				i = arguments.length,
				res, val;

			// Go through and convert anything to a `map` that needs to be converted.
			while (i--) {
				val = arguments[i];
				args[i] = this.__type(val, i);
			}

			// Call the original method.
			runningNative = true;
			res = orig.apply(this, args);
			runningNative = false;

			if (!this.comparator || args.length) {
				queues.batch.start();
				this._triggerChange("" + len, "add", args, undefined);
				this.dispatch('length', [ this._length, len ]);
				queues.batch.stop();
			}

			return res;
		};
	});

canReflect.eachKey({
	pop: "length",
	shift: 0
},
	// Creates a `remove` type method
	function(where, name) {
		var orig = [][name];
		DefineList.prototype[name] = function() {
			if (!this._length) {
				// For shift and pop, we just return undefined without
				// triggering events.
				return undefined;
			}

			var args = getArgs(arguments),
				len = where && this._length ? this._length - 1 : 0,
				oldLength = this._length ? this._length : 0,
				res;

			// Call the original method.
			runningNative = true;
			res = orig.apply(this, args);
			runningNative = false;

			// Create a change where the args are
			// `len` - Where these items were removed.
			// `remove` - Items removed.
			// `undefined` - The new values (there are none).
			// `res` - The old, removed values (should these be unbound).
			queues.batch.start();
			this._triggerChange("" + len, "remove", undefined, [ res ]);
			this.dispatch('length', [ this._length, oldLength ]);
			queues.batch.stop();

			return res;
		};
	});

canReflect.eachKey({
	"map": 3,
	"filter": 3,
	"reduce": 4,
	"reduceRight": 4,
	"every": 3,
	"some": 3
},
function a(fnLength, fnName) {
	DefineList.prototype[fnName] = function() {
		var self = this;
		var args = [].slice.call(arguments, 0);
		var callback = args[0];
		var thisArg = args[fnLength - 1] || self;

		if (typeof callback === "object") {
			callback = makeFilterCallback(callback);
		}

		args[0] = function() {
			var cbArgs = [].slice.call(arguments, 0);
			// use .get(index) to ensure observation added.
			// the arguments are (item, index) or (result, item, index)
			cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
			return callback.apply(thisArg, cbArgs);
		};
		var ret = Array.prototype[fnName].apply(this, args);

		if(fnName === "map") {
			return new DefineList(ret);
		}
		else if(fnName === "filter") {
			return new self.constructor(ret);
		} else {
			return ret;
		}
	};
});

assign(DefineList.prototype, {
	includes: (function(){
		var arrayIncludes =  Array.prototype.includes;
		if(arrayIncludes){
			return function includes() {
				return arrayIncludes.apply(this, arguments);
			};
		} else {
			return function includes() {
				throw new Error("DefineList.prototype.includes must have Array.prototype.includes available. Please add a polyfill to this environment.");
			};
		}
	})(),
	indexOf: function(item, fromIndex) {
		for (var i = fromIndex || 0, len = this.length; i < len; i++) {
			if (this.get(i) === item) {
				return i;
			}
		}
		return -1;
	},
	lastIndexOf: function(item, fromIndex) {
		fromIndex = typeof fromIndex === "undefined" ? this.length - 1: fromIndex;
		for (var i = fromIndex; i >= 0; i--) {
			if (this.get(i) === item) {
				return i;
			}
		}
		return -1;
	},
	join: function() {
		ObservationRecorder.add(this, "length");
		return [].join.apply(this, arguments);
	},
	reverse: function() {
		// this shouldn't be observable
		var list = [].reverse.call(this._items());
		return this.replace(list);
	},
	slice: function() {
		// tells computes to listen on length for changes.
		ObservationRecorder.add(this, "length");
		var temp = Array.prototype.slice.apply(this, arguments);
		return new this.constructor(temp);
	},
	concat: function() {
		var args = [];
		// Go through each of the passed `arguments` and
		// see if it is list-like, an array, or something else
		canReflect.eachIndex(arguments, function(arg) {
			if (canReflect.isListLike(arg)) {
				// If it is list-like we want convert to a JS array then
				// pass each item of the array to this.__type
				var arr = Array.isArray(arg) ? arg : canReflect.toArray(arg);
				arr.forEach(function(innerArg) {
					args.push(this.__type(innerArg));
				}, this);
			} else {
				// If it is a Map, Object, or some primitive
				// just pass arg to this.__type
				args.push(this.__type(arg));
			}
		}, this);

		// We will want to make `this` list into a JS array
		// as well (We know it should be list-like), then
		// concat with our passed in args, then pass it to
		// list constructor to make it back into a list
		return new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));
	},
	forEach: function(cb, thisarg) {
		var item;
		for (var i = 0, len = this.length; i < len; i++) {
			item = this.get(i);
			if (cb.call(thisarg || item, item, i, this) === false) {
				break;
			}
		}
		return this;
	},
	replace: function(newList) {
		var patches = diff(this, newList);

		queues.batch.start();
		for (var i = 0, len = patches.length; i < len; i++) {
			this.splice.apply(this, [
				patches[i].index,
				patches[i].deleteCount
			].concat(patches[i].insert));
		}
		queues.batch.stop();

		return this;
	},
	sort: function(compareFunction) {
		var sorting = Array.prototype.slice.call(this);
		Array.prototype.sort.call(sorting, compareFunction);
		this.splice.apply(this, [0,sorting.length].concat(sorting) );
		return this;
	}
});

// Add necessary event methods to this object.
for (var prop in define.eventsProto) {
	DefineList[prop] = define.eventsProto[prop];
	Object.defineProperty(DefineList.prototype, prop, {
		enumerable: false,
		value: define.eventsProto[prop],
		writable: true
	});
}

Object.defineProperty(DefineList.prototype, "length", {
	get: function() {
		if (!this[inSetupSymbol]) {
			ObservationRecorder.add(this, "length");
		}
		return this._length;
	},
	set: function(newVal) {
		if (runningNative) {
			this._length = newVal;
			return;
		}

		// Don't set _length if:
		//  - null or undefined
		//  - a string that doesn't convert to number
		//  - already the length being set
		if (newVal == null || isNaN(+newVal) || newVal === this._length) {
			return;
		}

		if (newVal > this._length - 1) {
			var newArr = new Array(newVal - this._length);
			this.push.apply(this, newArr);
		}
		else {
			this.splice(newVal);
		}
	},
	enumerable: true
});

DefineList.prototype.attr = function(prop, value) {
	canLog.warn("DefineMap::attr shouldn't be called");
	if (arguments.length === 0) {
		return this.get();
	} else if (prop && typeof prop === "object") {
		return this.set.apply(this, arguments);
	} else if (arguments.length === 1) {
		return this.get(prop);
	} else {
		return this.set(prop, value);
	}
};
DefineList.prototype.item = function(index, value) {
	if (arguments.length === 1) {
		return this.get(index);
	} else {
		return this.set(index, value);
	}
};
DefineList.prototype.items = function() {
	canLog.warn("DefineList::get should should be used instead of DefineList::items");
	return this.get();
};

var defineListProto = {
	// type
	"can.isMoreListLikeThanMapLike": true,
	"can.isMapLike": true,
	"can.isListLike": true,
	"can.isValueLike": false,
	// get/set
	"can.getKeyValue": DefineList.prototype.get,
	"can.setKeyValue": DefineList.prototype.set,

	// Called for every reference to a property in a template
	// if a key is a numerical index then translate to length event
	"can.onKeyValue": function(key, handler, queue) {
		var translationHandler;
		if (isNaN(key)) {
			return onKeyValue.apply(this, arguments);
		}
		else {
			translationHandler = function() {
				handler(this[key]);
			};
			//!steal-remove-start
			if(true) {
				Object.defineProperty(translationHandler, "name", {
					value: "translationHandler(" + key + ")::" + canReflect.getName(this) + ".onKeyValue('length'," + canReflect.getName(handler) + ")",
				});
			}
			//!steal-remove-end
			singleReference.set(handler, this, translationHandler, key);
			return onKeyValue.call(this, 'length',  translationHandler, queue);
		}
	},
	// Called when a property reference is removed
	"can.offKeyValue": function(key, handler, queue) {
		var translationHandler;
		if ( isNaN(key)) {
			return offKeyValue.apply(this, arguments);
		}
		else {
			translationHandler = singleReference.getAndDelete(handler, this, key);
			return offKeyValue.call(this, 'length',  translationHandler, queue);
		}
	},

	"can.deleteKeyValue": function(prop) {
		// convert string key to number index if key can be an integer:
		//   isNaN if prop isn't a numeric representation
		//   (prop % 1) if numeric representation is a float
		//   In both of the above cases, leave as string.
		prop = isNaN(+prop) || (prop % 1) ? prop : +prop;
		if(typeof prop === "number") {
			this.splice(prop, 1);
		} else if(prop === "length" || prop === "_length") {
			return; // length must not be deleted
		} else {
			this.set(prop, undefined);
		}
		return this;
	},
	// shape get/set
	"can.assignDeep": function(source){
		queues.batch.start();
		canReflect.assignList(this, source);
		queues.batch.stop();
	},
	"can.updateDeep": function(source){
		queues.batch.start();
		this.replace(source);
		queues.batch.stop();
	},

	// observability
	"can.keyHasDependencies": function(key) {
		return !!(this._computed && this._computed[key] && this._computed[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computed && this._computed[key] && this._computed[key].compute) {
			ret = {};
			ret.valueDependencies = new Set();
			ret.valueDependencies.add(this._computed[key].compute);
		}
		return ret;
	},
	/*"can.onKeysAdded": function(handler,queue) {
		this[canSymbol.for("can.onKeyValue")]("add", handler,queue);
	},
	"can.onKeysRemoved": function(handler,queue) {
		this[canSymbol.for("can.onKeyValue")]("remove", handler,queue);
	},*/
	"can.splice": function(index, deleteCount, insert){
		this.splice.apply(this, [index, deleteCount].concat(insert));
	},
	"can.onPatches": function(handler,queue){
		this[canSymbol.for("can.onKeyValue")](localOnPatchesSymbol, handler,queue);
	},
	"can.offPatches": function(handler,queue) {
		this[canSymbol.for("can.offKeyValue")](localOnPatchesSymbol, handler,queue);
	}
};

//!steal-remove-start
if(true) {
	defineListProto["can.getName"] = function() {
		return canReflect.getName(this.constructor) + "[]";
	};
}
//!steal-remove-end

canReflect.assignSymbols(DefineList.prototype, defineListProto);

canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function() {
	var index = -1;
	if(typeof this.length !== "number") {
		this.length = 0;
	}
	return {
		next: function() {
			index++;
			return {
				value: this[index],
				done: index >= this.length
			};
		}.bind(this)
	};
});

//!steal-remove-start
if(true) {
	// call `list.log()` to log all event changes
	// pass `key` to only log the matching event, e.g: `list.log("add")`
	DefineList.prototype.log = defineHelpers.log;
}
//!steal-remove-end

define.DefineList = DefineList;

module.exports = ns.DefineList = DefineList;


/***/ }),

/***/ "./node_modules/can-define/map/map.js":
/*!********************************************!*\
  !*** ./node_modules/can-define/map/map.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var define = __webpack_require__(/*! can-define */ "./node_modules/can-define/can-define.js");
var defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ "./node_modules/can-define/define-helpers/define-helpers.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");
var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");

var keysForDefinition = function(definitions) {
	var keys = [];
	for(var prop in definitions) {
		var definition = definitions[prop];
		if(typeof definition !== "object" || ("serialize" in definition ? !!definition.serialize : !definition.get)) {
			keys.push(prop);
		}
	}
	return keys;
};

function assign(source) {
	queues.batch.start();
	canReflect.assignMap(this, source || {});
	queues.batch.stop();
}
function update(source) {
	queues.batch.start();
	canReflect.updateMap(this, source || {});
	queues.batch.stop();
}
function assignDeep(source){
	queues.batch.start();
	// TODO: we should probably just throw an error instead of cleaning
	canReflect.assignDeepMap(this, source || {});
	queues.batch.stop();
}
function updateDeep(source){
	queues.batch.start();
	// TODO: we should probably just throw an error instead of cleaning
	canReflect.updateDeepMap(this, source || {});
	queues.batch.stop();
}
function setKeyValue(key, value) {
	var defined = defineHelpers.defineExpando(this, key, value);
	if(!defined) {
		this[key] = value;
	}
}
function getKeyValue(key) {
	var value = this[key];
	if(value !== undefined || key in this || Object.isSealed(this)) {
		return value;
	} else {
		ObservationRecorder.add(this, key);
		return this[key];
	}
}

var getSchemaSymbol = canSymbol.for("can.getSchema");

function getSchema() {
	var def = this.prototype._define;
	var definitions = def ? def.definitions : {};
	var schema = {
		type: "map",
		identity: [],
		keys: {}
	};
	return define.updateSchemaKeys(schema, definitions);
}

var sealedSetup = function(props){
	define.setup.call(
		this,
		props || {},
		this.constructor.seal
	);
};


var DefineMap = Construct.extend("DefineMap",{
	setup: function(base){
		var key,
			prototype = this.prototype;
		if(DefineMap) {
			// we have already created
			var result = define(prototype, prototype, base.prototype._define);
				define.makeDefineInstanceKey(this, result);

			addTypeEvents(this);
			for(key in DefineMap.prototype) {
				define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
			}
			// If someone provided their own setup, we call that.
			if(prototype.setup === DefineMap.prototype.setup) {
				define.defineConfigurableAndNotEnumerable(prototype, "setup", sealedSetup);
			}

			var _computedGetter = Object.getOwnPropertyDescriptor(prototype, "_computed").get;
			Object.defineProperty(prototype, "_computed", {
				configurable: true,
				enumerable: false,
				get: function(){
					if(this === prototype) {
						return;
					}
					return _computedGetter.call(this, arguments);
				}
			});
		} else {
			for(key in prototype) {
				define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
			}
		}
		define.defineConfigurableAndNotEnumerable(prototype, "constructor", this);
		this[getSchemaSymbol] = getSchema;
	}
},{
	// setup for only dynamic DefineMap instances
	setup: function(props, sealed){
		if(!this._define) {
			Object.defineProperty(this,"_define",{
				enumerable: false,
				value: {
					definitions: {}
				}
			});
			Object.defineProperty(this,"_data",{
				enumerable: false,
				value: {}
			});
		}
		define.setup.call(
			this,
			props || {},
			sealed === true
		);
	},
	get: function(prop){
		if(prop) {
			return getKeyValue.call(this, prop);
		} else {
			return canReflect.unwrap(this, Map);
		}
	},
	set: function(prop, value){
		if(typeof prop === "object") {
			//!steal-remove-start
			if(true) {
				canLogDev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');
			}
			//!steal-remove-end
			if(value === true) {
				updateDeep.call(this, prop);
			} else {
				assignDeep.call(this, prop);
			}

		} else {
			setKeyValue.call(this, prop, value);
		}

		return this;
	},
	assignDeep: function(prop) {
		assignDeep.call(this, prop);
		return this;
	},
	updateDeep: function(prop) {
		updateDeep.call(this, prop);
		return this;
	},
	assign: function(prop) {
		assign.call(this, prop);
		return this;
	},
	update: function(prop) {
		update.call(this, prop);
		return this;
	},
	serialize: function () {
		return canReflect.serialize(this, Map);
	},
	deleteKey: defineHelpers.deleteKey,
	forEach: (function(){

		var forEach = function(list, cb, thisarg){
			return canReflect.eachKey(list, cb, thisarg);
		},
			noObserve = ObservationRecorder.ignore(forEach);

		return function(cb, thisarg, observe) {
			return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
		};

	})(),
	"*": {
		type: define.types.observable
	}
});

var defineMapProto = {
	// -type-
	"can.isMapLike": true,
	"can.isListLike":  false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": getKeyValue,
	"can.setKeyValue": setKeyValue,
	"can.deleteKeyValue": defineHelpers.deleteKey,

	// -shape
	"can.getOwnKeys": function() {
		var keys = canReflect.getOwnEnumerableKeys(this);
		if(this._computed) {
			var computedKeys = canReflect.getOwnKeys(this._computed);

			var key;
			for (var i=0; i<computedKeys.length; i++) {
				key = computedKeys[i];
				if (keys.indexOf(key) < 0) {
					keys.push(key);
				}
			}
		}

		return keys;
	},
	"can.getOwnEnumerableKeys": function(){
		ObservationRecorder.add(this, 'can.keys');
		ObservationRecorder.add(Object.getPrototypeOf(this), 'can.keys');
		return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions) );
	},
	"can.hasOwnKey": function(key) {
		return Object.hasOwnProperty.call(this._define.definitions, key) ||
			( this._instanceDefinitions !== undefined && Object.hasOwnProperty.call(this._instanceDefinitions, key) );
	},
	"can.hasKey": function(key) {
		return (key in this._define.definitions) || (this._instanceDefinitions !== undefined && key in this._instanceDefinitions);
	},

	// -shape get/set-
	"can.assignDeep": assignDeep,
	"can.updateDeep": updateDeep,
	"can.unwrap": defineHelpers.reflectUnwrap,
	"can.serialize": defineHelpers.reflectSerialize,

	// observable
	"can.keyHasDependencies": function(key) {
		return !!(this._computed && this._computed[key] && this._computed[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computed && this._computed[key] && this._computed[key].compute) {
			ret = {};
			ret.valueDependencies = new Set();
			ret.valueDependencies.add(this._computed[key].compute);
		}
		return ret;
	}
};

//!steal-remove-start
if(true) {
	defineMapProto["can.getName"] = function() {
		return canReflect.getName(this.constructor) + "{}";
	};
}
//!steal-remove-end

canReflect.assignSymbols(DefineMap.prototype, defineMapProto);

canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function() {
	return new define.Iterator(this);
});

// Add necessary event methods to this object.
for(var prop in define.eventsProto) {
	DefineMap[prop] = define.eventsProto[prop];
	Object.defineProperty(DefineMap.prototype, prop, {
		enumerable:false,
		value: define.eventsProto[prop],
		writable: true
	});
}
function getSymbolsForIE(obj){
	return Object.getOwnPropertyNames(obj).filter(function(name){
		return name.indexOf("@@symbol") === 0;
	});
}
// Copy symbols over, but they aren't supported in IE
var eventsProtoSymbols = ("getOwnPropertySymbols" in Object) ?
  Object.getOwnPropertySymbols(define.eventsProto) :
  getSymbolsForIE(define.eventsProto);

eventsProtoSymbols.forEach(function(sym) {
  Object.defineProperty(DefineMap.prototype, sym, {
  	configurable: true,
    enumerable:false,
    value: define.eventsProto[sym],
    writable: true
  });
});


//!steal-remove-start
if(true) {
	// call `map.log()` to log all event changes
	// pass `key` to only log the matching property, e.g: `map.log("foo")`
	define.defineConfigurableAndNotEnumerable(DefineMap.prototype, "log", defineHelpers.log);
}
//!steal-remove-end

// tells `can-define` to use this
define.DefineMap = DefineMap;

Object.defineProperty(DefineMap.prototype, "toObject", {
	enumerable: false,
	writable: true,
	value: function(){
		canLog.warn("Use DefineMap::get instead of DefineMap::toObject");
		return this.get();
	}
});

module.exports = ns.DefineMap = DefineMap;


/***/ }),

/***/ "./node_modules/can-deparam/can-deparam.js":
/*!*************************************************!*\
  !*** ./node_modules/can-deparam/can-deparam.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var digitTest = /^\d+$/,
	keyBreaker = /([^\[\]]+)|(\[\])/g,
	paramTest = /([^?#]*)(#.*)?$/,
	entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i,
	startChars = {"#": true,"?": true},
	prep = function (str) {
		if (startChars[str.charAt(0)] === true) {
			str = str.substr(1);
		}
		str = str.replace(/\+/g, ' ');

		try {
			return decodeURIComponent(str);
		}
		catch (e) {
			return decodeURIComponent(str.replace(entityRegex, function(match, hex) {
				return '%25' + hex;
			}));
		}
	};

function isArrayLikeName(name) {
	return digitTest.test(name) || name === '[]';
}


function idenity(value){ return value; }

module.exports = namespace.deparam = function (params, valueDeserializer) {
	valueDeserializer = valueDeserializer || idenity;
	var data = {}, pairs, lastPart;
	if (params && paramTest.test(params)) {
		pairs = params.split('&');
		pairs.forEach(function (pair) {
			var parts = pair.split('='),
				key = prep(parts.shift()),
				value = prep(parts.join('=')),
				current = data;
			if (key) {
				parts = key.match(keyBreaker);
				for (var j = 0, l = parts.length - 1; j < l; j++) {
					var currentName = parts[j],
						nextName = parts[j + 1],
						currentIsArray = isArrayLikeName(currentName) && current instanceof Array;
					if (!current[currentName]) {
						if(currentIsArray) {
							current.push( isArrayLikeName(nextName) ? [] : {} );
						} else {
							// If what we are pointing to looks like an `array`
							current[currentName] = isArrayLikeName(nextName) ? [] : {};
						}

					}
					if(currentIsArray) {
						current = current[current.length - 1];
					} else {
						current = current[currentName];
					}

				}
				lastPart = parts.pop();
				if ( isArrayLikeName(lastPart) ) {
					current.push(valueDeserializer(value));
				} else {
					current[lastPart] = valueDeserializer(value);
				}
			}
		});
	}
	return data;
};


/***/ }),

/***/ "./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function assignExceptIdentity(obj, data, schema) {
    if(!schema) {
        schema = canReflect.getSchema(obj);
    }
    if(!schema) {
        throw new Error("can-diff/update-except-id is unable to update without a schema.");
    }
    // copy the keys onto data
    schema.identity.forEach(function(key){
        var id = canReflect.getKeyValue(obj, key);
        if(id!== undefined) {
            canReflect.setKeyValue(data, key, id );
        }
    });

    canReflect.assignDeep(obj, data);
};


/***/ }),

/***/ "./node_modules/can-diff/can-diff.js":
/*!*******************************************!*\
  !*** ./node_modules/can-diff/can-diff.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var deep = __webpack_require__(/*! ./deep/deep */ "./node_modules/can-diff/deep/deep.js"),
    list = __webpack_require__(/*! ./list/list */ "./node_modules/can-diff/list/list.js"),
    map = __webpack_require__(/*! ./map/map */ "./node_modules/can-diff/map/map.js"),
    mergeDeep = __webpack_require__(/*! ./merge-deep/merge-deep */ "./node_modules/can-diff/merge-deep/merge-deep.js"),
    Patcher = __webpack_require__(/*! ./patcher/patcher */ "./node_modules/can-diff/patcher/patcher.js"),
    namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var diff = {
    deep: deep,
    list: list,
    map: map,
    mergeDeep: mergeDeep,
    Patcher: Patcher
};

module.exports = namespace.diff = diff;


/***/ }),

/***/ "./node_modules/can-diff/deep/deep.js":
/*!********************************************!*\
  !*** ./node_modules/can-diff/deep/deep.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var diffMap = __webpack_require__(/*! ../map/map */ "./node_modules/can-diff/map/map.js"),
    diffList = __webpack_require__(/*! ../list/list */ "./node_modules/can-diff/list/list.js"),
    canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function shouldCheckSet(patch, destVal, sourceVal) {
    return patch.type === "set" && destVal && sourceVal &&
        typeof destVal === "object" &&
        typeof sourceVal === "object";
}

function makeIdentityFromMapSchema(typeSchema) {
    if(typeSchema.identity && typeSchema.identity.length) {
        return function identityCheck(a, b) {
            var aId = canReflect.getIdentity(a, typeSchema),
                bId = canReflect.getIdentity(b, typeSchema);
            return aId === bId;
        };
    }
}

function makeDiffListIdentityComparison(oldList, newList, parentKey, nestedPatches) {
    var listSchema = canReflect.getSchema(oldList),
        typeSchema,
        identityCheckFromSchema,
        oldListLength = canReflect.size( oldList );
    if(listSchema != null) {
        if(listSchema.values != null) {
            typeSchema = canReflect.getSchema(listSchema.values);
        }
    }
    if(typeSchema == null && oldListLength > 0) {
        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );
    }
    if(typeSchema) {
        identityCheckFromSchema = makeIdentityFromMapSchema(typeSchema);
    }


    return function(a, b, aIndex) {
        if(canReflect.isPrimitive(a)) {
            return a === b;
        }
        if(canReflect.isPrimitive(b)) {
            return a === b;
        }
        if(identityCheckFromSchema) {
            if(identityCheckFromSchema(a, b)) {
                var patches = diffDeep(a, b, parentKey ? parentKey+"."+aIndex : ""+aIndex);
                nestedPatches.push.apply(nestedPatches, patches);
                return true;
            }
        }
        return diffDeep(a, b).length === 0;
    };
}

function diffDeep(dest, source, parentKey){

    if (dest && canReflect.isMoreListLikeThanMapLike(dest)) {
        var nestedPatches = [],
            diffingIdentity = makeDiffListIdentityComparison(dest, source, parentKey, nestedPatches);

        var primaryPatches = diffList(dest, source, diffingIdentity).map(function(patch){
            if(parentKey) {
                patch.key = parentKey;
            }
            return patch;
        });

		return nestedPatches.concat(primaryPatches);
	} else {
        parentKey = parentKey ? parentKey+".": "";
		var patches = diffMap(dest, source);
        // any sets we are going to recurse within
        var finalPatches = [];
        patches.forEach(function(patch){
            var key = patch.key;

            patch.key = parentKey + patch.key;
            var destVal = dest && canReflect.getKeyValue(dest, key),
                sourceVal = source && canReflect.getKeyValue(source, key);
            if(shouldCheckSet(patch, destVal, sourceVal)) {

                var deepPatches = diffDeep(destVal, sourceVal, patch.key);
                finalPatches.push.apply(finalPatches, deepPatches);
            } else {
                finalPatches.push(patch);
            }
        });
        return finalPatches;
	}
}

module.exports = diffDeep;


/***/ }),

/***/ "./node_modules/can-diff/index-by-identity/index-by-identity.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-diff/index-by-identity/index-by-identity.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function(items, item, schema){
    var length = canReflect.size(items);
    if(!schema && length > 0) {
        schema = canReflect.getSchema( items[0] );
    }
    if(!schema) {
        schema = canReflect.getSchema( item );
    }
    if(!schema) {
        throw new Error("No schema to use to get identity.");
    }

	var id = canReflect.getIdentity(item, schema);

	for(var i = 0; i < length; i++) {
		var connId = canReflect.getIdentity(items[i], schema);
        // this was ==
		if( id === connId) {
			return i;
		}
	}
	return -1;
};


/***/ }),

/***/ "./node_modules/can-diff/list/list.js":
/*!********************************************!*\
  !*** ./node_modules/can-diff/list/list.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var slice = [].slice;
// a b c
// a b c d
// [[2,0, d]]


function defaultIdentity(a, b){
    return a === b;
}

function makeIdentityFromMapSchema(typeSchema) {
    if(typeSchema.identity && typeSchema.identity.length) {
        return function identityCheck(a, b) {
            var aId = canReflect.getIdentity(a, typeSchema),
                bId = canReflect.getIdentity(b, typeSchema);
            return aId === bId;
        };
    } else {
        return defaultIdentity;
    }
}

function makeIdentityFromListSchema(listSchema) {
    return listSchema.values != null ?
        makeIdentityFromMapSchema( canReflect.getSchema(listSchema.values) ) :
        defaultIdentity;
}

function makeIdentity(oldList, oldListLength) {
    var listSchema = canReflect.getSchema(oldList),
        typeSchema;
    if(listSchema != null) {
        if(listSchema.values != null) {
            typeSchema = canReflect.getSchema(listSchema.values);
        } else {
            return defaultIdentity;
        }
    }
    if(typeSchema == null && oldListLength > 0) {
        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );
    }
    if(typeSchema) {
        return makeIdentityFromMapSchema(typeSchema);
    } else {
        return defaultIdentity;
    }
}



function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
	var oldIndex = oldList.length - 1,
		newIndex =  newList.length - 1;

	while( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem, oldIndex ) ) {
			oldIndex--;
			newIndex--;
			continue;
		} else {
			// use newIndex because it reflects any deletions
			return [{
                type: "splice",
				index: newDiffStopIndex,
			 	deleteCount: (oldIndex-oldDiffStopIndex+1),
			 	insert: slice.call(newList, newDiffStopIndex,newIndex+1)
			}];
		}
	}
	// if we've reached of either the new or old list
	// we simply return
	return [{
        type: "splice",
		index: newDiffStopIndex,
		deleteCount: (oldIndex-oldDiffStopIndex+1),
		insert: slice.call(newList, newDiffStopIndex,newIndex+1)
	}];

}

/**
 * @module {function} can-diff/list/list
 * @parent can-diff
 *
 * @description Return a difference of two lists.
 *
 * @signature `diffList( oldList, newList, [identity] )`
 *
 * Compares two lists and produces a sequence of patches that can be applied to make `oldList` take
 * the shape of `newList`.
 *
 * ```js
 * var diffList = require("can-diff/list/list");
 *
 * console.log(diff([1], [1, 2])); // -> [{type: "splice", index: 1, deleteCount: 0, insert: [2]}]
 * console.log(diff([1, 2], [1])); // -> [{type: "splice", index: 1, deleteCount: 1, insert: []}]
 *
 * // with an optional identity function:
 * diffList(
 *     [{id:1},{id:2}],
 *     [{id:1},{id:3}],
 *     (a,b) => a.id === b.id
 * ); // -> [{type: "splice", index: 1, deleteCount: 1, insert: [{id:3}]}]
 * ```
 *
 * The patch algorithm is linear with respect to the length of the lists and therefore does not produce a
 * [perfect edit distance](https://en.wikipedia.org/wiki/Edit_distance) (which would be at least quadratic).
 *
 * It is designed to work with most common list change scenarios, when items are inserted or removed
 * to a list (as opposed to moved with in the last).
 *
 * For example, it is able to produce the following patches:
 *
 * ```js
 * diffList(
 *     ["a","b","c","d"],
 *     ["a","b","X","Y","c","d"]
 * ); // -> [{type: "splice", index: 2, deleteCount: 0, insert: ["X","Y"]}]
 * ```
 *
 * @param  {ArrayLike} oldList The source array or list to diff from.
 * @param  {ArrayLike} newList The array or list to diff to.
 * @param  {function|can-reflect.getSchema} schemaOrIdentity An optional identity function or a schema with
 * an identity property for comparing elements.  If a `schemaOrIdentity` is not provided, the schema of
 * the `oldList` will be used.  If a schema can not be found, items a default identity function will be created
 * that checks if the two values are strictly equal `===`.
 * @return {Array} An array of [can-symbol/types/Patch] objects representing the differences
 *
 * Returns the difference between two ArrayLike objects (that have nonnegative
 * integer keys and the `length` property) as an array of patch objects.
 *
 * A patch object returned by this function has the following properties:
 * - **type**: the type of patch (`"splice"`).
 * - **index**:  the index of newList where the patch begins
 * - **deleteCount**: the number of items deleted from that index in newList
 * - **insert**: an Array of items newly inserted at that index in newList
 *
 * Patches should be applied in the order they are returned.
 */

module.exports = function(oldList, newList, schemaOrIdentity){
    var oldIndex = 0,
		newIndex =  0,
		oldLength = canReflect.size( oldList ),
		newLength = canReflect.size( newList ),
		patches = [];

    var schemaType = typeof schemaOrIdentity,
        identity;
    if(schemaType === "function") {
        identity = schemaOrIdentity;
    } else if(schemaOrIdentity != null) {
        if(schemaOrIdentity.type === "map") {
            identity = makeIdentityFromMapSchema(schemaOrIdentity);
        } else {
            identity = makeIdentityFromListSchema(schemaOrIdentity);
        }
    } else {
        identity = makeIdentity(oldList, oldLength);
    }



	while(oldIndex < oldLength && newIndex < newLength) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem, oldIndex ) ) {
			oldIndex++;
			newIndex++;
			continue;
		}
		// look for single insert, does the next newList item equal the current oldList.
		// 1 2 3
		// 1 2 4 3
		if(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1], oldIndex ) ) {
			patches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ], type: "splice"});
			oldIndex++;
			newIndex += 2;
			continue;
		}
		// look for single removal, does the next item in the oldList equal the current newList item.
		// 1 2 3
		// 1 3
		else if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem, oldIndex+1 ) ) {
			patches.push({index: newIndex, deleteCount: 1, insert: [], type: "splice"});
			oldIndex += 2;
			newIndex++;
			continue;
		}
		// just clean up the rest and exit
		// 1 2 3
		// 1 2 5 6 7
		else {
			// iterate backwards to `newIndex`
			// "a", "b", "c", "d", "e"
			// "a", "x", "y", "z", "e"
			// -> {}
			patches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );


			return patches;
		}
	}
	if( (newIndex === newLength) && (oldIndex === oldLength) ) {
		return patches;
	}
	// a b
	// a b c d e
	patches.push(
				{type: "splice", index: newIndex,
				 deleteCount: oldLength-oldIndex,
				 insert: slice.call(newList, newIndex) } );

	return patches;
};




// a b c
// a d e b c


/***/ }),

/***/ "./node_modules/can-diff/map/map.js":
/*!******************************************!*\
  !*** ./node_modules/can-diff/map/map.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function defaultIdentity(a, b){
	return a === b;
}


/**
 * @module {function} can-diff/map/map
 * @parent can-diff
 *
 * @description Return a difference of two maps or objects.
 *
 * @signature `diffMap(oldObject, newObject)`
 *
 * Find the differences between two objects, based on properties and values.
 *
 * ```js
 * var diffObject = require("can-diff/map/map");
 *
 * diffMap({a: 1, b: 2}, {b: 3, c: 4})) // ->
 *   [{key: "a", type: "remove"},
 *    {key: "b", type: "set": value: 3},
 *    {key: "c", type: "add", "value": 4}]
 * ```
 *
 * @param {Object} oldObject The object to diff from.
 * @param {Object} newObject The object to diff to.
 * @return {Array} An array of object-[can-symbol/types/Patch patch] objects
 *
 * The object-patch object format has the following keys:
 * - **type**:  the type of operation on this property: add, remove, or set
 * - **key**:   the mutated property on the new object
 * - **value**: the new value (if type is "add" or "set")
 *
 */
module.exports = function(oldObject, newObject){
	var oldObjectClone,
		patches = [];

	// clone oldObject so properties can be deleted
	oldObjectClone = canReflect.assignMap({}, oldObject);

    canReflect.eachKey(newObject, function(value, newProp){
        // look for added properties
        if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
            patches.push({
                key: newProp,
                type: 'add',
                value: value
            });
        // look for changed properties
        } else if (newObject[newProp] !== oldObject[newProp]) {
            patches.push({
                key: newProp,
                type: 'set',
                value: value
            });
        }

        // delete properties found in newObject
        // so we can find removed properties
        delete oldObjectClone[newProp];
    });

	// loop over removed properties
	for (var oldProp in oldObjectClone) {
		patches.push({
			key: oldProp,
			type: 'delete'
		});
	}

	return patches;
};


/***/ }),

/***/ "./node_modules/can-diff/merge-deep/merge-deep.js":
/*!********************************************************!*\
  !*** ./node_modules/can-diff/merge-deep/merge-deep.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var diffList = __webpack_require__(/*! ../list/list */ "./node_modules/can-diff/list/list.js");

function smartMerge(instance, props) {

	props = canReflect.serialize(props);

	if (canReflect.isMoreListLikeThanMapLike(instance)) {
		mergeList(instance, props);
	} else {
		mergeMap(instance, props);
	}
	return instance;
}

// date is expected to be mutable here
function mergeMap(instance, data) {

	// for each key in
	canReflect.eachKey(instance, function(value, prop) {
		if(!canReflect.hasKey(data, prop)) {
			canReflect.deleteKeyValue(instance, prop);
			return;
		}
		var newValue = canReflect.getKeyValue(data, prop);
		canReflect.deleteKeyValue(data, prop);

		// cases:
		// a. list
		// b. map
		// c. primitive

		// if the data is typed, we would just replace it
		if (canReflect.isPrimitive(value)) {
			canReflect.setKeyValue(instance, prop, newValue);
			return;
		}


		var newValueIsList = Array.isArray(newValue),
			currentValueIsList = canReflect.isMoreListLikeThanMapLike(value);

		if (currentValueIsList && newValueIsList) {

			mergeList(value, newValue);

		} else if (!newValueIsList && !currentValueIsList && canReflect.isMapLike(value) && canReflect.isPlainObject(newValue)) {

			// TODO: the `TYPE` should probably be infered from the `_define` property definition.
			var schema = canReflect.getSchema(value);
			if (schema && schema.identity && schema.identity.length) {
				var id = canReflect.getIdentity(value, schema);
				if (id != null && id === canReflect.getIdentity(newValue, schema)) {
					mergeMap(value, newValue);
					return;
				}
			}
			canReflect.setKeyValue(instance, prop, canReflect.new(value.constructor, newValue));
		} else {
			canReflect.setKeyValue(instance, prop, newValue);
		}
	});
	canReflect.eachKey(data, function(value, prop) {
		canReflect.setKeyValue(instance, prop, value);
	});
}

function mergeList(list, data) {
	var ItemType, itemSchema;
	var listSchema = canReflect.getSchema(list);
	if (listSchema) {
		ItemType = listSchema.values;
	}

	if (ItemType) {
		itemSchema = canReflect.getSchema(ItemType);
	}
	if (!itemSchema && canReflect.size(list) > 0) {
		itemSchema = canReflect.getSchema(canReflect.getKeyValue(list, 0));
	}

	var identity;
	if(itemSchema && itemSchema.identity && itemSchema.identity.length) {
		identity = function(a, b) {
		   var aId = canReflect.getIdentity(a, itemSchema),
			   bId = canReflect.getIdentity(b, itemSchema);
		   var eq = aId === bId;
		   if (eq) {
			   // If id is the same we merge data in. Case #2
			   mergeMap(a, b);
		   }
		   return eq;
	   };
   } else {
	   identity = function(a, b) {
		  var eq = a === b;
		  if (eq) {
			  // If id is the same we merge data in. Case #2
			  if(! canReflect.isPrimitive(a) ) {
				   mergeMap(a, b);
			  }

		  }
		  return eq;
	  }
   }


	var patches = diffList(list, data, identity);



	var hydrate = ItemType ? canReflect.new.bind(canReflect, ItemType) : function(v) {
		return v;
	};


	// If there are no patches then data contains only updates for all of the existing items, and we just leave.
	if (!patches.length) {
		return list;
	}

	// Apply patches (add new, remove) #3. For any insertion use a hydrator.
	patches.forEach(function(patch) {
		applyPatch(list, patch, hydrate);
	});
}

function applyPatch(list, patch, makeInstance) {
	// Splice signature compared to patch:
	//   array.splice(start, deleteCount, item1, item2, ...)
	//   patch = {index: 1, deleteCount: 0, insert: [1.5]}
	var insert = makeInstance && patch.insert.map(function(val){
		return makeInstance(val);
	}) || patch.insert;

	var args = [patch.index, patch.deleteCount].concat(insert);
	list.splice.apply(list, args);

	return list;
}

smartMerge.applyPatch = applyPatch;

module.exports = smartMerge;


/***/ }),

/***/ "./node_modules/can-diff/patch-sort/patch-sort.js":
/*!********************************************************!*\
  !*** ./node_modules/can-diff/patch-sort/patch-sort.js ***!
  \********************************************************/
/***/ ((module) => {


module.exports = function(patches) {
	//!steal-remove-start
	if(true) {
		var deletes =[],
			inserts = [],
			moves = [];
		patches.forEach(function(patch){
			if (patch.type === "move") {
				moves.push(patch);
			} else {
				if (patch.deleteCount) {
					deletes.push(patch)
				}
				if (patch.insert && patch.insert.length) {
					inserts.push(inserts);
				}
			}
		})
		if(deletes.length + inserts.length > 2) {
			console.error("unable to group patches",patches);
			throw new Error("unable to group patches");
		}
		if(moves.length &&(deletes.length || inserts.length)) {
			console.error("unable to sort a move with a delete or insert");
			throw new Error("unable to sort a move with a delete or insert");
		}
	}
	//!steal-remove-end


	var splitPatches = [];
	patches.forEach(function(patch){
		if (patch.type === "move") {
			splitPatches.push( {patch: patch, kind: "move"} );
		} else {
			if (patch.deleteCount) {
				splitPatches.push({
					type: "splice",
					index: patch.index,
					deleteCount: patch.deleteCount,
					insert: [],
				});
			}
			if (patch.insert && patch.insert.length) {
				splitPatches.push({
					type: "splice",
					index: patch.index,
					deleteCount: 0,
					insert: patch.insert
				});
			}
		}
	});
	if(patches.length !== 2) {
		return patches;
	}
	var first = splitPatches[0],
		second = splitPatches[1];
	// if insert before a delete
	if(first.insert && first.insert.length && second.deleteCount) {
		// lets swap the order.
		var insert = first,
			remove = second;
		if(insert.index < remove.index) {
			remove.index = remove.index - insert.insert.length;
		} else if(insert.index > remove.index) {
			insert.index = insert.index - remove.deleteCount;
		} else {
			throw "indexes the same!"
		}
		return [remove, insert];
	}
	return patches;
};


/***/ }),

/***/ "./node_modules/can-diff/patcher/patcher.js":
/*!**************************************************!*\
  !*** ./node_modules/can-diff/patcher/patcher.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";




var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var diff = __webpack_require__(/*! ../list/list */ "./node_modules/can-diff/list/list.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var onValueSymbol = canSymbol.for("can.onValue"),
	offValueSymbol = canSymbol.for("can.offValue");
var onPatchesSymbol = canSymbol.for("can.onPatches");
var offPatchesSymbol = canSymbol.for("can.offPatches");

// Patcher takes a observable that might wrap a list type.
// When the observable changes, it will diff, and emit patches,
// and if the list emits patches, it will emit those too.
// It is expected that only `domUI` handlers are registered.
/*
var observable = new SimpleObservable( new DefineList([ "a", "b", "c" ]) )
var patcher = new Patcher(observable)
canReflect.onPatches( patcher,function(patches){
  console.log(patches) // a patch removing c, then a
})
var newList = new DefineList(["a","b"]);
observable.set(newList);
newList.unshift("X");
[
    {type: "splice", index: 2, deleteCount: 1}
]
var patches2 = [
    {type: "splice", index: 0, deleteCount: 0, inserted: ["X"]}
]
 */
var Patcher = function(observableOrList, priority) {
	// stores listeners for this patcher
	this.handlers = new KeyTree([Object, Array], {
		// call setup when the first handler is bound
		onFirst: this.setup.bind(this),
		// call teardown when the last handler is removed
		onEmpty: this.teardown.bind(this)
	});

	// save this value observable or patch emitter (list)
	this.observableOrList = observableOrList;
	// if we were passed an observable value that we need to read its array for changes
	this.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);
	if(this.isObservableValue) {
	    this.priority = canReflect.getPriority(observableOrList);
	} else {
	    this.priority = priority || 0;
	}
	this.onList = this.onList.bind(this);
	this.onPatchesNotify = this.onPatchesNotify.bind(this);
	// needs to be unique so the derive queue doesn't only add one.
	this.onPatchesDerive = this.onPatchesDerive.bind(this);

	// stores patches that have happened between notification and
	// when we queue the  `onPatches` handlers in the `domUI` queue
	this.patches = [];


	//!steal-remove-start
	if(true) {
		Object.defineProperty(this.onList, "name", {
			value: "live.list new list::"+canReflect.getName(observableOrList),
		});
		Object.defineProperty(this.onPatchesNotify, "name", {
			value: "live.list notify::"+canReflect.getName(observableOrList),
		});
		Object.defineProperty(this.onPatchesDerive, "name", {
			value: "live.list derive::"+canReflect.getName(observableOrList),
		});
	}
	//!steal-remove-end
};


Patcher.prototype = {
	constructor: Patcher,
	setup: function() {
		if (this.observableOrList[onValueSymbol]) {
			// if we have an observable value, listen to when it changes to get a
			// new list.
			canReflect.onValue(this.observableOrList, this.onList, "notify");
			// listen on the current value (which shoudl be a list) if there is one
			this.setupList(canReflect.getValue(this.observableOrList));
		} else {
			this.setupList(this.observableOrList);
		}
	},
	teardown: function() {
		if (this.observableOrList[offValueSymbol]) {
			canReflect.offValue(this.observableOrList, this.onList, "notify");
		}
		if (this.currentList && this.currentList[offPatchesSymbol]) {
			this.currentList[offPatchesSymbol](this.onPatchesNotify, "notify");
		}
	},
	// listen to the list for patches
	setupList: function(list) {
		this.currentList = list;
		if (list && list[onPatchesSymbol]) {
			// If observable, set up bindings on list changes
			list[onPatchesSymbol](this.onPatchesNotify, "notify");
		}
	},
	// when the list changes, teardown the old list bindings
	// and setup the new list
	onList: function onList(newList) {
		var current = this.currentList || [];
		newList = newList || [];
		if (current[offPatchesSymbol]) {
			current[offPatchesSymbol](this.onPatchesNotify, "notify");
		}
		var patches = diff(current, newList);
		this.currentList = newList;
		this.onPatchesNotify(patches);
		if (newList[onPatchesSymbol]) {
			// If observable, set up bindings on list changes
			newList[onPatchesSymbol](this.onPatchesNotify, "notify");
		}
	},
	// This is when we get notified of patches on the underlying list.
	// Save the patches and queue up a `derive` task that will
	// call `domUI` updates.
	onPatchesNotify: function onPatchesNotify(patches) {
		// we are going to collect all patches
		this.patches.push.apply(this.patches, patches);
		// TODO: share priority
		queues.deriveQueue.enqueue(this.onPatchesDerive, this, [], {
			priority: this.priority
		});
	},
	// Let handlers (which should only be registered in `domUI`) know about patches
	// that they can apply.
	onPatchesDerive: function onPatchesDerive() {
		var patches = this.patches;
		this.patches = [];
		queues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [patches, this.currentList], null,["Apply patches", patches]);
	}
};

canReflect.assignSymbols(Patcher.prototype, {
	"can.onPatches": function(handler, queue) {
		this.handlers.add([queue || "mutate", handler]);
	},
	"can.offPatches": function(handler, queue) {
		this.handlers.delete([queue || "mutate", handler]);
	}
});

module.exports = Patcher;


/***/ }),

/***/ "./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function updateExceptIdentity(obj, data, schema) {
    if(!schema) {
        schema = canReflect.getSchema(obj);
    }
    if(!schema) {
        throw new Error("can-diff/update-except-id is unable to update without a schema.");
    }
    // copy the keys onto data
    schema.identity.forEach(function(key){
        var id = canReflect.getKeyValue(obj, key);
        if(id!== undefined) {
            canReflect.setKeyValue(data, key, id );
        }
    });

    canReflect.updateDeep(obj, data);
};


/***/ }),

/***/ "./node_modules/can-dom-data/can-dom-data.js":
/*!***************************************************!*\
  !*** ./node_modules/can-dom-data/can-dom-data.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var isEmptyObject = function(obj){
	/* jshint -W098 */
	for(var prop in obj) {
		return false;
	}
	return true;
};

var data = new WeakMap();

// delete this node's `data`
// returns true if the node was deleted.
var deleteNode = function(node) {
	var nodeDeleted = false;
	if (data.has(node)) {
		nodeDeleted = true;
		data.delete(node);
	}
	return nodeDeleted;
};

var setData = function(node, name, value) {
	var store = data.get(node);
	if (store === undefined) {
		store = {};
		data.set(node, store);
	}
	if (name !== undefined) {
		store[name] = value;
	}
	return store;
};

/*
 * Core of domData that does not depend on mutationDocument
 * This is separated in order to prevent circular dependencies
 */
var domData = {
	_data: data,

	get: function(node, key) {
		var store = data.get(node);
		return key === undefined ? store : store && store[key];
	},

	set: setData,

	clean: function(node, prop) {
		var itemData = data.get(node);
		if (itemData && itemData[prop]) {
			delete itemData[prop];
		}
		if (isEmptyObject(itemData)) {
			deleteNode(node);
		}
	},

	delete: deleteNode
};

if (namespace.domData) {
	throw new Error("You can't have two versions of can-dom-data, check your dependencies");
} else {
	module.exports = namespace.domData = domData;
}


/***/ }),

/***/ "./node_modules/can-dom-events/can-dom-events.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-dom-events/can-dom-events.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var util = __webpack_require__(/*! ./helpers/util */ "./node_modules/can-dom-events/helpers/util.js");
var makeEventRegistry = __webpack_require__(/*! ./helpers/make-event-registry */ "./node_modules/can-dom-events/helpers/make-event-registry.js");
var makeDelegateEventTree = __webpack_require__(/*! ./helpers/-make-delegate-event-tree */ "./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js");


var domEvents = {
	_eventRegistry: makeEventRegistry(),

	/**
	* @function can-dom-events.addEvent addEvent
	* @parent can-dom-events.static
	*
	* Add a custom event to the global event registry.
	*
	* @signature `addEvent( event [, eventType ] )`
	*
	* ```js
	* var removeReturnEvent = domEvents.addEvent(enterEvent, "return");
	* ```
	*
	* @param {can-dom-events/EventDefinition} event The custom event definition.
	* @param {String} eventType The event type to associated with the custom event.
	* @return {function} The callback to remove the custom event from the registry.
	*/
	addEvent: function(event, eventType) {
		return this._eventRegistry.add(event, eventType);
	},

	/**
	* @function can-dom-events.addEventListener addEventListener
	*
	* Add an event listener for eventType to the target.
	*
	* @signature `addEventListener( target, eventType, ...eventArgs )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object to which to add the listener.
	* @param {String} eventType The event type with which to register.
	* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a
	* function event handler.
	*/
	addEventListener: function(target, eventType) {
		var hasCustomEvent = domEvents._eventRegistry.has(eventType);
		if (hasCustomEvent) {
			var event = domEvents._eventRegistry.get(eventType);
			return event.addEventListener.apply(domEvents, arguments);
		}

		var eventArgs = Array.prototype.slice.call(arguments, 1);
		return target.addEventListener.apply(target, eventArgs);
	},

	/**
	* @function can-dom-events.removeEventListener removeEventListener
	*
	* Remove an event listener for eventType from the target.
	*
	* @signature `removeEventListener( target, eventType, ...eventArgs )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object from which to remove the listener.
	* @param {String} eventType The event type with which to unregister.
	* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a
	* function event handler.
	*/
	removeEventListener: function(target, eventType) {
		var hasCustomEvent = domEvents._eventRegistry.has(eventType);
		if (hasCustomEvent) {
			var event = domEvents._eventRegistry.get(eventType);
			return event.removeEventListener.apply(domEvents, arguments);
		}

		var eventArgs = Array.prototype.slice.call(arguments, 1);
		return target.removeEventListener.apply(target, eventArgs);
	},

	/**
	* @function can-dom-events.addDelegateListener addDelegateListener
	*
	* Attach a handler for an event for all elements that match the selector,
	* now or in the future, based on a root element.
	*
	* @signature `addDelegateListener( target, eventType, selector, handler )`
	*
	* ```js
	* // Prevents all anchor elements from changing the page
	* domEvents.addDelegateListener(document.body,"click", "a", function(event){
	*   event.preventDefault();
	* })
	* ```
	* @parent can-dom-events.static
	* @param {DomEventTarget} root The html element to listen to events that match selector within.
	* @param {String} eventType The event name to listen to.
	* @param {String} selector A selector to filter the elements that trigger the event.
	* @param {function} handler A function to execute at the time the event is triggered.
	*/
	addDelegateListener: function(root, eventType, selector, handler) {
		domEvents._eventTree.add([root, eventType, selector, handler]);
	},
	/**
	* @function can-dom-events.removeDelegateListener removeDelegateListener
	*
	* Remove a handler for an event for all elements that match the selector.
	*
	* @signature `removeDelegateListener( target, eventType, selector, handler )`
	*
	* ```js
	* // Prevents all anchor elements from changing the page
	* function handler(event) {
	*   event.preventDefault();
	* }
	* domEvents.addDelegateListener(document.body,"click", "a", handler);
	*
	* domEvents.removeDelegateListener(document.body,"click", "a", handler);
	* ```
	* @parent can-dom-events.static
	* @param {DomEventTarget} root The html element to listen to events that match selector within.
	* @param {String} eventType The event name to listen to.
	* @param {String} selector A selector to filter the elements that trigger the event.
	* @param {function} handler A function that was previously passed to `addDelegateListener`.
	*/
	removeDelegateListener: function(target, eventType, selector, handler) {
		domEvents._eventTree.delete([target, eventType, selector, handler]);
	},

	/**
	* @function can-dom-events.dispatch dispatch
	*
	* Create and dispatch a configured event on the target.
	*
	* @signature `dispatch( target, eventData [, bubbles ][, cancelable ] )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object on which to dispatch the event.
	* @param {Object | String} eventData The data to be assigned to the event. If it is a string, that will be the event type.
	* @param {Boolean} bubbles Whether the event should bubble; defaults to true.
	* @param {Boolean} cancelable Whether the event can be cancelled; defaults to false.
	* @return {Boolean} notCancelled Whether the event dispatched without being cancelled.
	*/
	dispatch: function(target, eventData, bubbles, cancelable) {
		var event = util.createEvent(target, eventData, bubbles, cancelable);
		var enableForDispatch = util.forceEnabledForDispatch(target, event);
		if(enableForDispatch) {
			target.disabled = false;
		}

		var ret = target.dispatchEvent(event);
		if(enableForDispatch) {
			target.disabled = true;
		}

		return ret;
	}
};

domEvents._eventTree = makeDelegateEventTree(domEvents);





module.exports = namespace.domEvents = domEvents;


/***/ }),

/***/ "./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// Some events do not bubble, so delegating them requires registering the handler in the
// capturing phase.
// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
var useCapture = function(eventType) {
	return eventType === 'focus' || eventType === 'blur';
};

function makeDelegator (domEvents) {
	var Delegator = function Delegator (parentKey){
		this.element = parentKey; // HTMLElement
		this.events = {}; // {[eventType: string]: Array<(event) -> void>}
		this.delegated = {}; // {[eventType: string]: (event) -> void}
	};

	canReflect.assignSymbols( Delegator.prototype, {
		"can.setKeyValue": function(eventType, handlersBySelector){
			var handler = this.delegated[eventType] = function(ev){
				var cur = ev.target;
				var propagate = true;
				var origStopPropagation = ev.stopPropagation;
				ev.stopPropagation = function() {
					origStopPropagation.apply(this, arguments);
					propagate = false;
				};
				var origStopImmediatePropagation = ev.stopImmediatePropagation;
				ev.stopImmediatePropagation = function() {
					origStopImmediatePropagation.apply(this, arguments);
					propagate = false;
				};
				do {
					// document does not implement `.matches` but documentElement does
					var el = cur === document ? document.documentElement : cur;
					var matches = el.matches || el.msMatchesSelector;

					canReflect.each(handlersBySelector, function(handlers, selector){
						// Text and comment nodes may be included in mutation event targets
						//  but will never match selectors (and do not implement matches)
						if (matches && matches.call(el, selector)) {
							handlers.forEach(function(handler){
								handler.call(el, ev);
							});
						}
					});
					// since `el` points to `documentElement` when `cur` === document,
					// we need to continue using `cur` as the loop pointer, otherwhise
					// it will never end as documentElement.parentNode === document
					cur = cur.parentNode;
				} while ((cur && cur !== ev.currentTarget) && propagate);
			};
			this.events[eventType] = handlersBySelector;
			domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
		},
		"can.getKeyValue": function(eventType) {
			return this.events[eventType];
		},
		"can.deleteKeyValue": function(eventType) {
			domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
			delete this.delegated[eventType];
			delete this.events[eventType];
		},
		"can.getOwnEnumerableKeys": function() {
			return Object.keys(this.events);
		}
	});

	return Delegator;
}

module.exports = function makeDelegateEventTree (domEvents) {
	var Delegator = makeDelegator(domEvents);
	return new KeyTree([Map, Delegator, Object, Array]);
};


/***/ }),

/***/ "./node_modules/can-dom-events/helpers/add-jquery-events.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/add-jquery-events.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var domEvents = __webpack_require__(/*! ../can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

/**
 * @function can-dom-events/helpers/add-jquery-events ./helpers/add-jquery-events
 * @parent can-dom-events.helpers
 * @description Add jQuery’s special events to the global registry.
 * @signature `addJQueryEvents(jQuery)`
 * @param {jQuery} jQuery Your instance of jQuery.
 * @return {function} The callback to remove the jQuery events from the registry.
 *
 * @body
 *
 * ```js
 * const $ = require("jquery");
 * const addJQueryEvents = require("can-dom-events/helpers/add-jquery-events");
 * const domEvents = require("can-dom-events");
 * // Require another module that registers itself with jQuery.event.special,
 * // e.g. jQuery++ registers events such as draginit, dragmove, etc.
 *
 * const removeJQueryEvents = addJQueryEvents($);
 *
 * // Listen for an event in code; this might also be accomplished through a
 * // can-stache-binding such as <li on:draginit="listener()">
 * domEvents.addEventListener(listItemElement, "draginit", function listener() {
 *   // Will fire after a jQuery draginit event has been fired
 * });
 *
 * // Some other code that fires a jQuery event; this will probably be in the
 * // package you’re using…
 * $(listItemElement).trigger("draginit");
 *
 * // Later in your code… ready to stop listening for those jQuery events? Call
 * // the function returned by addJQueryEvents()
 * removeJQueryEvents();
 * ```
 */
module.exports = namespace.addJQueryEvents = function addJQueryEvents(jQuery) {
	var jQueryEvents = jQuery.event.special;
	var removeEvents = [];

	for (var eventType in jQueryEvents) {
		if (!domEvents._eventRegistry.has(eventType)) {
			var eventDefinition = {
				defaultEventType: eventType,
				addEventListener: function (target, eventType, handler) {
					$(target).on(eventType, handler);
				},
				removeEventListener: function (target, eventType, handler) {
					$(target).off(eventType, handler);
				}
			};
			var removeEvent = domEvents.addEvent(eventDefinition);
			removeEvents.push(removeEvent);
		}
	}

	return function removeJQueryEvents() {
		removeEvents.forEach(function(removeEvent) {
			removeEvent();
		});
	};
};


/***/ }),

/***/ "./node_modules/can-dom-events/helpers/make-event-registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/make-event-registry.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


function EventRegistry () {
	this._registry = {};
}

/**
 * @module can-dom-events/helpers/make-event-registry
 * @parent can-dom-events.helpers
 * @description Create an event registry.
 * @signature `makeEventRegistry()`
 *   @return {can-dom-events/EventRegistry}
 * @hide
 * 
 * @body
 *
 * ```js
 * var makeEventRegistry = require('can-dom-events/helpers/make-event-registry');
 * var registry = makeEventRegistry();
 *
 * var radioChange = require('can-events-dom-radiochange');
 * var removeRadioChange = registry.add(radioChange);
 *
 * registry.has('radiochange'); // => true
 * registry.get('radiochange'); // => radioChange
 *
 * removeRadioChange();
 * ```
 */
module.exports = function makeEventRegistry () {
	return new EventRegistry();
};

/**
 * @function make-event-registry.has eventRegistry.has
 *
 * Check whether an event type has already been registered.
 *
 * @signature `eventRegistry.has( eventType )`
 * @parent can-dom-events/EventRegistry
 * @param {String} eventType The event type for which to check.
 * @return {Boolean} Whether the event type is registered.
*/
EventRegistry.prototype.has = function (eventType) {
	return !!this._registry[eventType];
};

/**
 * @function make-event-registry.get eventRegistry.get
 *
 * Retrieve an event type which has already been registered.
 *
 * @signature `eventRegistry.get( eventType )`
 * @parent can-dom-events/EventRegistry
 * @param {String} eventType The event type for which to retrieve.
 * @return {EventDefinition} The registered event definition, or undefined if unregistered.
*/
EventRegistry.prototype.get = function (eventType) {
	return this._registry[eventType];
};

/**
 * @function make-event-registry.add eventRegistry.add
 *
 * Add an event to the registry.
 *
 * @signature `eventRegistry.add( event [, eventType ] )`
 * @parent can-dom-events/EventRegistry
 * @param {EventDefinition} event The event definition to register.
 * @param {String} eventType The event type with which to register the event.
 * @return {function} The callback to remove the event from the registry.
*/
EventRegistry.prototype.add = function (event, eventType) {
	if (!event) {
		throw new Error('An EventDefinition must be provided');
	}
	if (typeof event.addEventListener !== 'function') {
		throw new TypeError('EventDefinition addEventListener must be a function');
	}
	if (typeof event.removeEventListener !== 'function') {
		throw new TypeError('EventDefinition removeEventListener must be a function');
	}

	eventType = eventType || event.defaultEventType;
	if (typeof eventType !== 'string') {
		throw new TypeError('Event type must be a string, not ' + eventType);
	}

	if (this.has(eventType)) {
		throw new Error('Event "' + eventType + '" is already registered');
	}

	this._registry[eventType] = event;
	var self = this;
	return function remove () {
		self._registry[eventType] = undefined;
	};
};


/***/ }),

/***/ "./node_modules/can-dom-events/helpers/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getCurrentDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var isBrowserWindow = __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ "./node_modules/can-globals/is-browser-window/is-browser-window.js");

function getTargetDocument (target) {
	return target.ownerDocument || getCurrentDocument();
}

function createEvent (target, eventData, bubbles, cancelable) {
	var doc = getTargetDocument(target);
	var event = doc.createEvent('HTMLEvents');
	var eventType;
	if (typeof eventData === 'string') {
		eventType = eventData;
	} else {
		eventType = eventData.type;
		for (var prop in eventData) {
			if (event[prop] === undefined) {
				event[prop] = eventData[prop];
			}
		}
	}
	if (bubbles === undefined) {
		bubbles = true;
	}
	event.initEvent(eventType, bubbles, cancelable);
	return event;
}

// We do not account for all EventTarget classes,
// only EventTarget DOM nodes, fragments, and the window.
function isDomEventTarget (obj) {
	if (!(obj && obj.nodeName)) {
		return obj === window;
	}
	var nodeType = obj.nodeType;
	return (
		nodeType === 1 || // Node.ELEMENT_NODE
		nodeType === 9 || // Node.DOCUMENT_NODE
		nodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE
	);
}

function addDomContext (context, args) {
	if (isDomEventTarget(context)) {
		args = Array.prototype.slice.call(args, 0);
		args.unshift(context);
	}
	return args;
}

function removeDomContext (context, args) {
	if (!isDomEventTarget(context)) {
		args = Array.prototype.slice.call(args, 0);
		context = args.shift();
	}
	return {
		context: context,
		args: args
	};
}

var fixSyntheticEventsOnDisabled = false;
// In FireFox, dispatching a synthetic event on a disabled element throws an error.
// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.
// This determines if we have to work around that when dispatching events.
// https://bugzilla.mozilla.org/show_bug.cgi?id=329509
(function() {
	if(!isBrowserWindow()) {
		return;
	}

	var testEventName = 'fix_synthetic_events_on_disabled_test';
	var input = document.createElement("input");
	input.disabled = true;
	var timer = setTimeout(function() {
		fixSyntheticEventsOnDisabled = true;
	}, 50);
	var onTest = function onTest (){
		clearTimeout(timer);
		input.removeEventListener(testEventName, onTest);
	};
	input.addEventListener(testEventName, onTest);
	try {
		var event = document.create('HTMLEvents');
		event.initEvent(testEventName, false);
		input.dispatchEvent(event);
	} catch(e) {
		onTest();
		fixSyntheticEventsOnDisabled = true;
	}
})();

function isDispatchingOnDisabled(element, event) {
	var eventType = event.type;
	var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
	var isDisabled = !!element.disabled;
	return isInsertedOrRemoved && isDisabled;
}

function forceEnabledForDispatch (element, event) {
	return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
}

module.exports = {
	createEvent: createEvent,
	addDomContext: addDomContext,
	removeDomContext: removeDomContext,
	isDomEventTarget: isDomEventTarget,
	getTargetDocument: getTargetDocument,
	forceEnabledForDispatch: forceEnabledForDispatch
};


/***/ }),

/***/ "./node_modules/can-dom-mutate/-is-connected.js":
/*!******************************************************!*\
  !*** ./node_modules/can-dom-mutate/-is-connected.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var globals = __webpack_require__(/*! can-globals */ "./node_modules/can-globals/can-globals.js");
var util = __webpack_require__(/*! ./-util */ "./node_modules/can-dom-mutate/-util.js");
var contains = util.contains;
var mutate = {};
var isConnected;
function getIsConnectedFromNode(node) {
	return node.isConnected;
}
function getIsConnectedFromDocument(node) {
	var doc = node.ownerDocument;
	// if node *is* the document, ownerDocument is null
	// However, CanSimpleDom implements this incorrectly, and a document's ownerDocument is itself,
	//   so make both checks
	return doc === null || doc === node || contains(doc, node);
}

function setIsConnected(doc) {
	if(doc) {
		var node = doc.createTextNode("");
		isConnected = 'isConnected' in node.constructor.prototype ?
			getIsConnectedFromNode :
			getIsConnectedFromDocument;
		if(mutate) {
			mutate.isConnected = isConnected;
		}
	} else {
		mutate.isConnected = getIsConnectedFromNode;
	}
}
setIsConnected(globals.getKeyValue("document"));
globals.onKeyValue("document", setIsConnected);

module.exports = mutate;


/***/ }),

/***/ "./node_modules/can-dom-mutate/-util.js":
/*!**********************************************!*\
  !*** ./node_modules/can-dom-mutate/-util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");

function eliminate(array, item) {
	var index = array.indexOf(item);
	if (index >= 0) {
		array.splice(index, 1);
	}
}
function wasNotInSet(item, set) {
	var inSet = set.has(item);
	if(inSet === false) {
		set.add(item);
	}
	return !inSet;
}


function contains(parent, child){
	if(child && child.nodeType === Node.TEXT_NODE) {
		return contains(parent, child.parentNode);
	}
	if(parent.contains) {
		return parent.contains(child);
	}
	if(parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {
		return contains(parent.documentElement, child);
	} else {
		child = child.parentNode;
		if(child === parent) {
			return true;
		}
		return false;
	}
}

function isDocumentElement (node) {
	return getDocument().documentElement === node;
}

function isFragment (node) {
	return !!(node && node.nodeType === 11);
}

function isElementNode (node) {
	return !!(node && node.nodeType === 1);
}

function getChildren (parentNode) {
	var nodes = [];
	var node = parentNode.firstChild;
	while (node) {
		nodes.push(node);
		node = node.nextSibling;
	}
	return nodes;
}

function getParents (node) {
	var nodes;
	if (isFragment(node)) {
		nodes = getChildren(node);
	} else {
		nodes = [node];
	}
	return nodes;
}


function getNodesLegacyB(node) {
	var skip, tmp;

	var depth = 0;

	var items = isFragment(node) ? [] : [node];
	if(node.firstChild == null) {
		return items;
	}

	// Always start with the initial element.
	do {
		if ( !skip && (tmp = node.firstChild) ) {
			depth++;
			items.push(tmp);
		} else if ( tmp = node.nextSibling ) {
			skip = false;
			items.push(tmp);
		} else {
			// Skipped or no first child and no next sibling, so traverse upwards,
			tmp = node.parentNode;
			// and decrement the depth.
			depth--;
			// Enable skipping, so that in the next loop iteration, the children of
			// the now-current node (parent node) aren't processed again.
			skip = true;
		}

		// Instead of setting node explicitly in each conditional block, use the
		// tmp var and set it here.
		node = tmp;

		// Stop if depth comes back to 0 (or goes below zero, in conditions where
		// the passed node has neither children nore next siblings).
	} while ( depth > 0 );

	return items;
}

// IE11 requires a filter parameter for createTreeWalker
// it also must be an object with an `acceptNode` property
function treeWalkerFilterFunction() {
	return NodeFilter.FILTER_ACCEPT;
}
var treeWalkerFilter = treeWalkerFilterFunction;
treeWalkerFilter.acceptNode = treeWalkerFilterFunction;

function getNodesWithTreeWalker(rootNode) {
	var result = isFragment(rootNode) ? [] : [rootNode];

	// IE11 throws if createTreeWalker is called on a non-ElementNode
	var walker = isElementNode(rootNode) && getDocument().createTreeWalker(
		rootNode,
		NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,
		treeWalkerFilter,
		false
	);

	var node;
	while(node = walker && walker.nextNode()) {
		result.push(node);
	}
	return result;
}

function getAllNodes (node) {
	if( getDocument().createTreeWalker !== undefined ) {
		return getNodesWithTreeWalker(node);
	} else {
		return getNodesLegacyB(node);
	}
}

function subscription (fn) {
	return function _subscription () {
		var disposal = fn.apply(this, arguments);
		var isDisposed = false;
		return function _disposal () {
			if (isDisposed) {
				var fnName = fn.name || fn.displayName || 'an anonymous function';
				var message = 'Disposal function returned by ' + fnName + ' called more than once.';
				throw new Error(message);
			}
			disposal.apply(this, arguments);
			isDisposed = true;
		};
	};
}

module.exports = {
	eliminate: eliminate,
	getDocument: getDocument,
	isDocumentElement: isDocumentElement,
	isFragment: isFragment,
	getParents: getParents,
	getAllNodes: getAllNodes,
	getChildren: getChildren,
	subscription: subscription,
	wasNotInSet: wasNotInSet,
	contains: contains
};


/***/ }),

/***/ "./node_modules/can-dom-mutate/can-dom-mutate.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-dom-mutate/can-dom-mutate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals */ "./node_modules/can-globals/can-globals.js");
var getRoot = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ "./node_modules/can-globals/mutation-observer/mutation-observer.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var DOCUMENT = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");

var util = __webpack_require__(/*! ./-util */ "./node_modules/can-dom-mutate/-util.js");
var eliminate = util.eliminate;
var subscription = util.subscription;
var isDocumentElement = util.isDocumentElement;
var getAllNodes = util.getAllNodes;

var domMutate,
	dispatchNodeInserted,
	dispatchNodeConnected,
	dispatchGlobalConnected,
	dispatchNodeRemoved,
	dispatchNodeDisconnected,
	dispatchGlobalDisconnected,
	dispatchAttributeChange,
	dispatchGlobalAttributeChange;

var dataStore = new WeakMap();
var isConnected = __webpack_require__(/*! ./-is-connected */ "./node_modules/can-dom-mutate/-is-connected.js");

var queue;

function getRelatedData(node, key) {
	var data = dataStore.get(node);
	if (data) {
		return data[key];
	}
}

function setRelatedData(node, key, targetListenersMap) {
	var data = dataStore.get(node);
	if (!data) {
		data = {};
		dataStore.set(node, data);
	}
	data[key] = targetListenersMap;
}

function deleteRelatedData(node, key) {
	var data = dataStore.get(node);
	return delete data[key];
}

function toMutationEvent(node, mutation) {
	return {target: node, sourceMutation: mutation};
}

function getDocumentListeners (target, key) {
	// TODO: it's odd these functions read DOCUMENT() instead of
	// target.ownerDocument.  To change to ownerDocument, we might need a "is document"
	// check.
	var doc = DOCUMENT();
	var data = getRelatedData(doc, key);
	if (data) {
		return data.listeners;
	}
}

function getTargetListeners (target, key) {
	var doc = DOCUMENT();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		return;
	}

	return targetListenersMap.get(target);
}

function addTargetListener (target, key, listener) {
	var doc = DOCUMENT();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		targetListenersMap = new WeakMap();
		setRelatedData(doc, key, targetListenersMap);
	}
	var targetListeners = targetListenersMap.get(target);
	if (!targetListeners) {
		targetListeners = [];
		targetListenersMap.set(target, targetListeners);
	}
	targetListeners.push(listener);
}

function removeTargetListener (target, key, listener) {
	var doc = DOCUMENT();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		return;
	}
	var targetListeners = targetListenersMap.get(target);
	if (!targetListeners) {
		return;
	}
	eliminate(targetListeners, listener);
	if (targetListeners.length === 0) {
		targetListenersMap['delete'](target);
		if (targetListenersMap.size === 0) {
			deleteRelatedData(doc, key);
		}
	}
}

var promise = Promise.resolve();
function nextTick(handler) {
	promise.then(handler);
}

//var recordsAndCallbacks = null;

function flushCallbacks(callbacks, arg){
	var callbacksCount = callbacks.length;
	var safeCallbacks = callbacks.slice(0);
	for(var c = 0; c < callbacksCount; c++){
		safeCallbacks[c](arg);
	}
}

function dispatch(getListeners, targetKey) {

	return function dispatchEvents(event) {
		var targetListeners = getListeners(event.target, targetKey);

		if (targetListeners) {
			flushCallbacks(targetListeners, event);
		}
	};
}

var count = 0;

function observeMutations(target, observerKey, config, handler) {

	var observerData = getRelatedData(target, observerKey);
	if (!observerData) {
		observerData = {
			observingCount: 0
		};
		setRelatedData(target, observerKey, observerData);
	}

	var setupObserver = function () {
		// disconnect the old one
		if (observerData.observer) {
			observerData.observer.disconnect();
			observerData.observer = null;
		}

		var MutationObserver = getMutationObserver();
		if (MutationObserver) {
			var Node = getRoot().Node;
			var isRealNode = !!(Node && target instanceof Node);
			if (isRealNode) {
				var targetObserver = new MutationObserver(handler);
				targetObserver.id = count++;
				targetObserver.observe(target, config);
				observerData.observer = targetObserver;
			}
		}
	};

	if (observerData.observingCount === 0) {
		globals.onKeyValue('MutationObserver', setupObserver);
		setupObserver();
	}

	observerData.observingCount++;
	return function stopObservingMutations() {
		var observerData = getRelatedData(target, observerKey);
		if (observerData) {
			observerData.observingCount--;
			if (observerData.observingCount <= 0) {
				if (observerData.observer) {
					observerData.observer.disconnect();
				}
				deleteRelatedData(target, observerKey);
				globals.offKeyValue('MutationObserver', setupObserver);
			}
		}
	};
}

var treeMutationConfig = {
	subtree: true,
	childList: true
};

var attributeMutationConfig = {
	attributes: true,
	attributeOldValue: true
};

function addNodeListener(listenerKey, observerKey, isAttributes) {
	return subscription(function _addNodeListener(target, listener) {
		// DocumentFragment
		if(target.nodeType === 11) {
			// This returns a noop without actually doing anything.
			// We should probably warn about passing a DocumentFragment here,
			// but since can-stache does so currently we are ignoring until that is
			// fixed.
			return Function.prototype;
		}

		var stopObserving;
		if (isAttributes) {
			stopObserving = observeMutations(target, observerKey, attributeMutationConfig, queue.enqueueAndFlushMutations);
		} else {
			stopObserving = observeMutations(DOCUMENT(), observerKey, treeMutationConfig, queue.enqueueAndFlushMutations);
		}

		addTargetListener(target, listenerKey, listener);
		return function removeNodeListener() {
			if(stopObserving) {
				stopObserving();
			}

			removeTargetListener(target, listenerKey, listener);
		};
	});
}

function addGlobalListener(globalDataKey, addNodeListener) {
	return subscription(function addGlobalGroupListener(documentElement, listener) {
		if (!isDocumentElement(documentElement)) {
			throw new Error('Global mutation listeners must pass a documentElement');
		}

		var doc = DOCUMENT();
		var documentData = getRelatedData(doc, globalDataKey);
		if (!documentData) {
			documentData = {listeners: []};
			setRelatedData(doc, globalDataKey, documentData);
		}

		var listeners = documentData.listeners;
		if (listeners.length === 0) {
			// We need at least on listener for mutation events to propagate
			documentData.removeListener = addNodeListener(doc, function () {});
		}

		listeners.push(listener);

		return function removeGlobalGroupListener() {
			var documentData = getRelatedData(doc, globalDataKey);
			if (!documentData) {
				return;
			}

			var listeners = documentData.listeners;
			eliminate(listeners, listener);
			if (listeners.length === 0) {
				documentData.removeListener();
				deleteRelatedData(doc, globalDataKey);
			}
		};
	});
}



var domMutationPrefix = 'domMutation';

// target listener keys
var connectedDataKey = domMutationPrefix + 'ConnectedData';
var disconnectedDataKey = domMutationPrefix + 'DisconnectedData';
var insertedDataKey = domMutationPrefix + 'InsertedData';
var removedDataKey = domMutationPrefix + 'RemovedData';
var attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';

// document listener keys
var documentConnectedDataKey = domMutationPrefix + 'DocumentConnectedData';
var documentDisconnectedDataKey = domMutationPrefix + 'DocumentDisconnectedData';
var documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';

// observer keys
var treeDataKey = domMutationPrefix + 'TreeData';
var attributeDataKey = domMutationPrefix + 'AttributeData';

dispatchNodeInserted = dispatch(getTargetListeners, insertedDataKey);
dispatchNodeConnected = dispatch(getTargetListeners, connectedDataKey);
dispatchGlobalConnected = dispatch(getDocumentListeners, documentConnectedDataKey);

dispatchNodeRemoved = dispatch(getTargetListeners, removedDataKey);
dispatchNodeDisconnected = dispatch(getTargetListeners, disconnectedDataKey);
dispatchGlobalDisconnected = dispatch(getDocumentListeners, documentDisconnectedDataKey);

dispatchAttributeChange = dispatch(getTargetListeners, attributeChangeDataKey);
dispatchGlobalAttributeChange = dispatch(getDocumentListeners, documentAttributeChangeDataKey);

// node listeners
var addNodeConnectedListener = addNodeListener(connectedDataKey, treeDataKey);
var addNodeDisconnectedListener = addNodeListener(disconnectedDataKey, treeDataKey);
var addNodeInsertedListener = addNodeListener(insertedDataKey, treeDataKey);
var addNodeRemovedListener = addNodeListener(removedDataKey, treeDataKey);
var addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);

// global listeners
var addConnectedListener = addGlobalListener(
	documentConnectedDataKey,
	addNodeConnectedListener
);
var addDisconnectedListener = addGlobalListener(
	documentDisconnectedDataKey,
	addNodeDisconnectedListener
);
var addAttributeChangeListener = addGlobalListener(
	documentAttributeChangeDataKey,
	addNodeAttributeChangeListener
);

// ==========================================
function dispatchTreeMutation(mutation, processedState) {
	// was the mutation connected
	var wasConnected = mutation.isConnected === true || mutation.isConnected === undefined;

	// there are
	// - the global connected
	// - individual connected
	// - individual inserted
	var removedCount = mutation.removedNodes.length;
	for (var r = 0; r < removedCount; r++) {
		// get what already isn't in `removed`

		// see if "removed"
		// if wasConnected .. dispatch disconnected
		var removedNodes = getAllNodes(mutation.removedNodes[r]);
		removedNodes.forEach(function(node){
			var event = toMutationEvent(node, mutation);

			if( util.wasNotInSet(node, processedState.removed) ) {
				dispatchNodeRemoved( event );
			}
			if(wasConnected && util.wasNotInSet(node, processedState.disconnected) ) {
				dispatchNodeDisconnected( event );
				dispatchGlobalDisconnected( event );
			}
		});
	}

	var addedCount = mutation.addedNodes.length;
	for (var a = 0; a < addedCount; a++) {
		var insertedNodes = getAllNodes(mutation.addedNodes[a]);
		insertedNodes.forEach(function(node){
			var event = toMutationEvent(node, mutation);

			if(util.wasNotInSet(node, processedState.inserted)) {
				dispatchNodeInserted( event );
			}
			if(wasConnected && util.wasNotInSet(node, processedState.connected) ) {
				dispatchNodeConnected( event );
				dispatchGlobalConnected( event );
			}
		});
	}
	// run mutation
}


var FLUSHING_MUTATIONS = [];
var IS_FLUSHING = false;

var IS_FLUSH_PENDING = false;
var ENQUEUED_MUTATIONS = [];

queue = {
	// This is used to dispatch mutations immediately.
	// This is usually called by the result of a mutation observer.
	enqueueAndFlushMutations: function(mutations) {
		if(IS_FLUSH_PENDING) {
			FLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, ENQUEUED_MUTATIONS);
			IS_FLUSH_PENDING = false;
			ENQUEUED_MUTATIONS = [];
		}

		FLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, mutations);
		if(IS_FLUSHING) {
			return;
		}

		IS_FLUSHING = true;

		var index = 0;

		var processedState = {
			connected: new Set(),
			disconnected: new Set(),
			inserted: new Set(),
			removed: new Set()
		};

		while(index < FLUSHING_MUTATIONS.length) {
			var mutation = FLUSHING_MUTATIONS[index];
			// process mutation
			if(mutation.type === "childList") {
				dispatchTreeMutation(mutation, processedState);
			} else if(mutation.type === "attributes") {
				dispatchAttributeChange(mutation);
			}
			index++;

		}
		FLUSHING_MUTATIONS = [];
		IS_FLUSHING = false;
	},
	// called to dipatch later unless we are already dispatching.
	enqueueMutationsAndFlushAsync: function(mutations){
		ENQUEUED_MUTATIONS.push.apply(ENQUEUED_MUTATIONS, mutations);

		// if there are currently dispatching mutations, this should happen sometime after
		if(!IS_FLUSH_PENDING) {
			IS_FLUSH_PENDING = true;
			nextTick(function(){
				if(IS_FLUSH_PENDING) {
					IS_FLUSH_PENDING = false;
					var pending = ENQUEUED_MUTATIONS;
					ENQUEUED_MUTATIONS = [];
					queue.enqueueAndFlushMutations(pending);
				} else {
					// Someone called enqueueAndFlushMutations before this finished.
				}
			});
		}
	}
};


// ==========================================


domMutate = {
	/**
	* @function can-dom-mutate.dispatchNodeInsertion dispatchNodeInsertion
	* @hide
	*
	* Dispatch an insertion mutation on the given node.
	*
	* @signature `dispatchNodeInsertion( node [, callback ] )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to dispatch an insertion mutation.
	*/
	dispatchNodeInsertion: function (node, target) {
		queue.enqueueMutationsAndFlushAsync(
			[{
				type: "childList",
				target: target,
				addedNodes: [node],
				isConnected: isConnected.isConnected(target),
				removedNodes: []
			}]
		);
		/*
		var nodes = new Set();
		util.addToSet( getAllNodes(node), nodes);
		var events = toMutationEvents( canReflect.toArray(nodes) );
		// this is basically an array of every single child of node including node
		dispatchInsertion(events, callback, dispatchConnected, flushAsync);*/
	},

	/**
	* @function can-dom-mutate.dispatchNodeRemoval dispatchNodeRemoval
	* @hide
	*
	* Dispatch a removal mutation on the given node.
	*
	* @signature `dispatchNodeRemoval( node [, callback ] )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to dispatch a removal mutation.
	* @param {function} callback The optional callback called after the mutation is dispatched.
	*/
	dispatchNodeRemoval: function (node, target) {
		queue.enqueueMutationsAndFlushAsync(
			[{
				type: "childList",
				target: target,
				addedNodes: [],
				removedNodes: [node],
				isConnected: isConnected.isConnected(target)
			}]
		);
		/*
		var nodes = new Set();
		util.addToSet( getAllNodes(node), nodes);
		var events = toMutationEvents( canReflect.toArray(nodes) );
		dispatchRemoval(events, callback, dispatchConnected, flushAsync);*/
	},

	/**
	* @function can-dom-mutate.dispatchNodeAttributeChange dispatchNodeAttributeChange
	* @parent can-dom-mutate.static
	* @hide
	*
	* Dispatch an attribute change mutation on the given node.
	*
	* @signature `dispatchNodeAttributeChange( node, attributeName, oldValue [, callback ] )`
	*
	* ```
	* input.setAttribute("value", "newValue")
	* domMutate.dispatchNodeAttributeChange(input, "value","oldValue")
	* ```
	*
	*
	* @param {Node} target The node on which to dispatch an attribute change mutation.
	* @param {String} attributeName The attribute name whose value has changed.
	* @param {String} oldValue The attribute value before the change.
	*/
	dispatchNodeAttributeChange: function (target, attributeName, oldValue) {
		queue.enqueueMutationsAndFlushAsync(
			[{
				type: "attributes",
				target: target,
				attributeName: attributeName,
				oldValue: oldValue
			}]
		);
	},

	/**
	* @function can-dom-mutate.onNodeConnected onNodeConnected
	*
	* Listen for insertion mutations on the given node.
	*
	* @signature `onNodeConnected( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for insertion mutations.
	* @param {function} callback The callback called when an insertion mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeConnected: addNodeConnectedListener,
	onNodeInsertion: function(){
		// TODO: remove in prod
		console.warn("can-dom-mutate: Use onNodeConnected instead of onNodeInsertion");
		return addNodeConnectedListener.apply(this, arguments);
	},
	/**
	* @function can-dom-mutate.onNodeDisconnected onNodeDisconnected
	*
	* Listen for removal mutations on the given node.
	*
	* @signature `onNodeDisconnected( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for removal mutations.
	* @param {function} callback The callback called when a removal mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeDisconnected: addNodeDisconnectedListener,
	onNodeRemoval: function(){
		// TODO: remove in prod
		console.warn("can-dom-mutate: Use onNodeDisconnected instead of onNodeRemoval");
		return addNodeDisconnectedListener.apply(this, arguments);
	},
	/**
	* @function can-dom-mutate.onNodeAttributeChange onNodeAttributeChange
	*
	* Listen for attribute change mutations on the given node.
	*
	* @signature `onNodeAttributeChange( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for attribute change mutations.
	* @param {function} callback The callback called when an attribute change mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeAttributeChange: addNodeAttributeChangeListener,

	/**
	* @function can-dom-mutate.onDisconnected onDisconnected
	*
	* Listen for removal mutations on any node within the documentElement.
	*
	* @signature `onDisconnected( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when a removal mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onDisconnected: addDisconnectedListener,
	onRemoval: function(){
		// TODO: remove in prod
		console.warn("can-dom-mutate: Use onDisconnected instead of onRemoval");
		return addDisconnectedListener.apply(this, arguments);
	},
	/**
	* @function can-dom-mutate.onConnected onConnected
	*
	* Listen for insertion mutations on any node within the documentElement.
	*
	* @signature `onConnected( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when a insertion mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onConnected: addConnectedListener,
	onInsertion: function(){
		// TODO: remove in prod
		console.warn("can-dom-mutate: Use onConnected instead of onInsertion");
		return addConnectedListener.apply(this, arguments);
	},
	/**
	* @function can-dom-mutate.onAttributeChange onAttributeChange
	*
	* Listen for attribute change mutations on any node within the documentElement.
	*
	* @signature `onAttributeChange( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when an attribute change mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onAttributeChange: addAttributeChangeListener,

	flushRecords: function(doc){
		doc = doc || DOCUMENT();
		var data = dataStore.get(doc),
			records = [];
		if(data) {
			if(data.domMutationTreeData && data.domMutationTreeData.observer) {
				records = data.domMutationTreeData.observer.takeRecords();
			}
		}
		queue.enqueueAndFlushMutations(records);
	},
	onNodeInserted: addNodeInsertedListener,
	onNodeRemoved: addNodeRemovedListener
};

//!steal-remove-start
if(true) {
	domMutate.dataStore = dataStore;
}
//!steal-remove-end

module.exports = namespace.domMutate = domMutate;


/***/ }),

/***/ "./node_modules/can-dom-mutate/dom-events.js":
/*!***************************************************!*\
  !*** ./node_modules/can-dom-mutate/dom-events.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var domMutateEvents = __webpack_require__(/*! ./events/events */ "./node_modules/can-dom-mutate/events/events.js");

// backwards compatibility
module.exports = namespace.domMutateDomEvents = domMutateEvents;


/***/ }),

/***/ "./node_modules/can-dom-mutate/events/events.js":
/*!******************************************************!*\
  !*** ./node_modules/can-dom-mutate/events/events.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var domMutate = __webpack_require__(/*! ../can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

/**
 * @module {{}} can-dom-mutate/events/events
 * @parent can-dom-mutate/modules
 * 
 * @description This adds attributes, inserted and removed attributes to the DOM.
 * @signature `domMutateEvents`
 * 
 * `can-dom-mutate/events/events` Exports an object that allows to listen ```attributes```, ```inserted``` and ```removed``` events 
 *  in the DOM using [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
 * 
 * ```js
 * import domMutateEvents from "can-dom-mutate/events/events";
 * import domEvents from "can-dom-events";
 *
 * domMutateEvents //->
 * {
 *   attributes: {defaultEventType, addEventListener(), removeEventListener()},
 *   inserted: {defaultEventType, addEventListener(), removeEventListener},
 *   removed: {defaultEventType, addEventListener(), removeEventListener()},
 * }
 *
 * // listen to inserted change within an element:
 * // add inserted event to registry
 * domEvents.addEvent(domMutateEvents.inserted);
 * domEvent.addEventListener(document.querySelector("#foo"), "inserted", handler () => {})
 * ```
 */

function makeMutationEvent (defaultEventType, subscription, bubbles) {
	var elementSubscriptions = new Map();
	return {
		_subscriptions: elementSubscriptions,
		defaultEventType: defaultEventType,
		addEventListener: function (target, eventType, handler) {
			var dispatch = this.dispatch;
			var data = elementSubscriptions.get(target);
			if (!data) {
				data = {
					removeListener: null,
					listeners: new Set()
				};
				elementSubscriptions.set(target, data);
			}

			if (data.listeners.size === 0) {
				data.removeListener = subscription(target, function (mutation) {
					var eventData = {type: eventType};
					for (var key in mutation) {
						eventData[key] = mutation[key];
					}

					dispatch(target, eventData, bubbles !== false);
				});
			}

			data.listeners.add(handler);
			target.addEventListener(eventType, handler);
		},
		removeEventListener: function (target, eventType, handler) {
			target.removeEventListener(eventType, handler);
			var data = elementSubscriptions.get(target);
			if (data) {
				data.listeners['delete'](handler);
				if (data.listeners.size === 0) {
					data.removeListener();
					elementSubscriptions['delete'](target);
				}
			}		
		}
	};
}

module.exports = namespace.domMutateDomEvents = {
	attributes: makeMutationEvent('attributes', domMutate.onNodeAttributeChange),
	inserted: makeMutationEvent('inserted', domMutate.onNodeConnected, false),
	removed: makeMutationEvent('removed', domMutate.onNodeDisconnected)
};


/***/ }),

/***/ "./node_modules/can-dom-mutate/node.js":
/*!*********************************************!*\
  !*** ./node_modules/can-dom-mutate/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var node = __webpack_require__(/*! ./node/node */ "./node_modules/can-dom-mutate/node/node.js");

// backwards compatibility
module.exports = namespace.node = node;


/***/ }),

/***/ "./node_modules/can-dom-mutate/node/node.js":
/*!**************************************************!*\
  !*** ./node_modules/can-dom-mutate/node/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals */ "./node_modules/can-globals/can-globals.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var domMutate = __webpack_require__(/*! ../can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var util = __webpack_require__(/*! ../-util */ "./node_modules/can-dom-mutate/-util.js");

var getParents = util.getParents;
var contains = util.contains;
var isConnected = __webpack_require__(/*! ../-is-connected */ "./node_modules/can-dom-mutate/-is-connected.js");


var compat = {
	replaceChild: function (newChild, oldChild) {
		var newChildren = getParents(newChild);
		var result = this.replaceChild(newChild, oldChild);
		domMutate.dispatchNodeRemoval(oldChild, this);
		for (var i = 0; i < newChildren.length; i++) {
			domMutate.dispatchNodeInsertion(newChildren[i], this);
		}
		return result;
	},
	setAttribute: function (name, value) {
		var oldAttributeValue = this.getAttribute(name);
		var result = this.setAttribute(name, value);
		var newAttributeValue = this.getAttribute(name);
		if (oldAttributeValue !== newAttributeValue) {
			domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
		}
		return result;
	},
	setAttributeNS: function (namespace, name, value) {
		var oldAttributeValue = this.getAttribute(name);
		var result = this.setAttributeNS(namespace, name, value);
		var newAttributeValue = this.getAttribute(name);
		if (oldAttributeValue !== newAttributeValue) {
			domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
		}
		return result;
	},
	removeAttribute: function (name) {
		var oldAttributeValue = this.getAttribute(name);
		var result = this.removeAttribute(name);
		if (oldAttributeValue) {
			domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
		}
		return result;
	}
};

var compatData = [
	['appendChild', 'Insertion'],
	['insertBefore', 'Insertion'],
	['removeChild', 'Removal']
];
compatData.forEach(function (pair) {
	var nodeMethod = pair[0];
	var dispatchMethod = 'dispatchNode' + pair[1];
	compat[nodeMethod] = function (node) {
		var nodes = getParents(node);
		var result = this[nodeMethod].apply(this, arguments);
		for (var i = 0; i < nodes.length; i++) {
			domMutate[dispatchMethod](nodes[i], this);
		}
		return result;
	};
});

var normal = {};
var nodeMethods = ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'setAttributeNS', 'removeAttribute'];
nodeMethods.forEach(function (methodName) {
	normal[methodName] = function () {
		if(isConnected.isConnected(this)) {
			return this[methodName].apply(this, arguments);
		} else {
			return compat[methodName].apply(this, arguments);
		}
	};
});

/**
* @module {{}} can-dom-mutate/node node
* @parent can-dom-mutate/modules
*
* Append, insert, and remove DOM nodes. Also, change node attributes.
* This allows mutations to be dispatched in environments where MutationObserver is not supported.
* @signature `mutateNode`
*
* Exports an `Object` with methods that shouhld be used to mutate HTML.
*
* ```js
* var mutateNode = require('can-dom-mutate/node');
* var el = document.createElement('div');
*
* mutateNode.appendChild.call(document.body, el);
*
* ```
*/
var mutate = {};

/**
* @function can-dom-mutate/node.appendChild appendChild
* @parent can-dom-mutate/node
*
* Append a node to an element, effectively `Node.prototype.appendChild`.
*
* @signature `mutate.appendChild.call(parent, child)`
*
* @param {Node} parent The parent into which the child is inserted.
* @param {Node} child The child which will be inserted into the parent.
* @return {Node} The appended child.
*/

/**
* @function can-dom-mutate/node.insertBefore insertBefore
* @parent can-dom-mutate/node
*
* Insert a node before a given reference node in an element, effectively `Node.prototype.insertBefore`.
*
* @signature `mutate.insertBefore.call(parent, child, reference)`
* @param {Node} parent The parent into which the child is inserted.
* @param {Node} child The child which will be inserted into the parent.
* @param {Node} reference The reference which the child will be placed before.
* @return {Node} The inserted child.
*/

/**
* @function can-dom-mutate/node.removeChild removeChild
* @parent can-dom-mutate/node
*
* Remove a node from an element, effectively `Node.prototype.removeChild`.
*
* @signature `mutate.removeChild.call(parent, child)`
*
* @param {Node} parent The parent from which the child is removed.
* @param {Node} child The child which will be removed from the parent.
* @return {Node} The removed child.
*/

/**
* @function can-dom-mutate/node.replaceChild replaceChild
* @parent can-dom-mutate/node
*
* Insert a node before a given reference node in an element, effectively `Node.prototype.replaceChild`.
*
* @signature `mutate.replaceChild.call(parent, newChild, oldChild)`
*
* @param {Node} parent The parent into which the newChild is inserted.
* @param {Node} newChild The child which is inserted into the parent.
* @param {Node} oldChild The child which is removed from the parent.
* @return {Node} The replaced child.
*/

/**
* @function can-dom-mutate/node.setAttribute setAttribute
* @parent can-dom-mutate/node
*
* Set an attribute value on an element, effectively `Element.prototype.setAttribute`.
*
* @signature `mutate.setAttribute.call(element, name, value)`
*
* @param {Element} element The element on which to set the attribute.
* @param {String} name The name of the attribute to set.
* @param {String} value The value to set on the attribute.
*/

/**
* @function can-dom-mutate/node.removeAttribute removeAttribute
* @parent can-dom-mutate/node
*
* Removes an attribute from an element, effectively `Element.prototype.removeAttribute`.
*
* @signature `mutate.removeAttribute.call(element, name, value)`
*
* @param {Element} element The element from which to remove the attribute.
* @param {String} name The name of the attribute to remove.
*/

function setMutateStrategy(observer) {
	var strategy = observer ? normal : compat;

	for (var key in strategy) {
		mutate[key] = strategy[key];
	}
}

var mutationObserverKey = 'MutationObserver';
setMutateStrategy(globals.getKeyValue(mutationObserverKey));
globals.onKeyValue(mutationObserverKey, setMutateStrategy);

module.exports = namespace.domMutateNode = domMutate.node = mutate;


/***/ }),

/***/ "./node_modules/can-event-dom-enter/can-event-dom-enter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-event-dom-enter/can-event-dom-enter.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var baseEventType = 'keyup';

function isEnterEvent (event) {
	var hasEnterKey = event.key === 'Enter';
	var hasEnterCode = event.keyCode === 13;
	return hasEnterKey || hasEnterCode;
}

/**
 * @module {events} can-event-dom-enter
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @group can-event-dom-enter.modules modules
 * @package ./package.json
 *
 * Watch for when enter keys are pressed on a DomEventTarget.
 *
 * ```js
 * var domEvents = require('can-dom-events');
 * var enterEvent = require('can-event-dom-enter');
 *
 * domEvents.addEvent(enterEvent);
 *
 * var input = document.createElement('input');
 * function enterEventHandler() {
 * 	console.log('enter key pressed');
 * }
 *
 * domEvents.addEventHandler(input, 'enter', enterEventHandler);
 * domEvents.dispatch(input, {
 *   type: 'keyup',
 *   keyCode: keyCode
 * });
 * ```
 */
var enterEvent = {
	defaultEventType: 'enter',

	addEventListener: function (target, eventType, handler) {
		var keyHandler = function (event) {
			if (isEnterEvent(event)) {
				return handler.apply(this, arguments);
			}
		};

		var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
		if (!handlerMap) {
			handlerMap = enterEvent._eventTypeHandlerMap[eventType] = new Map();
		}

		handlerMap.set(handler, keyHandler);
		this.addEventListener(target, baseEventType, keyHandler);
	},

	removeEventListener: function (target, eventType, handler) {
		var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
		if (handlerMap) {
			var keyHandler = handlerMap.get(handler);
			if (keyHandler) {
				handlerMap.delete(handler);
				if (handlerMap.size === 0) {
					delete enterEvent._eventTypeHandlerMap[eventType];
				}
				this.removeEventListener(target, baseEventType, keyHandler);
			}
		}
	},

	// {[eventType: string]: WeakMap<OriginalHandler, KeyEventHandler>}
	_eventTypeHandlerMap: {}
};

module.exports = namespace.domEventEnter = enterEvent;


/***/ }),

/***/ "./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

function getRoot () {
	return getDocument().documentElement;
}

function findParentForm (el) {
	while (el) {
		if (el.nodeName === 'FORM') {
			break;
		}
		el = el.parentNode;
	}
	return el;
}

function shouldReceiveEventFromRadio (source, dest) {
	// Must have the same name attribute and parent form
	var name = source.getAttribute('name');
	return (
		name &&
		name === dest.getAttribute('name') &&
		findParentForm(source) === findParentForm(dest)
	);
}

function isRadioInput (el) {
	return el.nodeName === 'INPUT' && el.type === 'radio';
}


function attachRootListener (domEvents, eventTypeTargets) {
	var root = getRoot();
	var newListener = function (event) {
		var target = event.target;
		if (!isRadioInput(target)) {
			return;
		}

		for (var eventType in eventTypeTargets) {
			var newEvent = {type: eventType};
			var listeningNodes = eventTypeTargets[eventType];
			listeningNodes.forEach(function (el) {
				if (shouldReceiveEventFromRadio(target, el)) {
					domEvents.dispatch(el, newEvent, false);
				}
			});
		}
	};
	domEvents.addEventListener(root, 'change', newListener);
	return newListener;
}

function detachRootListener (domEvents, listener) {
	var root = getRoot();
	domEvents.removeEventListener(root, 'change', listener);
}

/**
 * @module {events} can-event-dom-radiochange
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 *
 * A custom event for listening to changes of inputs with type "radio",
 * which fires when a conflicting radio input changes. A "conflicting"
 * radio button has the same "name" attribute and exists within in the
 * same form, or lack thereof. This event coordinates state bound to
 * whether a radio is checked. The "change" event does not fire for deselected
 * radios. By using this event instead, deselected radios receive notification.
 *
 * ```js
 * var domEvents = require('can-dom-events');
 * var radioChange = require('can-event-dom-radiochange');
 * domEvents.addEvent(radioChange);
 *
 * var target = document.createElement('input');
 *
 * function handler () {
 * 	console.log('radiochange event fired');
 * }
 *
 * domEvents.addEventListener(target, 'radiochange', handler);
 * domEvents.removeEventListener(target, 'radiochange', handler);
 * ```
 */
var radioChangeEvent = {
	defaultEventType: 'radiochange',

	addEventListener: function (target, eventType, handler) {
		if (!isRadioInput(target)) {
			throw new Error('Listeners for ' + eventType + ' must be radio inputs');
		}

		var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
		if (!eventTypeTrackedRadios) {
			eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};
			if (!radioChangeEvent._rootListener) {
				radioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);
			}			
		}

		var trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];
		if (!trackedRadios) {
			trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();
		}

		trackedRadios.add(target);
		target.addEventListener(eventType, handler);
	},

	removeEventListener: function (target, eventType, handler) {
		target.removeEventListener(eventType, handler);

		var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
		if (!eventTypeTrackedRadios) {
			return;
		}

		var trackedRadios = eventTypeTrackedRadios[eventType];
		if (!trackedRadios) {
			return;
		}
	
		trackedRadios.delete(target);
		if (trackedRadios.size === 0) {
			delete eventTypeTrackedRadios[eventType];
			for (var key in eventTypeTrackedRadios) {
				if (eventTypeTrackedRadios.hasOwnProperty(key)) {
					return;
				}						
			}
			delete radioChangeEvent._eventTypeTrackedRadios;
			detachRootListener(this, radioChangeEvent._rootListener);
			delete radioChangeEvent._rootListener;
		}
	}
};

module.exports = namespace.domEventRadioChange = radioChangeEvent;


/***/ }),

/***/ "./node_modules/can-event-queue/dependency-record/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-event-queue/dependency-record/merge.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var mergeValueDependencies = function mergeValueDependencies(obj, source) {
	var sourceValueDeps = source.valueDependencies;

	if (sourceValueDeps) {
		var destValueDeps = obj.valueDependencies;

		// make sure there is a valueDependencies Set
		// in the [obj] dependency record
		if (!destValueDeps) {
			destValueDeps = new Set();
			obj.valueDependencies = destValueDeps;
		}

		canReflect.eachIndex(sourceValueDeps, function(dep) {
			destValueDeps.add(dep);
		});
	}
};

var mergeKeyDependencies = function mergeKeyDependencies(obj, source) {
	var sourcekeyDeps = source.keyDependencies;

	if (sourcekeyDeps) {
		var destKeyDeps = obj.keyDependencies;

		// make sure there is a keyDependencies Map
		// in the [obj] dependency record
		if (!destKeyDeps) {
			destKeyDeps = new Map();
			obj.keyDependencies = destKeyDeps;
		}

		canReflect.eachKey(sourcekeyDeps, function(keys, obj) {
			var entry = destKeyDeps.get(obj);

			if (!entry) {
				entry = new Set();
				destKeyDeps.set(obj, entry);
			}

			canReflect.eachIndex(keys, function(key) {
				entry.add(key);
			});
		});
	}
};

// Merges the key and value dependencies of the source object into the
// destination object
module.exports = function mergeDependencyRecords(object, source) {
	mergeKeyDependencies(object, source);
	mergeValueDependencies(object, source);
	return object;
};


/***/ }),

/***/ "./node_modules/can-event-queue/map/map.js":
/*!*************************************************!*\
  !*** ./node_modules/can-event-queue/map/map.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {function} can-event-queue/map/map
 * @parent can-event-queue
 * @templateRender true
 *
 * @description Mixin methods and symbols to make this object or prototype object
 * behave like a key-value observable.
 *
 * @signature `mixinMapBindings( obj )`
 *
 * Adds symbols and methods that make `obj` or instances having `obj` on their prototype
 * behave like key-value observables.
 *
 * When `mixinMapBindings` is called on an `obj` like:
 *
 * ```js
 * var mixinMapBindings = require("can-event-queue/map/map");
 *
 * var observable = mixinValueBindings({});
 *
 * observable.on("prop",function(ev, newVal, oldVal){
 *   console.log(newVal);
 * });
 *
 * observable[canSymbol.for("can.dispatch")]("prop",[2,1]);
 * // Logs: 2
 * ```
 *
 * `mixinMapBindings` adds the following properties and symbols to the object:
 *
 * {{#each (getChildren [can-event-queue/map/map])}}
 * - [{{name}}] - {{description}}{{/each}}
 *
 * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`
 * property:
 *
 * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.
 * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of
 *   patches.
 */
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");

var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
var isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ "./node_modules/can-dom-events/helpers/util.js").isDomEventTarget;

var mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ "./node_modules/can-event-queue/dependency-record/merge.js");

var metaSymbol = canSymbol.for("can.meta"),
	dispatchBoundChangeSymbol = canSymbol.for("can.dispatchInstanceBoundChange"),
	dispatchInstanceOnPatchesSymbol = canSymbol.for("can.dispatchInstanceOnPatches"),
	onKeyValueSymbol = canSymbol.for("can.onKeyValue"),
	offKeyValueSymbol = canSymbol.for("can.offKeyValue"),
	onEventSymbol = canSymbol.for("can.onEvent"),
	offEventSymbol = canSymbol.for("can.offEvent"),
	onValueSymbol = canSymbol.for("can.onValue"),
	offValueSymbol = canSymbol.for("can.offValue"),
	inSetupSymbol = canSymbol.for("can.initializing");

var legacyMapBindings;

function addHandlers(obj, meta) {
	if (!meta.handlers) {
		// Handlers are organized by:
		// event name - the type of event bound to
		// binding type - "event" for things that expect an event object (legacy), "onKeyValue" for reflective bindings.
		// queue name - mutate, queue, etc
		// handlers - the handlers.
		meta.handlers = new KeyTree([Object, Object, Object, Array], {
			onFirst: function() {
				if (obj._eventSetup !== undefined) {
					obj._eventSetup();
				}
				var constructor = obj.constructor;
				if(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {
					constructor[dispatchBoundChangeSymbol](obj, true);
				}
				//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);
			},
			onEmpty: function() {
				if (obj._eventTeardown !== undefined) {
					obj._eventTeardown();
				}
				var constructor = obj.constructor;
				if(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {
					constructor[dispatchBoundChangeSymbol](obj, false);
				}
				//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);
			}
		});
	}

	if (!meta.listenHandlers) {
		// context, eventName (might be undefined), queue, handlers
		meta.listenHandlers = new KeyTree([Map, Map, Object, Array]);
	}
}


// getHandlers returns a KeyTree used for event handling.
// `handlers` will be on the `can.meta` symbol on the object.
// Ensure the "obj" passed as an argument has an object on @@can.meta
var ensureMeta = function ensureMeta(obj) {
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect.setKeyValue(obj, metaSymbol, meta);
	}
	addHandlers(obj, meta);

	return meta;
};

function stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {
	if(arguments.length && canReflect.isPrimitive(bindTarget)) {
		queueName = handler;
		handler = event;
		event = bindTarget;
		bindTarget = this.context;
	}
	if(typeof event === "function") {
		queueName = handler;
		handler = event;
		event = undefined;
	}
	if(typeof handler === "string") {
		queueName = handler;
		handler = undefined;
	}
	var keys = [];
	if(bindTarget) {
		keys.push(bindTarget);
		if(event || handler || queueName) {
			keys.push(event);
			if(queueName || handler) {
				keys.push(queueName || this.defaultQueue);
				if(handler) {
					keys.push(handler);
				}
			}
		}
	}
	return keys;
}


// These are the properties we are going to add to objects
var props = {
	/**
	 * @function can-event-queue/map/map.dispatch dispatch
	 * @parent can-event-queue/map/map
	 *
	 * @description Dispatch event and key binding handlers.
	 *
	 * @signature `obj.dispatch(event, [args])`
	 *
	 * Dispatches registered [can-event-queue/map/map.addEventListener] and
	 * [can-event-queue/map/map.can.onKeyValue] value binding handlers.
	 *
	 * The following shows dispatching the `property` event and
	 * `keyValue` handlers:
	 *
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * obj.addEventListener("property", function(event, newVal){
	 *   event.type //-> "property"
	 *   newVal     //-> 5
	 * });
	 *
	 * canReflect.onKeyValue("property", function(newVal){
	 *   newVal     //-> 5
	 * })
	 *
	 * obj.dispatch("property", [5]);
	 * ```
	 *
	 * > NOTE: Event handlers have an additional `event` argument.
	 *
	 * @param {String|Object} event The event to dispatch. If a string is passed,
	 *   it will be used as the `type` of the event that will be dispatched and dispatch matching
	 *   [can-event-queue/map/map.can.onKeyValue] bindings:
	 *
	 *   ```js
	 *   obs.dispatch("key")
	 *   ```
	 *
	 *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,
	 *   it will be used as the `type` of the event that will be dispatched and dispatch matching
	 *   [can-event-queue/map/map.can.onKeyValue] bindings:
	 *
	 *   ```js
	 *   obs.dispatch({type: "key"})
	 *   ```
	 *
	 *   The `event` object can also have the following properties and values:
	 *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to
	 *     [can-queues.enqueueByQueue] for debugging purposes.
	 *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to
	 *     [can-queues.enqueueByQueue] for debugging purposes.
	 *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be
	 *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.
	 *
	 * @param {Array} [args] Additional arguments to pass to event handlers.
	 * @return {Object} event The resulting event object.
	 */
	dispatch: function(event, args) {
		//!steal-remove-start
		if(true) {
			if (arguments.length > 4) {
				canDev.warn('Arguments to dispatch should be an array, not multiple arguments.');
				args = Array.prototype.slice.call(arguments, 1);
			}

			if (args && !Array.isArray(args)) {
				canDev.warn('Arguments to dispatch should be an array.');
				args = [args];
			}
		}
		//!steal-remove-end

		// Don't send events if initalizing.
		if (this.__inSetup !== true && this[inSetupSymbol] !== true) {
			if (typeof event === 'string') {
				event = {
					type: event
				};
			}

			var meta = ensureMeta(this);

			//!steal-remove-start
			if(true) {
				if (!event.reasonLog) {
					event.reasonLog = [canReflect.getName(this), "dispatched", '"' + event.type + '"', "with"].concat(args);
				}
			}

			if (typeof meta._log === "function") {
				meta._log.call(this, event, args);
			}
			//!steal-remove-end
			var handlers = meta.handlers;
			var handlersByType = event.type !== undefined && handlers.getNode([event.type]);
			var dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];
			var patchesNode = event.patches !== undefined && handlers.getNode(["can.patches","onKeyValue"]);
			var keysNode = event.keyChanged !== undefined && handlers.getNode(["can.keys","onKeyValue"]);
			var batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;
			if ( batch ) {
				queues.batch.start();
			}
			if(handlersByType) {
				if (handlersByType.onKeyValue) {
					queues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);
				}
				if (handlersByType.event) {
					event.batchNum = queues.batch.number();
					var eventAndArgs = [event].concat(args);
					queues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);
				}
			}
			if(keysNode) {
				queues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);
			}
			if(patchesNode) {
				queues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);
			}
			if(dispatchConstructorPatches) {
				this.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);
			}
			if ( batch ) {
				queues.batch.stop();
			}
		}
		return event;
	},
	/**
	 * @function can-event-queue/map/map.addEventListener addEventListener
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler to be called when an event is dispatched.
	 *
	 * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`
	 *
	 * Add a event listener to an object.  Handlers attached by `.addEventListener` get
	 * called back with the [can-event-queue/map/map.dispatch]
	 * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do
	 * not get the event object.
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * obj.addEventListener("foo", function(event){ ... });
	 * ```
	 *
	 * @param {String} eventName The name of the event to listen for.
	 * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called
	 *   with the dispatched `event` and `args`.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called
	 *   back within. Defaults to `"mutate"`.
	 * @return {Object} Returns the object `.addEventListener` was called on.
	 *
	 */
	addEventListener: function(key, handler, queueName) {
		ensureMeta(this).handlers.add([key, "event", queueName || "mutate", handler]);
		return this;
	},
	/**
	 * @function can-event-queue/map/map.removeEventListener removeEventListener
	 * @parent can-event-queue/map/map
	 *
	 * @description Unregister an event handler to be called when an event is dispatched.
	 *
	 * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`
	 *
	 * Removes one or more handlers from being called when `eventName`
	 * is [can-event-queue/map/map.dispatch]ed.
	 *
	 * ```js
	 * // Removes `handler` if it is in the notify queue.
	 * obj.removeEventListener("closed", handler, "notify")
	 *
	 * // Removes `handler` if it is in the mutate queue.
	 * obj.removeEventListener("closed", handler)
	 *
	 * // Removes all "closed" handlers.
	 * obj.removeEventListener("closed")
	 * ```
	 *
	 * @param {String} eventName The name of the event to remove. If not specified, all events are removed.
	 * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `"mutate"`.
	 * @return {Object} Returns the object `.removeEventListener` was called on.
	 */
	removeEventListener: function(key, handler, queueName) {
		if(key === undefined) {
			// This isn't super fast, but this pattern isn't used much.
			// We could re-arrange the tree so it would be faster.
			var handlers = ensureMeta(this).handlers;
			var keyHandlers = handlers.getNode([]);
			Object.keys(keyHandlers).forEach(function(key){
				handlers.delete([key,"event"]);
			});
		} else if (!handler && !queueName) {
			ensureMeta(this).handlers.delete([key, "event"]);
		} else if (!handler) {
			ensureMeta(this).handlers.delete([key, "event", queueName || "mutate"]);
		} else {
			ensureMeta(this).handlers.delete([key, "event", queueName || "mutate", handler]);
		}
		return this;
	},
	/**
	 * @function can-event-queue/map/map.one one
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler that gets called only once.
	 *
	 * @signature `obj.one(event, handler(event, args...) )`
	 *
	 * Adds a basic event listener that listens to an event once and only once.
	 *
	 * ```js
	 * obj.one("prop", function(){
	 *   console.log("prop dispatched");
	 * })
	 *
	 * obj[canSymbol.for("prop")]("prop") //-> logs "prop dispatched"
	 * obj[canSymbol.for("prop")]("prop")
	 * ```
	 *
	 * @param {String} eventName The name of the event to listen to.
	 * @param {Function} handler(event, args...) The handler that will be run when the
	 *   event is dispached.
	 * @return {Object} this
	 */
	one: function(event, handler) {
		// Unbind the listener after it has been executed
		var one = function() {
			legacyMapBindings.off.call(this, event, one);
			return handler.apply(this, arguments);
		};

		// Bind the altered listener
		legacyMapBindings.on.call(this, event, one);
		return this;
	},
	/**
	 * @function can-event-queue/map/map.listenTo listenTo
	 * @parent can-event-queue/map/map
	 *
	 * @description Listen to an event and register the binding for simplified unbinding.
	 *
	 * @signature `obj.listenTo([bindTarget,] event, handler)`
	 *
	 * `.listenTo` is useful for creating bindings that can can be torn down with
	 * [can-event-queue/map/map.stopListening].  This is useful when creating
	 * rich behaviors that can't be accomplished using computed values, or if you are trying to
	 * avoid streams.
	 *
	 * For example, the following creates an observable that counts how many times its
	 * `name` property has changed:
	 *
	 * ```js
	 * class Person {
	 *   constructor(){
	 *     this.nameChanged = 0;
	 *     this.listenTo("name", function(){
	 *       this.nameChanged++;
	 *     })
	 *   },
	 *   setName(newVal) {
	 *     this.name = newVal;
	 *     this.dispatch("name",[newVal])
	 *   }
	 * }
	 * mixinMapBindings(Person.prototype);
	 *
	 * var person = new Person();
	 * person.setName("Justin");
	 * person.setName("Ramiya");
	 * person.nameChanged //-> 2
	 * ```
	 *
	 * `.listenTo` event bindings are stored on an observable and MUST be unbound using
	 * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind
	 * all of the `.listenTo` event bindings when the observable is no longer needed:
	 *
	 * ```js
	 * person.stopListening();
	 * ```
	 *
	 * If no `bindTarget` is passed, `.listenTo` binds to the current
	 * observable.
	 *
	 * [can-component]'s `connectedCallback` lifecyle hook is often used to call
	 * `.listenTo` to setup bindings that update viewmodel properties.
	 *
	 *
	 * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,
	 * the observable `.listenTo` was called on will be the `bindTarget`.
	 * @param {String} event The name of the event to listen for.
	 * @param {Function} handler The handler that will be executed to handle the event.
	 * @return {Object} this
	 */
	listenTo: function (bindTarget, event, handler, queueName) {

		if(canReflect.isPrimitive(bindTarget)) {
			queueName = handler;
			handler = event;
			event = bindTarget;
			bindTarget = this;
		}

		if(typeof event === "function") {
			queueName = handler;
			handler = event;
			event = undefined;
		}

		// Initialize event cache
		ensureMeta(this).listenHandlers.add([bindTarget, event, queueName || "mutate", handler]);

		legacyMapBindings.on.call(bindTarget, event, handler, queueName || "mutate");
		return this;
	},
	/**
	 * @function can-event-queue/map/map.stopListening stopListening
	 * @parent can-event-queue/map/map
	 * @description Stops listening for registered event handlers.
	 *
	 * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`
	 *
	 * `.stopListening` unbinds on event handlers registered through
	 * [can-event-queue/map/map.listenTo]. All event handlers
	 * that match the arguments will be unbound. For example:
	 *
	 * ```js
	 * // Unbinds all .listenTo registered handlers
	 * obj.stopListening()
	 *
	 * // Unbinds all .listenTo registered with `bindTarget`
	 * obj.stopListening(bindTarget)
	 *
	 * // Unbinds all .listenTo registered with `bindTarget`, `event`
	 * obj.stopListening(bindTarget, event)
	 *
	 * // Unbinds the handler registered with `bindTarget`, `event`, `handler`
	 * obj.stopListening(bindTarget, event, handler)
	 * ```
	 *
	 * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.
	 *
	 * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is
	 * not provided, the observable `.stopListening` was called on will be the `bindTarget`.
	 * @param {String} [event] The name of the event to listen for.
	 * @param {Function} [handler] The handler that will be executed to handle the event.
	 * @return {Object} this
	 *
	 */
	stopListening: function () {
		var keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: "mutate"}, arguments);

		var listenHandlers = ensureMeta(this).listenHandlers;

		function deleteHandler(bindTarget, event, queue, handler){
			legacyMapBindings.off.call(bindTarget, event, handler, queue);
		}
		listenHandlers.delete(keys, deleteHandler);

		return this;
	},
	/**
	 * @function can-event-queue/map/map.on on
	 * @parent can-event-queue/map/map
	 *
	 * @description A shorthand method for listening to event.
	 *
	 * @signature `obj.on( event, handler [, queue] )`
	 *
	 * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]
	 * change, or a [can-reflect/observe.onValue] change in that order.
	 *
	 * As this is the __legacy__ `.on`, it will look for an `.addEventListener`
	 * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]
	 * and then [can-symbol/symbols/onValue] symbol.
	 *
	 * @param {String} eventName
	 * @param {Function} handler
	 * @param {String} [queue]
	 * @return {Any} The object `on` was called on.
	 */
	on: function(eventName, handler, queue) {
		var listenWithDOM = isDomEventTarget(this);
		if (listenWithDOM) {
			if (typeof handler === 'string') {
				domEvents.addDelegateListener(this, eventName, handler, queue);
			} else {
				domEvents.addEventListener(this, eventName, handler, queue);
			}
		} else {
			if (this[onEventSymbol]) {
				this[onEventSymbol](eventName, handler, queue);
			} else if ("addEventListener" in this) {
				this.addEventListener(eventName, handler, queue);
			} else if (this[onKeyValueSymbol]) {
				canReflect.onKeyValue(this, eventName, handler, queue);
			} else {
				if (!eventName && this[onValueSymbol]) {
					canReflect.onValue(this, handler, queue);
				} else {
					throw new Error("can-event-queue: Unable to bind " + eventName);
				}
			}
		}
		return this;
	},
	/**
	 * @function can-event-queue/map/map.off off
	 * @parent can-event-queue/map/map
	 *
	 * @description A shorthand method for unbinding an event.
	 *
	 * @signature `obj.on( event, handler [, queue] )`
	 *
	 * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]
	 * change, or a [can-reflect/observe.onValue] change in that order.
	 *
	 * As this is the __legacy__ `.on`, it will look for an `.addEventListener`
	 * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]
	 * and then [can-symbol/symbols/onValue] symbol.
	 *
	 * @param {String} eventName
	 * @param {Function} handler
	 * @param {String} [queue]
	 * @return {Any} The object `on` was called on.
	 */
	off: function(eventName, handler, queue) {
		var listenWithDOM = isDomEventTarget(this);
		if (listenWithDOM) {
			if (typeof handler === 'string') {
				domEvents.removeDelegateListener(this, eventName, handler, queue);
			} else {
				domEvents.removeEventListener(this, eventName, handler, queue);
			}
		} else {
			if (this[offEventSymbol]) {
				this[offEventSymbol](eventName, handler, queue);
			} else if ("removeEventListener" in this) {
				this.removeEventListener(eventName, handler, queue);
			} else if (this[offKeyValueSymbol]) {
				canReflect.offKeyValue(this, eventName, handler, queue);
			} else {
				if (!eventName && this[offValueSymbol]) {
					canReflect.offValue(this, handler, queue);
				} else {
					throw new Error("can-event-queue: Unable to unbind " + eventName);
				}

			}
		}
		return this;
	}
};

// The symbols we'll add to objects
var symbols = {
	/**
	 * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler to be called when a key value changes.
	 *
	 * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`
	 *
	 * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get
	 * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]
	 * get the event object.
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * canReflect.onKeyValue( obj, "prop", function(newPropValue){ ... });
	 * ```
	 *
	 * @param {String} key The name of property to listen to changes in values.
	 * @param {Function} handler(newVal, oldValue) The handler that will be called
	 *   back with the new and old value of the key.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called
	 *   back within. Defaults to `"mutate"`.
	 */
	"can.onKeyValue": function(key, handler, queueName) {
		ensureMeta(this).handlers.add([key, "onKeyValue", queueName || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue
	 * @parent can-event-queue/map/map
	 *
	 * @description Unregister an event handler to be called when an event is dispatched.
	 *
	 * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`
	 *
	 * Removes a handlers from being called when `key` changes are
	 * [can-event-queue/map/map.dispatch]ed.
	 *
	 * ```js
	 * // Removes `handler` if it is in the notify queue.
	 * canReflect.offKeyValue( obj, "prop", handler, "notify" )
	 * ```
	 *
	 * @param {String} eventName The name of the event to remove. If not specified, all events are removed.
	 * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `"mutate"`.
	 */
	"can.offKeyValue": function(key, handler, queueName) {
		ensureMeta(this).handlers.delete([key, "onKeyValue", queueName || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/map/map.can.isBound @can.isBound
	 * @parent can-event-queue/map/map
	 *
	 * @description Return if the observable is bound to.
	 *
	 * @signature `canReflect.isBound(obj)`
	 *
	 * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]
	 * return if `obj` is bound or not.
	 *
	 * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.
	 */
	"can.isBound": function() {
		return !ensureMeta(this).handlers.isEmpty();
	},
	/**
	 * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange
	 * @parent can-event-queue/map/map
	 *
	 * @description Return observables whose values are affected by attached event handlers
	 * @signature `@can.getWhatIChange(key)`
	 *
	 * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report
	 * all the observables whose values are set by a given observable's key.
	 *
	 * This function iterates over the event handlers attached to a given `key` and
	 * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;
	 * this symbol allows the caller to tell what observables are being mutated by
	 * the event handler when it is executed.
	 *
	 * In the following example a [can-simple-map] instance named `me` is created
	 * and when its `age` property changes, the value of a [can-simple-observable]
	 * instance is set. The event handler that causes the mutation is then decatorated
	 * with `@@can.getChangesDependencyRecord` to register the mutation dependency.
	 *
	 * ```js
	 * var obs = new SimpleObservable("a");
	 * var me = new SimpleMap({ age: 30 });
	 * var canReflect = require("can-reflect");
	 *
	 * var onAgeChange = function onAgeChange() {
	 *	canReflect.setValue(obs, "b");
	 * };
	 *
	 * onAgeChange[canSymbol.for("can.getChangesDependencyRecord")] = function() {
	 *	return {
	 *		valueDependencies: new Set([ obs ]);
	 *	}
	 * };
	 *
	 * canReflect.onKeyValue(me, "age", onAgeChange);
	 * me[canSymbol.for("can.getWhatIChange")]("age");
	 * ```
	 *
	 * The dependency records collected from the event handlers are divided into
	 * two categories:
	 *
	 * - mutate: Handlers in the mutate/domUI queues
	 * - derive: Handlers in the notify queue
	 *
	 * Since event handlers are added by default to the "mutate" queue, calling
	 * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate
	 * property and the `valueDependencies` Set registered on the `onAgeChange`
	 * handler.
	 *
	 * Please check out the [can-reflect-dependencies] docs to learn more about
	 * how this symbol is used to keep track of custom observable dependencies.
	 */
	"can.getWhatIChange": function getWhatIChange(key) {
		//!steal-remove-start
			if(true) {
			var whatIChange = {};
			var meta = ensureMeta(this);

			var notifyHandlers = [].concat(
				meta.handlers.get([key, "event", "notify"]),
				meta.handlers.get([key, "onKeyValue", "notify"])
			);

			var mutateHandlers = [].concat(
				meta.handlers.get([key, "event", "mutate"]),
				meta.handlers.get([key, "event", "domUI"]),
				meta.handlers.get([key, "onKeyValue", "mutate"]),
				meta.handlers.get([key, "onKeyValue", "domUI"])
			);

			if (notifyHandlers.length) {
				notifyHandlers.forEach(function(handler) {
					var changes = canReflect.getChangesDependencyRecord(handler);

					if (changes) {
						var record = whatIChange.derive;
						if (!record) {
							record = (whatIChange.derive = {});
						}
						mergeDependencyRecords(record, changes);
					}
				});
			}

			if (mutateHandlers.length) {
				mutateHandlers.forEach(function(handler) {
					var changes = canReflect.getChangesDependencyRecord(handler);

					if (changes) {
						var record = whatIChange.mutate;
						if (!record) {
							record = (whatIChange.mutate = {});
						}
						mergeDependencyRecords(record, changes);
					}
				});
			}

			return Object.keys(whatIChange).length ? whatIChange : undefined;
		}
		//!steal-remove-end
	},
	"can.onPatches": function(handler, queue) {
		var handlers = ensureMeta(this).handlers;
		handlers.add(["can.patches", "onKeyValue", queue || "notify", handler]);
	},
	"can.offPatches": function(handler, queue) {
		var handlers = ensureMeta(this).handlers;
		handlers.delete(["can.patches", "onKeyValue", queue || "notify", handler]);
	}
};

// This can be removed in a future version.
function defineNonEnumerable(obj, prop, value) {
	Object.defineProperty(obj, prop, {
		enumerable: false,
		value: value
	});
}

// The actual legacyMapBindings mixin function
legacyMapBindings = function(obj) {
	// add properties
	canReflect.assignMap(obj, props);
	// add symbols
	return canReflect.assignSymbols(obj, symbols);
};

defineNonEnumerable(legacyMapBindings, "addHandlers", addHandlers);
defineNonEnumerable(legacyMapBindings, "stopListeningArgumentsToKeys", stopListeningArgumentsToKeys);



// ## LEGACY
// The following is for compatability with the old can-event
props.bind = props.addEventListener;
props.unbind = props.removeEventListener;



// Adds methods directly to method so it can be used like `can-event` used to be used.
canReflect.assignMap(legacyMapBindings, props);
canReflect.assignSymbols(legacyMapBindings, symbols);

defineNonEnumerable(legacyMapBindings, "start", function() {
	console.warn("use can-queues.batch.start()");
	queues.batch.start();
});
defineNonEnumerable(legacyMapBindings, "stop", function() {
	console.warn("use can-queues.batch.stop()");
	queues.batch.stop();
});
defineNonEnumerable(legacyMapBindings, "flush", function() {
	console.warn("use can-queues.flush()");
	queues.flush();
});

defineNonEnumerable(legacyMapBindings, "afterPreviousEvents", function(handler) {
	console.warn("don't use afterPreviousEvents");
	queues.mutateQueue.enqueue(function afterPreviousEvents() {
		queues.mutateQueue.enqueue(handler);
	});
	queues.flush();
});

defineNonEnumerable(legacyMapBindings, "after", function(handler) {
	console.warn("don't use after");
	queues.mutateQueue.enqueue(handler);
	queues.flush();
});

module.exports = legacyMapBindings;


/***/ }),

/***/ "./node_modules/can-event-queue/type/type.js":
/*!***************************************************!*\
  !*** ./node_modules/can-event-queue/type/type.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {function} can-event-queue/type/type
 * @parent can-event-queue
 *
 * @description Mixin methods and symbols to make a type constructor function able to
 * broadcast changes in its instances.
 *
 * @signature `mixinTypeBindings( type )`
 *
 * Adds symbols and methods that make `type` work with the following [can-reflect] APIs:
 *
 * - [can-reflect/observe.onInstanceBoundChange] - Observe when instances are bound.
 * - [can-reflect/observe.onInstancePatches] - Observe patche events on all instances.
 *
 * When `mixinTypeBindings` is called on an `Person` _type_ like:
 *
 * ```js
 * var mixinTypeBindings = require("can-event-queue/type/type");
 * var mixinLegacyMapBindings = require("can-event-queue/map/map");
 *
 * class Person {
 *   constructor(data){
 *     this.data = data;
 *   }
 * }
 * mixinTypeBindings(Person);
 * mixinLegacyMapBindings(Person.prototype);
 *
 * var me = new Person({first: "Justin", last: "Meyer"});
 *
 * // mixinTypeBindings allows you to listen to
 * // when a person instance's bind stache changes
 * canReflect.onInstanceBoundChange(Person, function(person, isBound){
 *    console.log("isBound");
 * });
 *
 * // mixinTypeBindings allows you to listen to
 * // when a patch change happens.
 * canReflect.onInstancePatches(Person, function(person, patches){
 *    console.log(patches[0]);
 * });
 *
 * me.on("name",function(ev, newVal, oldVal){}) //-> logs: "isBound"
 *
 * me.dispatch({
 *   type: "first",
 *   patches: [{type: "set", key: "first", value: "Ramiya"}]
 * }, ["Ramiya","Justin"])
 * //-> logs: {type: "set", key: "first", value: "Ramiya"}
 * ```
 *
 */
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var metaSymbol = canSymbol.for("can.meta");

function addHandlers(obj, meta) {
    if (!meta.lifecycleHandlers) {
        meta.lifecycleHandlers = new KeyTree([Object, Array]);
    }
    if (!meta.instancePatchesHandlers) {
        meta.instancePatchesHandlers = new KeyTree([Object, Array]);
    }
}

function ensureMeta(obj) {
    var meta = obj[metaSymbol];

    if (!meta) {
        meta = {};
        canReflect.setKeyValue(obj, metaSymbol, meta);
    }

    addHandlers(obj, meta);
    return meta;
}

var props = {
    /**
     * @function can-event-queue/type/type.can.onInstanceBoundChange @can.onInstanceBoundChange
     * @parent can-event-queue/type/type
     * @description Listen to when any instance is bound for the first time or all handlers are removed.
     *
     * @signature `canReflect.onInstanceBoundChange(Type, handler(instance, isBound) )`
     *
     * ```js
     * canReflect.onInstanceBoundChange(Person, function(person, isBound){
     *    console.log("isBound");
     * });
     * ```
     *
     * @param {function(Any,Boolean)} handler(instance,isBound) A function is called
     * when an instance is bound or unbound.  `isBound` will be `true` when the instance
     * becomes bound and `false` when unbound.
     */

    /**
     * @function can-event-queue/type/type.can.offInstanceBoundChange @can.offInstanceBoundChange
     * @parent can-event-queue/type/type
     *
     * @description Stop listening to when an instance's bound status changes.
     *
     * @signature `canReflect.offInstanceBoundChange(Type, handler )`
     *
     * Stop listening to a handler bound with
     * [can-event-queue/type/type.can.onInstanceBoundChange].
     */


    /**
     * @function can-event-queue/type/type.can.onInstancePatches @can.onInstancePatches
     * @parent can-event-queue/type/type
     *
     * @description Listen to patch changes on any instance.
     *
     * @signature `canReflect.onInstancePatches(Type, handler(instance, patches) )`
     *
     * Listen to patch changes on any instance of `Type`. This is used by
     * [can-connect] to know when a potentially `unbound` instance's `id`
     * changes. If the `id` changes, the instance can be moved into the store
     * while it is being saved.
     *
     */

    /**
     * @function can-event-queue/type/type.can.offInstancePatches @can.offInstancePatches
     * @parent can-event-queue/type/type
     *
     * @description Stop listening to patch changes on any instance.
     *
     * @signature `canReflect.onInstancePatches(Type, handler )`
     *
     * Stop listening to a handler bound with [can-event-queue/type/type.can.onInstancePatches].
     */
};

function onOffAndDispatch(symbolName, dispatchName, handlersName){
    props["can.on"+symbolName] = function(handler, queueName) {
        ensureMeta(this)[handlersName].add([queueName || "mutate", handler]);
    };
    props["can.off"+symbolName] = function(handler, queueName) {
        ensureMeta(this)[handlersName].delete([queueName || "mutate", handler]);
    };
    props["can."+dispatchName] = function(instance, arg){
        queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [instance, arg]);
    };
}

onOffAndDispatch("InstancePatches","dispatchInstanceOnPatches","instancePatchesHandlers");
onOffAndDispatch("InstanceBoundChange","dispatchInstanceBoundChange","lifecycleHandlers");

function mixinTypeBindings(obj){
    return canReflect.assignSymbols(obj,props);
}

Object.defineProperty(mixinTypeBindings, "addHandlers", {
    enumerable: false,
    value: addHandlers
});

module.exports = mixinTypeBindings;


/***/ }),

/***/ "./node_modules/can-event-queue/value/value.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-event-queue/value/value.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");
var mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ "./node_modules/can-event-queue/dependency-record/merge.js");

var properties = {
	/**
	 * @function can-event-queue/value/value.on on
	 * @parent can-event-queue/value/value
	 *
	 * @description Listen to changes in the observable's value.
	 *
	 * @signature `.on( handler[, queue='mutate'] )`
	 *
	 * This adds an event handler in the observable's [can-event-queue/value/value.handlers]
	 * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.
	 *
	 * ```js
	 * observable.on(function(newVal){ ... });
	 * observable.on(function(newVal){ ... }, "notify");
	 * ```
	 *
	 * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the
	 * observable and optionally the old value of the observable.
	 * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will
	 * be called within the `mutate` queue.
	 */
	on: function(handler, queue) {
		this.handlers.add([queue || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/value/value.off off
	 * @parent can-event-queue/value/value
	 *
	 * @description Stop listening to changes in the observable's value.
	 *
	 * @signature `.off( [handler [, queue='mutate']] )`
	 *
	 * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]
	 * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.
	 *
	 * ```js
	 * observable.off(function(newVal){ ... });
	 * observable.off(function(newVal){ ... }, "notify");
	 * observable.off();
	 * observable.off(undefined, "mutate");
	 * ```
	 *
	 * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no
	 * `queue` is provided, all handlers will be removed.
	 * @param {String} [queue] The [can-queues] queue this event handler should be removed from.
	 *
	 *  If a `handler` is
	 *  provided and no `queue` is provided, the `queue` will default to `"mutate"`.
	 *
	 *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be
	 *   removed.
	 */
	off: function(handler, queueName) {
		if (handler === undefined) {
			if (queueName === undefined) {
				this.handlers.delete([]);
			} else {
				this.handlers.delete([queueName]);
			}
		} else {
			this.handlers.delete([queueName || "mutate", handler]);
		}
	}
};

var symbols = {
	/**
	 * @function can-event-queue/value/value.can.onValue @can.onValue
	 * @parent can-event-queue/value/value
	 *
	 * @description Listen to changes in this observable value.
	 *
	 * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].
	 */
	"can.onValue": properties.on,
	/**
	 * @function can-event-queue/value/value.can.offValue @can.offValue
	 * @parent can-event-queue/value/value
	 *
	 * @description Stop listening to changes in this observable value.
	 *
	 * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].
	 */
	"can.offValue": properties.off,
	/**
	 * @function can-event-queue/value/value.can.dispatch @can.dispatch
	 * @parent can-event-queue/value/value
	 *
	 * @description Dispatch all event handlers within their appropriate queues.
	 *
	 * @signature `@can.dispatch(newValue, oldValue)`
	 *
	 * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within
	 * their appropriate [can-queues] queue.
	 *
	 * Furthermore, it will make sure the handlers include useful meta data for debugging.
	 *
	 * ```js
	 * var observable = mixinValueBindings({});
	 * observable[canSymbol.for("can.dispatch")]( 2, 1 );
	 * ```
	 *
	 * @param {Any} newValue The new value of the observable.
	 * @param {Any} oldValue The old value of the observable.
	 */
	"can.dispatch": function(value, old) {
		var queuesArgs = [];
		queuesArgs = [
			this.handlers.getNode([]),
			this,
			[value, old]
		];

		//!steal-remove-start
		if(true) {
			queuesArgs = [
				this.handlers.getNode([]),
				this,
				[value, old]
				/* jshint laxcomma: true */
				, null
				, [canReflect.getName(this), "changed to", value, "from", old]
				/* jshint laxcomma: false */
			];
		}
		//!steal-remove-end
		queues.enqueueByQueue.apply(queues, queuesArgs);
		//!steal-remove-start
		if(true) {
			if (typeof this._log === "function") {
				this._log(old, value);
			}
		}
		//!steal-remove-end
	},
	/**
	 * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange
	 * @parent can-event-queue/value/value
	 *
	 * @description Return observables whose values are affected by attached event handlers
	 * @signature `@can.getWhatIChange()`
	 *
	 * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report
	 * all the observables whose values are set by value-like observables.
	 *
	 * This function iterates over the event handlers attached to  the observable's value
	 * event and collects the result of calling `@@can.getChangesDependencyRecord` on each
	 * handler; this symbol allows the caller to tell what observables are being mutated
	 * by the event handler when it is executed.
	 *
	 * In the following example a [can-simple-observable] instance named `month` is
	 * created and when its value changes the `age` property of the `map` [can-simple-map]
	 * instance is set. The event handler that causes the mutation is then decatorated with
	 * `@@can.getChangesDependencyRecord` to register the mutation dependency.
	 *
	 * ```js
	 * var month = new SimpleObservable(11);
	 * var map = new SimpleMap({ age: 30 });
	 * var canReflect = require("can-reflect");
	 *
	 * var onValueChange = function onValueChange() {
	 *	map.set("age", 31);
	 * };
	 *
	 * onValueChange[canSymbol.for("can.getChangesDependencyRecord")] = function() {
	 *	return {
	 *		keyDependencies: new Map([ [map, new Set(["age"])] ])
	 *	}
	 * };
	 *
	 * canReflect.onValue(month, onValueChange);
	 * month[canSymbol.for("can.getWhatIChange")]();
	 * ```
	 *
	 * The dependency records collected from the event handlers are divided into
	 * two categories:
	 *
	 * - mutate: Handlers in the mutate/domUI queues
	 * - derive: Handlers in the notify queue
	 *
	 * Since event handlers are added by default to the "mutate" queue, calling
	 * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate
	 * property and the `keyDependencies` Map registered on the `onValueChange` handler.
	 *
	 * If multiple event handlers were attached to `month`, the dependency records
	 * of each handler are merged by `@@can.getWhatIChange`. Please check out the
	 * [can-reflect-dependencies] docs to learn more about how this symbol is used
	 * to keep track of custom observable dependencies.
	 */
	"can.getWhatIChange": function getWhatIChange() {
		//!steal-remove-start
		if(true) {
			var whatIChange = {};

			var notifyHandlers = this.handlers.get(["notify"]);
			var mutateHandlers = [].concat(
				this.handlers.get(["mutate"]),
				this.handlers.get(["domUI"]),
				this.handlers.get(["dom"])
			);

			if (notifyHandlers.length) {
				notifyHandlers.forEach(function(handler) {
					var changes = canReflect.getChangesDependencyRecord(handler);

					if (changes) {
						var record = whatIChange.derive;
						if (!record) {
							record = (whatIChange.derive = {});
						}
						mergeDependencyRecords(record, changes);
					}
				});
			}

			if (mutateHandlers.length) {
				mutateHandlers.forEach(function(handler) {
					var changes = canReflect.getChangesDependencyRecord(handler);

					if (changes) {
						var record = whatIChange.mutate;
						if (!record) {
							record = (whatIChange.mutate = {});
						}
						mergeDependencyRecords(record, changes);
					}
				});
			}

			return Object.keys(whatIChange).length ? whatIChange : undefined;
		}
		//!steal-remove-end
	},

	/**
	 * @function can-event-queue/value/value.can.isBound @can.isBound
	 * @parent can-event-queue/value/value
	 */
	"can.isBound": function isBound() {
		return !this.handlers.isEmpty();
	}
};

/**
 * @property {can-key-tree} can-event-queue/value/value.handlers handlers
 * @parent can-event-queue/value/value
 *
 * @description Access the handlers tree directly.
 *
 * @type {can-key-tree}
 *
 *  The handlers property is a [can-define-lazy-value lazily] defined property containing
 *  all handlers bound with [can-event-queue/value/value.on] and
 *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:
 *
 *  ```js
 *  this.handlers = new KeyTree([Object, Array])
 *  ```
 *
 *  It is configured to call [can-event-queue/value/value.onBound] and
 *  [can-event-queue/value/value.onUnbound] on the instances when the first item is
 *  added to the tree and when the tree is emptied.
 */
function defineLazyHandlers(){
	return new KeyTree([Object, Array], {
		onFirst: this.onBound !== undefined && this.onBound.bind(this),
		onEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)
	});
}

/**
 * @function can-event-queue/value/value.onBound onBound
 * @parent can-event-queue/value/value
 *
 * @description Perform operations when an observable is gains its first event handler.
 *
 * @signature `.onBound()`
 *
 * This method is not implemented by `can-event-queue/value/value`. Instead, the object
 * should implement it if it wants to perform some actions when it becomes bound.
 *
 * ```js
 * var mixinValueBindings = require("can-event-queue/value/value");
 *
 * var observable = mixinValueBindings({
 *   onBound: function(){
 *     console.log("I AM BOUND!");
 *   }
 * });
 *
 * observable.on(function(){});
 * // Logs: "I AM BOUND!"
 * ```
 *
 */

/**
 * @function can-event-queue/value/value.onUnbound onUnbound
 * @parent can-event-queue/value/value
 *
 * @description Perform operations when an observable loses all of its event handlers.
 *
 * @signature `.onBound()`
 *
 * This method is not implemented by `can-event-queue/value/value`. Instead, the object
 * should implement it if it wants to perform some actions when it becomes unbound.
 *
 * ```js
 * var mixinValueBindings = require("can-event-queue/value/value");
 *
 * var observable = mixinValueBindings({
 *   onUnbound: function(){
 *     console.log("I AM UNBOUND!");
 *   }
 * });
 * var handler = function(){}
 * observable.on(function(){});
 * observable.off(function(){});
 * // Logs: "I AM UNBOUND!"
 * ```
 */

/**
 * @module {function} can-event-queue/value/value
 * @parent can-event-queue
 *
 * @description Mixin methods and symbols to make this object or prototype object
 * behave like a single-value observable.
 *
 * @signature `mixinValueBindings( obj )`
 *
 * Adds symbols and methods that make `obj` or instances having `obj` on their prototype
 * behave like single-value observables.
 *
 * When `mixinValueBindings` is called on an `obj` like:
 *
 * ```js
 * var mixinValueBindings = require("can-event-queue/value/value");
 *
 * var observable = mixinValueBindings({});
 *
 * observable.on(function(newVal, oldVal){
 *   console.log(newVal);
 * });
 *
 * observable[canSymbol.for("can.dispatch")](2,1);
 * // Logs: 2
 * ```
 *
 * `mixinValueBindings` adds the following properties and symbols to the object:
 *
 * - [can-event-queue/value/value.on]
 * - [can-event-queue/value/value.off]
 * - [can-event-queue/value/value.can.dispatch]
 * - [can-event-queue/value/value.can.getWhatIChange]
 * - [can-event-queue/value/value.handlers]
 *
 * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]
 * function on the object and call it.
 *
 * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]
 * function on the object and call it.
 */
var mixinValueEventBindings = function(obj) {
	canReflect.assign(obj, properties);
	canReflect.assignSymbols(obj, symbols);
	defineLazyValue(obj,"handlers",defineLazyHandlers, true);
	return obj;
};

// callbacks is optional
mixinValueEventBindings.addHandlers = function(obj, callbacks) {
	console.warn("can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.");
	obj.handlers = new KeyTree([Object, Array], callbacks);
	return obj;
};

module.exports = mixinValueEventBindings;


/***/ }),

/***/ "./node_modules/can-fixture-socket/can-fixture-socket.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-fixture-socket/can-fixture-socket.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fixtureSocket = __webpack_require__(/*! ./src/index */ "./node_modules/can-fixture-socket/src/index.js");
var fixtureStore = __webpack_require__(/*! ./src/store */ "./node_modules/can-fixture-socket/src/store.js");

module.exports = {
	Server: fixtureSocket.Server,
	requestHandlerToListener: fixtureStore.requestHandlerToListener,
	storeToListeners: fixtureStore.storeToListeners
};


/***/ }),

/***/ "./node_modules/can-fixture-socket/src/feathers-client.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/feathers-client.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
 * FEATHERS protocol.
 * Feathers service api (REST provider): https://docs.feathersjs.com/rest/readme.html
 * 
 * 
 * - Common Error Response Packet:
 * REQ: 422["messages::get",111,{}]
 * RES: 432[{"stack":"NotFound: No record found for id '111' ...","message":"No record found for id '111'","type":"FeathersError","name":"NotFound","code":404,"className":"not-found","errors":{}}]
 * 
 * 
 * - socket.emit('messages::find', {}, function(error, data){});
 * REQ: 421["messages::find",{"$sort":{"createdAt":-1},"$limit":10}]
 * RES: 434[null,{"total":10,"limit":5,"skip":0,"data":[]}]
 * 
 * 
 * - socket.emit('messages::get', 'uOybkd5RVe5wKoxy', {}, function(error, data){});
 * REQ: 422["messages::get","uOybkd5RVe5wKoxy",{}]
 * RES: 432[null,{"text":"Hello from cmd!","createdAt":1475294332699,"_id":"uOybkd5RVe5wKoxy"}]
 * 
 * 
 * - socket.emit('messages::create', {text: 'New message'}, {}, function(error, data){});
 * REQ: 422["messages::create",{"text":"new message"},{}]
 * RES: 432[null,{"text":"new message","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722319537,"_id":"ttnWkW4YhGRc1CDM","sentBy":{"email":"fadeev.ilya@gmail.com","password":"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q","avatar":"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60","_id":"Ke8I0Kmn0lCyrEaq"}}]
 * EXT: 42["messages created",{"text":"new message","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722319537,"_id":"ttnWkW4YhGRc1CDM","sentBy":{"email":"fadeev.ilya@gmail.com","password":"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q","avatar":"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60","_id":"Ke8I0Kmn0lCyrEaq"}}]
 * 
 * 
 * - socket.emit('messages::remove', 'yDLARueVwSF0S6v8', {}, function(error, data){});
 * REQ: 422["messages::remove","yDLARueVwSF0S6v8",{}]
 * RES: 432[null,{"text":"helllllo","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722461622,"_id":"yDLARueVwSF0S6v8"}]
 * EXT: 42["messages removed",{"text":"helllllo","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722461622,"_id":"yDLARueVwSF0S6v8"}]
 * 
 * 
 * - socket.emit('messages::update', 'ttnWkW4YhGRc1CDM', {}, function(error, data){});
 * REQ: 422["messages::update","ttnWkW4YhGRc1CDM",{"text":"Updated text!"},{}]
 * RES: 432[null,{"text":"Updated text!","_id":"ttnWkW4YhGRc1CDM"}]
 * EXT: 42 ["messages updated",{"text":"Updated text!","_id":"ttnWkW4YhGRc1CDM"}]
 * 
 */

var storeToListeners = __webpack_require__(/*! ./store */ "./node_modules/can-fixture-socket/src/store.js").storeToListeners;
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

/**
 * Subscribes to mocked socket server events for FeathersJS service.
 * Transforms ((query, fn))
 * @param serviceName
 * @param fixtureStore
 * @param mockServer
 * @param options
 * @returns {*}
 * @hide
 *
 * fixture.store data:
 * 		getListData: {}
 */
function subscribeFeathersStoreToServer(serviceName, fixtureStore, mockServer, options){
	var listeners = storeToListeners(fixtureStore);
	mockServer.on(serviceName + '::find', toFeathersDataHandler(listeners.getListData, null, toFeathersFind));
	mockServer.on(serviceName + '::get', toFeathersDataHandler(listeners.getData, wrapToId(options), null));
	
	// fixture.store.destroyData returns back the passed set, e.g. {id: 1}
	// https://github.com/canjs/can-connect/blob/master/data/memory-cache/memory-cache.js#L416
	// Feathers.remove returns back the whole object.
	mockServer.on(serviceName + '::remove', toFeathersRemoveHandler(listeners.getData, listeners.destroyData, options));
	
	mockServer.on(serviceName + '::create', toFeathersCreateHandler(listeners.createData));
	mockServer.on(serviceName + '::update', toFeathersUpdateHandler(listeners.updateData, options));
}

function toFeathersDataHandler(method, queryTransformer, dataTransformer){
	return function(query){
		var args = Array.prototype.slice.call(arguments),
			fn;
		if (typeof args[args.length-1] === 'function'){
			fn = args[args.length-1];
		}
		query = queryTransformer ? queryTransformer(query) : query;
		method(query, function(err, data){
			if (err){
				fn && fn(err);
			} else {
				data = dataTransformer ? dataTransformer(data) : data;
				fn && fn(null, data);
			}
		})
	}
}
/**
 * Wraps given id into an object with property name `id` (or options.id).
 * @param options
 * @returns {Function}
 * @hide
 */
function wrapToId(options){
	return function(id){
		var o = {},
			idProp = options && options.id || 'id';
		o[idProp] = id;
		return o;
	}
}

/**
 * Transforms getListData from fixture to feathers format.
 *   - fixture.store.getListData: {count, limit, offset, data}
 *   - feathers.find:             {total, limit, skip, data}
 * @param data
 * @returns {{total: number, limit: number, skip: number, data: *}}
 */
// fixture.store.getListData: {count, limit, offset, data}
// feathers.find:             {total, limit, skip, data}
function toFeathersFind(data){
	return {
		total: data.count,
		limit: data.limit,
		skip: data.offset,
		data: data.data
	};
}

/**
 * FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).
 * Find the item by id first, then remove from fixture.store and return the item back.
 * 
 * Feathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.
 * 
 * @param destroyData The wrapped fixture.store.destroyData method.
 * @param getData The wrapped fixture.store.getData method.
 * @returns {Function}
 * @hide
 */
function toFeathersRemoveHandler(getData, destroyData, options){
	return function(id, query, fn){
		var setQuery = wrapToId(options)(id);
		getData(setQuery, function(err, item){
			if (err){
				fn(err);
			} else {
				destroyData(setQuery, function(err, data){
					if (err){
						fn(err);
					} else {
						fn(null, item);
					}
				});
			}
		});
	}
}
function toFeathersUpdateHandler(updateData, options){
	return function(id, data, query, fn){
		var setQuery = wrapToId(options)(id);
		updateData(assign(setQuery, data), function(err, data2){
			if (err){
				fn(err);
			} else {
				fn(null, assign(setQuery, assign(data, data2)));
			}
		});
	}
}
function toFeathersCreateHandler(createData){
	return function(data, query, fn){
		createData(data, function(err, data2){
			if (err){
				fn(err);
			} else {
				fn(null, assign(data, data2));
			}
		});
	}
}

module.exports = {
	subscribeFeathersStoreToServer: subscribeFeathersStoreToServer
};


/***/ }),

/***/ "./node_modules/can-fixture-socket/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
 * Summary: `io(url)` creates an instance of `io.Manager` for the given url and stores it in cache of managers `io.managers`.
 * If `io` is called with the same URL several times it will lookup Manager in the cache.
 * One manager creates one physical (transport) connection and can create several "virtual" connections within
 * the transport connection.
 * Manager has two main methods: `open` (alias `connect`) and `socket`. The first one establishes a transport connection
 * (e.g. http://localhost), the second one creates a socket.io connection (e.g. http://localhost/users).
 *
 * To fixture socket.io we need to:
 *   - mock a socket server;
 *   - override io.Manager.prototype methods to work with the mocked server.
 */

var subscribeFeathersStoreToServer = __webpack_require__(/*! ./feathers-client */ "./node_modules/can-fixture-socket/src/feathers-client.js").subscribeFeathersStoreToServer;

/* 
 * See/update `docs/can-fixture-socket.server.md`.
 *
 * Mocked socket.io server that intercepts socket.io connection and can simulate socket.io server behaviour.
 * @constructor
 * @param {Object} io Imported `socket.io-client` object.
 */
var MockedServer = function(io){
	this.io = io;
	
	// PubSub:
	this.events = {};
	this.subscribers = {};

	// SocketIO stores an instantiated Manager in cache to reuse it for the same URL.
	// Reset cache of managers since we override Manager prototype to work with this particular instance of the mocked server:
	resetManagerCache(io.managers);

	// Override Manager's prototype:
	this.origs = mockManager(io.Manager.prototype, this);
};

/**
 * @function can-fixture-socket.Server.prototype.on on
 * @parent can-fixture-socket.Server.prototype
 * 
 * Adds a socket event listener.
 * 
 * @signature `server.on(event, handler)`
 * 
 * Adds a socket event listener.
 * 
 * ```js
 * server.on("notifications", function(data, ackFn){
 *   console.log("Received " + data);
 *   ackFn("Acknowledged, thank you");
 * });
 * ```
 * 
 *   @param {string} event The name of the socket event to listen for.
 *   @param {can-fixture-socket.socket-event-listener} handler The handler that will be executed to handle the socket event.
 * 
 * @signature `server.on(eventsObject)`
 * 
 * A short hand method to add multiple event listeners.
 * 
 * ```js
 * server.on({
 *   "news": handleNews,
 *   "tweets": handleTweets,
 *   "users": handleUsers
 * });
 * ```
 * 
 *   @param {object} eventsObject 
 */
MockedServer.prototype.on = function(event, cb){
	var self = this;
	var events = {};
	if (typeof event === 'string'){
		events[event] = cb;
	}
	if (typeof event === 'object'){
		events = event;
	}
	Object.keys(events).forEach(function(name){
		sub(self.events,  name, events[name]);
	})
};

/**
 * @function can-fixture-socket.Server.prototype.emit emit
 * @parent can-fixture-socket.Server.prototype
 * 
 * Emits a socket event.
 *
 * @signature `server.emit(event, ...data, [ackFn])`
 *
 * Emits a socket event.
 *
 * ```js
 * server.emit("news", data1, data2, function(ackData){
 *   console.log("Client acknowledged", ackData);
 * });
 * ```
 *
 *   @param {string} event The name of the socket event.
 *   @param {*} data Data to be sent with the event. Socket.io allows to send more than one data objects.
 *   @param {function} [ackFn] The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.
 */
MockedServer.prototype.emit = function(event){
	var dataArgs = Array.prototype.slice.call(arguments, 1);
	pub(this.subscribers, event, dataArgs);
};

/* 
 * See/update `docs/can-fixture-socket.on-feathers-service.md`.
 * 
 * Subscribes to mocked server socket events to work as FeathersJS CRUD service. Uses fixture store [can-fixture.Store] as a resource storage.
 * 
 * @param {String} name The name of Feathers service.
 * @param {can-fixture.Store} fixtureStore An instance of [can-fixture.Store].
 * @param {Object} [options] Options, e.g. property name for id.
 */
MockedServer.prototype.onFeathersService = function(serviceName, fixtureStore, options){
	subscribeFeathersStoreToServer(serviceName, fixtureStore, this, options);
};

/**
 * @function can-fixture-socket.Server.prototype.restore restore
 * @parent can-fixture-socket.Server.prototype
 * 
 * @signature `server.restore()`
 * 
 * Restores `io.Manager.prototype` and clears `io.managers` cache.
 * 
 * ```
 * server.restore();
 * ```
 */
MockedServer.prototype.restore = function(){
	restoreManager(this.io.Manager.prototype, this.origs);
	resetManagerCache(this.io.managers);
};

/*
 * @constructor can-fixture-socket.Socket Socket
 * @private
 * @parent can-fixture-socket.types
 * 
 * @signature `new Socket(server)`
 * 
 * Manager instantiates Socket. We mock Socket's methods to work with the mocked server instance.
 * 
 *   @param {can-fixture-socket.Server} server Mocked server.
 */
var MockedSocket = function(server){
	this._server = server;
	this.io = {
		engine: this
	};
};
MockedSocket.prototype = {
	on: function(event, cb){
		debug('MockedSocket.on ... ' + event);
		sub(this._server.subscribers, event, cb);
	},
	/*
	 * The first argument is always `event`
	 * The middle arguments are data (usually one or two arguments).
	 * If the last argument is a function then its the ACK callback.
     */
	emit: function(event){
		var dataArgs = Array.prototype.slice.call(arguments, 1);
		debug('MockedSocket.emit ...' + event);
		pub(this._server.events, event, dataArgs);
	},
	once: function(){
		debug('MockedSocket.once ...');
	},
	off: function(event, cb){
		debug('MockedSocket.off ... ' + event);
		unsub(this._server.subscribers, event, cb);
	},
	open: function(){
		return this.connect();
	},
	connect: function(){
		this.connected = true;
		this.disconnected = false;
	},
	close: function(){
		return this.disconnect();
	},
	disconnect: function(){
		this.connected = false;
		this.disconnected = true;
	},
};

/*
 * PubSub helpers.
 * @param pubsub A list of pubs or subs.
 * @param event {String} A name for a pubsub item (e.g. a name of event that we emit or subscribe to).
 * @param dataArgs There could be either one or more data arguments (e.g. FeathersJS) and the last argument can be used for ACK callback. 
 */
function pub(pubsub, event, dataArgs){
	debug(' >>> pub ' + event, dataArgs);
	// Feathers does not emit the event and path like `messages::find` anymore
	// The `path` or `serviceName` is now the first argument after the `event`
	if (dataArgs && typeof dataArgs[0] === 'string' && pubsub[dataArgs[0] + '::' + event]) {
		event = dataArgs.shift() + '::' + event;
	}
	var subscribers = pubsub[event] || [];
	subscribers.forEach(function(subscriber){
		subscriber.apply(null, dataArgs);
	});
}
function sub(pubsub, event, cb){
	debug(' <<< sub ' + event);
	if (!pubsub[event]){
		pubsub[event] = [];
	}
	pubsub[event].push(cb);
}
function unsub(pubsub, event, cb){
	debug(' <<< unsub ' + event);
	pubsub[event].forEach(function(registeredCb, index){
		if(registeredCb === cb){
			pubsub[event].splice(index, 1);
		}
	});
}

/*
 * Override Manager.prototype's method to work with the instantiated mocked server.
 * @param managerProto
 * @param server
 * @returns {Array}
 */
function mockManager(managerProto, server){
	// We need to override `open` and `socket` methods:
	var methods = ['open','socket'];
	var origs = methods.map(function(name){
		return {
			name: name,
			method: managerProto[name]
		};
	});
	managerProto.open = managerProto.connect = function(){
		debug('MockedManager.prototype.open or connect ... arguments:', arguments);
		setTimeout(function(){
			pub(server.subscribers, 'connect');
			pub(server.events, 'connection');
		}, 0);
	};
	managerProto.socket = function(){
		debug('MockedManager.prototype.socket ...');
		var socket = new MockedSocket(server);
		socket.connected = true;
		socket.disconnected = false;
		return socket;
	};
	return origs;
}

/*
 * Restore Manager prototype.
 * @param managerProto
 * @param origs
 */
function restoreManager(managerProto, origs){
	debug('Restore.');
	origs.forEach(function(orig){
		managerProto[orig.name] = orig.method;
	});
}

/*
 * We need to reset cache of Managers so that the new mocked server would create a new Manager for the same URL.
 * @param cache
 */
function resetManagerCache(cache){
	for (var i in cache){
		if (cache.hasOwnProperty(i)){
			delete cache[i];
		}
	}
}

var _DEBUG = false;
function debug(msg, obj){
	if (_DEBUG){
		console.log.apply(console, arguments);
	}
}

module.exports = {
	Server: MockedServer,
	mockSocketManager: mockManager,
	restoreManager: restoreManager
};




/***/ }),

/***/ "./node_modules/can-fixture-socket/src/store.js":
/*!******************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/store.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var extractResponse = __webpack_require__(/*! can-fixture/core */ "./node_modules/can-fixture/core.js").extractResponse;

/**
 * @function can-fixture-socket.requestHandlerToListener requestHandlerToListener
 * @parent can-fixture-socket.properties
 * 
 * Transforms XHR request handler into socket event listener.
 * 
 * @signature `requestHandlerToListener( reqHandler )`
 *
 * Transforms request handler that expects two arguments `request` and `response` into socket event listener.
 * 
 * ```js
 * server.on("news find", requestHandlerToListener( fixtureStore.getListData ));
 * ```
 *     
 * @param {Function} reqHandler A request handler, e.g. [can-fixture/StoreType.prototype.getListData].
 * @returns {can-fixture-store.socket-event-listener}
 * 
 * @body
 * 
 * ## Use
 *
 * Fixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:
 *   - grab query from `req.data`;
 *   - on error call `res( 403, err )`;
 *   - on success call `res( data )`.
 *   
 * The format of the returned data is:
 *   - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}
 *   - for [can-fixture/StoreType.prototype.getData]: the item object.
 * 
 * We can use the helper to transform fixture store methods into event listeners:
 * ```js
 * var fixture = require("can-fixture");
 * var canSet = require("can-set");
 * var io = require("socket.io-client");
 * var fixtureSocket = require("can-fixture-socket");
 * 
 * // Create fixture store:
 * var fixtureStore = fixture.store([
 *   {id: 1, title: 'One'},
 *   {id: 2, title: 'Two'},
 *   {id: 3, title: 'Three'}
 * ], new canSet.Algebra({}));
 * 
 * var mockedServer = new fixtureSocket.Server(io);
 * mockedServer.on("books find", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));
 * ```
 */
function requestHandlerToListener(method){
	return function(query, fn){
		var req = {data: query};
		var res = function(){
			var response = extractResponse.apply(null, arguments);
			if (response[0] === 200){
				fn(null, response[1]);
			} else {
				fn(response[1]);
			}
		};
		method(req, res);
	}
}

/**
 * @function can-fixture-socket.storeToListeners storeToListeners
 * @parent can-fixture-socket.properties
 * 
 * Returns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.
 * 
 * @signature `storeToListeners( fixtureStore )`
 * 
 * Wraps methods of fixture.store to make them socket event listener.
 * 
 * ```js
 * var listeners = storeToListeners( fixtureStore );
 * 
 * server.on({
 *   "news find": listeners.getListData,
 *   "news get": listeners.getData,
 * })
 * ```
 * 
 * @param fixtureStore
 * @returns {*}
 * 
 * @body
 * 
 * ## Use
 * 
 * Fixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.
 * 
 * Here is how we can do this:
 * 
 * ```js
 * var fixture = require("can-fixture");
 * var canSet = require("can-set");
 * var io = require("socket.io-client");
 * var fixtureSocket = require("can-fixture-socket");
 *
 * // Create fixture store:
 * var fixtureStore = fixture.store([
 *   {id: 1, title: 'One'},
 *   {id: 2, title: 'Two'},
 *   {id: 3, title: 'Three'}
 * ], new canSet.Algebra({}));
 * 
 * // Instantiate mocked socket server:
 * var mockedServer = new fixtureSocket.Server(io);
 * 
 * // Now use fixture store to emulate REST-ful service:
 * var toListener = fixtureStore.requestHandlerToListener;
 * mockedServer.on({
 *   "books find":   toListener( fixtureStore.getListData ),
 *   "books get":    toListener( fixtureStore.getData ),
 *   "books create": toListener( fixtureStore.createData ),
 *   "books update": toListener( fixtureStore.updateData ),
 *   "books delete": toListener( fixtureStore.destroyData )
 * });
 * ```
 */
function storeToListeners(fixtureStore){
	var methods = ['getListData', 'getData', 'updateData', 'createData', 'destroyData'];
	return methods.reduce(function(listeners, method){
		listeners[method] = requestHandlerToListener(fixtureStore[method]);
		return listeners;
	}, {});
}

module.exports = {
	requestHandlerToListener: requestHandlerToListener,
	storeToListeners: storeToListeners
};


/***/ }),

/***/ "./node_modules/can-fixture/core.js":
/*!******************************************!*\
  !*** ./node_modules/can-fixture/core.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Adds
var sub = __webpack_require__(/*! can-key/sub/sub */ "./node_modules/can-key/sub/sub.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var matches = __webpack_require__(/*! ./matches */ "./node_modules/can-fixture/matches.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var dataFromUrl = __webpack_require__(/*! ./data-from-url */ "./node_modules/can-fixture/data-from-url.js");

__webpack_require__(/*! ./store */ "./node_modules/can-fixture/store.js");

var fixtures = [];
exports.fixtures = fixtures;

function isStoreLike (fixture) {
	return fixture && (fixture.getData || fixture.getListData);
}

var methodMapping = {
	item: {
		'GET': 'getData',
		'PUT': 'updateData',
		'DELETE': 'destroyData',
	},
	list: {
		'GET': 'getListData',
		'POST': 'createData'
	}
};

function getMethodAndPath (route) {
	// Match URL if it has GET, POST, PUT, DELETE or PATCH.
	var matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
	if (!matches) {
		return [undefined, route];
	}
	var method = matches[1];
	var path = matches[2];
	return [method, path];
}

function inferIdProp (url) {
	var wrappedInBraces = /\{(.*)\}/;
	var matches = url.match(wrappedInBraces);
	var isUniqueMatch = matches && matches.length === 2;
	if (isUniqueMatch) {
		return matches[1];
	}
}

function getItemAndListUrls (url, idProp) {
	idProp = idProp || inferIdProp(url);
	if (!idProp) {
		return [undefined, url];
	}
	var itemRegex = new RegExp('\\/\\{' + idProp+"\\}.*" );
	var rootIsItemUrl = itemRegex.test(url);
	var listUrl = rootIsItemUrl ? url.replace(itemRegex, "") : url;
	var itemUrl = rootIsItemUrl ? url : (url.trim() + "/{" + idProp + "}");
	return [itemUrl, listUrl];
}

function addStoreFixture (root, store) {
	var settings = {};
	var typeAndUrl = getMethodAndPath(root);
	var type = typeAndUrl[0];
	var url = typeAndUrl[1];

	var itemAndListUrls = getItemAndListUrls(url, store.idProp);
	var itemUrl = itemAndListUrls[0];
	var listUrl = itemAndListUrls[1];

	if (type) {
		var warning = [
			'fixture("' + root + '", fixture) must use a store method, not a store directly.',
		];
		if (itemUrl) {
			var itemAction = methodMapping.item[type];
			if (itemAction) {
				settings[type + ' ' + itemUrl] = store[itemAction];
				var itemWarning = 'Replace with fixture("' + type + ' ' + itemUrl + '", fixture.' + itemAction + ') for items.';
				warning.push(itemWarning);
			}
		}
		var listAction = methodMapping.list[type];
		if (listAction) {
			settings[type + ' ' + listUrl] = store[listAction];
			var listWarning = 'Replace with fixture("' + type + ' ' + listUrl + '", fixture.' + listAction + ') for lists.';
			warning.push(listWarning);
		}
		var message = warning.join(' ');
		canDev.warn(message);
	} else {
		var itemMapping = methodMapping.item;
		for (var itemMethod in itemMapping) {
			var storeItemMethod = itemMapping[itemMethod];
			settings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];
		}
		var listMapping = methodMapping.list;
		for (var listMethod in listMapping) {
			var storeListMethod = listMapping[listMethod];
			settings[listMethod + ' ' + listUrl] = store[storeListMethod];
		}
	}

	return settings;
}

function getSettingsFromString (route) {
	var typeAndUrl = getMethodAndPath(route);
	var type = typeAndUrl[0];
	var url = typeAndUrl[1];
	if (type) {
		return {
			type: type,
			url: url
		};
	}
	return {
		url: url
	};
}

// Check if the same fixture was previously added, if so, we remove it
// from our array of fixture overwrites.
function upsertFixture (fixtureList, settings, fixture) {
	var index = exports.index(settings, true);
	var oldFixture;
	if (index > -1) {
		oldFixture = fixtures.splice(index, 1);
	}
	if (fixture == null) {
		return oldFixture;
	}
	if(typeof fixture === "object") {
		var data = fixture;
		fixture = function(){
			return data;
		};
	}
	settings.fixture = fixture;
	fixtures.unshift(settings);
	return oldFixture;
}

// Adds a fixture to the list of fixtures.
exports.add = function (settings, fixture) {
	// If a fixture isn't provided, we assume that settings is
	// an array of fixtures, and we should iterate over it, and set up
	// the new fixtures.
	if (fixture === undefined) {
		var oldFixtures = [];
		if(Array.isArray(settings)) {
			canReflect.eachIndex(settings, function(ajaxSettings){
				var fixture = ajaxSettings.fixture;
				ajaxSettings = canReflect.assignMap({}, ajaxSettings);
				delete ajaxSettings.fixture;
				return exports.add(ajaxSettings, fixture);
			});
		} else {
			canReflect.eachKey(settings, function (fixture, url) {
				oldFixtures = oldFixtures.concat(exports.add(url, fixture));
			});
			return oldFixtures;
		}
	}

	// When a fixture is passed a store like:
	// `fixture("/things/{id}", store)`
	if (isStoreLike(fixture)) {
		settings = addStoreFixture(settings, fixture);
		return exports.add(settings);
	}

	if (typeof settings === 'string') {
		settings = getSettingsFromString(settings);
	}
	return upsertFixture(fixtures, settings, fixture);
};

var $fixture = exports.add;
$fixture.on = true;
$fixture.delay =10;

function FixtureResponse(fixture, response){
	this.statusCode= response[0];
	this.responseBody= response[1];
	this.headers= response[2];
	this.statusText= response[3];
	this.fixture= fixture;
}

// Calls a dynamic fixture and calls `cb` with the response data.
exports.callDynamicFixture = function(xhrSettings, fixtureSettings, cb){
	// this is for legacy.  In the future, people should get it from fixtureSettings probably.
	xhrSettings.data = fixtureSettings.data;

	//!steal-remove-start
	if(true) {
		var json = JSON.stringify(xhrSettings.data);
		canLog.log("" + xhrSettings.type.toUpperCase() + " " + xhrSettings.url+" "+json.substr(0,50)+" -> handler(req,res)");
	}
	//!steal-remove-end

	var response = function(){
		var res = exports.extractResponse.apply(xhrSettings, arguments);
		//!steal-remove-start
		canLog.log("can-fixture: " + xhrSettings.type.toUpperCase() + " " + xhrSettings.url+" ",xhrSettings.data," => ",new FixtureResponse(fixtureSettings.fixture,res));
		//!steal-remove-end
		return cb.apply(this, res);
	};
	var callFixture = function () {
		// fall the fixture
		var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);

		if (canReflect.isPromise(result)) {
			// If we have a promise, wait for it to resolve
			result.then(function (result) {
				if (result !== undefined) {
					// Resolve with fixture results
					response(200, result );
				}
			});
		} else {
			if (result !== undefined) {
				// Resolve with fixture results
				response(200, result );
			}
		}
	};

	if(!xhrSettings.async) {
		callFixture();
		return null;
	} else {
		return setTimeout(callFixture, $fixture.delay);
	}
};

exports.index = function (settings, exact) {
	for (var i = 0; i < fixtures.length; i++) {
		if (matches.matches(settings, fixtures[i], exact)) {
			return i;
		}
	}
	return -1;
};
exports.get = function(xhrSettings) {
	if ( !$fixture.on ) {
		return;
	}
	// First try an exact match
	var index = exports.index(xhrSettings, true);

	// If that doesn't work, try a looser match.
	if(index === -1) {
		index = exports.index(xhrSettings, false);
	}

	var fixtureSettings = index >=0 ? canReflect.assignMap({},fixtures[index]) : undefined;
	if(fixtureSettings) {
		var url = fixtureSettings.fixture,
			data = dataFromUrl(fixtureSettings.url, xhrSettings.url);
		if(typeof fixtureSettings.fixture === "string") {
			// check that we might have a replacement

			// here we could read data from first url and translate into next
			if (data) {
				// Template static fixture URLs
				url = sub(url, data);
			}

			// Override the AJAX settings, changing the URL to the fixture file,
			// removing the data, and changing the type to GET.
			fixtureSettings.url = url;
			fixtureSettings.data = null;
			fixtureSettings.type = "GET";
			if (!fixtureSettings.error) {
				// If no error handling is provided, we provide one and throw an
				// error.
				fixtureSettings.error = function (xhr, error, message) {
					throw "fixtures.js Error " + error + " " + message;
				};
			}

		} else if (canReflect.isPlainObject(xhrSettings.data) || xhrSettings.data == null) {
			var xhrData = canReflect.assignMap({}, xhrSettings.data || {});
			fixtureSettings.data = canReflect.assignMap(xhrData, data);

		} else {
			fixtureSettings.data = xhrSettings.data;
		}
	}

	return fixtureSettings;
};

exports.matches = matches;




// A helper function that takes what's called with response
// and moves some common args around to make it easier to call
exports.extractResponse = function (status, response, headers, statusText) {
	// if we get response(RESPONSE, HEADERS)
	if (typeof status !== "number") {
		headers = response;
		response = status;
		status = 200;
	}
	// if we get response(200, RESPONSE, STATUS_TEXT)
	if (typeof headers === "string") {
		statusText = headers;
		headers = {};
	}
	return [status, response, headers, statusText];
};


/***/ }),

/***/ "./node_modules/can-fixture/data-from-url.js":
/*!***************************************************!*\
  !*** ./node_modules/can-fixture/data-from-url.js ***!
  \***************************************************/
/***/ ((module) => {

var replacer =  /\{([^\}]+)\}/g;
// Returns data from a url, given a fixtue URL. For example, given
// "todo/{id}" and "todo/5", it will return an object with an id property
// equal to 5.
module.exports = function dataFromUrl(fixtureUrl, url) {
	if(!fixtureUrl) {
		// if there's no url, it's a match
		return {};
	}

	var order = [],
		// Sanitizes fixture URL
		fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.')
			.replace('?', '\\?'),
		// Creates a regular expression out of the adjusted fixture URL and
		// runs it on the URL we passed in.
		res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
			order.push(part);
			return "([^\/]+)";
		}) + "$")
			.exec(url),
		data = {};

	// If there were no matches, return null;
	if (!res) {
		return null;
	}

	// Shift off the URL and just keep the data.
	res.shift();
	order.forEach( function (name) {
		// Add data from regular expression onto data object.
		data[name] = res.shift();
	});
	return data;
};


/***/ }),

/***/ "./node_modules/can-fixture/fixture.js":
/*!*********************************************!*\
  !*** ./node_modules/can-fixture/fixture.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! ./core */ "./node_modules/can-fixture/core.js");
var fixture = core.add;
var Store = __webpack_require__(/*! ./store */ "./node_modules/can-fixture/store.js");
__webpack_require__(/*! ./xhr */ "./node_modules/can-fixture/xhr.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
// HELPERS START

var noop = function(){};

canReflect.assignMap(fixture, {
	rand: function randomize (arr, min, max) {
		if (typeof arr === 'number') {
			if (typeof min === 'number') {
				return arr + Math.floor(Math.random() * (min - arr+1));
			} else {
				return Math.floor(Math.random() * (arr+1));
			}

		}
		// clone the array because we will remove items from it.
		var choices = arr.slice(0);

		// get a random set
		if (min === undefined) {
			min = 1;
			max = choices.length;
		} else if(max === undefined){
			max = min;
		}
		// get a random selection of arr
		var result = [];

		// set max
		//random max
		var selectedCount = min + Math.round(randomize(max - min));
		for (var i = 0; i < selectedCount; i++) {
			var selectedIndex = randomize(choices.length - 1),
				selected = choices.splice(selectedIndex, 1)[0];
			result.push(selected);
		}
		return result;
	},
	xhr: function (xhr) {
		return canReflect.assignMap({}, {
			abort: noop,
			getAllResponseHeaders: function () {
				return "";
			},
			getResponseHeader: function () {
				return "";
			},
			open: noop,
			overrideMimeType: noop,
			readyState: 4,
			responseText: "",
			responseXML: null,
			send: noop,
			setRequestHeader: noop,
			status: 200,
			statusText: "OK"
		}, xhr);
	},
	store: Store.make,
	fixtures: core.fixtures
});

if(typeof window !== "undefined" && "function" !== "function") {

	window.fixture = function(){
		canDev.warn("You are using the global fixture. Make sure you import can-fixture.");

		return fixture.apply(this, arguments);
	};	
}


module.exports = ns.fixture = fixture;


/***/ }),

/***/ "./node_modules/can-fixture/matches.js":
/*!*********************************************!*\
  !*** ./node_modules/can-fixture/matches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! can-query-logic/src/set */ "./node_modules/can-query-logic/src/set.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var dataFromUrl = __webpack_require__(/*! ./data-from-url */ "./node_modules/can-fixture/data-from-url.js");
var QueryLogic = __webpack_require__(/*! can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");


function deepEqual(a, b) {
	if(a === b) {
		return true;
	} else if(Array.isArray(a) && Array.isArray(b)) {
		if(a.length !== b.length) {
			return false;
		} else {
			return a.every(function(aVal, i){
				return deepEqual(aVal, b[i]);
			});
		}
	} else if(a && b && canReflect.isPlainObject(a) && canReflect.isPlainObject(b)) {
		var aKeys = Object.keys(a),
			bKeys = Object.keys(b);
		if(aKeys.length === bKeys.length) {
			for(var prop in a) {
				if(!b.hasOwnProperty(prop)) {
					return false;
				}
				if(!deepEqual(a[prop], b[prop])) {
					return false;
				}
			}
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}


function deepMatches(a, b) {
	if(a === b) {
		return true;
	} else if(Array.isArray(a) && Array.isArray(b)) {

		return a.every(function(aVal, i){
			return deepMatches(aVal, b[i]);
		});

	} else if(a && b && canReflect.isPlainObject(a) && canReflect.isPlainObject(b)) {

		for(var prop in a) {
			if(!b.hasOwnProperty(prop)) {
				return false;
			}
			if(!deepMatches(a[prop], b[prop])) {
				return false;
			}
		}
		return true;

	} else {
		return false
	}
}

function removeFixtureAndXHR(query) {
	if(query.fixture || query.xhr || query.data) {
		var clone = canReflect.serialize(query);
		delete clone.fixture;
		delete clone.xhr;
		delete clone.data;
		return clone;
	} else {
		return query;
	}
}

function identityIntersection(v1, v2) {
    return v1.value === v2.value ? v1 : set.EMPTY;
}
function identityDifference(v1, v2){
    return v1.value === v2.value ? set.EMPTY : v1;
}
function identityUnion(v1, v2) {
    return v1.value === v2.value ? v1 : set.UNDEFINABLE;
}
var identityComparitor = {
    intersection: identityIntersection,
    difference: identityDifference,
    union: identityUnion
};



function makeComparatorType(compare) {
	var Type = function(){};
	var SetType = function(value) {
		this.value = value;
	};
	SetType.prototype.isMember = function(value, root, keys){
	    return compare(this.value, value, root, keys);
	};
	canReflect.assignSymbols(Type,{
		"can.SetType": SetType
	});

	set.defineComparison(SetType,SetType, identityComparitor);

	set.defineComparison(set.UNIVERSAL,SetType,{
		difference: function(){
			return set.UNDEFINABLE;
		}
	});
	return Type;
}

function quickEqual(queryA, queryB){
	var dataA = queryA.data,
		dataB = queryB.data;
	if(dataA && dataB) {
		if(!deepMatches(dataA, dataB)) {
			return false;
		}
	}
	var q1 = new QueryLogic.KeysAnd(removeFixtureAndXHR(queryA)),
		q2 = new QueryLogic.KeysAnd(removeFixtureAndXHR(queryB));
	return set.isEqual( q1, q2 );
}

function quickSubset(queryA, queryB){
	return set.isSubset( new QueryLogic.KeysAnd(queryA), new QueryLogic.KeysAnd(queryB) );
}

// Define types
var types = {};
canReflect.eachKey({
	IsEmptyOrNull: function(a, b){
		if( a == null && canReflect.size(b) === 0 ) {
			return true;
		} else if( b == null && canReflect.size(a) === 0 ) {
			return true;
		} else {
			return quickEqual(a, b);
		}
	},
	isEmptyOrSubset: function(a, b) {
		if( a == null && canReflect.size(b) === 0 ) {
			return true;
		} else if( b == null && canReflect.size(a) === 0 ) {
			return true;
		} else {
			return quickSubset(a, b);
		}
	},
	TemplateUrl: function(a, b) {
		return !!dataFromUrl(a, b);
	},
	StringIgnoreCase: function(a, b){
		return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
	},
	Ignore: function(){
		return true;
	}
}, function(compare, name){
	types[name] = makeComparatorType(compare);
});





var schema = {
	identity: ["id"],
	keys: {
		url: types.TemplateUrl,
		fixture: types.Ignore,
		xhr: types.Ignore,
		type: types.StringIgnoreCase,
		method: types.StringIgnoreCase,
		helpers: types.Ignore,
		headers: types.IsEmptyOrNull,
		data: types.IsEmptyOrSubset
	}
};

var query = new QueryLogic(schema);




module.exports = {
	fixture: quickEqual,
	request: function(requestData, fixtureData) {
		return query.isMember({filter: fixtureData}, requestData);
	},
	matches: function(settings, fixture, exact) {
		if (exact) {
			return this.fixture(settings, fixture);
		} else {
			return this.request(settings, fixture)
		}
	},
	makeComparatorType: makeComparatorType
};


/***/ }),

/***/ "./node_modules/can-fixture/store.js":
/*!*******************************************!*\
  !*** ./node_modules/can-fixture/store.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var QueryLogic = __webpack_require__(/*! can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var memoryStore = __webpack_require__(/*! can-memory-store */ "./node_modules/can-memory-store/can-memory-store.js");



// Returns a function that calls the method on a connection.
// Wires up fixture signature to a connection signature.
var connectToConnection = function(method, convert){
	return function(req, res){
		// have to get data from
		this.connection[method]( convert.call(this, req.data) ).then(function(data){
			res(data);
		}, function(err){
			res(parseInt(err.status, 10), err);
		});
	};
};
// Returns a new makeItems function for a different baseItems;
var makeMakeItems = function(baseItems, idProp){
	return function () {
		// clone baseItems
		var items = [],
			maxId = 0,
			idType = "number";
		baseItems.forEach(function(item){
			items.push(canReflect.serialize(item) );
			var type = typeof item[idProp];
			if(type === "number") {
				maxId = Math.max(item[idProp], maxId) ;
			} else {
				idType = type;
			}
		});

		return {
			maxId: maxId,
			items: items,
			idType: idType
		};
	};
};

var stringToAny = function(str){
	switch(str) {
		case "NaN":
		case "Infinity":
			return +str;
		case "null":
			return null;
		case "undefined":
			return undefined;
		case "true":
		case "false":
			return str === "true";
		default:
			var val = +str;
			if(!isNaN(val)) {
				return val;
			} else {
				return str;
			}
	}
};

// A store constructor function
var Store = function(connection, makeItems, idProp){
	var schema = connection.queryLogic.schema;
	var identityKey = schema.identity[0],
		keys = schema.keys;

	if(!keys || !keys[identityKey]) {
		console.warn("No type specified for identity key. Going to convert strings to reasonable type.");
	}

	this.connection = connection;
	this.makeItems = makeItems;
	this.idProp = idProp;
	this.reset();
	// we have to make sure the methods can be called without their context
	for(var method in Store.prototype) {
		this[method] = this[method].bind(this);
	}
};

var doNotConvert = function(v){ return v; };

function typeConvert(data){
	var schema = this.connection.queryLogic.schema;
	var idType = this.idType;
	var identityKey = schema.identity[0],
		keys = schema.keys;
	if(!keys || !keys[identityKey]) {
		keys = {};
		keys[identityKey] = function(value) {
			if(idType === "string") {
				return ""+value;
			} else {
				return typeof value === "string" ? stringToAny(value) : value;
			}

		};
	}
		// this probably needs to be recursive, but this is ok for now
	var copy = {};
	canReflect.eachKey(data, function(value, key){
		if(keys[key]) {
			copy[key] = canReflect.serialize(canReflect.convert(value, keys[key]));
		} else {
			copy[key] = value;
		}
	});
	// clone the data

	return copy;

}

canReflect.assignMap(Store.prototype,{
	getListData: connectToConnection("getListData",doNotConvert),
	getData: connectToConnection( "getData",typeConvert),

	// used
	createData: function(req, res){
		var idProp = this.idProp;
		// add an id
		req.data[idProp] = ++this.maxId;

		this.connection.createData( typeConvert.call(this,req.data) ).then(function(data){
			res(data);
		}, function(err){
			res(403, err);
		});
	},
	createInstance: function(record){
		var idProp = this.idProp;
		if(!(idProp in record)) {
			record[idProp] = ++this.maxId;
		}
		return this.connection.createData( record );
	},
	updateData: connectToConnection("updateData",typeConvert),
	updateInstance: function(record) {
		return this.connection.updateData(record);
	},
	destroyInstance: function(record) {
		return this.connection.destroyData(record);
	},
	destroyData: connectToConnection("destroyData",typeConvert),
	reset: function(newItems){
		if(newItems) {
			this.makeItems = makeMakeItems(newItems, this.idProp);
		}
		var itemData =  this.makeItems();
		this.maxId = itemData.maxId;
		this.idType = itemData.idType;
		this.connection.updateListData(itemData.items, {});
	},
	get: function (params) {
		var id = this.connection.queryLogic.memberIdentity(params);
		return this.connection.getRecord(id);
	},
	getList: function(set){
		return this.connection.getListDataSync(set);
	}
});

function looksLikeAQueryLogic(obj){
	return obj && ("identityKeys" in obj);
}

// ## fixture.store
// Make a store of objects to use when making requests against fixtures.
Store.make = function (count, make, queryLogic) {
	/*jshint eqeqeq:false */


	// Figure out makeItems which populates data
	var makeItems,
		idProp;
	if(typeof count === "number") {
		if(!queryLogic) {
			queryLogic = new QueryLogic({});
		} else if(!looksLikeAQueryLogic(queryLogic)) {
			queryLogic = new QueryLogic(queryLogic);
		}
		idProp = queryLogic.identityKeys()[0] || "id";
		makeItems = function () {
			var items = [];
			var maxId = 0;
			for (var i = 0; i < (count); i++) {
				//call back provided make
				var item = make(i, items);

				if (!item[idProp]) {
					item[idProp] = i;
				}
				maxId = Math.max(item[idProp] , maxId);
				items.push(item);
			}

			return {
				maxId: maxId,
				items: items
			};
		};
	} else if(Array.isArray(count)){
		queryLogic = make;
		if(!queryLogic) {
			queryLogic = new QueryLogic({});
		} else if(!looksLikeAQueryLogic(queryLogic)) {
			queryLogic = new QueryLogic(queryLogic);
		}
		idProp = queryLogic.identityKeys()[0] || "id";
		makeItems = makeMakeItems(count, idProp);
	}

	var connection = memoryStore({
		queryLogic: queryLogic,
		errorOnMissingRecord: true
	});

	return new Store(connection, makeItems, idProp);
};

module.exports = Store;


/***/ }),

/***/ "./node_modules/can-fixture/xhr.js":
/*!*****************************************!*\
  !*** ./node_modules/can-fixture/xhr.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global require, window, global */
/* global setTimeout, clearTimeout, XMLHttpRequest */

// This overwrites the default XHR with a mock XHR object.
// The mock XHR object's `.send` method is able to
// call the fixture callbacks or create a real XHR request
// and then respond normally.
var fixtureCore = __webpack_require__(/*! ./core */ "./node_modules/can-fixture/core.js");
var deparam = __webpack_require__(/*! can-deparam */ "./node_modules/can-deparam/can-deparam.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");

// Save the real XHR object as XHR
var XHR = XMLHttpRequest,
// Get a global reference.
	GLOBAL = typeof __webpack_require__.g !== "undefined"? __webpack_require__.g : window;

// Figure out props and events on XHR object
// but start with some defaults
var props = [
	"type", "url", "async", "response", "responseText", "responseType",
	"responseXML", "responseURL", "status", "statusText", "readyState"
];
var events = ["abort", "error", "load", "loadend", "loadstart",  "progress", "readystatechange"];
(function(){
	var x = new XHR();
	for(var prop in x) {
		if(prop.indexOf("on") === 0) {
			if (events.indexOf(prop.substr(2)) === -1) {
				events.push(prop.substr(2));
			}
		} else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
			props.push(prop);
		}
	}
})();
// DEFINE HELPERS

// Call all of an event for an XHR object
function callEvents(xhr, ev) {
	var evs = xhr.__events[ev] || [], fn;
	for(var i = 0, len = evs.length; i < len; i++) {
		fn = evs[i];
		fn.call(xhr);
	}
}

function defineNonEnumerable(obj, prop, value) {
	Object.defineProperty(obj, prop, {
		enumerable: false,
		configurable: true,
		writable: true,
		value: value
	});
}

GLOBAL.XMLHttpRequest = function() {
	var mockXHR = this;
	var realXHR = new XHR();

	// store real xhr on mockXHR
	defineNonEnumerable(this, "_xhr", realXHR);

	// create other properties needed by prototype functions
	defineNonEnumerable(this, "_requestHeaders", {});
	defineNonEnumerable(this, "__events", {});

	// wire up events to forward from real xhr to fake xhr
	events.forEach(function(eventName) {
		realXHR["on" + eventName] = function() {
			callEvents(mockXHR, eventName);
			if(mockXHR["on"+eventName]) {
				return mockXHR["on"+eventName].apply(mockXHR, arguments);
			}
		};
	});

	// The way code detects if the browser supports onload is to check
	// if a new XHR object has the onload property, so setting it to null
	// passes that check.
	this.onload = null;
};
GLOBAL.XMLHttpRequest._XHR = XHR;

// Methods on the mock XHR:
canReflect.assignMap(XMLHttpRequest.prototype,{
	setRequestHeader: function(name, value){
		this._requestHeaders[name] = value;
	},
	open: function(type, url, async){
		this.type = type;
		this.url = url;
		this.async = async === false ? false : true;
	},
	getAllResponseHeaders: function(){
		return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
	},
	addEventListener: function(ev, fn){
		var evs = this.__events[ev] = this.__events[ev] || [];
		evs.push(fn);
	},
	removeEventListener: function(ev, fn){
		var evs = this.__events[ev] = this.__events[ev] || [];
		var idx = evs.indexOf(fn);
		if(idx >= 0) {
			evs.splice(idx, 1);
		}
	},
	setDisableHeaderCheck: function(val){
		this._disableHeaderCheck = !!val;
	},
	getResponseHeader: function(key){
		return this._xhr.getResponseHeader(key);
	},
	abort: function() {
		var xhr = this._xhr;

		// If we are aborting a delayed fixture we have to make the fake
		// steps that are expected for `abort` to
		if(this.timeoutId !== undefined) {
			clearTimeout(this.timeoutId);
			xhr.open(this.type, this.url, this.async === false ? false : true);
			xhr.send();
		}

		return xhr.abort();
	},
	// This needs to compile the information necessary to see if
	// there is a corresponding fixture.
	// If there isn't a fixture, this should create a real XHR object
	// linked to the mock XHR instance and make a data request.
	// If there is a fixture, depending on the type of fixture the following happens:
	// - dynamic fixtures - call the dynamic fixture, use the result to update the
	//   mock XHR object and trigger its callbacks.
	// - redirect fixtures - create a real XHR linked to the mock XHR for the new url.
	send: function(data) {
		// derive the XHR settings object from the XHR object
		var type = this.type.toLowerCase() || 'get';
		var xhrSettings = {
			url: this.url,
			data: data,
			headers: this._requestHeaders,
			type: type,
			method: type,
			async: this.async,
			xhr: this
		};
		// if get or delete, the url should not include the querystring.
		// the querystring should be the data.
		if(!xhrSettings.data && xhrSettings.type === "get" || xhrSettings.type === "delete") {
			xhrSettings.data = deparam( xhrSettings.url.split("?")[1] );
			xhrSettings.url = xhrSettings.url.split("?")[0];
		}

		// Try to convert the request body to POJOs.
		if(typeof xhrSettings.data === "string") {
			try {
				xhrSettings.data = JSON.parse(xhrSettings.data);
			} catch(e) {
				xhrSettings.data = deparam( xhrSettings.data );
			}
		}

		// See if the XHR settings match a fixture.
		var fixtureSettings = fixtureCore.get(xhrSettings);
		var mockXHR = this;

		// If a dynamic fixture is being used, we call the dynamic fixture function and then
		// copy the response back onto the `mockXHR` in the right places.
		if(fixtureSettings && typeof fixtureSettings.fixture === "function") {

			this.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function(status, body, headers, statusText){
				body = typeof body === "string" ? body :  JSON.stringify(body);

				// we are no longer using the real XHR
				// set it to an object so that props like readyState can be set
				mockXHR._xhr = {
					open: function(){},
					send: function() {},
					abort: function(){},
					getResponseHeader: function(){}
				};

				canReflect.assignMap(mockXHR, {
					readyState: 4,
					status: status
				});

				var success = (status >= 200 && status < 300 || status === 304);
				if ( success ) {
					canReflect.assignMap(mockXHR,{
						statusText: statusText || "OK",
						responseText: body
					});
				} else {
					canReflect.assignMap(mockXHR,{
						statusText: statusText || "error",
						responseText: body
					});
				}

				mockXHR.getAllResponseHeaders = function() {
					var ret = [];
					canReflect.eachKey(headers || {}, function(value, name) {
						Array.prototype.push.apply(ret, [name, ': ', value, '\r\n']);
					});
					return ret.join('');
				};

				if(mockXHR.onreadystatechange) {
					mockXHR.onreadystatechange({ target: mockXHR });
				}

				// fire progress events
				callEvents(mockXHR, "progress");
				if(mockXHR.onprogress) {
					mockXHR.onprogress();
				}

				callEvents(mockXHR, "load");
				if(mockXHR.onload) {
					mockXHR.onload();
				}

				callEvents(mockXHR, "loadend");
				if(mockXHR.onloadend) {
					mockXHR.onloadend();
				}
			});

			return;
		}
		// At this point there is either not a fixture or a redirect fixture.
		// Either way we are doing a request.
		var makeRequest = function() {
			mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
			if(mockXHR._requestHeaders) {
				Object.keys(mockXHR._requestHeaders).forEach(function(key) {
					mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
				});
			}
			return mockXHR._xhr.send(data);
		};

		if(fixtureSettings && typeof fixtureSettings.fixture === "number") {
			canLog.log("can-fixture: "+xhrSettings.url+" => delay " + fixtureSettings.fixture+"ms");
			this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
			return;
		}

		// if we do have a fixture, update the real XHR object.
		if(fixtureSettings) {
			canLog.log("can-fixture: "+xhrSettings.url+" => " + fixtureSettings.url);
			canReflect.assignMap(mockXHR, fixtureSettings);
		}

		// Make the request.
		return makeRequest();
	}
});

// when props of mockXHR are get/set, return the prop from the real XHR
props.forEach(function(prop) {
	Object.defineProperty(XMLHttpRequest.prototype, prop, {
		get: function(){
			return this._xhr[prop];
		},
		set: function(newVal){
			try {
				this._xhr[prop] = newVal;
			} catch(e) {}
		}
	});
});


/***/ }),

/***/ "./node_modules/can-fragment/can-fragment.js":
/*!***************************************************!*\
  !*** ./node_modules/can-fragment/can-fragment.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var childNodes = __webpack_require__(/*! can-child-nodes */ "./node_modules/can-child-nodes/can-child-nodes.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
/**
@module {function} can-fragment
@parent can-dom-utilities
@collection can-infrastructure
@package ./package.json

Convert a String, HTMLElement, documentFragment, contentArray, or object with a `can.toDOM` symbol into a documentFragment.

@signature `fragment(item, doc)`

@param {String|HTMLElement|documentFragment|contentArray} item
@param {Document} doc   an optional DOM document in which to build the fragment

@return {documentFragment}

@body

## Use

ContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:

    var fragment = require("can-fragment");

    var p = document.createElement("p");
    p.innerHTML = "Welcome to <b>CanJS</b>";
    var contentArray = ["<h1>Hi There</h1>", p];
    var fragment = fragment( contentArray )

`fragment` will be a documentFragment with the following elements:

    <h1>Hi There</h1>
    <p>Welcome to <b>CanJS</b></p>

 */


// fragment.js
// ---------
// _DOM Fragment support._
var fragmentRE = /^\s*<(\w+)[^>]*>/,
	toString = {}.toString,
	toDOMSymbol = canSymbol.for("can.toDOM");

function makeFragment(html, name, doc) {
	if (name === undefined) {
		name = fragmentRE.test(html) && RegExp.$1;
	}
	if (html && toString.call(html.replace) === "[object Function]") {
		// Fix "XHTML"-style tags in all browsers
		html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
	}
	var container = doc.createElement('div'),
		temp = doc.createElement('div');
	// IE's parser will strip any `<tr><td>` tags when `innerHTML`
	// is called on a `tbody`. To get around this, we construct a
	// valid table with a `tbody` that has the `innerHTML` we want.
	// Then the container is the `firstChild` of the `tbody`.
	// [source](http://www.ericvasilik.com/2006/07/code-karma.html).
	if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
		temp.innerHTML = '<table>' + html + '</table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
	} else if (name === 'col') {
		temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
	} else if (name === 'tr') {
		temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
	} else if (name === 'td' || name === 'th') {
		temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
	} else if (name === 'option') {
		temp.innerHTML = '<select>' + html + '</select>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
	} else {
		container.innerHTML = '' + html;
	}

	return [].slice.call(childNodes(container));
}

function fragment(html, doc) {
	if (html && html.nodeType === 11) {
		return html;
	}
	if (!doc) {
		doc = getDocument();
	} else if (doc.length) {
		doc = doc[0];
	}

	var parts = makeFragment(html, undefined, doc),
		frag = (doc || document).createDocumentFragment();
	for (var i = 0, length = parts.length; i < length; i++) {
		frag.appendChild(parts[i]);
	}
	return frag;
}

var makeFrag = function(item, doc) {
	var document = doc || getDocument();
	var frag;
	if (!item || typeof item === "string") {
		frag = fragment(item == null ? "" : "" + item, document);
		// If we have an empty frag...
	} else if(typeof item[toDOMSymbol] === "function") {
		return makeFrag(item[toDOMSymbol]());
	}
	else if (item.nodeType === 11) {
		return item;
	} else if (typeof item.nodeType === "number") {
		frag = document.createDocumentFragment();
		frag.appendChild(item);
		return frag;
	} else if (canReflect.isListLike(item)) {
		frag = document.createDocumentFragment();
		canReflect.eachIndex(item, function(item) {
			frag.appendChild(makeFrag(item));
		});
	} else {
		frag = fragment("" + item, document);
	}
    if (!childNodes(frag).length) {
        frag.appendChild(document.createTextNode(''));
    }
    return frag;
};

module.exports = namespace.fragment = namespace.frag = makeFrag;


/***/ }),

/***/ "./node_modules/can-globals/base-url/base-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/base-url/base-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var globals = __webpack_require__(/*! ../can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");
__webpack_require__(/*! ../global/global */ "./node_modules/can-globals/global/global.js");
__webpack_require__(/*! ../document/document */ "./node_modules/can-globals/document/document.js");

/**
 * @module {function} can-globals/base-url/base-url base-url
 * @parent can-globals/modules
 *
 * @signature `baseUrl(optionalBaseUrlToSet)`
 *
 * Get and/or set the "base" (containing path) of the document.
 *
 * ```js
 * var baseUrl = require("can-globals/base-url/base-url");
 *
 * console.log(baseUrl());           // -> "http://localhost:8080"
 * console.log(baseUrl(baseUrl() + "/foo/bar")); // -> "http://localhost:8080/foo/bar"
 * console.log(baseUrl());           // -> "http://localhost:8080/foo/bar"
 * ```
 *
 * @param {String} setUrl An optional base url to override reading the base URL from the known path.
 *
 * @return {String} Returns the set or computed base URL
 */

globals.define('base-url', function(){
	var global = globals.getKeyValue('global');
	var domDocument = globals.getKeyValue('document');
	if (domDocument && 'baseURI' in domDocument) {
		return domDocument.baseURI;
	} else if(global.location) {
		var href = global.location.href;
		var lastSlash = href.lastIndexOf("/");
		return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
	} else if(typeof process !== "undefined") {
		return process.cwd();
	}
});

module.exports = globals.makeExport('base-url');


/***/ }),

/***/ "./node_modules/can-globals/can-globals-instance.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-globals/can-globals-instance.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var Globals = __webpack_require__(/*! ./can-globals-proto */ "./node_modules/can-globals/can-globals-proto.js");
var globals = new Globals();

if (namespace.globals) {
	throw new Error("You can't have two versions of can-globals, check your dependencies");
} else {
	module.exports = namespace.globals = globals;
}


/***/ }),

/***/ "./node_modules/can-globals/can-globals-proto.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/can-globals-proto.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function dispatch(key) {
	// jshint -W040
	var handlers = this.eventHandlers[key];
	if (handlers) {
		var handlersCopy = handlers.slice();
		var value = this.getKeyValue(key);
		for (var i = 0; i < handlersCopy.length; i++) {
			handlersCopy[i](value);
		}
	}
}

function Globals() {
	this.eventHandlers = {};
	this.properties = {};
}

/**
 * @function define 
 * @parent can-globals/methods
 * 
 * Create a new global environment variable.
 * 
 * @signature `globals.define(key, value[, cache])`
 * 
 * Defines a new global called `key`, who's value defaults to `value`.
 * 
 * The following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:
 * ```javascript
 * globals.define('global', window);
 * globals.getKeyValue('window') //-> window
 * ```
 * 
 * If a function is provided and `cache` is falsy, that function is run every time the key value is read:
 * ```javascript
 * globals.define('isBrowserWindow', function() {
 *   console.log('EVALUATING')
 *   return typeof window !== 'undefined' &&
 *     typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'
 * }, false);
 * globals.get('isBrowserWindow') // logs 'EVALUATING'
 *                                // -> true
 * globals.get('isBrowserWindow') // logs 'EVALUATING' again
 *                                // -> true
 * ```
 * 
 * If a function is provided and `cache` is truthy, that function is run only the first time the value is read:
 * ```javascript
 * globals.define('isWebkit', function() {
 *   console.log('EVALUATING')
 *   var div = document.createElement('div')
 *   return 'WebkitTransition' in div.style
 * })
 * globals.getKeyValue('isWebkit') // logs 'EVALUATING'
 * 								   // -> true
 * globals.getKeyValue('isWebkit') // Does NOT log again!
 * 								   // -> true
 * ```
 * 
 * @param {String} key
 * The key value to create.
 * 
 * @param {*} value
 * The default value. If this is a function, its return value will be used.
 * 
 * @param {Boolean} [cache=true]
 * Enable cache. If false the `value` function is run every time the key value is read.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.define = function (key, value, enableCache) {
	if (enableCache === undefined) {
		enableCache = true;
	}
	if (!this.properties[key]) {
		this.properties[key] = {
			default: value,
			value: value,
			enableCache: enableCache
		};
	}
	return this;
};

/**
 * @function getKeyValue 
 * @parent can-globals/methods
 * 
 * Get a global environment variable by name.
 * 
 * @signature `globals.getKeyValue(key)`
 * 
 * Returns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.getKeyValue('foo'); //-> 'bar'
 * ```
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @return {*}
 * Returns the value of a given key.
 */
Globals.prototype.getKeyValue = function (key) {
	var property = this.properties[key];
	if (property) {
		if (typeof property.value === 'function') {
			if (property.cachedValue) {
				return property.cachedValue;
			}
			if (property.enableCache) {
				property.cachedValue = property.value();
				return property.cachedValue;
			} else {
				return property.value();
			}
		}
		return property.value;
	}
};

Globals.prototype.makeExport = function (key) {
	return function (value) {
		if (arguments.length === 0) {
			return this.getKeyValue(key);
		}

		if (typeof value === 'undefined' || value === null) {
			this.deleteKeyValue(key);
		} else {
			if (typeof value === 'function') {
				this.setKeyValue(key, function () {
					return value;
				});
			} else {
				this.setKeyValue(key, value);
			}
			return value;
		}
	}.bind(this);
};

/**
 * @function offKeyValue 
 * @parent can-globals/methods
 * 
 * Remove handler from event queue.
 * 
 * @signature `globals.offKeyValue(key, handler)`
 * 
 * Removes `handler` from future change events for `key`.
 * 
 * 
 * ```javascript
 * var handler = (value) => {
 *   value === 'baz' //-> true
 * };
 * globals.define('foo', 'bar');
 * globals.onKeyValue('foo', handler);
 * globals.setKeyValue('foo', 'baz');
 * globals.offKeyValue('foo', handler);
 * ```
 * 
 * @param {String} key
 * The key value to observe.
 * 
 * @param {Function} handler([value])
 * The observer callback.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.offKeyValue = function (key, handler) {
	if (this.properties[key]) {
		var handlers = this.eventHandlers[key];
		if (handlers) {
			var i = handlers.indexOf(handler);
			handlers.splice(i, 1);
		}
	}
	return this;
};

/**
 * @function onKeyValue 
 * @parent can-globals/methods
 * 
 * Add handler to event queue.
 * 
 * @signature `globals.onKeyValue(key, handler)`
 * 
 * Calls `handler` each time the value of `key` is set or reset.
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.onKeyValue('foo', (value) => {
 *   value === 'baz' //-> true
 * });
 * globals.setKeyValue('foo', 'baz');
 * ```
 * 
 * @param {String} key
 * The key value to observe.
 * 
 * @param {function(*)} handler([value])
 * The observer callback.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.onKeyValue = function (key, handler) {
	if (this.properties[key]) {
		if (!this.eventHandlers[key]) {
			this.eventHandlers[key] = [];
		}
		this.eventHandlers[key].push(handler);
	}
	return this;
};

/**
 * @function deleteKeyValue 
 * @parent can-globals/methods
 * 
 * Reset global environment variable.
 * 
 * @signature `globals.deleteKeyValue(key)`
 * 
 * Deletes the current value at `key`. Future `get`s will use the default value.
 * 
 * ```javascript
 * globals.define('global', window);
 * globals.setKeyValue('global', {});
 * globals.deleteKeyValue('global');
 * globals.getKeyValue('global') === window; //-> true
 * ```
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.deleteKeyValue = function (key) {
	var property = this.properties[key];
	if (property !== undefined) {
		property.value = property.default;
		property.cachedValue = undefined;
		dispatch.call(this, key);
	}
	return this;
};

/**
 * @function setKeyValue 
 * @parent can-globals/methods
 * 
 * Overwrite an existing global environment variable.
 * 
 * @signature `globals.setKeyValue(key, value)`
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.setKeyValue('foo', 'baz');
 * globals.getKeyValue('foo'); //-> 'baz'
 * ```
 * 
 * Sets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).
 * 
 * Setting a key which was not previously defined will call `define` with the key and value.
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @param {*} value
 * The new value.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.setKeyValue = function (key, value) {
	if (!this.properties[key]) {
		return this.define(key, value);
	}
	var property = this.properties[key];
	property.value = value;
	property.cachedValue = undefined;
	dispatch.call(this, key);
	return this;
};

/**
 * @function reset 
 * @parent can-globals/methods
 * 
 * Reset all keys to their default value and clear their caches.
 * 
 * @signature `globals.setKeyValue(key, value)`
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.setKeyValue('foo', 'baz');
 * globals.getKeyValue('foo'); //-> 'baz'
 * globals.reset();
 * globals.getKeyValue('foo'); //-> 'bar'
 * ```
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.reset = function () {
	for (var key in this.properties) {
		if (this.properties.hasOwnProperty(key)) {
			this.properties[key].value = this.properties[key].default;
			this.properties[key].cachedValue = undefined;
			dispatch.call(this, key);
		}
	}
	return this;
};

canReflect.assignSymbols(Globals.prototype, {
	'can.getKeyValue': Globals.prototype.getKeyValue,
	'can.setKeyValue': Globals.prototype.setKeyValue,
	'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
	'can.onKeyValue': Globals.prototype.onKeyValue,
	'can.offKeyValue': Globals.prototype.offKeyValue
});

module.exports = Globals;


/***/ }),

/***/ "./node_modules/can-globals/can-globals.js":
/*!*************************************************!*\
  !*** ./node_modules/can-globals/can-globals.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

__webpack_require__(/*! ./global/global */ "./node_modules/can-globals/global/global.js");
__webpack_require__(/*! ./document/document */ "./node_modules/can-globals/document/document.js");
__webpack_require__(/*! ./location/location */ "./node_modules/can-globals/location/location.js");
__webpack_require__(/*! ./mutation-observer/mutation-observer */ "./node_modules/can-globals/mutation-observer/mutation-observer.js");
__webpack_require__(/*! ./is-browser-window/is-browser-window */ "./node_modules/can-globals/is-browser-window/is-browser-window.js");
__webpack_require__(/*! ./is-node/is-node */ "./node_modules/can-globals/is-node/is-node.js");
__webpack_require__(/*! ./custom-elements/custom-elements */ "./node_modules/can-globals/custom-elements/custom-elements.js");

module.exports = globals;


/***/ }),

/***/ "./node_modules/can-globals/custom-elements/custom-elements.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-globals/custom-elements/custom-elements.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/custom-elements/custom-elements custom-elements
 * @parent can-globals/modules
 *
 * Get the global [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the current context.
 *
 * @signature `CUSTOMELEMENTS([newCustomElements])`
 *
 * Optionally sets, and returns, the [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the context.
 *
 * ```js
 * var customElementsShim = require('some-custom-elements-shim');
 * CUSTOMELEMENTS(customElementsShim);
 * CUSTOMELEMENTS() //-> customElementsShim
 * ```
 *
 * @param {Object} customElements An optional CustomElementRegistry-like object to set as the context's customElements
 *
 * @return {Object} The customElements object for this JavaScript environment.
 */

globals.define('customElements', function(){
	var GLOBAL = globals.getKeyValue('global');
	return GLOBAL.customElements;
});

module.exports = globals.makeExport('customElements');


/***/ }),

/***/ "./node_modules/can-globals/document/document.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/document/document.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/document/document document
 * @parent can-globals/modules
 * 
 * Get the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.
 * 
 * @signature `DOCUMENT([newDocument])`
 * 
 * Optionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.
 * 
 * ```js
 * var documentShim = { getElementById() {...} };
 * var DOCUMENT = require('can-globals/document/document');
 * DOCUMENT(documentShim); //-> document
 * DOCUMENT().getElementById('foo');
 * ```
 *
 * @param {Object} [newDocument] An optional document-like object to set as the context's document 
 * 
 * @return {Object} The window object for this JavaScript environment.
 */
globals.define('document', function(){
	return globals.getKeyValue('global').document;
});

module.exports = globals.makeExport('document');


/***/ }),

/***/ "./node_modules/can-globals/global/global.js":
/*!***************************************************!*\
  !*** ./node_modules/can-globals/global/global.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* global self */
/* global WorkerGlobalScope */

var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/global/global global
 * @parent can-globals/modules
 * 
 * Get the global object for the current context.
 * 
 * @signature `GLOBAL([newGlobal])`
 *
 * Optionally sets, and returns the global that this environment provides. It will be one of:
 * 
 * ```js
 * var GLOBAL = require('can-globals/global/global');
 * var g = GLOBAL();
 * // In a browser
 * console.log(g === window); // -> true
 * ```
 *
 * - **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)
 * - **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)
 * - **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)
 * 
 * @param {Object} [newGlobal] An optional global-like object to set as the context's global 
 *
 * @return {Object} The global object for this JavaScript environment.
 */
globals.define('global', function(){
	// Web Worker
	return (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :

		// Node.js
		typeof process === 'object' &&
		{}.toString.call(process) === '[object process]' ? __webpack_require__.g :

		// Browser window
		window;
});

module.exports = globals.makeExport('global');


/***/ }),

/***/ "./node_modules/can-globals/is-browser-window/is-browser-window.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-globals/is-browser-window/is-browser-window.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

// This module depends on isNode being defined
__webpack_require__(/*! ../is-node/is-node */ "./node_modules/can-globals/is-node/is-node.js");

/**
 * @module {function} can-globals/is-browser-window/is-browser-window is-browser-window
 * @parent can-globals/modules
 * @signature `isBrowserWindow()`
 *
 * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).
 *
 * ```js
 * var isBrowserWindow = require("can-globals/is-browser-window/is-browser-window");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isBrowserWindow()) {
 *   console.log(GLOBAL() === window); // -> true
 * }
 * ```
 *
 * @return {Boolean} True if the environment is a Browser window.
 */

globals.define('isBrowserWindow', function(){
	var isNode = globals.getKeyValue('isNode');
	return typeof window !== "undefined" &&
		typeof document !== "undefined" &&
		isNode === false;
});

module.exports = globals.makeExport('isBrowserWindow');


/***/ }),

/***/ "./node_modules/can-globals/is-node/is-node.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-globals/is-node/is-node.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/is-node/is-node is-node
 * @parent can-globals/modules
 * @description Determines if your code is running in [Node.js](https://nodejs.org).
 * @signature `isNode()`
 *
 * ```js
 * var isNode = require("can-globals/is-node/is-node");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isNode()) {
 *   console.log(GLOBAL() === global); // -> true
 * }
 * ```
 *
 * @return {Boolean} True if running in Node.js
 */

globals.define('isNode', function(){
	return typeof process === "object" &&
		{}.toString.call(process) === "[object process]";
});

module.exports = globals.makeExport('isNode');


/***/ }),

/***/ "./node_modules/can-globals/is-web-worker/is-web-worker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-globals/is-web-worker/is-web-worker.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/* globals WorkerGlobalScope */
// A bit of weirdness to avoid complaining linters
var funcConstructor = Function;


/**
 * @module {function} can-globals/is-browser-window/is-web-worker is-web-worker
 * @parent can-globals/modules
 * @signature `isWebWorker()`
 *
 * Returns `true` if the code is running within a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker).
 *
 * ```js
 * var isWebWorker = require("can-globals/is-web-worker/is-web-worker");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isWebWorker()) {
 *   ...
 * }
 * ```
 *
 * @return {Boolean} True if the environment is a web worker.
 */

globals.define('isWebWorker', function(){
    var global = funcConstructor('return this')();
    return typeof WorkerGlobalScope !== "undefined" &&
        (global instanceof WorkerGlobalScope);
});

module.exports = globals.makeExport('isWebWorker');


/***/ }),

/***/ "./node_modules/can-globals/location/location.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/location/location.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/location/location location
 * @parent can-globals/modules
 * 
 * Get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.
 * 
 * @signature `LOCATION([newLocation])`
 * 
 * Optionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.
 * 
 * ```js
 * var locationShim = { path: '/' };
 * var LOCATION = require('can-globals/location/location');
 * LOCATION(locationShim);
 * LOCATION().path; // -> '/'
 * ```
 *
 * @param {Object} location An optional location-like object to set as the context's location
 *
 * @return {Object} The location object for this JavaScript environment.
 */
globals.define('location', function(){
	return globals.getKeyValue('global').location;
});

module.exports = globals.makeExport('location');


/***/ }),

/***/ "./node_modules/can-globals/mutation-observer/mutation-observer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-globals/mutation-observer/mutation-observer.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var globals = __webpack_require__(/*! can-globals/can-globals-instance */ "./node_modules/can-globals/can-globals-instance.js");

/**
 * @module {function} can-globals/mutation-observer/mutation-observer mutation-observer
 * @parent can-globals/modules
 * 
 * Get the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.
 * 
 * @signature `MUTATIONOBSERVER([newMutationObserver])`
 * 
 * Optionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.
 * 
 * ```js
 * var mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');
 * MUTATIONOBSERVER(mutationObserverShim);
 * MUTATIONOBSERVER() //-> MutationObserver
 * ```
 *
 * @param {Object} MutationObserver An optional MutationObserver-like object to set as the context's MutationObserver
 *
 * @return {Object} The MutationObserver object for this JavaScript environment.
 */

globals.define('MutationObserver', function(){
	var GLOBAL = globals.getKeyValue('global');
	return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
});

module.exports = globals.makeExport('MutationObserver');


/***/ }),

/***/ "./node_modules/can-import-module/can-import-module.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-import-module/can-import-module.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getGlobal = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

/**
 * @module {function} can-util/js/import/import import
 * @parent can-util/js
 * @signature `importModule(moduleName, parentName)`
 *
 * ```js
 * var importModule = require("can-util/js/import/import");
 *
 * importModule("foo.stache").then(function(){
 *   // module was imported
 * });
 * ```
 *
 * @param {String} moduleName The module to be imported.
 * @param {String} [parentName] A parent module that will be used as a reference for resolving relative module imports.
 * @return {Promise} A Promise that will resolve when the module has been imported.
 */

module.exports = namespace.import = function(moduleName, parentName) {
	return new Promise(function(resolve, reject) {
		try {
			var global = getGlobal();
			if(typeof global.System === "object" && isFunction(global.System["import"])) {
				global.System["import"](moduleName, {
					name: parentName
				}).then(resolve, reject);
			} else if(global.define && global.define.amd){
				global.require([moduleName], function(value){
					resolve(value);
				});
			} else if(global.require){
				resolve(global.require(moduleName));
			} else {
				// steal optimized build
				if (typeof stealRequire !== "undefined") {
					steal.import(moduleName, { name: parentName }).then(resolve, reject);
				} else {
					// ideally this will use can.getObject
					resolve();
				}
			}
		} catch(err) {
			reject(err);
		}
	});
};

function isFunction(fn) {
	return typeof fn === "function";
}


/***/ }),

/***/ "./node_modules/can-join-uris/can-join-uris.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-join-uris/can-join-uris.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var parseURI = __webpack_require__(/*! can-parse-uri */ "./node_modules/can-parse-uri/can-parse-uri.js");

module.exports = namespace.joinURIs = function(base, href) {
	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
			});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
			(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
			href.hash;
};


/***/ }),

/***/ "./node_modules/can-kefir/can-kefir.js":
/*!*********************************************!*\
  !*** ./node_modules/can-kefir/can-kefir.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Kefir = __webpack_require__(/*! kefir */ "./node_modules/kefir/dist/kefir.esm.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var mapEventsMixin = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var metaSymbol = canSymbol.for("can.meta");
var onKeyValueSymbol = canSymbol.for("can.onKeyValue");
var offKeyValueSymbol = canSymbol.for("can.offKeyValue");

var keyNames = {
	value: {
		on: "onValue",
		off: "offValue",
		handler: "onValueHandler",
		handlers: "onValueHandlers"
	},
	error: {
		on: "onError",
		off: "offError",
		handler: "onErrorHandler",
		handlers: "onErrorHandlers"
	}
};

function ensureMeta(obj) {
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect.setKeyValue(obj, metaSymbol, meta);
	}

	return meta;
}

// get the current value from a stream
function getCurrentValue(stream, key) {
	if (stream._currentEvent && stream._currentEvent.type === key) {
		return stream._currentEvent.value;
	} else {
		var names = keyNames[key];
		if (!names) {
			return stream[key];
		}
		var VALUE,
			valueHandler = function(value) {
				VALUE = value;
			};
		stream[names.on](valueHandler);
		stream[names.off](valueHandler);
		return VALUE;
	}
}

// The conditional is needed or the global CanJS build,
// this code should not break if Kefir is not bundled
if (Kefir) {
	// https://github.com/donejs/bitballs/issues/332
	// Kefir can appear to be an ES module.  This works around that.
	if(Object.isExtensible && !Object.isExtensible(Kefir)) {
		Kefir = Kefir.Kefir;
	}

	Kefir.Observable.prototype._eventSetup = function eventSetup() {
		var stream = this;
		var meta = ensureMeta(stream);

		meta.bound = true;

		meta.onValueHandler = function onValueHandler(newValue) {
			var oldValue = meta.value;
			meta.value = newValue;

			// only send events for a change
			if (newValue !== oldValue) {
				mapEventsMixin.dispatch.call(
					stream,
					{ type: "value" },
					[newValue, oldValue]
				);
			}
		};

		meta.onErrorHandler = function onErrorHandler(error) {
			var prevError = meta.error;
			meta.error = error;

			mapEventsMixin.dispatch.call(
				stream,
				{ type: "error" },
				[error, prevError]
			);
		};

		stream.onValue(meta.onValueHandler);
		stream.onError(meta.onErrorHandler);
	};

	Kefir.Observable.prototype._eventTeardown = function eventTeardown() {
		var stream = this;
		var meta = ensureMeta(stream);

		meta.bound = false;

		stream.offValue(meta.onValueHandler);
		stream.offError(meta.onErrorHandler);
	};

	// Observable is parent of Kefir.Stream
	canReflect.assignSymbols(Kefir.Observable.prototype, {
		"can.onKeyValue": function onKeyValue() {
			return mapEventsMixin[onKeyValueSymbol].apply(
				this,
				arguments
			);
		},
		"can.offKeyValue": function() {
			return mapEventsMixin[offKeyValueSymbol].apply(
				this,
				arguments
			);
		},
		"can.getKeyValue": function(key) {
			var stream = this;
			var meta = ensureMeta(stream);

			if (!keyNames[key]) {
				return stream[key];
			}

			ObservationRecorder.add(stream, key);

			if (meta.bound) {
				return meta[key];
			} else {
				// we haven't been bound ... see what we can get from the observable
				// using internals for performance ...
				var currentValue = getCurrentValue(stream, key);

				// save current value so we won't through events if we provided a value
				meta[key] = currentValue;

				return currentValue;
			}
		},
		"can.getValueDependencies": function getValueDependencies() {
			var sources;
			var stream = this;

			// streams created by methods like .scan have a single source,
			// stored in stream._source
			if (stream._source != null) {
				sources = [stream._source];

			// ... while methods like .combine have multiple sources
			// stored as an array in stream._sources
			} else if (stream._sources != null) {
				sources = stream._sources;
			}

			if (sources != null) {
				return {
					valueDependencies: new Set(sources)
				};
			}
		}
	});

	Kefir.emitterProperty = function() {
		var emitter;
		var setLastValue = false;
		var lastValue, lastError;

		var stream = Kefir.stream(function(EMITTER) {
			emitter = EMITTER;
			if (setLastValue) {
				emitter.value(lastValue);
			}
			return function() {
				emitter = undefined;
			};
		});

		var property = stream.toProperty(function() {
			return lastValue;
		});
		property.emitter = {
			value: function(newValue) {
				if (emitter) {
					return emitter.emit(newValue);
				} else {
					setLastValue = true;
					lastValue = newValue;
				}
			},
			error: function(error) {
				if (emitter) {
					return emitter.error(error);
				} else {
					lastError = error;
				}
			}
		};
		property.emitter.emit = property.emitter.value;

		canReflect.assignSymbols(property, {
			"can.setKeyValue": function setKeyValue(key, value) {
				this.emitter[key](value);
			},
			"can.hasKey": function hasKey(key) {
				return key in this.emitter;
			}
		});

		return property;
	};
}

module.exports = Kefir;


/***/ }),

/***/ "./node_modules/can-key-tree/can-key-tree.js":
/*!***************************************************!*\
  !*** ./node_modules/can-key-tree/can-key-tree.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var reflect = __webpack_require__( /*! can-reflect */ "./node_modules/can-reflect/can-reflect.js" );

// ## Helpers
// The following implement helper functions useful to `can-key-tree`'s main methods.

// ### isBuiltInPrototype
// Returns if `obj` is the prototype of a built-in JS type like `Map`.
// Built in types' `toString` returns `[object TYPENAME]`.
function isBuiltInPrototype ( obj ) {
	if ( obj === Object.prototype ) {
		return true;
	}
	var protoString = Object.prototype.toString.call( obj );
	var isNotObjObj = protoString !== '[object Object]';
	var isObjSomething = protoString.indexOf( '[object ' ) !== -1;
	return isNotObjObj && isObjSomething;
}

// ### getDeepSize
// Recursively returns the number of leaf values below `root` node.
function getDeepSize ( root, level ) {
	if ( level === 0 ) {
		return reflect.size( root );
	} else if ( reflect.size( root ) === 0 ) {
		return 0;
	} else {
		var count = 0;
		reflect.each( root, function ( value ) {
			count += getDeepSize( value, level - 1 );
		});
		return count;
	}
}

// ### getDeep
// Adds all leaf values under `node` to `items`.
// `depth` is how deep `node` is in the tree.
// `maxDepth` is the total depth of the tree structure.
function getDeep ( node, items, depth, maxDepth ) {
	if ( !node ) {
		return;
	}
	if ( maxDepth === depth ) {
		if ( reflect.isMoreListLikeThanMapLike( node ) ) {
			reflect.addValues( items, reflect.toArray( node ) );
		} else {
			throw new Error( "can-key-tree: Map-type leaf containers are not supported yet." );
		}
	} else {
		reflect.each( node, function ( value ) {
			getDeep( value, items, depth + 1, maxDepth );
		});
	}
}

// ### clearDeep
// Recursively removes value from all child nodes of `node`.
function clearDeep ( node, keys, maxDepth, deleteHandler ) {
	if ( maxDepth === keys.length ) {
		if ( reflect.isMoreListLikeThanMapLike( node ) ) {
			var valuesToRemove = reflect.toArray( node );
			if(deleteHandler) {
				valuesToRemove.forEach(function(value){
					deleteHandler.apply(null, keys.concat(value));
				});
			}
			reflect.removeValues( node, valuesToRemove );
		} else {
			throw new Error( "can-key-tree: Map-type leaf containers are not supported yet." );
		}
	} else {
		reflect.each( node, function ( value, key ) {
			clearDeep( value, keys.concat(key), maxDepth, deleteHandler );
			reflect.deleteKeyValue( node, key );
		});
	}
}

// ## KeyTree
// Creates an instance of the KeyTree.
var KeyTree = function ( treeStructure, callbacks ) {
	var FirstConstructor = treeStructure[0];
	if ( reflect.isConstructorLike( FirstConstructor ) ) {
		this.root = new FirstConstructor();
	} else {
		this.root = FirstConstructor;
	}
	this.callbacks = callbacks || {};
	this.treeStructure = treeStructure;
	// An extra bit of state held for performance
	this.empty = true;
};

// ## Methods
reflect.assign(KeyTree.prototype,{
    // ### Add
    add: function ( keys ) {
    	if ( keys.length > this.treeStructure.length ) {
    		throw new Error( "can-key-tree: Can not add path deeper than tree." );
    	}
        // The place we will add the final leaf value.
    	var place = this.root;

        // Record if the root was empty so we know to call `onFirst`.
    	var rootWasEmpty = this.empty === true;

        // For each key, try to get the corresponding childNode.
        for ( var i = 0; i < keys.length - 1; i++ ) {
    		var key = keys[i];
    		var childNode = reflect.getKeyValue( place, key );
    		if ( !childNode ) {
                // If there is no childNode, create it and add it to the parent node.
    			var Constructor = this.treeStructure[i + 1];
    			if ( isBuiltInPrototype( Constructor.prototype ) ) {
    				childNode = new Constructor();
    			} else {
    				childNode = new Constructor( key );
    			}
    			reflect.setKeyValue( place, key, childNode );
    		}
    		place = childNode;
    	}

        // Add the final leaf value in the tree.
    	if ( reflect.isMoreListLikeThanMapLike( place ) ) {
    		reflect.addValues( place, [keys[keys.length - 1]] );
    	} else {
    		throw new Error( "can-key-tree: Map types are not supported yet." );
    	}

        // Callback `onFirst` if appropriate.
    	if ( rootWasEmpty ) {
			this.empty = false;
			if(this.callbacks.onFirst) {
				this.callbacks.onFirst.call( this );
			}

    	}

    	return this;
    },
    // ### getNode
    getNode: function ( keys ) {
        var node = this.root;
        // For each key, try to read the child node.
        // If a child is not found, return `undefined`.
        for ( var i = 0; i < keys.length; i++ ) {
            var key = keys[i];
            node = reflect.getKeyValue( node, key );
            if ( !node ) {
                return;
            }
        }
        return node;
    },
    // ### get
    get: function ( keys ) {
        // Get the node specified by keys.
    	var node = this.getNode( keys );

        // If it's a leaf, return it.
    	if ( this.treeStructure.length === keys.length ) {
    		return node;
    	} else {
    		// Otherwise, create a container for leaf values and
            // recursively walk the node's children.
    		var Type = this.treeStructure[this.treeStructure.length - 1];
    		var items = new Type();
    		getDeep( node, items, keys.length, this.treeStructure.length - 1 );
    		return items;
    	}
    },
    // ### delete
    delete: function ( keys, deleteHandler ) {

        // `parentNode` will eventually be the parent nodde of the
        // node specified by keys.
        var parentNode = this.root,
            // The nodes traversed to the node specified by `keys`.
            path = [this.root],
            lastKey = keys[keys.length - 1];

        // Set parentNode to the node specified by keys
        // and record the nodes in `path`.
        for ( var i = 0; i < keys.length - 1; i++ ) {
    		var key = keys[i];
    		var childNode = reflect.getKeyValue( parentNode, key );
    		if ( childNode === undefined ) {
    			return false;
    		} else {
    			path.push( childNode );
    		}
    		parentNode = childNode;
    	}


        // Depending on which keys were specified and the content of the
        // key, do various cleanups ...
        if ( !keys.length ) {
            // If there are no keys, recursively clear the entire tree.
    		clearDeep( parentNode, [], this.treeStructure.length - 1, deleteHandler );
    	}
        else if ( keys.length === this.treeStructure.length ) {
            // If removing a leaf, remove that value.
    		if ( reflect.isMoreListLikeThanMapLike( parentNode ) ) {
				if(deleteHandler) {
					deleteHandler.apply(null, keys.concat(lastKey));
				}
    			reflect.removeValues( parentNode, [lastKey] );
    		} else {
    			throw new Error( "can-key-tree: Map types are not supported yet." );
    		}
    	}
        else {
            // If removing a node 'within' the tree, recursively clear
            // that node and then delete the key from parent to node.
            var nodeToRemove = reflect.getKeyValue( parentNode, lastKey );
    		if ( nodeToRemove !== undefined ) {
    			clearDeep( nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler );
    			reflect.deleteKeyValue( parentNode, lastKey );
    		} else {
    			return false;
    		}
    	}

        // After deleting the node, check if its parent is empty and
        // recursively prune parent nodes that are now empty.
    	for ( i = path.length - 2; i >= 0; i-- ) {
    		if ( reflect.size( parentNode ) === 0 ) {
    			parentNode = path[i];
    			reflect.deleteKeyValue( parentNode, keys[i] );
    		} else {
    			break;
    		}
    	}
        // Call `onEmpty` if the tree is now empty.
    	if (  reflect.size( this.root ) === 0 ) {
			this.empty = true;
			if(this.callbacks.onEmpty) {
				this.callbacks.onEmpty.call( this );
			}
    	}
    	return true;
    },
    // ### size
    // Recursively count the number of leaf values.
    size: function () {
    	return getDeepSize( this.root, this.treeStructure.length - 1 );
    },
	isEmpty: function(){
		return this.empty;
	}
});

module.exports = KeyTree;


/***/ }),

/***/ "./node_modules/can-key/can-key.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/can-key.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var deleteKey = __webpack_require__(/*! can-key/delete/delete */ "./node_modules/can-key/delete/delete.js"),
    get = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js"),
    replaceWith = __webpack_require__(/*! can-key/replace-with/replace-with */ "./node_modules/can-key/replace-with/replace-with.js"),
    set = __webpack_require__(/*! can-key/set/set */ "./node_modules/can-key/set/set.js"),
    transform = __webpack_require__(/*! can-key/transform/transform */ "./node_modules/can-key/transform/transform.js"),
    walk = __webpack_require__(/*! can-key/walk/walk */ "./node_modules/can-key/walk/walk.js"),
    namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

module.exports = namespace.key = {
    deleteKey: deleteKey,
    get: get,
    replaceWith: replaceWith,
    set: set,
    transform: transform,
    walk: walk
};


/***/ }),

/***/ "./node_modules/can-key/delete/delete.js":
/*!***********************************************!*\
  !*** ./node_modules/can-key/delete/delete.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");

/**
 * @module {function} can-key/delete/delete
 * @parent can-key
 */
module.exports = function deleteAtPath(data, path) {
    var parts = utils.parts(path);
    var current = data;

    for(var i = 0; i < parts.length - 1; i++) {
        if(current) {
            current = canReflect.getKeyValue( current, parts[i]);
        }
    }

    if(current) {
        canReflect.deleteKeyValue(current, parts[parts.length - 1 ]);
    }
};


/***/ }),

/***/ "./node_modules/can-key/get/get.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/get/get.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");

/**
 * @module {function} can-key/get/get
 * @parent can-key
 * @description Get properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.
 *
 * @signature `get(obj, path)`
 * @param  {Object} obj the object to use as the root for property-based navigation
 * @param  {String} path a String of dot-separated keys, representing a path of properties
 * @return {*}       the value at the property path
 *
 * @body
 *
 * A *path* is a dot-delimited sequence of zero or more property names, such that "foo.bar" means "the property
 * 'bar' of the object at the property 'foo' of the root."  An empty path returns the object passed.
 *
 * ```js
 * var get = require("can-key");
 * console.log(get({a: {b: {c: "foo"}}}, "a.b.c")); // -> "foo"
 * console.log(get({a: {}}, "a.b.c")); // -> undefined
 * console.log(get([{a: {}}, {a: {b: "bar"}}], "a.b")); // -> "bar"
 *
 * var map = new Map();
 * map.set("first", {second: "third"});
 *
 * get(map, "first.second") //-> "third"
 * ```
 */
function get(obj, name) {
    // The parts of the name we are looking up
    // `['App','Models','Recipe']`
    var parts = utils.parts(name);

    var length = parts.length,
        current, i, container;

    if (!length) {
        return obj;
    }

    current = obj;

    // Walk current to the 2nd to last object or until there
    // is not a container.
    for (i = 0; i < length && utils.isContainer(current) && current !== null; i++) {
        container = current;
        current = canReflect.getKeyValue( container, parts[i] );
    }

    return current;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/can-key/replace-with/replace-with.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-key/replace-with/replace-with.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");
var get = __webpack_require__(/*! ../get/get */ "./node_modules/can-key/get/get.js");
var deleteKey = __webpack_require__(/*! ../delete/delete */ "./node_modules/can-key/delete/delete.js");
/**
 * @module {function} can-key/replace-with/replace-with
 * @parent can-key
 *
 * Replace the templated parts of a string with values from an object.
 *
 * @signature `replaceWith(str, data, replacer, remove)`
 *
 * ```js
 * import replaceWith from "can-key/replace-with/replace-with";
 *
 * replaceWith("foo_{bar}", {bar: "baz"}); // -> "foo_baz"
 * ```
 *
 * @param {String} str String with {curly brace} delimited property names.
 * @param {Object} data Object from which to read properties.
 * @param {function(String,*)} [replacer(key,value)] Function which returns string replacements.  Optional.
 *
 *   ```js
 *   replaceWith("foo_{bar}", {bar: "baz"}, (key, value) => {
 *     return value.toUpperCase();
 *   }); // -> "foo_BAZ"
 *   ```
 *
 *
 * @param {Boolean} shouldRemoveMatchedPaths Whether to remove properties
 * found in delimiters in `str` from `data`.
 * @return {String} the supplied string with delimited properties replaced with their values.
 *
 * @body
 *
 * ```js
 * var replaceWith = require("can-key/replace-with/replace-with");
 * var answer = replaceWith(
 *   '{.}{.}{.}{.}{.} Batman!',
 *   {},
 *   () => 'Na'
 * );
 * // => 'NaNaNaNaNa Batman!'
 * ```
 */
module.exports = function (str, data, replacer, shouldRemoveMatchedPaths) {
    return str.replace(utils.strReplacer, function (whole, path) {
        var value = get(data, path);
        if(shouldRemoveMatchedPaths) {
            deleteKey(data, path);
        }
        return replacer ? replacer(path, value) : value;
    });
};


/***/ }),

/***/ "./node_modules/can-key/set/set.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/set/set.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");

var setValueSymbol = canSymbol.for("can.setValue");

/**
 * @module {function} can-key/set/set
 * @parent can-key
 * @description Set properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.
 *
 * @signature `set(object, path, value)`
 * @param  {Object} object The object to use as the root for property-based navigation.
 * @param  {String} path A String of dot-separated keys, representing a path of properties.
 * @param  {*} value The new value to be set at the property path.
 * @return {*} The object passed to set (for chaining calls).
 *
 * @body
 *
 * A *path* is a dot-delimited sequence of one or more property names, such that "foo.bar" means "the property
 * 'bar' of the object at the property 'foo' of the root."
 *
 * ```js
 * import set from "can-key/set/set";
 *
 * const object = {a: {b: {c: "foo"}}};
 * set(object, "a.b.c", "bar");
 * // Now object.a.b.c === "bar"
 *
 * var map = new Map();
 * map.set("first", {second: "third"});
 *
 * set(map, "first.second", "3rd");
 * // Now map.first.second === "3rd"
 * ```
 *
 * > **Note:** an error will be thrown if one of the objects in the key path does not exist.
 */
function set(object, path, value) {
    var parts = utils.parts(path);

    var current = object;
    var length = parts.length;

    // Walk current until there is not a container
    for (var i = 0; i < length - 1; i++) {
        if (utils.isContainer(current)) {
            current = canReflect.getKeyValue(current, parts[i]);
        } else {
            break;
        }
    }

    // Set the value
    if (current) {
        canReflect.setKeyValue(current, parts[i], value);
    } else {
        throw new TypeError("Cannot set value at key path '" + path + "'");
    }

    return object;
}

module.exports = set;


/***/ }),

/***/ "./node_modules/can-key/sub/sub.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/sub/sub.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");
var get = __webpack_require__(/*! ../get/get */ "./node_modules/can-key/get/get.js");
var canReflect= __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var deleteKey = __webpack_require__(/*! ../delete/delete */ "./node_modules/can-key/delete/delete.js");
/**
 * @module {function} can-key/sub/sub
 * @parent can-key
 * @hide
 *
 * Replace templated parts of a string with values.
 *
 * @signature `sub(str, data, remove)`
 *
 * `sub` is used to replace templated parts of a string with values.
 *
 * ```js
 * var sub = require("can-key/sub/sub");
 *
 * sub("foo_{bar}", {bar: "baz"}); // -> "foo_baz"
 * ```
 *
 * If `null` or `undefined` values are found, `null` is returned:
 *
 * ```js
 * sub("foo_{bar}", {}); // -> null
 * ```
 *
 * If an object value is found, the templated part of the string is replace with `""`
 * and the object is added to an array that is returned.
 *
 * ```js
 * var data = {element: div, selector: "li" }
 * var res = sub("{element} {selector} click", data);
 * res //-> [" li click", div]
 * ```
 *
 * @param {String} str   a string with {curly brace} delimited property names
 * @param {Object} data  an object from which to read properties
 * @return {String|null|Array} the supplied string with delimited properties replaced with their values
 *                       if all properties exist on the object, null otherwise
 *
 * If `remove` is true, the properties found in delimiters in `str` are removed from `data`.
 *
 *
 */
module.exports = function sub(str, data, remove) {
	var obs = [];
	str = str || '';
	obs.push(str.replace(utils.strReplacer, function (whole, inside) {
		// Convert inside to type.
		var ob = get(data, inside);

		if(remove === true) {
			deleteKey(data, inside);
		}

		if (ob === undefined || ob === null) {
			obs = null;
			return '';
		}
		// If a container, push into objs (which will return objects found).
		if (!canReflect.isPrimitive(ob) && obs) {
			obs.push(ob);
			return '';
		}
		return '' + ob;
	}));
	return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
};


/***/ }),

/***/ "./node_modules/can-key/transform/transform.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-key/transform/transform.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var walk = __webpack_require__(/*! ../walk/walk */ "./node_modules/can-key/walk/walk.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function deleteKeys(parentsAndKeys) {
    for(var i  = parentsAndKeys.length - 1; i >= 0; i--) {
        var parentAndKey = parentsAndKeys[i];
        delete  parentAndKey.parent[parentAndKey.key];
        if(canReflect.size(parentAndKey.parent) !== 0) {
            return;
        }
    }
}
/**
 * @module {function} can-key/transform/transform
 * @parent can-key
 */
module.exports = function(obj, transformer){
    var copy = canReflect.serialize( obj);

    canReflect.eachKey(transformer, function(writeKey, readKey){
        var readParts = utils.parts(readKey),
            writeParts = utils.parts(writeKey);

        // find the value
        var parentsAndKeys = [];
        walk(copy, readParts, function(info){
            parentsAndKeys.push(info);
        });
        var last = parentsAndKeys[parentsAndKeys.length - 1];
        var value = last.value;
        if(value !== undefined) {
            // write the value
            walk(copy, writeParts, function(info, i){
                if(i < writeParts.length - 1 && !info.value) {
                    return info.parent[info.key] = {};
                } else if(i === writeParts.length - 1){
                    info.parent[info.key] = value;
                }
            });
            // delete the keys on old
            deleteKeys(parentsAndKeys);

        }
    });
    return copy;
};


/***/ }),

/***/ "./node_modules/can-key/utils.js":
/*!***************************************!*\
  !*** ./node_modules/can-key/utils.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";

var utils = {
    isContainer: function (current) {
        var type = typeof current;
        return current && (type === "object" || type === "function");
    },
    strReplacer: /\{([^\}]+)\}/g,

    parts: function(name) {
        if(Array.isArray(name)) {
            return name;
        } else {
            return typeof name !== 'undefined' ? (name + '').replace(/\[/g,'.')
            		.replace(/]/g,'').split('.') : [];
        }
    }
};

module.exports= utils;


/***/ }),

/***/ "./node_modules/can-key/walk/walk.js":
/*!*******************************************!*\
  !*** ./node_modules/can-key/walk/walk.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/can-key/utils.js");


/**
 * @module {function} can-key/walk/walk
 * @parent can-key
 *
 * @signature `walk(obj, name, keyCallback(info) )`
 *
 * ```js
 * import walk from "can-key/walk/walk";
 *
 * var user = {name: {first: "Justin"}}
 * walk(user, "name.first", (keyInfo)=> {
 *   // Called 2 times.
 *   // first call:
 *   keyInfo //-> {parent: user, key: "name", value: user.name}
 *   // second call:
 *   keyInfo //-> {parent: user.name, key: "first", value: user.name.first}
 * })
 * ```
 *
 * @param {Object} obj An object to read key values from.
 * @param {String} name A string key name like "foo.bar".
 * @param {function(Object)} keyCallback(info) For every key value,
 * `keyCallback` will be called back with an `info` object containing:
 *
 * - `info.parent` - The object the property value is being read from.
 * - `info.key` - The key being read.
 * - `info.value` - The key's value.
 *
 * If `keyCallback` returns a value other than `undefined`, the next key value
 * will be read from that value.
 */
module.exports = function walk(obj, name, keyCallback){

    // The parts of the name we are looking up
    // `['App','Models','Recipe']`
    var parts = utils.parts(name);

    var length = parts.length,
        current, i, container, part;


    if (!length) {
        return;
    }

    current = obj;

    // Walk current to the 2nd to last object or until there
    // is not a container.
    for (i = 0; i < length; i++) {
        container = current;
        part = parts[i];
        current = utils.isContainer(container) && canReflect.getKeyValue( container, part );

        var result = keyCallback({
            parent:container,
            key: part,
            value: current
        }, i);
        if(result !== undefined) {
            current = result;
        }
    }
};


/***/ }),

/***/ "./node_modules/can-list/can-list.js":
/*!*******************************************!*\
  !*** ./node_modules/can-list/can-list.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint -W079 */
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var Map = __webpack_require__(/*! can-map */ "./node_modules/can-map/can-map.js");
var bubble = __webpack_require__(/*! can-map/bubble */ "./node_modules/can-map/bubble.js");
var mapHelpers = __webpack_require__(/*! can-map/map-helpers */ "./node_modules/can-map/map-helpers.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canEvent = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var CID = __webpack_require__(/*! can-cid */ "./node_modules/can-cid/can-cid.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var types = __webpack_require__(/*! can-types */ "./node_modules/can-types/can-types.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var CIDMap = __webpack_require__(/*! can-cid/map/map */ "./node_modules/can-cid/map/map.js");

// Helpers for `observable` lists.
var splice = [].splice,
	// test if splice works correctly
	spliceRemovesProps = (function () {
		// IE's splice doesn't remove properties
		var obj = {
			0: "a",
			length: 1
		};
		splice.call(obj, 0, 1);
		return !obj[0];
	})();

// Function that serializes the passed arg if
// type does not match MapType of `this` list
// then adds to args array
var serializeNonTypes = function(MapType, arg, args) {
	if(arg && arg.serialize && !(arg instanceof MapType)) {
		args.push(new MapType(arg.serialize()));
	} else {
		args.push(arg);
	}
};

var List = Map.extend(
	{
		Map: Map
	},
	{
		setup: function (instances, options) {
			this.length = 0;
			CID(this, ".map");
			this._setupComputedProperties();
			instances = instances === undefined ? [] : canReflect.toArray(instances);
			var teardownMapping;

			if (canReflect.isPromise(instances)) {
				this.replace(instances);
			} else {
				teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
				this.push.apply(this, instances);
			}

			if (teardownMapping) {
				teardownMapping();
			}

			// this change needs to be ignored
			assign(this, options);
		},
		_triggerChange: function (attr, how, newVal, oldVal) {
			queues.batch.start();
			// `batchTrigger` direct add and remove events...
			var index = +attr, patches;
			// Make sure this is not nested and not an expando

			if (!~(""+attr).indexOf('.') && !isNaN(index)) {
				if(bubble.isBubbling(this, "change")) {
					canEvent.dispatch.call(this, {
						type: "change",
						target: this
					}, [attr, how, newVal, oldVal]);
				}
				if (how === 'add') {
					patches = [{insert: newVal, index: index, deleteCount: 0, type: "splice"}];
					canEvent.dispatch.call(this, {type: how, patches: patches}, [newVal, index]);
					canEvent.dispatch.call(this, 'length', [this.length]);
					canEvent.dispatch.call(this, 'can.patches', [patches]);
				} else if (how === 'remove') {
					patches = [{index: index, deleteCount: oldVal.length, type: "splice"}];
					canEvent.dispatch.call(this, {type: how, patches: patches}, [oldVal, index]);
					canEvent.dispatch.call(this, 'length', [this.length]);
					canEvent.dispatch.call(this, 'can.patches', [patches]);
				} else {
					canEvent.dispatch.call(this, how, [newVal, index]);
				}

			} else {
				Map.prototype._triggerChange.apply(this, arguments);
			}
			queues.batch.stop();
		},
		__get: function(prop){
			prop = isNaN(+prop) || (prop % 1) ? prop : +prop;
			if(typeof prop === "number") {
				ObservationRecorder.add(this, "can.patches");
				return this.___get( "" + prop );
			} else {
				return Map.prototype.__get.call(this, prop);
			}
		},
		___get: function (attr) {
			if (attr) {
				var computedAttr = this._computedAttrs[attr];
				if(computedAttr && computedAttr.compute) {
					return canReflect.getValue(computedAttr.compute);
				}

				if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === "function" ) {
					return canReflect.getValue(this[attr]);
				} else {
					return this[attr];
				}
			} else {
				return this;
			}
		},
		__set: function (prop, value, current) {
			// We want change events to notify using integers if we're
			// setting an integer index. Note that <float> % 1 !== 0;
			prop = isNaN(+prop) || (prop % 1) ? prop : +prop;

			// Check to see if we're doing a .attr() on an out of
			// bounds index property.
			if (typeof prop === "number") {
				if( prop > this.length - 1 ) {
					var newArr = new Array((prop + 1) - this.length);
					newArr[newArr.length-1] = value;
					this.push.apply(this, newArr);
					return newArr;
				} else {
					this.splice(prop,1,value);
					return this;
				}
			}

			return Map.prototype.__set.call(this, ""+prop, value, current);
		},
		___set: function (attr, val) {
			this[attr] = val;
			if (+attr >= this.length) {
				this.length = (+attr + 1);
			}
		},
		__remove: function(prop, current) {
			// if removing an expando property
			if(isNaN(+prop)) {
				delete this[prop];
				this._triggerChange(prop, "remove", undefined, current);
			} else {
				this.splice(prop, 1);
			}
		},
		_each: function (callback) {
			var data = this.___get();
			for (var i = 0; i < data.length; i++) {
				callback(data[i], i);
			}
		},
		// Returns the serialized form of this list.
		/**
		 * @hide
		 * Returns the serialized form of this list.
		 */
		serialize: function () {
			return canReflect.serialize(this, CIDMap);
		},
		splice: function (index, howMany) {
			var args = canReflect.toArray(arguments),
				added =[],
				i, len, listIndex,
				allSame = args.length > 2;

			index = index || 0;

			// converting the arguments to the right type
			for (i = 0, len = args.length-2; i < len; i++) {
				listIndex = i + 2;
				args[listIndex] = this.__type(args[listIndex], listIndex);
				added.push(args[listIndex]);

				// Now lets check if anything will change
				if(this[i+index] !== args[listIndex]) {
					allSame = false;
				}
			}

			// if nothing has changed, then return
			if(allSame && this.length <= added.length) {
				return added;
			}

			// default howMany if not provided
			if (howMany === undefined) {
				howMany = args[1] = this.length - index;
			}

			var removed = splice.apply(this, args);

			// delete properties for browsers who's splice sucks (old ie)
			if (!spliceRemovesProps) {
				for (i = this.length; i < removed.length + this.length; i++) {
					delete this[i];
				}
			}

			queues.batch.start();
			if (howMany > 0) {
				// tears down bubbling
				bubble.removeMany(this, removed);
				this._triggerChange("" + index, "remove", undefined, removed);
			}
			if (args.length > 2) {
				// make added items bubble to this list
				bubble.addMany(this, added);
				this._triggerChange("" + index, "add", added, removed);
			}
			queues.batch.stop();
			return removed;
		}
	}),

	// Converts to an `array` of arguments.
	getArgs = function (args) {
		return args[0] && Array.isArray(args[0]) ?
			args[0] :
			canReflect.toArray(args);
	};
// Create `push`, `pop`, `shift`, and `unshift`
canReflect.eachKey({
		/**
		 * @function can-list.prototype.push push
		 * @parent can-list.prototype
		 * @description Add elements to the end of a list.
		 * @signature `list.push(...elements)`
		 *
		 * `push` adds elements onto the end of a List.
		 *
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `push` adds elements onto the end of a List here is an example:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.push('Bob', 'Eve');
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * If you have an array you want to concatenate to the end
		 * of the List, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new List(['Alice']);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * ## Events
		 *
		 * `push` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `push` has a counterpart in [can-list.prototype.pop], or you may be
		 * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].
		 */
		push: "length",
		/**
		 * @function can-list.prototype.unshift unshift
		 * @parent can-list.prototype
		 * @description Add elements to the beginning of a List.
		 * @signature `list.unshift(...elements)`
		 *
		 * `unshift` adds elements onto the beginning of a List.
		 *
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `unshift` adds elements to the front of the list in bulk in the order specified:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * If you have an array you want to concatenate to the beginning
		 * of the List, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new List(['Alice']);
		 *
		 * list.unshift.apply(list, names);
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * ## Events
		 *
		 * `unshift` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `unshift` has a counterpart in [can-list.prototype.shift], or you may be
		 * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].
		 */
		unshift: 0
	},
	// Adds a method
	// `name` - The method name.
	// `where` - Where items in the `array` should be added.
	function (where, name) {
		var orig = [][name];
		List.prototype[name] = function () {
			// Get the items being added.
			var args = [],
				// Where we are going to add items.
				len = where ? this.length : 0,
				i = arguments.length,
				res, val;

			// Go through and convert anything to a `map` that needs to be converted.
			while (i--) {
				val = arguments[i];
				args[i] = bubble.set(this, i, this.__type(val, i) );
			}

			// Call the original method.
			res = orig.apply(this, args);

			if (!this.comparator || args.length) {

				this._triggerChange("" + len, "add", args, undefined);
			}

			return res;
		};
	});

canReflect.eachKey({
		/**
		 * @function can-list.prototype.pop pop
		 * @parent can-list.prototype
		 * @description Remove an element from the end of a List.
		 * @signature `list.pop()`
		 *
		 * `pop` removes an element from the end of a List.
		 *
		 * @return {*} the element just popped off the List, or `undefined` if the List was empty
		 *
		 * @body
		 * `pop` is the opposite action from [can-list.prototype.push]:
		 *
		 * ```
		 * var list = new List(['Alice', 'Bob', 'Eve']);
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 *
		 * list.pop(); // 'Eve'
		 * list.pop(); // 'Bob'
		 * list.pop(); // 'Alice'
		 * list.pop(); // undefined
		 * ```
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `pop` has its counterpart in [can-list.prototype.push], or you may be
		 * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].
		 */
		pop: "length",
		/**
		 * @function can-list.prototype.shift shift
		 * @parent can-list.prototype
		 * @description Remove en element from the front of a list.
		 * @signature `list.shift()`
		 *
		 * `shift` removes an element from the beginning of a List.
		 *
		 * @return {*} the element just shifted off the List, or `undefined` if the List is empty
		 *
		 * @body
		 * `shift` is the opposite action from `[can-list.prototype.unshift]`:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 *
		 * list.shift(); // 'Bob'
		 * list.shift(); // 'Eve'
		 * list.shift(); // 'Alice'
		 * list.shift(); // undefined
		 * ```
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `shift` has a counterpart in [can-list.prototype.unshift], or you may be
		 * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].
		 */
		shift: 0
	},
	// Creates a `remove` type method
	function (where, name) {
		List.prototype[name] = function () {
			if (!this.length) {
				// For shift and pop, we just return undefined without
				// triggering events.
				return undefined;
			}

			var args = getArgs(arguments),
				len = where && this.length ? this.length - 1 : 0;

			var res = [][name].apply(this, args);

			// Create a change where the args are
			// `len` - Where these items were removed.
			// `remove` - Items removed.
			// `undefined` - The new values (there are none).
			// `res` - The old, removed values (should these be unbound).
			this._triggerChange("" + len, "remove", undefined, [res]);

			if (res && res.removeEventListener) {
				bubble.remove(this, res);
			}

			return res;
		};
	});

assign(List.prototype, {
	/**
	 * @function can-list.prototype.indexOf indexOf
	 * @parent can-list.prototype
	 * @description Look for an item in a List.
	 * @signature `list.indexOf(item)`
	 *
	 * `indexOf` finds the position of a given item in the List.
	 *
	 * @param {*} item the item to find
	 *
	 * @return {Number} the position of the item in the List, or -1 if the item is not found.
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * list.indexOf('Alice');   // 0
	 * list.indexOf('Charlie'); // -1
	 * ```
	 *
	 * It is trivial to make a `contains`-type function using `indexOf`:
	 *
	 * ```
	 * function(list, item) {
	 *     return list.indexOf(item) >= 0;
	 * }
	 * ```
	 */
	indexOf: function (item, fromIndex) {
		ObservationRecorder.add(this, "length");
		for(var i = fromIndex || 0, len = this.length; i < len; i++) {
			if(this.attr(i) === item) {
				return i;
			}
		}
		return -1;
	},

	/**
	 * @function can-list.prototype.join join
	 * @parent can-list.prototype
	 * @description Join a List's elements into a string.
	 * @signature `list.join(separator)`
	 *
	 * `join` turns a List into a string by inserting _separator_ between the string representations
	 * of all the elements of the List.
	 *
	 * @param {String} separator the string to seperate elements with
	 *
	 * @return {String} the joined string
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * list.join(', '); // 'Alice, Bob, Eve'
	 *
	 * var beatles = new List(['John', 'Paul', 'Ringo', 'George']);
	 * beatles.join('&'); // 'John&Paul&Ringo&George'
	 * ```
	 */
	join: function () {
		ObservationRecorder.add(this, "length");
		return [].join.apply(this, arguments);
	},

	/**
	 * @function can-list.prototype.reverse reverse
	 * @parent can-list.prototype
	 * @description Reverse the order of a List.
	 * @signature `list.reverse()`
	 *
	 * `reverse` reverses the elements of the List in place.
	 *
	 * @return {can-list} the List, for chaining
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * var reversedList = list.reverse();
	 *
	 * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];
	 * list === reversedList; // true
	 * ```
	 */
	reverse: function() {
		var list = [].reverse.call(canReflect.toArray(this));
		return this.replace(list);
	},

	/**
	 * @function can-list.prototype.slice slice
	 * @parent can-list.prototype
	 * @description Make a copy of a part of a List.
	 * @signature `list.slice([start[, end]])`
	 *
	 * `slice` creates a copy of a portion of the List.
	 *
	 * @param {Number} [start=0] the index to start copying from
	 *
	 * @param {Number} [end] the first index not to include in the copy
	 * If _end_ is not supplied, `slice` will copy until the end of the list.
	 *
	 * @return {can-list} a new `can-list` with the extracted elements
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);
	 * var newList = list.slice(1, 4);
	 * newList.attr(); // ['Bob', 'Charlie', 'Daniel']
	 * ```
	 *
	 * `slice` is the simplest way to copy a List:
	 *
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * var copy = list.slice();
	 *
	 * copy.attr();   // ['Alice', 'Bob', 'Eve']
	 * list === copy; // false
	 * ```
	 */
	slice: function () {
		// tells computes to listen on length for changes.
		ObservationRecorder.add(this, "length");
		var temp = Array.prototype.slice.apply(this, arguments);
		return new this.constructor(temp);
	},

	/**
	 * @function can-list.prototype.concat concat
	 * @parent can-list.prototype
	 * @description Merge many collections together into a List.
	 * @signature `list.concat(...args)`
	 * @param {Array|can-list|*} args Any number of arrays, Lists, or values to add in
	 * For each parameter given, if it is an Array or a List, each of its elements will be added to
	 * the end of the concatenated List. Otherwise, the parameter itself will be added.
	 *
	 * @body
	 * `concat` makes a new List with the elements of the List followed by the elements of the parameters.
	 *
	 * ```
	 * var list = new List();
	 * var newList = list.concat(
	 *     'Alice',
	 *     ['Bob', 'Charlie']),
	 *     new List(['Daniel', 'Eve']),
	 *     {f: 'Francis'}
	 * );
	 * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]
	 * ```
	 */
	concat: function() {
		var args = [],
			MapType = this.constructor.Map;
		// Go through each of the passed `arguments` and
		// see if it is list-like, an array, or something else
		canReflect.each(arguments, function(arg) {
			if((canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) || Array.isArray(arg)) {
				// If it is list-like we want convert to a JS array then
				// pass each item of the array to serializeNonTypes
				var arr = (canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) ? canReflect.toArray(arg) : arg;
				canReflect.each(arr, function(innerArg) {
					serializeNonTypes(MapType, innerArg, args);
				});
			}
			else {
				// If it is a Map, Object, or some primitive
				// just pass arg to serializeNonTypes
				serializeNonTypes(MapType, arg, args);
			}
		});

		// We will want to make `this` list into a JS array
		// as well (We know it should be list-like), then
		// concat with our passed in args, then pass it to
		// list constructor to make it back into a list
		return new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));
	},

	/**
	 * @function can-list.prototype.forEach forEach
	 * @parent can-list.prototype
	 * @description Call a function for each element of a List.
	 * @signature `list.forEach(callback[, thisArg])`
	 * @param {function(element, index, list)} callback a function to call with each element of the List
	 * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the
	 * current element of the list, and _list_ the List the elements are coming from. _callback_ is
	 * not invoked for List elements that were never initialized.
	 * @param {Object} [thisArg] the object to use as `this` inside the callback
	 *
	 * @body
	 * `forEach` calls a callback for each element in the List.
	 *
	 * ```
	 * var list = new List([1, 2, 3]);
	 * list.forEach(function(element, index, list) {
	 *     list.attr(index, element * element);
	 * });
	 * list.attr(); // [1, 4, 9]
	 * ```
	 */
	forEach: function (cb, thisarg) {
		var item;
		for (var i = 0, len = this.attr("length"); i < len; i++) {
			item = this.attr(i);
			if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
				break;
			}
		}
		return this;
	},

	/**
	 * @function can-list.prototype.replace replace
	 * @parent can-list.prototype
	 * @description Replace all the elements of a List.
	 * @signature `list.replace(collection)`
	 * @param {Array|can-list|can.Deferred} collection the collection of new elements to use
	 * If a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.
	 * The elements of the list are not actually removed until the Deferred resolves.
	 *
	 * @body
	 * `replace` replaces all the elements of this List with new ones.
	 *
	 * `replace` is especially useful when `can-list`s are live-bound into `[can-control]`s,
	 * and you intend to populate them with the results of a `[can-model]` call:
	 *
	 * ```
	 * can.Control({
	 *     init: function() {
	 *         this.list = new Todo.List();
	 *         // live-bind the list into the DOM
	 *         this.element.html(can.view('list.stache', this.list));
	 *         // when this AJAX call returns, the live-bound DOM will be updated
	 *         this.list.replace(Todo.findAll());
	 *     }
	 * });
	 * ```
	 *
	 * Learn more about [can.Model.List making Lists of models].
	 *
	 * ## Events
	 *
	 * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits
	 * an _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_
	 * event if needed. Corresponding _change_ and _length_ events will be fired as well.
	 *
	 * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:
	 * ```
	 * var attrList = new List(['Alexis', 'Bill']);
	 * attrList.bind('change', function(ev, index, how, newVals, oldVals) {
	 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
	 * });
	 *
	 * var replaceList = new List(['Alexis', 'Bill']);
	 * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {
	 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
	 * });
	 *
	 * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis
	 *                                               // 1, set, Ben, Bill
	 * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']
	 *                                               // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']
	 *
	 * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam
	 *                                               // 1, remove, undefined, Ben
	 * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']
	 *                                               // 0, add, Amber, ['Adam', 'Ben']
	 *
	 * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber
	 *                                               // 1, add, ['Bob', 'Eve'], undefined
	 * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber
	 *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber
	 * ```
	 */
	replace: function (newList) {
		if (canReflect.isPromise(newList)) {
			if(this._promise) {
				this._promise.__isCurrentPromise = false;
			}
			var promise = this._promise = newList;
			promise.__isCurrentPromise = true;
			var self = this;
			newList.then(function(newList){
				if(promise.__isCurrentPromise) {
					self.replace(newList);
				}
			});
		} else {
			newList = newList === undefined ? [] : canReflect.toArray(newList);
			this.splice.apply(this, [0, this.length].concat(newList));
		}

		return this;
	},
	filter: function (callback, thisArg) {
		var filteredList = new this.constructor(),
			self = this,
			filtered;
		this.forEach(function(item, index, list){
			filtered = callback.call( thisArg || self, item, index, self);
			if(filtered){
				filteredList.push(item);
			}
		});
		return filteredList;
	},
	map: function (callback, thisArg) {
		var filteredList = new List(),
			self = this;
		this.forEach(function(item, index, list){
			var mapped = callback.call( thisArg || self, item, index, self);
			filteredList.push(mapped);

		});
		return filteredList;
	},
	sort: function(compareFunction) {
		var sorting = Array.prototype.slice.call(this);
		Array.prototype.sort.call(sorting, compareFunction);
		this.splice.apply(this, [0,sorting.length].concat(sorting) );
		return this;
	}
});

// change some map stuff to include list stuff
var oldType = Map.prototype.__type;
Map.prototype.__type = function(value, prop){

	if (typeof value === "object" && Array.isArray(value) ) {

		var cached = mapHelpers.getMapFromObject(value);
		if(cached) {
			return cached;
		}

		return new List(value);

	}
	return oldType.apply(this, arguments);
};

var oldSetup = Map.setup;
Map.setup = function(){
	oldSetup.apply(this, arguments);
	if (!(this.prototype instanceof List)) {
		this.List = Map.List.extend({
			Map: this
		}, {});
	}
};

if(!types.DefaultList) {
	types.DefaultList = List;
}

// Setup other symbols

canReflect.assignSymbols(List.prototype,{
	// -type-

	"can.isMoreListLikeThanMapLike":  true,
	"can.isListLike":  true,

	// -get/set-
	"can.getKeyValue": List.prototype._get,
	"can.setKeyValue": List.prototype._set,
	"can.deleteKeyValue": List.prototype._remove,

	// -shape
	"can.getOwnEnumerableKeys": function(){
		return Object.keys(this._data || {}).concat(this.map(function(val, index) {
			return index;
		}));
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		queues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.assignDeepList(this, source);
		queues.batch.stop();
	},
	"can.updateDeep": function(source){
		queues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.updateDeepList(this, source);
		queues.batch.stop();
	},

	"can.unwrap": mapHelpers.reflectUnwrap,
	"can.serialize": mapHelpers.reflectSerialize,

	// observable
	"can.onKeysAdded": function(handler) {
		this[canSymbol.for("can.onKeyValue")]("add", handler);
	},
	"can.onKeysRemoved":  function(handler) {
		this[canSymbol.for("can.onKeyValue")]("remove", handler);
	},
	"can.splice": function(index, deleteCount, insert){
		this.splice.apply(this, [index, deleteCount].concat(insert));
	},
	"can.onPatches": function(handler,queue){
		this[canSymbol.for("can.onKeyValue")]("can.patches", handler,queue);
	},
	"can.offPatches": function(handler,queue) {
		this[canSymbol.for("can.offKeyValue")]("can.patches", handler,queue);
	}
});




// @@can.keyHasDependencies and @@can.getKeyDependencies same as can-map

Map.List = List;
module.exports = namespace.List = List;


/***/ }),

/***/ "./node_modules/can-local-store/can-local-store.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-local-store/can-local-store.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var makeSimpleStore = __webpack_require__(/*! can-memory-store/make-simple-store */ "./node_modules/can-memory-store/make-simple-store.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

module.exports = namespace.localStore = function localStore(baseConnection){
    baseConnection.constructor = localStore;
    var behavior = Object.create(makeSimpleStore(baseConnection));

    canReflect.assignMap(behavior, {
		clear: function(){
			localStorage.removeItem(this.name+"/queries");
			localStorage.removeItem(this.name+"/records");
            this._recordsMap = null;
            return Promise.resolve();
		},
		updateQueryDataSync: function(queries){
			localStorage.setItem(this.name+"/queries", JSON.stringify(queries) );
		},
		getQueryDataSync: function(){
			return JSON.parse( localStorage.getItem(this.name+"/queries") ) || [];
		},

		getRecord: function(id){
			// a little side-effectual mischeif for performance
			if(!this._recordsMap) {
				this.getAllRecords();
			}

			return this._recordsMap[id];
		},
		getAllRecords: function(){
			// this._records is a in memory representation so things can be fast
            // Must turn on `cacheLocalStorageReads` for this to work.
			if(!this.cacheLocalStorageReads || !this._recordsMap) {
				var recordsMap = JSON.parse( localStorage.getItem(this.name+"/records") ) || {};
				this._recordsMap = recordsMap;
			}

			var records = [];
			for(var id in this._recordsMap) {
				records.push(this._recordsMap[id]);
			}
			return records;
		},
		destroyRecords: function(records) {
            if(!this._recordsMap) {
				this.getAllRecords();
			}
			canReflect.eachIndex(records, function(record){
				var id = canReflect.getIdentity(record, this.queryLogic.schema);
				delete this._recordsMap[id];
			}, this);
			localStorage.setItem(this.name+"/records", JSON.stringify(this._recordsMap) );
		},
		updateRecordsSync: function(records){
            if(!this._recordsMap) {
				this.getAllRecords();
			}
			records.forEach(function(record){
				var id = canReflect.getIdentity(record, this.queryLogic.schema);
				this._recordsMap[id] = record;
			},this);
			localStorage.setItem(this.name+"/records", JSON.stringify(this._recordsMap) );
		}
		// ## Identifiers

		/**
		 * @property {String} can-connect/data/localstorage-cache/localstorage-cache.name name
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.identifiers
		 *
		 * Specify a name to use when saving data in localstorage.
		 *
		 * @option {String} This name is used to find and save data in
		 * localstorage. Instances are saved in `{name}/instance/{id}`
		 * and sets are saved in `{name}/set/{set}`.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```
		 * var cacheConnection = connect(["data-localstorage-cache"],{
		 *   name: "todos"
		 * });
		 * ```
		 */


		// ## External interface

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.clear clear
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Resets the memory cache so it contains nothing.
		 *
		 * @signature `connection.clear()`
		 *
		 */



		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getSets getSets
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Returns the sets contained within the cache.
		 *
		 * @signature `connection.getSets(set)`
		 *
		 *   Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].
		 *
		 *   @return {Promise<Array<Set>>} A promise that resolves to the list of sets.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```
		 * connection.getSets() //-> Promise( [{type: "completed"},{user: 5}] )
		 * ```
		 *
		 */

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getListData getListData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Gets a set of data from localstorage.
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Goes through each set add by [can-connect/data/memory-cache.updateListData]. If
		 *   `set` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `set`.
		 *
		 *   @param {can-query-logic/query} query An object that represents the data to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that resolves if `set` is a subset of
		 *   some data added by [can-connect/data/memory-cache.updateListData].  If it is not,
		 *   the promise is rejected.
		 */

		/**
		 * @function can-connect/data/localstorage-cache.getListDataSync getListDataSync
		 * @parent can-connect/data/localstorage-cache.data-methods
		 *
		 * Synchronously gets a set of data from localstorage.
		 *
		 * @signature `connection.getListDataSync(set)`
		 * @hide
		 */

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getData getData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Get an instance's data from localstorage.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Looks in localstorage for the requested instance.
		 *
		 *   @param {Object} params An object that should have the [conenction.id] of the element
		 *   being retrieved.
		 *
		 *   @return {Promise} A promise that resolves to the item if the memory cache has this item.
		 *   If localstorage does not have this item, it rejects the promise.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.updateListData updateListData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Saves a set of data in the cache.
		 *
		 * @signature `connection.updateListData(listData, set)`
		 *
		 *   Tries to merge this set of data with any other saved sets of data. If
		 *   unable to merge this data, saves the set by itself.
		 *
		 *   @param {can-connect.listData} listData
		 *   @param {can-query-logic/query} query
		 *   @return {Promise} Promise resolves if and when the data has been successfully saved.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.createData createData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance is created and should be added to cache.
		 *
		 * @signature `connection.createData(props)`
		 *
		 *   Adds `props` to the stored list of instances. Then, goes
		 *   through every set and adds props the sets it belongs to.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.updateData updateData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance is updated.
		 *
		 * @signature `connection.updateData(props)`
		 *
		 *   Overwrites the stored instance with the new props. Then, goes
		 *   through every set and adds or removes the instance if it belongs or not.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.destroyData destroyData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance should be removed from the cache.
		 *
		 * @signature `connection.destroyData(props)`
		 *
		 *   Goes through each set of data and removes any data that matches
		 *   `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.
		 */

	});

	return behavior;

};


/***/ }),

/***/ "./node_modules/can-log/can-log.js":
/*!*****************************************!*\
  !*** ./node_modules/can-log/can-log.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.warnTimeout = 5000;
exports.logLevel = 0;

/**
 * @module {{}} can-log log
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @hide
 *
 * Utilities for logging to the console.
 */

/**
 * @function can-log.warn warn
 * @parent can-log
 * @description
 *
 * Adds a warning message to the console.
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.warn("something evil");
 * ```
 *
 * @signature `canLog.warn(msg)`
 * @param {String} msg the message to be logged.
 */
exports.warn = function() {
	var ll = this.logLevel;
	if (ll < 2) {
		if (typeof console !== "undefined" && console.warn) {
			this._logger("warn", Array.prototype.slice.call(arguments));
		} else if (typeof console !== "undefined" && console.log) {
			this._logger("log", Array.prototype.slice.call(arguments));
		}
	}
};

/**
 * @function can-log.log log
 * @parent can-log
 * @description
 * Adds a message to the console.
 * @hide
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.log("hi");
 * ```
 *
 * @signature `canLog.log(msg)`
 * @param {String} msg the message
 */
exports.log = function() {
	var ll = this.logLevel;
	if (ll < 1) {
		if (typeof console !== "undefined" && console.log) {
			this._logger("log", Array.prototype.slice.call(arguments));
		}
	}
};

/**
 * @function can-log.error error
 * @parent can-log
 * @description
 * Adds an error message to the console.
 * @hide
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.error(new Error("Oh no!"));
 * ```
 *
 * @signature `canLog.error(err)`
 * @param {String|Error} err The error to be logged.
 */
exports.error = function() {
	var ll = this.logLevel;
	if (ll < 1) {
		if (typeof console !== "undefined" && console.error) {
			this._logger("error", Array.prototype.slice.call(arguments));
		}
	}
};

exports._logger = function (type, arr) {
	try {
		console[type].apply(console, arr);
	} catch(e) {
		console[type](arr);
	}
};


/***/ }),

/***/ "./node_modules/can-log/dev/dev.js":
/*!*****************************************!*\
  !*** ./node_modules/can-log/dev/dev.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canLog = __webpack_require__(/*! ../can-log */ "./node_modules/can-log/can-log.js");

/**
 * @module {{}} can-log/dev dev
 * @parent can-log
 * @hide
 * 
 * Utilities for logging development-mode messages. Use this module for
 * anything that should be shown to the user during development but isn't
 * needed in production. In production these functions become noops.
 */
module.exports = {
	warnTimeout: 5000,
	logLevel: 0,
	/**
	 * @function can-log/dev.stringify stringify
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * JSON stringifies a value, but unlike JSON, will output properties with
	 * a value of `undefined` (e.g. `{ "prop": undefined }`, not `{}`).
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * var query = { where: undefined };
	 * 
	 * dev.warn('No records found: ' + dev.stringify(query));
	 * ```
	 *
	 * @signature `dev.stringify(value)`
	 * @param {Any} value A value to stringify.
	 * @return {String} A stringified representation of the passed in value.
	 */
	stringify: function(value) {
		var flagUndefined = function flagUndefined(key, value) {
			return value === undefined ?
				 "/* void(undefined) */" : value;
		};
		
		return JSON.stringify(value, flagUndefined, "  ").replace(
			/"\/\* void\(undefined\) \*\/"/g, "undefined");
	},
	/**
	 * @function can-log/dev.warn warn
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds a warning message to the console.
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * 
	 * dev.warn("something evil");
	 * ```
	 *
	 * @signature `dev.warn(msg)`
	 * @param {String} msg The warning message.
	 */
	warn: function() {
		//!steal-remove-start
		if (true) {
			canLog.warn.apply(this, arguments);
		}
		//!steal-remove-end
	},
	/**
	 * @function can-log/dev.log log
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds a message to the console.
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * 
	 * dev.log("hi");
	 * ```
	 *
	 * @signature `dev.log(msg)`
	 * @param {String} msg The message.
	 */
	log: function() {
		//!steal-remove-start
		if (true) {
			canLog.log.apply(this, arguments);
		}
		//!steal-remove-end
	},
	/**
	 * @function can-log/dev.error error
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds an error message to the console.
	 *
	 * ```
	 * var dev = require("can-log/dev");
	 * 
	 * dev.error(new Error("Oh no!"));
	 * ```
	 *
	 * @signature `dev.error(err)`
	 * @param {String|Error} err The error to be logged.
	 */
	error: function() {
		//!steal-remove-start
		if (true) {
			canLog.error.apply(this, arguments);
		}
		//!steal-remove-end
	},
	_logger: canLog._logger
};


/***/ }),

/***/ "./node_modules/can-make-map/can-make-map.js":
/*!***************************************************!*\
  !*** ./node_modules/can-make-map/can-make-map.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

/**
 * @module {function} can-make-map can-make-map
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @package ./package.json
 * @description Convert a comma-separated string into a plain JavaScript object.
 * @signature `makeMap( string )`
 * @param  {String} string A comma separated list of values
 * @return {Object} A JavaScript object with the same keys as the passed-in comma-separated values
 *
 * makeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object
 */
function makeMap(str) {
	var obj = {}, items = str.split(",");
	items.forEach(function(name){
		obj[name] = true;
	});
	return obj;
}

module.exports = makeMap;


/***/ }),

/***/ "./node_modules/can-make-rest/can-make-rest.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-make-rest/can-make-rest.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var methodMapping = {
	item: {
		'GET': 'getData',
		'PUT': 'updateData',
		'DELETE': 'destroyData',
	},
	list: {
		'GET': 'getListData',
		'POST': 'createData'
	}
};


function inferIdProp (url) {
	var wrappedInBraces = /\{(.*)\}/;
	var matches = url.match(wrappedInBraces);
	var isUniqueMatch = matches && matches.length === 2;
	if (isUniqueMatch) {
		return matches[1];
	}
}

function getItemAndListUrls (url, idProp) {
	idProp = idProp || inferIdProp(url) || "id";
	var itemRegex = new RegExp('\\/\\{' + idProp+"\\}.*" );
	var rootIsItemUrl = itemRegex.test(url);
	var listUrl = rootIsItemUrl ? url.replace(itemRegex, "") : url;
	var itemUrl = rootIsItemUrl ? url : (url.trim() + "/{" + idProp + "}");
	return {item: itemUrl, list: listUrl};
}



module.exports = function(url, idProp){
	var data= {};
	canReflect.eachKey( getItemAndListUrls(url, idProp), function(url, type){
		canReflect.eachKey(methodMapping[type], function(interfaceMethod, method){
			data[interfaceMethod] = {
				method: method,
				url: url
			};
		});
	});
	return data;
};


/***/ }),

/***/ "./node_modules/can-map-compat/can-map-compat.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-map-compat/can-map-compat.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

var canKey = __webpack_require__(/*! can-key */ "./node_modules/can-key/can-key.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");

function makeCompat(Type, enableWarning) {
	var proto = Type.prototype;
	var isDefined = typeof proto.attr === "function";

	if(isDefined) {
		return Type;
	}

	// Whether we should be warning when this is used.
	var warnOnUse = enableWarning === true;

	proto.attr = function(key, value) {
		if(warnOnUse) {
			canLog.warn("can-map-compat is intended for migrating away from can-map. Remove all uses of .attr() to remove this warning.");
		}

		var type = typeof key;
		var argsLen = arguments.length;

		// map.attr()
		if(argsLen === 0) {
			return canReflect.unwrap(this);
		}
		// map.attr({ key: val })
		else if(type !== "string" && type !== "number") {
			// Remove others
			if(value === true) {
				canReflect.updateDeep(this, key);
			} else {
				canReflect.assignDeep(this, key);
			}
			return this;
		}
		// map.attr(key)
		else if(argsLen === 1) {
			return canKey.get(this, key);
		}
		// map.attr(key, val)
		else {
			canKey.set(this, key, value);
			return this;
		}
	};

	proto.removeAttr = function(key) {
		var val = canReflect.getKeyValue(this, key);
		canReflect.deleteKeyValue(this, key);
		return val;
	};

	return Type;
}

exports = module.exports = function(Type) {
	return makeCompat(Type, true);
};

exports.makeCompat = makeCompat;


/***/ }),

/***/ "./node_modules/can-map-define/can-map-define.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-map-define/can-map-define.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var extend = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var mapEventsMixin = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var mapHelpers = __webpack_require__(/*! can-map/map-helpers */ "./node_modules/can-map/map-helpers.js");
var CanMap = __webpack_require__(/*! can-map */ "./node_modules/can-map/can-map.js");
var compute = __webpack_require__(/*! can-compute */ "./node_modules/can-compute/can-compute.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var Resolver = __webpack_require__(/*! can-simple-observable/resolver/resolver */ "./node_modules/can-simple-observable/resolver/resolver.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

__webpack_require__(/*! can-list */ "./node_modules/can-list/can-list.js");

var define = {}; // jshint ignore:line
var inSetupSymbol = canSymbol.for("can.initializing");

var hasDefaultForSerialize = function(defaultDefinition) {
	return (
		typeof defaultDefinition === "object" &&
		"serialize" in defaultDefinition
	);
};

var getDefaultForSerialize = function(defaultDefinition) {
	var shouldSerialize = true;

	if (hasDefaultForSerialize(defaultDefinition)) {
		shouldSerialize = !!defaultDefinition.serialize;
	}

	return shouldSerialize;
};

var keysForDefinition = function(definitions) {
	var keys = [];
	var defaultDefinition = definitions && definitions["*"];
	for (var prop in definitions) {
		var definition = definitions[prop];
		var shouldSerialize = getDefaultForSerialize(defaultDefinition);
		// allow property definitions to override default behavior
		if (typeof definition === "object" && "serialize" in definition) {
			shouldSerialize = !!definition.serialize;
		} else if (
			typeof definition === "object" &&
			!hasDefaultForSerialize(defaultDefinition)
		) {
			shouldSerialize = !definition.get;
		}
		if (shouldSerialize) {
			keys.push(prop);
		}
	}
	return keys;
};

var getPropDefineBehavior = function(behavior, attr, define) {
	var prop, defaultProp;

	if (define) {
		prop = define[attr];
		defaultProp = define['*'];

		if (prop && prop[behavior] !== undefined) {
			return prop[behavior];
		} else if (defaultProp && defaultProp[behavior] !== undefined) {
			return defaultProp[behavior];
		}
	}
};

// This is called when the Map is defined
mapHelpers.define = function(Map, baseDefine) {
	var definitions = Map.prototype.define;

	if (baseDefine) {
		var defines = {};
		mapHelpers.twoLevelDeepExtend(defines, baseDefine);
		mapHelpers.twoLevelDeepExtend(defines, definitions);
		extend(definitions, defines);
	}
	//!steal-remove-start
	if (true) {
		if (Map.define) {
			dev.warn("The define property should be on the map's prototype properties, " +
				"not the static properties.");
		}
	}
	//!steal-remove-end
	Map.defaultGenerators = {};
	for (var prop in definitions) {
		var type = definitions[prop].type;
		if (typeof type === "string") {
			if (typeof define.types[type] === "object") {
				delete definitions[prop].type;
				extend(definitions[prop], define.types[type]);
			}
		}
		if ("value" in definitions[prop]) {
			if (typeof definitions[prop].value === "function") {
				Map.defaultGenerators[prop] = definitions[prop].value;
			} else {
				Map.defaults[prop] = definitions[prop].value;
			}
		}
		if (typeof definitions[prop].Value === "function") {
			(function(Constructor) {
				Map.defaultGenerators[prop] = function() {
					return new Constructor();
				};
			})(definitions[prop].Value);
		}
	}
};

var oldSetupDefaults = CanMap.prototype._setupDefaults;
CanMap.prototype._setupDefaults = function(obj) {
	var defaults = extend({},oldSetupDefaults.call(this)),
		propsCommittedToAttr = {},
		Map = this.constructor,
		originalGet = this._get;

	// Overwrite this._get with a version that commits defaults to
	// this.attr() as needed. Because calling this.attr() for each
	// individual default would be expensive.
	this._get = function(originalProp) {
		// If a this.attr() was called using dot syntax (e.g number.0),
		// disregard everything after the "." until we call the
		// original this._get().
		var prop = (originalProp.indexOf('.') !== -1 ?
			originalProp.substr(0, originalProp.indexOf('.')) :
			originalProp);

		// If this property has a default and we haven't yet committed it to
		// this.attr()
		if ((prop in defaults) && !(prop in propsCommittedToAttr)) {

			// Commit the property's default so that it can be read in
			// other defaultGenerators.
			this.attr(prop, defaults[prop]);

			// Make not so that we don't commit this property again.
			propsCommittedToAttr[prop] = true;
		}

		return originalGet.apply(this, arguments);
	};

	for (var prop in Map.defaultGenerators) {
		// Only call the prop's value method if the property wasn't provided
		// during instantiation.
		if (!obj || !(prop in obj)) {
			defaults[prop] = Map.defaultGenerators[prop].call(this);
		}
	}

	// delete this._get which will default to the one on the prototype.
	delete this._get;

	return defaults;
};


var proto = CanMap.prototype,
	oldSet = proto.__set;
proto.__set = function(prop, value, current, success, error) {
	//!steal-remove-start
	var asyncTimer;
	//!steal-remove-end

	var self = this;

	// check if there's a setter
	var errorCallback = function(errors) {
			//!steal-remove-start
			if (true) {
				clearTimeout(asyncTimer);
			}
			//!steal-remove-end

			var stub = error && error.call(self, errors);
			// if 'validations' is on the page it will trigger
			// the error itself and we dont want to trigger
			// the event twice. :)
			if (stub !== false) {
				mapEventsMixin.dispatch.call(self, 'error', [ prop, errors ], true);
			}
			return false;
		},
		setter = getPropDefineBehavior("set", prop, this.define),
		getter = getPropDefineBehavior("get", prop, this.define);


	// if we have a setter
	if (setter) {
		// call the setter, if returned value is undefined,
		// this means the setter is async so we
		// do not call update property and return right away
		queues.batch.start();
		var setterCalled = false,

			setValue = setter.call(this, value, function(value) {
				if (getter) {
					self[prop](value);
				} else {
					oldSet.call(self, prop, value, current, success, errorCallback);
				}

				setterCalled = true;
				//!steal-remove-start
				if (true) {
					clearTimeout(asyncTimer);
				}
				//!steal-remove-end
			}, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
		if (getter) {
			// if there's a getter we don't call old set
			// instead we call the getter's compute with the new value
			if (setValue !== undefined && !setterCalled && setter.length >= 1) {
				this._computedAttrs[prop].compute(setValue);
			}

			queues.batch.stop();
			return;
		}
		// if it took a setter and returned nothing, don't set the value
		else if (setValue === undefined && !setterCalled && setter.length > 1) {
			//!steal-remove-start
			if (true) {
				asyncTimer = setTimeout(function() {
					dev.warn('can/map/define: Setter "' + prop + '" did not return a value or call the setter callback.');
				}, dev.warnTimeout);
			}
			//!steal-remove-end
			queues.batch.stop();
			return;
		} else {
			if (!setterCalled) {
				oldSet.call(self, prop,
					// if no arguments, we are side-effects only
					setter.length === 0 && setValue === undefined ? value : setValue,
					current,
					success,
					errorCallback);
			}
			queues.batch.stop();
			return this;
		}

	} else {
		oldSet.call(self, prop, value, current, success, errorCallback);
	}

	return this;
};

define.types = {
	'date': function(str) {
		var type = typeof str;
		if (type === 'string') {
			str = Date.parse(str);
			return isNaN(str) ? null : new Date(str);
		} else if (type === 'number') {
			return new Date(str);
		} else {
			return str;
		}
	},
	'number': function(val) {
		if (val == null) {
			return val;
		}
		return +(val);
	},
	'boolean': function(val) {
		if(val == null) {
			return val;
		}
		if (val === 'false' || val === '0' || !val) {
			return false;
		}
		return true;
	},
	'htmlbool': function(val) {
		return typeof val === "string" || !!val;
	},
	'*': function(val) {
		return val;
	},
	'string': function(val) {
		if (val == null) {
			return val;
		}
		return '' + val;
	},
	'compute': {
		set: function(newValue, setVal, setErr, oldValue) {
			if (newValue && newValue.isComputed) {
				return newValue;
			}
			if (oldValue && oldValue.isComputed) {
				oldValue(newValue);
				return oldValue;
			}
			return newValue;
		},
		get: function(value) {
			return value && value.isComputed ? value() : value;
		}
	}
};

// the old type sets up bubbling
var oldType = proto.__type;
proto.__type = function(value, prop) {
	var type = getPropDefineBehavior("type", prop, this.define),
		Type = getPropDefineBehavior("Type", prop, this.define),
		newValue = value;

	if (typeof type === "string") {
		type = define.types[type];
	}

	if (type || Type) {
		// If there's a type, convert it.
		if (type) {
			newValue = type.call(this, newValue, prop);
		}
		// If there's a Type and newValue is non-null create a new instance of it
		if (Type && newValue != null && !(newValue instanceof Type)) {
			newValue = new Type(newValue);
		}
		// If the newValue is a Map, we need to hook it up
		return newValue;

	}
	// If we pass in a object with define
	else if (canReflect.isPlainObject(newValue) && newValue.define) {
		newValue = CanMap.extend(newValue);
		newValue = new newValue();
	}
	return oldType.call(this, newValue, prop);
};

var oldRemove = proto.__remove;
proto.__remove = function(prop, current) {
	var remove = getPropDefineBehavior("remove", prop, this.define),
		res;
	if (remove) {
		queues.batch.start();
		res = remove.call(this, current);

		if (res === false) {
			queues.batch.stop();
			return;
		} else {

			res = oldRemove.call(this, prop, current);
			queues.batch.stop();
			return res;
		}
	}
	return oldRemove.call(this, prop, current);
};

var oldSetupComputes = proto._setupComputedProperties;
proto._setupComputedProperties = function() {
	oldSetupComputes.apply(this, arguments);
	for (var attr in this.define) {
		var def = this.define[attr],
			get = def.get;
		if (get) {
			mapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));
		}
		if (def.resolver) {
			mapHelpers.addComputedAttr(this, attr, new Resolver(def.resolver, this, def.value ) );
		}
	}
};
// Overwrite the invidual property serializer b/c we will overwrite it.
var oldSingleSerialize = proto.___serialize;
// If the map has a define serializer for the given attr, run it.
var serializeProp = function(map, attr, val) {
	var serializer = attr === "*" ? false : getPropDefineBehavior("serialize", attr, map.define);
	if (serializer === undefined) {
		return oldSingleSerialize.call(map, attr, val);
	} else if (serializer !== false) {
		return typeof serializer === "function" ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
	}
};

proto.___serialize = function(name, val) {
	return serializeProp(this, name, val);
};

// Overwrite serialize to add in any missing define serialized properties.
var oldSerialize = proto.serialize;
proto.serialize = function(property) {
	var serialized = oldSerialize.apply(this, arguments);
	if (property) {
		return serialized;
	}
	// add in properties not already serialized

	var serializer,
		val;
	// Go through each property.
	for (var attr in this.define) {
		// if it's not already defined
		if (!(attr in serialized)) {
			// check there is a serializer so we aren't doing extra work on serializer:false
			// also check for a wildcard serializer
			serializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);
			if (serializer) {
				val = serializeProp(this, attr, this.attr(attr));
				if (val !== undefined) {
					serialized[attr] = val;
				}
			}
		}
	}
	return serialized;
};

canReflect.assignSymbols(proto, {
	"can.hasKey": function(key) {
		var defined = this.define && key in this.define;
		var dataExists = this._data && key in this._data;
		var propExists = key in this;
		return defined || dataExists || propExists;
	},

	"can.getOwnEnumerableKeys": function() {
		if (!this[inSetupSymbol]) {
			ObservationRecorder.add(this, '__keys');
		}

		var definedKeys = keysForDefinition(this.define);
		var dataKeys = Object.keys(this._data);
		var shouldSerialize = getDefaultForSerialize(this.define && this.define["*"]);

		var enumerable = this.constructor.enumerable;
		dataKeys = dataKeys.filter(function(key) {
			return enumerable ?
				shouldSerialize && enumerable[key] !== false :
				shouldSerialize;
		});

		var i, newKey;
		for(i=0; i<dataKeys.length; i++) {
			newKey = dataKeys[i];
			// add keys that are in _data, but are not in `define`
			// keys in `define` are in `definedKeys` based on their `serialize` prop
			if (definedKeys.indexOf(newKey) < 0 && (!this.define || !this.define[newKey])) {
				definedKeys.push(dataKeys[i]);
			}
		}

		return definedKeys;
	}
});

module.exports = define;


/***/ }),

/***/ "./node_modules/can-map/bubble.js":
/*!****************************************!*\
  !*** ./node_modules/can-map/bubble.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # can/map/map_helpers
// Helpers that enable bubbling of an event on a child object to a
// parent event on a parent object. Bubbling works by listening on the child object
// and forwarding events to the parent object.
//
// Bubbling is complicated because bubbling setup can happen before or after
// items are added to the parent object.
//
// This means that:
// - When bubbling is first initialied, by binding to an event that bubbles,
//   all child objects need to be setup to bubble. This is managed by [bubble.bind](#bubble-bind).
// - When bubbling is stopped, by removing all listeners to events that bubble,
//   all child objects need to have bubbling torn down. This is managed by [bubble.unbind](#bubble-unbind).
// - While bubbling is running, as child items are added,
//   the child elements need to be setup to bubble.  This is managed by [bubble.add](#bubble-add) and [bubble.addMany](#bubble-addmany).
// - While bubbling is running, as child items are removed,
//   the child elements need to stop bubbling. This is managed by
//   [bubble.remove](#bubble-remove) and [bubble.removeMany](#bubble-removeMany).
// - While bubbling is running, as child item replaces another child, the old child needs bubbling removed
//   and the new child needs bubbling setup. This is managed by [bubble.set](bubble-set).
//
// [bubble.events](bubble-events) controls which events setup bubbling.

var canEvent = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// Helper function to check the Map type
var isMap = function(map) {
	return (
		map &&
		!canReflect.isFunctionLike(map) && 
		canReflect.isMapLike(map) &&
		!Array.isArray(map) &&
		canReflect.isObservableLike(map)
	);
};


var bubble = {
		// ## bubble.bind
		// Called when an event is bound to an object. This
		// should setup bubbling if this is the first time
		// an event that bubbles is bound.
		bind: function(parent, eventName) {
			if (!parent.__inSetup ) {

				var bubbleEvents = bubble.events(parent, eventName),
					len = bubbleEvents.length,
					bubbleEvent;

				if(!parent._bubbleBindings) {
					parent._bubbleBindings = {};
				}

				for (var i = 0; i < len; i++) {
					bubbleEvent = bubbleEvents[i];

					// If there isn't a bubbling setup for this binding,
					// bubble all the children; otherwise, increment the
					// number of bubble bindings.
					if (!parent._bubbleBindings[bubbleEvent]) {
						parent._bubbleBindings[bubbleEvent] = 1;
						bubble.childrenOf(parent, bubbleEvent);
					} else {
						parent._bubbleBindings[bubbleEvent]++;
					}
				}
			}
		},

		// ## bubble.unbind
		// Called when an event is unbound from an object.  This should
		// teardown bubbling if there are no more bubbling event handlers.
		unbind: function(parent, eventName) {
			var bubbleEvents = bubble.events(parent, eventName),
				len = bubbleEvents.length,
				bubbleEvent;

			for (var i = 0; i < len; i++) {
				bubbleEvent = bubbleEvents[i];

				if (parent._bubbleBindings ) {
					parent._bubbleBindings[bubbleEvent]--;
				}

				if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent] ) {
					delete parent._bubbleBindings[bubbleEvent];
					bubble.teardownChildrenFrom(parent, bubbleEvent);
					if(canReflect.size(parent._bubbleBindings) === 0) {
						delete parent._bubbleBindings;
					}
				}
			}
		},

		// ## bubble.add
		// Called when a new `child` value has been added to `parent`.
		// If the `parent` is bubbling and the child is observable,
		// setup bubbling on the child to the parent. This calls
		// `teardownFromParent` to ensure we aren't bubbling the same
		// child more than once.
		add: function(parent, child, prop){
			if(canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
				for(var eventName in parent._bubbleBindings) {
					if( parent._bubbleBindings[eventName] ) {
						bubble.teardownFromParent(parent, child, eventName);
						bubble.toParent(child, parent, prop, eventName);
					}
				}
			}
		},
		// ## bubble.addMany
		// Called when many `children` are added to `parent`.
		addMany: function(parent, children){
			for (var i = 0, len = children.length; i < len; i++) {
				bubble.add(parent, children[i], i);
			}
		},
		// ## bubble.remove
		// Called when a `child` has been removed from `parent`.
		// Removes all bubbling events from `child` to `parent`.
		remove: function(parent, child){
			if(canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
				for(var eventName in parent._bubbleBindings) {
					if( parent._bubbleBindings[eventName] ) {
						bubble.teardownFromParent(parent, child, eventName);
					}
				}
			}
		},
		// ## bubble.removeMany
		// Called when many `children` are removed from `parent`.
		removeMany: function(parent, children){
			for(var i = 0, len = children.length; i < len; i++) {
				bubble.remove(parent, children[i]);
			}
		},
		// ## bubble.set
		// Called when a new child `value` replaces `current` value.
		set: function(parent, prop, value, current){

			if(canReflect.isObservableLike(value) && canReflect.isMapLike(value)) {
				bubble.add(parent, value, prop);
			}
			// bubble.add will remove, so only remove if we are replacing another object
			if(canReflect.isObservableLike(current) && canReflect.isMapLike(current)) {
				bubble.remove(parent, current);
			}
			return value;
		},

		// ## bubble.events
		// For an event binding on an object, returns the events that should be bubbled.
		// For example, `"change" -> ["change"]`.
		events: function(map, boundEventName) {
			if (isMap(map)) {
				return map.constructor._bubbleRule(boundEventName, map);
			}
		},


		// ## bubble.toParent
		// Forwards an event on `child` to `parent`.  `child` is
		// the `prop` property of `parent`.
		toParent: function(child, parent, prop, eventName) {
			canEvent.listenTo.call(parent, child, eventName, function ( /* ev, attr */ ) {

				var args = canReflect.toArray(arguments),
					ev = args.shift();

				// Updates the nested property name that will be dispatched.
				// If the parent is a list, the index of the child needs to
				// be calculated every time.
				args[0] =
					((canReflect.isObservableLike(parent) && canReflect.isListLike(parent)) ?
						parent.indexOf(child) :
						prop ) + (args[0] ? "."+args[0] : "");

				// Track all objects that we have bubbled this event to.
				// If we have already bubbled to this object, do not dispatch another
				// event on it. This prevents cycles.
				ev.triggeredNS = ev.triggeredNS || {};
				if (ev.triggeredNS[parent._cid]) {
					return;
				}
				ev.triggeredNS[parent._cid] = true;

				// Send bubbled event to parent.
				canEvent.dispatch.call(parent, ev, args);

				// Trigger named event.
				if(eventName === "change") {
					canEvent.dispatch.call(parent, args[0], [args[2], args[3]]);
				}

			});
		},

		// ## bubble.childrenOf
		// Bubbles all the observable children of `parent`.
		childrenOf: function (parent, eventName) {

			parent._each(function (child, prop) {
				if (isMap(child)) {
					bubble.toParent(child, parent, prop, eventName);
				}
			});
		},

		// ## bubble.teardownFromParent
		// Undo the bubbling from `child` to `parent`.
		teardownFromParent: function (parent, child, eventName ) {
			if(child && child.unbind ) {
				canEvent.stopListening.call(parent, child, eventName);
			}
		},

		// ## bubble.teardownChildrenFrom
		// Undo the bubbling of every child of `parent`
		teardownChildrenFrom: function(parent, eventName){
			parent._each(function (child) {

				bubble.teardownFromParent(parent, child, eventName);
			});
		},

		// ## bubble.isBubbling
		// Returns true or false if `parent` is bubbling `eventName`.
		isBubbling: function(parent, eventName){
			return parent._bubbleBindings && parent._bubbleBindings[eventName];
		}
	};

module.exports = bubble;


/***/ }),

/***/ "./node_modules/can-map/can-map.js":
/*!*****************************************!*\
  !*** ./node_modules/can-map/can-map.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint -W079 */
// # can/map/map.js (aka can.Map)
// `can.Map` provides the observable pattern for JavaScript objects. It
// provides an `attr` and `removeAttr` method that can be used to get/set and
// remove properties and nested properties by calling a "pipeline" of protected
// methods:
//
// - `_get`, `_set`, `_remove` - handle nested properties.
// - `__get`, `__set`, `__remove` - handle triggering events.
// - `___get`, `___set`, `___remove` - read / write / remove raw values.
//
// When `attr` gets or sets multiple properties it calls `_getAttrs` or `_setAttrs`.
//
// [bubble.js](bubble.html) - Handles bubbling of child events to parent events.
// [map_helpers.js](map_helpers.html) - Assorted helpers for handling cycles during serialization or
// instantition of objects.
var bubble = __webpack_require__(/*! ./bubble */ "./node_modules/can-map/bubble.js");
var mapHelpers = __webpack_require__(/*! ./map-helpers */ "./node_modules/can-map/map-helpers.js");
var canEvent = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");
var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var ObserveReader = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var canCompute = __webpack_require__(/*! can-compute */ "./node_modules/can-compute/can-compute.js");
var singleReference = __webpack_require__(/*! can-single-reference */ "./node_modules/can-single-reference/can-single-reference.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var CID = __webpack_require__(/*! can-cid */ "./node_modules/can-cid/can-cid.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var types = __webpack_require__(/*! can-types */ "./node_modules/can-types/can-types.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var CIDSet = __webpack_require__(/*! can-cid/set/set */ "./node_modules/can-cid/set/set.js");
var CIDMap = __webpack_require__(/*! can-cid/map/map */ "./node_modules/can-cid/map/map.js");
var canQueues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

// properties that can't be observed on ... no matter what
var unobservable = {
	"constructor": true
};

var hasOwnProperty = ({}).hasOwnProperty;
var inSetupSymbol = canSymbol.for("can.initializing");

// Extend [can.Construct](../construct/construct.html) to make inheriting a `can.Map` easier.
var Map = Construct.extend(
	/**
	 * @static
	 */
	// ## Static Properties and Methods
	{
		// ### setup
		// Called when a Map constructor is defined/extended to
		// perform any initialization behavior for the new constructor
		// function.
		setup: function (baseMap) {

			Construct.setup.apply(this, arguments);

			// A cached list of computed properties on the prototype.
			this._computedPropertyNames = [];

			// Do not run if we are defining can.Map.
			if (Map) {
				addTypeEvents(this);
				this[canSymbol.for("can.defineInstanceKey")] = function(prop, definition){
					if(definition.value !== undefined) {
						this.defaults[prop] = definition.value;
					}
					if(definition.enumerable === false ) {
						this.enumerable[prop] = false;
					}
				};
				// Provide warnings if can.Map is used incorrectly.
				//!steal-remove-start
				if (true) {
					if(this.prototype.define && !mapHelpers.define) {
						dev.warn("can/map/define is not included, yet there is a define property "+
						"used. You may want to add this plugin.");
					}
					if(this.define && !mapHelpers.define) {
						dev.warn("The define property should be on the map's prototype properties, "+
						"not the static properties. Also, can/map/define is not included.");
					}
				}
				//!steal-remove-end

				// Create a placeholder for default values.
				if (!this.defaults) {
					this.defaults = {};
				}
				if(!this.enumerable) {
					this.enumerable = {};
				}


				// Go through everything on the prototype.  If it's a primitive,
				// treat it as a default value.  If it's a compute, identify it so
				// it can be setup as a computed property.
				for (var prop in this.prototype) {
					if (
						prop !== "define" &&
						prop !== "constructor" &&
						(typeof this.prototype[prop] !== "function" ||
							this.prototype[prop].prototype instanceof Construct)
					) {
						this.defaults[prop] = this.prototype[prop];
					} else if (canReflect.isObservableLike(this.prototype[prop])) {
						this._computedPropertyNames.push(prop);
					}
				}

				// If define is a function, call it with this can.Map
				if(mapHelpers.define) {
					mapHelpers.define(this, baseMap.prototype.define);
				}
			}

			// If we inherit from can.Map, but not can.List, create a can.List that
			// creates instances of this Map type.
            // This is something List should weave in.
			/*if (can.List && !(this.prototype instanceof can.List)) {
				this.List = Map.List.extend({
					Map: this
				}, {});
			}*/

		},
		// ### shortName
		// Tells `can.Construct` to show instance as `Map` in the debugger.
		shortName: "Map",

		// ### _bubbleRule
		// Returns which events to setup bubbling on for a given bound event.
		// By default, only bubbles "change" events if someone listens to a
		// "change" event or a nested event like "foo.bar".
		_bubbleRule: function(eventName) {
			return (eventName === "change" || eventName.indexOf(".") >= 0 ) ?
				["change"] :
				[];
		},

		// ### bind,  unbind
		// Listen to events on the Map constructor.  These
		// are here mostly for can.Model.
		addEventListener: canEvent.addEventListener,
		removeEventListener: canEvent.removeEventListener,

		// ### keys
		// An observable way to get the keys from a map.
		keys: function (map) {
			return canReflect.getOwnEnumerableKeys(map);
		}
	},
	/**
	 * @prototype
	 */
	// ## Prototype Properties and Methods
	{
		// ### setup
		// Initializes the map instance's behavior.
		setup: function (obj) {

			if(canReflect.isObservableLike(obj) && typeof obj.serialize === "function"){
				obj = obj.serialize();
			}

			// Where we keep the values of the compute.
			this._data = Object.create(null);

			// The namespace this `object` uses to listen to events.
			CID(this, ".map");

			this._setupComputedProperties();
			var teardownMapping = obj && mapHelpers.addToMap(obj, this);

			var defaultValues = this._setupDefaults(obj);
			var data = assign(canReflect.assignDeep({}, defaultValues), obj);

			this.attr(data);

			if (teardownMapping) {
				teardownMapping();
			}
		},

		// ### _setupComputes
		// Sets up computed properties on a Map.
		// Stores information for each computed property on
		//  `this._computedAttrs` that looks like:
		//
		// ```
		// {
		//   // the number of bindings on this property
		//   count: 1,
		//   // a handler that forwards events on the compute
		//   // to the map instance
		//   handler: handler,
		//   compute: compute  // the compute
		// }
		// ```
		_setupComputedProperties: function () {
			this._computedAttrs = Object.create(null);

			var computes = this.constructor._computedPropertyNames;

			for (var i = 0, len = computes.length; i < len; i++) {
				var attrName = computes[i];
				mapHelpers.addComputedAttr(this, attrName, this[attrName]);
			}
		},

		// ### _setupDefaults
		// Returns the default values for the instance.
		_setupDefaults: function(){
			return this.constructor.defaults || {};
		},

		// ### attr
		// The primary get/set interface for can.Map.
		// Calls `_get`, `_set` or `_attrs` depending on
		// how it is called.
		attr: function (attr, val) {
			var type = typeof attr;
			if(attr === undefined) {
				return this._getAttrs();
			} else if (type !== "string" && type !== "number") {
				// Get or set multiple attributes.
				return this._setAttrs(attr, val);
			}
			else if (arguments.length === 1) {
				// Get a single attribute.
				return this._get(attr);
			} else {
				// Set an attribute.
				this._set(attr+"", val);
				return this;
			}
		},

		// ### _get
		// Handles reading nested properties like "foo.bar" by
		// getting the value of "foo" and recursively
		// calling `_get` for the value of "bar".
		// To read the actual values, `_get` calls
		// `___get`.
		_get: function (attr) {
			attr = attr + "";
			var dotIndex = attr.indexOf('.');

			if( dotIndex >= 0 ) {

				// Attempt to get the value anyway in case
				// somone wrote `new can.Map({"foo.bar": 1})`.
				var value = this.___get(attr);
				if (value !== undefined) {
					ObservationRecorder.add(this, attr);
					return value;
				}

				var first = attr.substr(0, dotIndex),
					second = attr.substr(dotIndex+1);

				var current = this.__get( first );

				return current && canReflect.getKeyValue(current, second);
			} else {
				return this.__get( attr );
			}
		},

		// ### __get
		// Signals `can.compute` that an observable
		// property is being read.
		__get: function(attr){
			if(!unobservable[attr] && !this._computedAttrs[attr]) {
				ObservationRecorder.add(this, attr);
			}
			return this.___get( attr );
		},

		// ### ___get
		// When called with an argument, returns the value of this property. If that
		// property is represented by a computed attribute, return the value of that compute.
		// If no argument is provided, return the raw data.
		___get: function (attr) {
			if (attr !== undefined) {
				var computedAttr = this._computedAttrs[attr];
				if (computedAttr) {
					// return computedAttr.compute();
					return canReflect.getValue(computedAttr.compute);
				} else {
					return hasOwnProperty.call(this._data, attr) ? this._data[attr] : undefined;
				}
			} else {
				return this._data;
			}
		},

		// ### _set
		// Handles setting nested properties by finding the
		// nested observable and recursively calling `_set` on it. Eventually,
		// it calls `__set` with the `__type` converted value to set
		// and the current value.  The current value is passed for two reasons:
		//  - so `__set` can trigger an event if the value has changed.
		//  - for advanced setting behavior that define.set can do.
		//
		// If the map is initializing, the current value does not need to be
		// read because no change events are dispatched anyway.
		_set: function (attr, value, keepKey) {
			attr = attr + "";

			var dotIndex = attr.indexOf('.'),
				current;

			//!steal-remove-start
			if(true) {
				var lastItem, lastFn;
				// If there are observations currently recording, this isn't a good time to
				//   mutate values: it's likely a cycle, and even if it doesn't cycle infinitely,
				//   it will likely cause unnecessary recomputation of derived values.  Warn the user.
				if(ObservationRecorder.isRecording() && canQueues.stack().length && !this[inSetupSymbol]) {
					lastItem = canQueues.stack()[canQueues.stack().length - 1];
					lastFn = lastItem.context instanceof Observation ? lastItem.context.func : lastItem.fn;
					var mutationWarning = "can-map: The " + attr + " property on " +
						canReflect.getName(this) +
						" is being set in " +
						(canReflect.getName(lastFn) || canReflect.getName(lastItem.fn)) +
						". This can cause infinite loops and performance issues. " +
						"Use getters and listeners to derive properties instead. https://canjs.com/doc/guides/logic.html#Derivedproperties";

					dev.warn(mutationWarning);
					canQueues.logStack();
				}

			}
			//!steal-remove-end

			if(dotIndex >= 0 && !keepKey){
				var first = attr.substr(0, dotIndex),
					second = attr.substr(dotIndex+1);

				current =  this[inSetupSymbol] ? undefined : this.___get( first );

				if( canReflect.isMapLike(current) ) {
					canReflect.setKeyValue(current, second, value);
				} else {
					current = this[inSetupSymbol] ? undefined : this.___get( attr );

					// //Convert if there is a converter.  Remove in 3.0.
					if (this.__convert) {
						value = this.__convert(attr, value);
					}

					this.__set(attr, this.__type(value, attr), current);
				}

			} else {
				current = this[inSetupSymbol] ? undefined : this.___get( attr );

				// //Convert if there is a converter.  Remove in 3.0.
				if (this.__convert) {
					value = this.__convert(attr, value);
				}

				this.__set(attr, this.__type(value, attr), current);
			}
		},

		// ## __type
		// Converts set values to another type.  By default,
		// this converts Objects to can.Maps and Arrays to
		// can.Lists.
		// This also makes it so if a plain JavaScript object
		// has already been converted to a list or map, that same
		// list or map instance is used.
		__type: function(value, prop){

			if (typeof value === "object" &&
				!canReflect.isObservableLike( value ) &&
				mapHelpers.canMakeObserve(value) &&
				!canReflect.isListLike(value)
			) {

				var cached = mapHelpers.getMapFromObject(value);
				if(cached) {
					return cached;
				}
				var MapConstructor = this.constructor.Map || Map;
				return new MapConstructor(value);

			}
			return value;
		},

		// ## __set
		// Handles firing events if the value has changed and
		// works with the `bubble` helpers to setup bubbling.
		// Calls `___set` to do the actual setting.
		__set: function (prop, value, current) {

			if ( value !== current || !Object.prototype.hasOwnProperty.call( this._data, prop ) ) {
				var computedAttr = this._computedAttrs[prop];

				// Dispatch an "add" event if adding a new property.
				var changeType = computedAttr || current !== undefined ||
					hasOwnProperty.call(this.___get(), prop) ? "set" : "add";

				// Set the value on `_data` and set up bubbling.
				this.___set(prop, typeof value === "object" ? bubble.set(this, prop, value, current) : value );

				// Computed properties change events are already forwarded except if
				// no one is listening to them.
				if(!computedAttr || !computedAttr.count) {
					this._triggerChange(prop, changeType, value, current);
				}


				// Stop bubbling old nested maps.
				if (typeof current === "object") {
					bubble.teardownFromParent(this, current);
				}
			}
		},

		// ### ___set
		// Directly saves the set value as a property on `_data`
		// or sets the computed attribute.
		___set: function (prop, val) {
			var computedAttr = this._computedAttrs[prop];
			if ( computedAttr ) {
				canReflect.setValue(computedAttr.compute, val);
			} else {
				this._data[prop] = val;
			}

			// Adds the property directly to the map instance. But first,
			// checks that it's not overwriting a method. This should be removed
			// in 3.0.
			if ( typeof this.constructor.prototype[prop] !== 'function' && !computedAttr ) {
				this[prop] = val;
			}
		},

		removeAttr: function (attr) {
			return this._remove(attr);
		},

		// ### _remove
		// Handles removing nested observes.
		_remove: function(attr){
			// If this is List.
			var parts = mapHelpers.attrParts(attr),
			// The actual property to remove.
				prop = parts.shift(),
			// The current value.
				current = this.___get(prop);

			// If we have more parts, call `removeAttr` on that part.
			if (parts.length && current) {
				return canReflect.deleteKeyValue(current, parts.join("."));
			} else {

				// If attr does not have a `.`
				if (typeof attr === 'string' && !!~attr.indexOf('.')) {
					prop = attr;
				}

				this.__remove(prop, current);
				return current;
			}
		},

		// ### __remove
		// Handles triggering an event if a property could be removed.
		__remove: function(prop, current){
			if (prop in this._data) {
				this.___remove(prop);
				// Let others now this property has been removed.
				this._triggerChange(prop, "remove", undefined, current);
			}
		},

		// ### ___remove
		// Deletes a property from `_data` and the map instance.
		___remove: function(prop){
			delete this._data[prop];
			if (!(prop in this.constructor.prototype)) {
				delete this[prop];
			}
		},

		// ### ___serialize
		// Serializes a property.  Uses map helpers to
		// recursively serialize nested observables.
		___serialize: function(name, val){
			if(this._legacyAttrBehavior) {
				return mapHelpers.getValue(this, name, val, "serialize");
			} else {
				return canReflect.serialize(val, CIDMap);
			}
		},

		// ### _getAttrs
		// Returns the values of all attributes as a plain JavaScript object.
		_getAttrs: function(){
			if(this._legacyAttrBehavior) {
				return mapHelpers.serialize(this, 'attr', {});
			} else {
				return canReflect.unwrap(this, CIDMap);
			}

		},
		// ### _setAttrs
		// Sets multiple properties on this object at once.
		// First, goes through all current properties and either merges
		// or removes old properties.
		// Then it goes through the remaining ones to be added and sets those properties.
		_setAttrs: function (props, remove) {
			if(this._legacyAttrBehavior) {
				return this.__setAttrs(props, remove);
			}
			if(remove === true || remove === "true") {
				this[canSymbol.for("can.updateDeep")](props);
			} else {
				this[canSymbol.for("can.assignDeep")](props);
			}
			return this;
		},
		__setAttrs: function (props, remove) {
			props = assign({}, props);
			var prop,
				self = this,
				newVal;

			// Batch all of the change events until we are done.
			canQueues.batch.start();
			// Merge current properties with the new ones.
			this._each(function (curVal, prop) {
				// You can not have a _cid property; abort.
				if (prop === "_cid") {
					return;
				}
				newVal = props[prop];

				// If we are merging, remove the property if it has no value.
				if (newVal === undefined) {
					if (remove) {
						self.removeAttr(prop);
					}
					return;
				}

				// Run converter if there is one. Remove in 3.0.
				if (self.__convert) {
					newVal = self.__convert( prop, newVal );
				}

				if ( canReflect.isObservableLike(curVal) && canReflect.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal) ) {
					if(remove === true) {
						canReflect.updateDeep(curVal, newVal);
					} else {
						canReflect.assignDeep(curVal, newVal);
					}
					// Otherwise just set.
				} else if (curVal !== newVal) {
					self.__set(prop, self.__type(newVal, prop), curVal);
				}

				delete props[prop];
			});
			// Add remaining props.
			for (prop in props) {
				// Ignore _cid.
				if (prop !== "_cid") {
					newVal = props[prop];
					this._set(prop, newVal, true);
				}

			}
			canQueues.batch.stop();
			return this;
		},

		serialize: function () {
			return canReflect.serialize(this, CIDMap);
		},


		// ### _triggerChange
		// A helper function used to trigger events on this map.
		// If the map is bubbling, this will fire a change event.
		// Otherwise, it only fires a "named" event. Triggers a
		// "__keys" event if a property has been added or removed.
		_triggerChange: function (attr, how, newVal, oldVal, batchNum) {
			canQueues.batch.start();
			if(bubble.isBubbling(this, "change")) {
				canEvent.dispatch.call(this, {
					type: "change",
					target: this,
					batchNum: batchNum
				}, [attr, how, newVal, oldVal]);

			}

			canEvent.dispatch.call(this, {
				type: attr,
				target: this,
				batchNum: batchNum,
				patches: [{type: "set", key: attr, value: newVal}]
			}, [newVal, oldVal]);

			if(how === "remove" || how === "add") {
				canEvent.dispatch.call(this, {
					type: "__keys",
					target: this,
					batchNum: batchNum
				});
			}

			canQueues.batch.stop();
		},



		// ### compute
		// Creates a compute that represents a value on this map. If the property is a function
		// on the prototype, a "function" compute wil be created.
		// Otherwise, a compute will be created that reads the observable attributes
		compute: function (prop) {
			if (typeof this.constructor.prototype[prop] === "function") {
				return canCompute(this[prop], this);
			} else {
				var reads = ObserveReader.reads(prop);
				var last = reads.length - 1;

				return canCompute(function (newVal) {
					if (arguments.length) {
						ObserveReader.write(this, reads[last].key, newVal, {});
					} else {
						return ObserveReader.get(this, prop);
					}
				}, this);
			}
		},

		// ### each
		// loops through all the key-value pairs on this map.
		forEach: function (callback, context) {
				var key, item;
			var keys = canReflect.getOwnEnumerableKeys(this);
			for(var i =0, len = keys.length; i < len; i++) {
			    key = keys[i];
			    item = this.attr(key);
			    if (callback.call(context || item, item, key, this) === false) {
			        break;
			    }
			}
			return this;
		},

		// ### _each
		// Iterator that does not trigger live binding.
		_each: function (callback) {
			var data = this.___get();
			for (var prop in data) {
				if (hasOwnProperty.call(data, prop)) {
					callback(data[prop], prop);
				}
			}
		},

		dispatch: canEvent.dispatch
	});

// makes it so things can read this.
canEvent(Map.prototype);

// ### bind
// Listens to an event on a map.
// If the event is a  computed property,
// listen to the compute and forward its events
// to this map.
Map.prototype.addEventListener = function (eventName, handler) {

	var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
	if (computedBinding && computedBinding.compute) {
		if (!computedBinding.count) {
			computedBinding.count = 1;
			canReflect.onValue(computedBinding.compute, computedBinding.handler, "notify");
		} else {
			computedBinding.count++;
		}

	}

	// Sets up bubbling if needed.
	bubble.bind(this, eventName);

	return canEvent.addEventListener.apply(this, arguments);
};

// ### unbind
// Stops listening to an event.
// If this is the last listener of a computed property,
// stop forwarding events of the computed property to this map.
Map.prototype.removeEventListener = function (eventName, handler) {
	var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
	if (computedBinding) {
		if (computedBinding.count === 1) {
			computedBinding.count = 0;
			canReflect.offValue(computedBinding.compute, computedBinding.handler, "notify");
		} else {
			computedBinding.count--;
		}

	}

	// Teardown bubbling if needed.
	bubble.unbind(this, eventName);
	return canEvent.removeEventListener.apply(this, arguments);

};

// ### etc
// Setup on/off aliases
Map.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;
Map.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;
Map.on = Map.bind = Map.addEventListener;
Map.off = Map.unbind = Map.removeEventListener;

// - type -

canReflect.assignSymbols(Map.prototype,{
	// -type-
	"can.isMapLike": true,
	"can.isListLike":  false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": Map.prototype._get,
	"can.setKeyValue": Map.prototype._set,
	"can.deleteKeyValue": Map.prototype._remove,

	// -shape
	"can.getOwnEnumerableKeys": function(){
		if (!this[inSetupSymbol]) {
			ObservationRecorder.add(this, '__keys');
		}
		var enumerable = this.constructor.enumerable;
		if(enumerable) {
			return Object.keys(this._data).filter(function(key){
				return enumerable[key] !== false;
			},this);
		} else {
			return Object.keys(this._data);
		}
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.assignDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
		canQueues.batch.stop();
	},
	"can.updateDeep": function(source){
		canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.updateDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
		canQueues.batch.stop();
	},
	"can.unwrap": mapHelpers.reflectUnwrap,
	"can.serialize": mapHelpers.reflectSerialize,

	// observable
	"can.onKeyValue": function(key, handler, queue){
		var translationHandler = function(ev, newValue, oldValue){
			handler.call(this, newValue, oldValue);
		};
		singleReference.set(handler, this, translationHandler, key);

		this.addEventListener(key, translationHandler, queue);
	},
	"can.offKeyValue": function(key, handler, queue){
		this.removeEventListener(key, singleReference.getAndDelete(handler, this, key), queue );
	},
	"can.keyHasDependencies": function(key) {
		return !!(this._computedAttrs && this._computedAttrs[key] &&
			this._computedAttrs[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {
			ret = {};
			ret.valueDependencies = new CIDSet();
			ret.valueDependencies.add(this._computedAttrs[key].compute);
		}
		return ret;
	}
});


if(!types.DefaultMap) {
	types.DefaultMap = Map;
}

module.exports = namespace.Map = Map;


/***/ }),

/***/ "./node_modules/can-map/map-helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/can-map/map-helpers.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

// # can/map/map_hepers
// Helper functions that are primarily used to serialize
// a map, or track the maps created from plain JavaScript objects.
// `can.Map` handles cycles in objects nicely!
var CID = __webpack_require__(/*! can-cid */ "./node_modules/can-cid/can-cid.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
// ## POJOs to Map instance helpers

// ### madeMap
// A temporary map of Maps that have been made from plain JS objects.
// `{POJO_CID: {obj: POJO, instance: MAP, added: Boolean}}`
var madeMap = null;

// ### teardownMap
// Clears out map of converted objects and removes temporary `cids`.
var teardownMap = function () {
	for (var cid in madeMap) {
		if (madeMap[cid].added) {
			delete madeMap[cid].obj._cid;
		}
	}
	madeMap = null;
};

var mapHelpers = {
	// ### mapHelpers.attrParts
	// Parses attribute name into its parts.
	attrParts: function (attr, keepKey) {
		//Keep key intact
		if (keepKey ) {
			return [attr];
		}
		// Split key on '.'
		return typeof attr === "object" ? attr : ("" + attr)
			.split(".");
	},

	// ### can.mapHelpers.canMakeObserve
	// Determines if an object can be made into an observable.
	canMakeObserve: function (obj) {
		return obj && !canReflect.isPromise(obj) && (Array.isArray(obj) || canReflect.isPlainObject(obj) );
	},
	reflectSerialize: function(unwrapped){
		this.forEach(function(val, name){
			if( this.___serialize ) {
				val = this.___serialize(name, val);
			} else {
				val = canReflect.serialize(val);
			}
			if(val !== undefined) {
				unwrapped[name] = val;
			}
		}, this);
		return unwrapped;
	},
	reflectUnwrap: function(unwrapped){
		this.forEach(function(value, key){
			if(value !== undefined) {
				unwrapped[key] = canReflect.unwrap(value);
			}
		});
		return unwrapped;
	},
	removeSpecialKeys: function(map) {
		if(map) {
			["_data", "constructor", "_cid", "__bindEvents"].forEach(function(key) {
				delete map[key];
			});
		}
		return map;
	},
	// ### mapHelpers.serialize
	// Serializes a Map or Map.List by recursively calling the `how`
	// method on any child objects. This is able to handle
	// cycles.
	// `map` - the map or list to serialize.
	// `how` - the method to call recursively.
	// `where` - the target Object or Array that becomes the serialized result.
	serialize: (function(){

		// A temporary mapping of map cids to the serialized result.
		var serializeMap = null;

		return function (map, how, where) {
			var cid = CID(map),
				firstSerialize = false;

			// If there isn't an existing serializeMap, this means
			// this is the initial non-recursive call to this function.
			// We mark this  as the first call, and then setup the serializeMap.
			// The serialize map is further devided into `how` because
			// `.serialize` might call `.attr`.
			if(!serializeMap) {
				firstSerialize = true;
				serializeMap = {
					attr: {},
					serialize: {}
				};
			}

			serializeMap[how][cid] = where;
			// Go through each property.
			map.forEach(function (val, name) {
				// If the value is an `object`, and has an `attr` or `serialize` function.
				var result,
					isObservable = canReflect.isObservableLike(val),
					serialized = isObservable && serializeMap[how][CID(val)];

				if( serialized ) {
					result = serialized;
				} else {
					// special attr or serializer
					if(map["___"+how]) {
						result =  map["___"+how](name, val);
					} else {
						result = mapHelpers.getValue(map, name, val, how);
					}
				}
				// this is probably removable
				if(result !== undefined){
					where[name] = result;
				}
			});

			if(firstSerialize) {
				serializeMap = null;
			}
			return where;
		};
	})(),

	// ## getValue
	// If `val` is an observable, calls `how` on it; otherwise
	// returns the value of `val`.
	getValue: function(map, name, val, how){
		if(how === "attr") {
			how = canSymbol.for("can.getValue");
		}
		if( canReflect.isObservableLike(val) && val[how] ) {
			return val[how]();
		} else {
			return val;
		}
	},

	// ## define
	// A hook to call whenever a Map is defined.
	// We need a better place for this.
	define: null,

	// ## addComputedAttr
	// Adds a compute so it will control the behavior of an
	// attribute.  Each computedAttrs object has:
	// - `compute` - the compute that will be read and updated.
	// - `count` - the number of bindings to this individual property.
	//   This is used to know when to bind `handler` to the compute.
	// - `handler` - a function that when bound to `compute` forwards all
	//   events to `map`.
	addComputedAttr: function(map, attrName, compute){
		map._computedAttrs[attrName] = {
			compute: compute,
			count: 0,
			handler: function (newVal, oldVal) {
				map._triggerChange(attrName, "set", newVal, oldVal);
			}
		};
	},

	// ### can.mapHelpers.addToMap
	// Tracks map instances created from JS objects.
	// This should be called whenever an instance is created for a particular object.
	// This may return a `teardown` function that should be called after all instances
	// might be created.
	//
	// While creating map instances from plain ole JS objects (POJOs), it's
	// possible that the same JS object exists as two different properties and
	// we want only one map instance created for one JS object.
	//
	// ```
	// var obj = {name: "I am everywhere"}
	// var map = new can.Map({obj1: obj, obj2: obj});
	// ok( map.attr("obj1") === map.attr("obj2") )
	// ```
	//
	// This works by temporarily adding a `cid` to any found POJO object
	// and storing it in a temporary Object that maps those `cid`s to
	// the POJO and the instance created for it.
	// The `teardown` function removes those temporary `cid`s and
	// clears the map for memory safety.
	addToMap: function addToMap(obj, instance) {
		var teardown;

		// Setup a fresh mapping if `madeMap` is missing.
		if (!madeMap) {
			teardown = teardownMap;
			madeMap = {};
		}

		// Record if Object has a `_cid` before adding one.
		var hasCid = obj._cid;
		var cid = CID(obj);

		// Only update if there already isn't one already.
		if (!madeMap[cid]) {

			madeMap[cid] = {
				obj: obj,
				instance: instance,
				added: !hasCid
			};
		}
		return teardown;
	},

	// ### getMapFromObject
	// Returns the map instance already created for this object `obj` or
	// `undefined` if nothing has been already created.
	getMapFromObject: function (obj) {
		return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
	},
	twoLevelDeepExtend: function (destination, source) {
		for (var prop in source) {
			destination[prop] = destination[prop] || {};
			assign(destination[prop], source[prop]);
		}
	}
};

module.exports = exports = mapHelpers;


/***/ }),

/***/ "./node_modules/can-memory-store/can-memory-store.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-memory-store/can-memory-store.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var makeSimpleStore = __webpack_require__(/*! ./make-simple-store */ "./node_modules/can-memory-store/make-simple-store.js");


module.exports = namespace.memoryStore = function memoryStore(baseConnection){
    baseConnection.constructor = memoryStore;
    var behavior = Object.create(makeSimpleStore(baseConnection));

    canReflect.assignMap(behavior, {
		clear: function(){
			this._instances = {};
			this._queryData = [];
		},
		_queryData: [],
		updateQueryDataSync: function(queries){
			this._queryData = queries;
		},
		getQueryDataSync: function(){
			return this._queryData;
		},

		_instances: {},
		getRecord: function(id){
			return this._instances[id];
		},
		getAllRecords: function(){
			var records = [];
			for(var id in this._instances) {
				records.push(this._instances[id]);
			}
			return records;
		},
		destroyRecords: function(records) {
			canReflect.eachIndex(records, function(record){
				var id = canReflect.getIdentity(record, this.queryLogic.schema);
				delete this._instances[id];
			}, this);
		},
		updateRecordsSync: function(records){
			records.forEach(function(record){
				var id = canReflect.getIdentity(record, this.queryLogic.schema);
				this._instances[id] = record;
			},this);
		},

		// ## External interface

		/**
		 * @function can-memory-store.getQueries getQueries
		 * @parent can-memory-store.data-methods
		 *
		 * Returns the queries contained within the cache.
		 *
		 * @signature `connection.getQueries()`
		 *
		 *   Returns the queries added by [can-memory-store.updateListData].
		 *
		 *   @return {Promise<Array<can-query-logic/query>>} A promise that resolves to the list of queries.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * connection.getSets() //-> Promise( [{type: "completed"},{user: 5}] )
		 * ```
		 *
		 */

		/**
		 * @function can-memory-store.clear clear
		 * @parent can-memory-store.data-methods
		 *
		 * Resets the memory store so it contains nothing.
		 *
		 * @signature `connection.clear()`
		 *
		 *   Removes all instances and lists being stored in memory.
		 *
		 *   ```js
		 *   memoryStore({queryLogic: new QueryLogic()});
		 *
		 *   cacheConnection.updateInstance({id: 5, name: "justin"});
		 *
		 *   cacheConnection.getData({id: 5}).then(function(data){
		 *     data //-> {id: 5, name: "justin"}
		 *     cacheConnection.clear();
		 *     cacheConnection.getData({id: 5}).catch(function(err){
		 *       err -> {message: "no data", error: 404}
		 *     });
		 *   });
		 *   ```
		 *
		 */

		/**
		 * @function can-memory-store.getListData getListData
		 * @parent can-memory-store.data-methods
		 *
		 * Gets a list of data from the memory store.
		 *
		 * @signature `connection.getListData(query)`
		 *
		 *   Goes through each query add by [can-memory-store.updateListData]. If
		 *   `query` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `query`.
		 *
		 *   @param {can-query-logic/query} query An object that represents the data to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that resolves if `query` is a subset of
		 *   some data added by [can-memory-store.updateListData].  If it is not,
		 *   the promise is rejected.
		 */

		/**
		 * @function can-connect/data/memory-cache.getListDataSync getListDataSync
		 * @parent can-connect/data/memory-cache.data-methods
		 *
		 * Synchronously gets a query of data from the memory cache.
		 *
		 * @signature `connection.getListDataSync(query)`
		 * @hide
		 */


		/**
		 * @function can-memory-store.updateListData updateListData
		 * @parent can-memory-store.data-methods
		 *
		 * Saves a query of data in the cache.
		 *
		 * @signature `connection.updateListData(listData, query)`
		 *
		 *   Tries to merge this query of data with any other saved queries of data. If
		 *   unable to merge this data, saves the query by itself.
		 *
		 *   @param {can-connect.listData} listData The data that belongs to `query`.
		 *   @param {can-query-logic/query} query The query `listData` belongs to.
		 *   @return {Promise} Promise resolves if and when the data has been successfully saved.
		 */


		/**
		 * @function can-memory-store.getData getData
		 * @parent can-memory-store.data-methods
		 *
		 * Get an instance's data from the memory cache.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Looks in the instance store for the requested instance.
		 *
		 *   @param {Object} params An object that should have the [conenction.id] of the element
		 *   being retrieved.
		 *
		 *   @return {Promise} A promise that resolves to the item if the memory cache has this item.
		 *   If the memory cache does not have this item, it rejects the promise.
		 */




		/**
		 * @function can-memory-store.createData createData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance is created and should be added to cache.
		 *
		 * @signature `connection.createData(record)`
		 *
		 *   Adds `record` to the stored list of instances. Then, goes
		 *   through every query and adds record the queries it belongs to.
		 */


		/**
		 * @function can-memory-store.updateData updateData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance is updated.
		 *
		 * @signature `connection.updateData(record)`
		 *
		 *   Overwrites the stored instance with the new record. Then, goes
		 *   through every query and adds or removes the instance if it belongs or not.
		 */

		/**
		 * @function can-memory-store.destroyData destroyData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance should be removed from the cache.
		 *
		 * @signature `connection.destroyData(record)`
		 *
		 *   Goes through each query of data and removes any data that matches
		 *   `record`'s [can-connect/base/base.id]. Finally removes this from the instance store.
		 */

	});

	return behavior;

};


/***/ }),

/***/ "./node_modules/can-memory-store/make-simple-store.js":
/*!************************************************************!*\
  !*** ./node_modules/can-memory-store/make-simple-store.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");


function getItems(data){
	if(Array.isArray(data)) {
		return data;
	} else {
		return data.data;
	}
}

function indexOf(records, identity, queryLogic ){
	var schema = canReflect.getSchema( queryLogic );
	for(var i = 0 ; i < records.length; i++) {
		if(identity === canReflect.getIdentity(records[i],  schema) ) {
			return i;
		}
	}
	return -1;
}

// update could remove all other records that would be in the set
function makeSimpleStore(baseConnection) {
    baseConnection.constructor = makeSimpleStore;
    var behavior = Object.create(baseConnection);

    // this stores data like:
    // queries: {[queryKey]: {queryKey, query, recordIds}}
    // records
    return canReflect.assignMap(behavior, {
        getRecordFromParams: function(record) {
        	var id = canReflect.getIdentity(record, this.queryLogic.schema);
        	return this.getRecord(id);
        },

        log: function(){
			this._log = true;
		},

        getSets: function(){
			return this.getQueries();
		},
		getQueries: function(){
			return Promise.resolve(this.getQueriesSync());
		},
		getQueriesSync: function(){
			return this.getQueryDataSync().map(function(queryData){
				return queryData.query;
			});
		},

        getListData: function(query){
        	query = query || {};
        	var listData = this.getListDataSync(query);
        	if(listData) {
        		return Promise.resolve(listData);
        	}
        	return Promise.reject({
        		title: "no data",
        		status: "404",
        		detail: "No data available for this query.\nAvailable queries: "+
        			JSON.stringify(this.getQueriesSync())
        	});
        },
		getPaginatedListDataSync: function(superSetQueryData) {
			var records = this.getAllRecords();
			var queryWithoutPagination = this.queryLogic.removePagination(superSetQueryData.query);
			var matchingSuperRecordsNoPagination = this.queryLogic.filterMembersAndGetCount(queryWithoutPagination, {}, records);
			var startIndex = indexOf(matchingSuperRecordsNoPagination.data, superSetQueryData.startIdentity, this.queryLogic);
			var matchingSuperRecords = matchingSuperRecordsNoPagination.data.slice(startIndex, startIndex+ this.queryLogic.count(superSetQueryData.query));
			return {
				count: matchingSuperRecordsNoPagination.data.length,
				data: matchingSuperRecords
			};
		},
        getListDataSync: function(query){
			var queryData = this.getQueryDataSync(),
				superSetQueryData,
				isPaginated = this.queryLogic.isPaginated(query);

			for(var i = 0; i < queryData.length; i++) {
        		var checkSet = queryData[i].query;
        		if( this.queryLogic.isSubset(query, checkSet) ) {
					superSetQueryData = queryData[i];
        		}
        	}
			var records = this.getAllRecords();

			if(isPaginated && this.queryLogic.isPaginated(superSetQueryData.query) ) {
				var result = this.getPaginatedListDataSync(superSetQueryData);
				return this.queryLogic.filterMembersAndGetCount(query, superSetQueryData.query, result.data);
			}

            var matching = this.queryLogic.filterMembersAndGetCount(query, {}, records);
            if(matching && matching.count) {
                return matching;
            }
            // now check if we have a query  for it
        	if(superSetQueryData) {
				return {count: 0, data: []};
			}
        },

        updateListData: function(data, query){
			var queryData = this.getQueryDataSync();
        	query = query || {};
            var clonedData = canReflect.serialize(data);
        	var records = getItems(clonedData);
			// Update or create all records
			this.updateRecordsSync(records);
			var isPaginated = this.queryLogic.isPaginated(query);
			var identity = records.length ? canReflect.getIdentity(records[0],  this.queryLogic.schema) : undefined;
			if(isPaginated) {
				// we are going to merge with some paginated set
				for(var i = 0; i < queryData.length; i++) {
	        		var checkSet = queryData[i].query;
					var union = this.queryLogic.union(checkSet, query);
					if( this.queryLogic.isDefinedAndHasMembers(union)  ) {
						var siblingRecords = this.getPaginatedListDataSync(queryData[i]);
						var res = this.queryLogic.unionMembers(checkSet, query, siblingRecords.data, records );
						identity = canReflect.getIdentity(res[0],  this.queryLogic.schema);
						queryData[i] = {
							query: union,
							startIdentity: identity
						};
						this.updateQueryDataSync(queryData);
						return Promise.resolve();
					}
	        	}

				queryData.push({
					query: query,
					startIdentity: identity
				});
				this.updateQueryDataSync(queryData);
				return Promise.resolve();
			}

            // we need to remove everything that would have matched this query before, but that's not in data
            // but what if it's in another set -> we remove it
            var allRecords = this.getAllRecords();
            var curretMatching = this.queryLogic.filterMembers(query, allRecords);
            if(curretMatching.length) {
                var toBeDeleted = new Map();
                curretMatching.forEach(function(record){
                    toBeDeleted.set( canReflect.getIdentity(record, this.queryLogic.schema), record );
                }, this);

                // remove what's in records
                records.forEach(function(record){
                    toBeDeleted.delete( canReflect.getIdentity(record, this.queryLogic.schema) );
                }, this);

                this.destroyRecords( canReflect.toArray(toBeDeleted) );
            }

            // the queries that are not consumed by query
            var allQueries = this.getQueryDataSync();
            var notSubsets = allQueries.filter(function(existingQueryData){
                    return !this.queryLogic.isSubset(existingQueryData.query, query);
                }, this),
                superSets = notSubsets.filter(function(existingQueryData){
                    return this.queryLogic.isSubset(query, existingQueryData.query);
                }, this);

			// would need to note the first record ... so we can do a query w/o pagination
			//

            // if there are sets that are parents of query
            if(superSets.length) {
                this.updateQueryDataSync(notSubsets);
            } else {
                this.updateQueryDataSync(notSubsets.concat([{
					query: query,
					startIdentity:identity
				}]));
            }

        	// setData.push({query: query, items: data});
        	return Promise.resolve();
        },

        getData: function(params){
        	var id = canReflect.getIdentity(params, canReflect.getSchema( this.queryLogic ) );
        	var res = this.getRecord(id);
        	if(res){
        		return Promise.resolve( res );
        	} else {
        		return Promise.reject({
        			title: "no data",
        			status: "404",
        			detail: "No record with matching identity ("+id+")."
        		});
        	}
        },
        createData: function(record){
			this.updateRecordsSync([record]);

			return Promise.resolve(canReflect.assignMap({}, this.getRecordFromParams(record) ));
		},

		updateData: function(record){

			if(this.errorOnMissingRecord && !this.getRecordFromParams(record)) {
				var id = canReflect.getIdentity(record, this.queryLogic.schema);
				return Promise.reject({
					title: "no data",
					status: "404",
					detail: "No record with matching identity ("+id+")."
				});
			}

			this.updateRecordsSync([record]);

			return Promise.resolve(canReflect.assignMap({},this.getRecordFromParams(record) ));
		},

		destroyData: function(record){
			var id = canReflect.getIdentity(record,  this.queryLogic.schema),
				savedRecord = this.getRecordFromParams(record);

			if(this.errorOnMissingRecord && !savedRecord) {

				return Promise.reject({
					title: "no data",
					status: "404",
					detail: "No record with matching identity ("+id+")."
				});
			}
            this.destroyRecords([record]);
			return Promise.resolve(canReflect.assignMap({},savedRecord || record));
		}
    });
}

module.exports = makeSimpleStore;


/***/ }),

/***/ "./node_modules/can-namespace/can-namespace.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-namespace/can-namespace.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/can-ndjson-stream/can-ndjson-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-ndjson-stream/can-ndjson-stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*exported ndjsonStream*/

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var ndjsonStream = function(response) {
  // For cancellation
  var is_reader, cancellationRequest = false;
  return new ReadableStream({
    start: function(controller) {
      var reader = response.getReader();
      is_reader = reader;
      var decoder = new TextDecoder();
      var data_buf = "";

      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancellationRequest) {
            // Immediately exit
            return;
          }

          data_buf = data_buf.trim();
          if (data_buf.length !== 0) {
            try {
              var data_l = JSON.parse(data_buf);
              controller.enqueue(data_l);
            } catch(e) {
              controller.error(e);
              return;
            }
          }
          controller.close();
          return;
        }

        var data = decoder.decode(result.value, {stream: true});
        data_buf += data;
        var lines = data_buf.split("\n");
        for(var i = 0; i < lines.length - 1; ++i) {
          var l = lines[i].trim();
          if (l.length > 0) {
            try {
              var data_line = JSON.parse(l);
              controller.enqueue(data_line);
            } catch(e) {
              controller.error(e);
              cancellationRequest = true;
              reader.cancel();
              return;
            }
          }
        }
        data_buf = lines[lines.length-1];

        return reader.read().then(processResult);
      });

    },
    cancel: function(reason) {
      console.log("Cancel registered due to ", reason);
      cancellationRequest = true;
      is_reader.cancel();
    }
  });
};

module.exports = namespace.ndjsonStream = ndjsonStream;


/***/ }),

/***/ "./node_modules/can-observable-array/dist/can-observable-array.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/can-observable-array.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var _require = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    createConstructorFunction = _require.createConstructorFunction,
    makeDefineInstanceKey = _require.makeDefineInstanceKey,
    mixins = _require.mixins,
    mixinMapProps = _require.mixinMapProps,
    mixinTypeEvents = _require.mixinTypeEvents;

var _require2 = __webpack_require__(/*! ./helpers */ "./node_modules/can-observable-array/dist/helpers.js"),
    convertItem = _require2.convertItem,
    convertItems = _require2.convertItems,
    dispatchLengthPatch = _require2.dispatchLengthPatch;

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var ProxyArray = __webpack_require__(/*! ./proxy-array */ "./node_modules/can-observable-array/dist/proxy-array.js")();

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js"); // symbols aren't enumerable ... we'd need a version of Object that treats them that way


var localOnPatchesSymbol = "can.patches";
var onKeyValueSymbol = Symbol.for("can.onKeyValue");
var offKeyValueSymbol = Symbol.for("can.offKeyValue");
var metaSymbol = Symbol.for("can.meta");

function isListLike(items) {
  return canReflect.isListLike(items) && typeof items !== "string";
}

var MixedInArray = mixinTypeEvents(mixinMapProps(ProxyArray));

var ObservableArray = /*#__PURE__*/function (_MixedInArray) {
  _inherits(ObservableArray, _MixedInArray);

  var _super = _createSuper(ObservableArray);

  // TODO define stuff here
  function ObservableArray(items, props) {
    var _this;

    _classCallCheck(this, ObservableArray);

    // Arrays can be passed a length like `new Array(15)`
    var isLengthArg = typeof items === "number";

    if (isLengthArg) {
      _this = _super.call(this, items);
    } else if (arguments.length > 0 && !isListLike(items)) {
      throw new Error("can-observable-array: Unexpected argument: " + _typeof(items));
    } else {
      _this = _super.call(this);
    }

    mixins.finalizeClass(this instanceof ObservableArray ? this.constructor : void 0);
    mixins.initialize(_assertThisInitialized(_this), props || {});

    for (var i = 0, len = items && items.length; i < len; i++) {
      _this[i] = convertItem(this instanceof ObservableArray ? this.constructor : void 0, items[i]);
    } // Define class fields observables 
    //and return the proxy


    return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), {
      defineProperty: function defineProperty(target, prop, descriptor) {
        if ('items' === prop) {
          throw new Error('ObservableArray does not support a class field named items. Try using a different name or using static items');
        } // do not create expando properties for special keys set by can-observable-mixin


        if (prop === '_instanceDefinitions') {
          return Reflect.defineProperty(target, prop, descriptor);
        }

        var value = descriptor.value; // do not create expando properties for properties that are described
        // by `static props` or `static propertyDefaults`

        var props = target.constructor.props;

        if (props && props[prop] || target.constructor.propertyDefaults) {
          if (value) {
            target.set(prop, value);
            return true;
          }

          return Reflect.defineProperty(target, prop, descriptor);
        } // create expandos to make all other properties observable


        return mixins.expando(target, prop, value);
      }
    }));
  }

  _createClass(ObservableArray, [{
    key: "push",
    value: function push() {
      var _get2;

      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(ObservableArray.prototype), "push", this)).call.apply(_get2, [this].concat(items));
    }
  }, {
    key: "unshift",
    value: function unshift() {
      var _get3;

      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      return (_get3 = _get(_getPrototypeOf(ObservableArray.prototype), "unshift", this)).call.apply(_get3, [this].concat(items));
    }
  }, {
    key: "filter",
    value: function filter(callback) {
      if (_typeof(callback) === "object") {
        var props = callback;

        callback = function callback(item) {
          for (var prop in props) {
            if (item[prop] !== props[prop]) {
              return false;
            }
          }

          return true;
        };
      }

      return _get(_getPrototypeOf(ObservableArray.prototype), "filter", this).call(this, callback);
    }
  }, {
    key: "forEach",
    value: function forEach() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return Array.prototype.forEach.apply(this, args);
    }
  }, {
    key: "splice",
    value: function splice() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var index = args[0],
          howMany = args[1],
          added = [],
          i,
          len,
          listIndex,
          allSame = args.length > 2;
      index = index || 0; // converting the arguments to the right type

      for (i = 0, len = args.length - 2; i < len; i++) {
        listIndex = i + 2;
        added.push(args[listIndex]); // Now lets check if anything will change

        if (this[i + index] !== args[listIndex]) {
          allSame = false;
        }
      } // if nothing has changed, then return


      if (allSame && this.length <= added.length) {
        return added;
      } // default howMany if not provided


      if (howMany === undefined) {
        howMany = args[1] = this.length - index;
      }

      queues.batch.start();

      var removed = _get(_getPrototypeOf(ObservableArray.prototype), "splice", this).apply(this, args);

      queues.batch.stop();
      return removed;
    }
  }, {
    key: Symbol.for("can.splice"),

    /* Symbols */
    value: function value(index, deleteCount, insert) {
      return this.splice.apply(this, _toConsumableArray([index, deleteCount].concat(insert)));
    }
  }, {
    key: Symbol.for("can.onPatches"),
    value: function value(handler, queue) {
      this[onKeyValueSymbol](localOnPatchesSymbol, handler, queue);
    }
  }, {
    key: Symbol.for("can.offPatches"),
    value: function value(handler, queue) {
      this[offKeyValueSymbol](localOnPatchesSymbol, handler, queue);
    }
  }, {
    key: Symbol.for("can.getOwnEnumerableKeys"),
    value: function value() {
      var base = _get(_getPrototypeOf(ObservableArray.prototype), Symbol.for("can.getOwnEnumerableKeys"), this).call(this);

      var keysSet = new Set([].concat(_toConsumableArray(Object.keys(this)), _toConsumableArray(base)));
      return Array.from(keysSet);
    }
  }, {
    key: Symbol.for("can.isListLike"),
    get: function get() {
      return true;
    }
  }], [{
    key: Symbol.for("can.new"),
    value: function value(items) {
      var array = items || [];
      return new this(array);
    }
  }, {
    key: "convertsTo",
    value: function convertsTo(Type) {
      var ConvertedType = type.convert(Type);

      var ArrayType = /*#__PURE__*/function (_this2) {
        _inherits(ArrayType, _this2);

        var _super2 = _createSuper(ArrayType);

        function ArrayType() {
          _classCallCheck(this, ArrayType);

          return _super2.apply(this, arguments);
        }

        _createClass(ArrayType, null, [{
          key: "items",
          get: function get() {
            return ConvertedType;
          }
        }]);

        return ArrayType;
      }(this);

      var name = "ConvertedObservableArray<".concat(canReflect.getName(Type), ">");
      canReflect.setName(ArrayType, name);
      return ArrayType;
    }
  }, {
    key: Symbol.species,
    get: function get() {
      return this;
    }
  }]);

  return ObservableArray;
}(MixedInArray);

var mutateMethods = {
  "push": function push(arr, args) {
    return [{
      index: arr.length - args.length,
      deleteCount: 0,
      insert: args,
      type: "splice"
    }];
  },
  "pop": function pop(arr, args, oldLength) {
    return [{
      index: arr.length,
      deleteCount: oldLength > 0 ? 1 : 0,
      type: "splice"
    }];
  },
  "shift": function shift(arr, args, oldLength) {
    return [{
      index: 0,
      deleteCount: oldLength > 0 ? 1 : 0,
      type: "splice"
    }];
  },
  "unshift": function unshift(arr, args) {
    return [{
      index: 0,
      deleteCount: 0,
      insert: args,
      type: "splice"
    }];
  },
  "splice": function splice(arr, args, oldLength) {
    var index = args[0] < 0 ? Math.max(oldLength + args[0], 0) : Math.min(oldLength, args[0]);
    return [{
      index: index,
      deleteCount: Math.max(0, Math.min(args[1], oldLength - index)),
      insert: args.slice(2),
      type: "splice"
    }];
  },
  "sort": function sort(arr) {
    return [{
      index: 0,
      deleteCount: arr.length,
      insert: arr,
      type: "splice"
    }];
  },
  "reverse": function reverse(arr) {
    return [{
      index: 0,
      deleteCount: arr.length,
      insert: arr,
      type: "splice"
    }];
  }
};
var convertArgs = {
  "push": function push(arr, args) {
    return convertItems(arr.constructor, args);
  },
  "unshift": function unshift(arr, args) {
    return convertItems(arr.constructor, args);
  },
  "splice": function splice(arr, args) {
    return args.slice(0, 2).concat(convertItems(arr.constructor, args.slice(2)));
  }
};
canReflect.eachKey(mutateMethods, function (makePatches, prop) {
  var protoFn = ObservableArray.prototype[prop];

  ObservableArray.prototype[prop] = function () {
    var oldLength = this.length;
    var args = Array.from(arguments);

    if (convertArgs[prop]) {
      args = convertArgs[prop](this, args);
    } // prevent `length` event from being dispatched by get/set proxy hooks


    this[metaSymbol].preventSideEffects = (this[metaSymbol].preventSideEffects || 0) + 1;
    var result = protoFn.apply(this, args);
    this[metaSymbol].preventSideEffects--;
    var patches = makePatches(this, args, oldLength);
    dispatchLengthPatch.call(this, prop, patches, this.length, oldLength);
    return result;
  };
});
makeDefineInstanceKey(ObservableArray); // Export a constructor function to workaround an issue where ES2015 classes
// cannot be extended in code that's transpiled by Babel.

module.exports = namespace.ObservableArray = createConstructorFunction(ObservableArray);

/***/ }),

/***/ "./node_modules/can-observable-array/dist/computed-helpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/computed-helpers.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var canMeta = Symbol.for("can.meta");
var computedPropertyDefinitionSymbol = Symbol.for("can.computedPropertyDefinitions");
var onKeyValueSymbol = Symbol.for("can.onKeyValue");
var offKeyValueSymbol = Symbol.for("can.offKeyValue"); // ## ComputedObjectObservationData
// Instances of this are created to wrap the observation.
// The `.bind` and `.unbind` methods should be called when the
// instance's prop is bound or unbound.

function ComputedObjectObservationData(instance, prop, observation) {
  this.instance = instance;
  this.prop = prop;
  this.observation = observation;
  this.forward = this.forward.bind(this);
}

ComputedObjectObservationData.prototype.bind = function () {
  this.bindingCount++;

  if (this.bindingCount === 1) {
    this.observation.on(this.forward, "notify");
  }
};

ComputedObjectObservationData.prototype.unbind = function () {
  this.bindingCount--;

  if (this.bindingCount === 0) {
    this.observation.off(this.forward, "notify");
  }
};

ComputedObjectObservationData.prototype.forward = function (newValue, oldValue) {
  mapBindings.dispatch.call(this.instance, {
    type: this.prop,
    key: this.prop,
    target: this.instance,
    value: newValue,
    oldValue: oldValue // patches: [{
    // 	key: this.prop,
    // 	type: "set",
    // 	value: newValue
    // }]
    // keyChanged: undefined

  }, [newValue, oldValue]);
};

ComputedObjectObservationData.prototype.bindingCount = 0;

function findComputed(instance, key) {
  var meta = instance[canMeta];
  var target = meta.target;
  var computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];

  if (computedPropertyDefinitions === undefined) {
    return;
  }

  var computedPropertyDefinition = computedPropertyDefinitions[key];

  if (computedPropertyDefinition === undefined) {
    return;
  }

  if (meta.computedKeys[key] === undefined) {
    meta.computedKeys[key] = new ComputedObjectObservationData(instance, key, computedPropertyDefinition(instance, key));
  }

  return meta.computedKeys[key];
}

var computedHelpers = {
  bind: function bind(instance, key) {
    var computedObj = findComputed(instance, key);

    if (computedObj === undefined) {
      return;
    }

    computedObj.bind();
  },
  addKeyDependencies: function addKeyDependencies(proxyKeys) {
    var onKeyValue = proxyKeys[onKeyValueSymbol];
    var offKeyValue = proxyKeys[offKeyValueSymbol];
    canReflect.assignSymbols(proxyKeys, {
      "can.onKeyValue": function canOnKeyValue(key) {
        computedHelpers.bind(this, key);
        return onKeyValue.apply(this, arguments);
      },
      "can.offKeyValue": function canOffKeyValue(key) {
        computedHelpers.unbind(this, key);
        return offKeyValue.apply(this, arguments);
      },
      "can.getKeyDependencies": function canGetKeyDependencies(key) {
        var computedObj = findComputed(this, key);

        if (computedObj === undefined) {
          return;
        }

        return {
          valueDependencies: new Set([computedObj.observation])
        };
      }
    });
  }
};
module.exports = computedHelpers;

/***/ }),

/***/ "./node_modules/can-observable-array/dist/helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observable-array/dist/helpers.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var _require = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    mixins = _require.mixins;

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var metaSymbol = Symbol.for("can.meta");
var helpers = {
  assignNonEnumerable: function assignNonEnumerable(obj, key, value) {
    return Object.defineProperty(obj, key, {
      enumerable: false,
      writable: true,
      configurable: true,
      value: value
    });
  },
  shouldRecordObservationOnAllKeysExceptFunctionsOnProto: function shouldRecordObservationOnAllKeysExceptFunctionsOnProto(keyInfo, meta) {
    return meta.preventSideEffects === 0 && !keyInfo.isAccessor && ( // it's on us
    // it's on our proto, but not a function
    keyInfo.targetHasOwnKey || // it's "missing", and we are not sealed
    !keyInfo.protoHasKey && !Object.isSealed(meta.target) || keyInfo.protoHasKey && typeof targetValue !== "function");
  },

  /*
   * dispatch an event when an index changes
   */
  dispatchIndexEvent: function dispatchIndexEvent(attr, how, newVal, oldVal) {
    var index = +attr; // Make sure this is not nested and not an expando

    if (!isNaN(index)) {
      var itemsDefinition = this._define.definitions["#"];

      if (how === 'set') {
        this.dispatch({
          type: index,
          action: how,
          key: index,
          value: newVal,
          oldValue: oldVal
        }, [newVal, oldVal]); // if event is being set through an ObservableArray.prototype method,
        // do not dispatch length or patch events.
        // This will be handled by ObservableArray.prototype method.

        var meta = this[metaSymbol];

        if (!("preventSideEffects" in meta) || meta.preventSideEffects === 0) {
          var patches = [{
            index: index,
            deleteCount: 1,
            insert: [newVal],
            type: "splice"
          }];
          helpers.dispatchLengthPatch.call(this, how, patches, this.length, this.length);
        }
      } else if (how === 'add') {
        if (itemsDefinition && typeof itemsDefinition.added === 'function') {
          ObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);
        }

        this.dispatch({
          type: index,
          action: how,
          key: index,
          value: newVal,
          oldValue: oldVal
        }, [newVal, oldVal]); // if event is being set through an ObservableArray.prototype method,
        // do not dispatch length or patch events.
        // This will be handled by ObservableArray.prototype method.

        var _meta = this[metaSymbol];

        if (!("preventSideEffects" in _meta) || _meta.preventSideEffects === 0) {
          var _patches = [{
            index: index,
            deleteCount: 0,
            insert: [newVal],
            type: "splice"
          }];
          helpers.dispatchLengthPatch.call(this, how, _patches, this.length, this.length - 1);
        }
      } else if (how === 'remove') {
        if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
          ObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);
        }
      }
    } else {
      var key = "" + attr;
      this.dispatch({
        type: key,
        key: key,
        action: how,
        value: newVal,
        oldValue: oldVal,
        target: this
      }, [newVal, oldVal]);
    }
  },

  /*
   * Dispatch a `type: "splice"` patch and a `length` event
   */
  dispatchLengthPatch: function dispatchLengthPatch(how, patches, newLength, oldLength) {
    var dispatchArgs = {
      type: "length",
      key: "length",
      action: how,
      value: newLength,
      oldValue: oldLength,
      patches: patches
    }; //!steal-remove-start

    if (true) {
      dispatchArgs.reasonLog = [canReflect.getName(this) + "." + how + " called with", arguments];
    } //!steal-remove-end


    mapBindings.dispatch.call(this, dispatchArgs, [newLength, oldLength]);
  },
  convertItem: function convertItem(Constructor, item) {
    if (Constructor.items) {
      var definition = mixins.normalizeTypeDefinition(Constructor.items.type || Constructor.items);
      return canReflect.convert(item, definition);
    }

    return item;
  },
  convertItems: function convertItems(Constructor, items) {
    if (items.length) {
      if (Constructor.items) {
        for (var i = 0, len = items.length; i < len; i++) {
          items[i] = helpers.convertItem(Constructor, items[i]);
        }
      }
    }

    return items;
  }
};
module.exports = helpers;

/***/ }),

/***/ "./node_modules/can-observable-array/dist/proxy-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/proxy-array.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var computedHelpers = __webpack_require__(/*! ./computed-helpers */ "./node_modules/can-observable-array/dist/computed-helpers.js");

var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var _require = __webpack_require__(/*! ./helpers */ "./node_modules/can-observable-array/dist/helpers.js"),
    assignNonEnumerable = _require.assignNonEnumerable,
    convertItem = _require.convertItem,
    dispatchIndexEvent = _require.dispatchIndexEvent,
    shouldRecordObservationOnAllKeysExceptFunctionsOnProto = _require.shouldRecordObservationOnAllKeysExceptFunctionsOnProto;

var _require2 = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    mixins = _require2.mixins;

var hasOwn = Object.prototype.hasOwnProperty;
var isSymbolLike = canReflect.isSymbolLike;
var metaSymbol = Symbol.for("can.meta");
var proxiedObjects = new WeakMap();
var proxies = new WeakSet();
var proxyKeys = Object.create(null);
Object.getOwnPropertySymbols(mapBindings).forEach(function (symbol) {
  assignNonEnumerable(proxyKeys, symbol, mapBindings[symbol]);
});
computedHelpers.addKeyDependencies(proxyKeys);
var mutateMethods = {
  "push": function push(arr, args) {
    return [{
      index: arr.length - args.length,
      deleteCount: 0,
      insert: args,
      type: "splice"
    }];
  },
  "pop": function pop(arr) {
    return [{
      index: arr.length,
      deleteCount: 1,
      insert: [],
      type: "splice"
    }];
  },
  "shift": function shift() {
    return [{
      index: 0,
      deleteCount: 1,
      insert: [],
      type: "splice"
    }];
  },
  "unshift": function unshift(arr, args) {
    return [{
      index: 0,
      deleteCount: 0,
      insert: args,
      type: "splice"
    }];
  },
  "splice": function splice(arr, args) {
    return [{
      index: args[0],
      deleteCount: args[1],
      insert: args.slice(2),
      type: "splice"
    }];
  },
  "sort": function sort(arr) {
    // The array replaced everything.
    return [{
      index: 0,
      deleteCount: arr.length,
      insert: arr,
      type: "splice"
    }];
  },
  "reverse": function reverse(arr) {
    // The array replaced everything.
    return [{
      index: 0,
      deleteCount: arr.length,
      insert: arr,
      type: "splice"
    }];
  }
}; // Overwrite Array's methods that mutate to:
// - prevent other events from being fired off (index events and length events.)
// - dispatch patches events.

canReflect.eachKey(mutateMethods, function (makePatches, prop) {
  var protoFn = Array.prototype[prop];

  var mutateMethod = function mutateMethod() {
    var meta = this[metaSymbol],
        // Capture if this function should be making sideEffects
    makeSideEffects = meta.preventSideEffects === 0,
        oldLength = meta.target.length; // Prevent proxy from calling ObservationRecorder and sending events.

    meta.preventSideEffects++; // Call the function -- note that *this* is the Proxy here, so
    // accesses in the function still go through `get()` and `set()`.

    var ret = protoFn.apply(meta.target, arguments);
    var patches = makePatches(meta.target, Array.from(arguments), oldLength);

    if (makeSideEffects === true) {
      //!steal-remove-start
      var reasonLog = [canReflect.getName(meta.proxy) + "." + prop + " called with", arguments]; //!steal-remove-end

      var dispatchArgs = {
        type: "length",
        key: "length",
        value: meta.target.length,
        oldValue: oldLength,
        patches: patches
      }; //!steal-remove-start

      if (true) {
        dispatchArgs.reasonLog = reasonLog;
      } //!steal-remove-end


      mapBindings.dispatch.call(meta.proxy, dispatchArgs, [meta.target.length, oldLength]);
    }

    meta.preventSideEffects--;
    return ret;
  }; //!steal-remove-start


  if (true) {
    Object.defineProperty(mutateMethod, "name", {
      value: prop
    });
  } //!steal-remove-end
  // Store the proxied method so it will be used instead of the
  // prototype method.


  proxiedObjects.set(protoFn, mutateMethod);
  proxies.add(mutateMethod);
});

function setValueAndOnChange(key, value, target, proxy, onChange) {
  var old, change;
  var hadOwn = hasOwn.call(target, key);
  var descriptor = Object.getOwnPropertyDescriptor(target, key); // call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)
  // -- setters do not return values, so it is unnecessary to check for changes.

  if (descriptor && descriptor.set) {
    descriptor.set.call(proxy, value);
  } else {
    // otherwise check for a changed value
    old = target[key];
    change = old !== value;

    if (change) {
      var keyType = _typeof(key);

      var keyIsString = keyType === "string"; // String keys added to the instance (and is not "length")
      // Are newly defined properties and have propertyDefaults provided.

      if (keyIsString && !(key in target)) {
        mixins.expando(target, key, value);
      } else {
        // arr[0] = { foo: 'bar' } should convert to MyArray.items
        if (keyType === "number") {
          value = convertItem(target.constructor, value);
        }

        target[key] = value;
        onChange(hadOwn, old);
      }
    }
  }
}

var proxyHandlers = {
  get: function get(target, key, receiver) {
    if (isSymbolLike(key)) {
      return target[key];
    }

    var proxy = proxiedObjects.get(target);
    ObservationRecorder.add(proxy, key.toString());
    var numberKey = !isSymbolLike(key) && +key;

    if (Number.isInteger(numberKey)) {
      ObservationRecorder.add(proxy, "length");
    }

    var value = Reflect.get(target, key, receiver);
    return value;
  },
  set: function set(target, key, newValue, receiver) {
    var proxy = proxiedObjects.get(target);
    var numberKey = !isSymbolLike(key) && +key;

    if (Number.isInteger(numberKey)) {
      key = numberKey;
    }

    setValueAndOnChange(key, newValue, target, proxy, function onChange(hadOwn, oldValue) {
      if (Number.isInteger(key)) {
        dispatchIndexEvent.call(receiver, key, hadOwn ? typeof newValue !== 'undefined' ? "set" : "remove" : "add", newValue, oldValue);
      }
    });
    return true;
  },
  deleteProperty: function deleteProperty(target, key) {
    var old = this.target[key];
    var deleteSuccessful = delete this.target[key]; // Fire event handlers if we were able to delete and the value changed.

    if (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {
      dispatchIndexEvent.call(this.proxy, key, "remove", undefined, old);
    }

    return deleteSuccessful;
  },
  ownKeys: function ownKeys() {
    ObservationRecorder.add(this.proxy, "can.keys");
    var keysSet = new Set(Object.getOwnPropertyNames(this.target).concat(Object.getOwnPropertySymbols(this.target)).concat(Object.getOwnPropertySymbols(this.proxyKeys)));
    return Array.from(keysSet);
  }
};

function makeObservable(array, options) {
  var meta = {
    target: array,
    proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(proxyKeys),
    computedKeys: Object.create(null),
    options: options,
    // `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
    // function (like `Array.splice`) wants to handle event dispatching and/or calling
    // `ObservationRecorder` itself for performance reasons.
    preventSideEffects: 0
  };
  meta.proxyKeys[metaSymbol] = meta;
  meta.proxy = new Proxy(array, {
    get: proxyHandlers.get.bind(meta),
    set: proxyHandlers.set.bind(meta),
    ownKeys: proxyHandlers.ownKeys.bind(meta),
    deleteProperty: proxyHandlers.deleteProperty.bind(meta),
    meta: meta
  });
  mapBindings.addHandlers(meta.proxy, meta);
  return meta.proxy;
}

function proxyArray() {
  return /*#__PURE__*/function (_Array) {
    _inherits(ProxyArray, _Array);

    var _super = _createSuper(ProxyArray);

    function ProxyArray() {
      var _this;

      _classCallCheck(this, ProxyArray);

      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(items));
      var localProxyKeys = Object.create(proxyKeys);
      localProxyKeys.constructor = _this.constructor;
      var observable = makeObservable(_assertThisInitialized(_this), {
        //observe: makeObserve.observe,
        proxyKeys: localProxyKeys,
        shouldRecordObservation: shouldRecordObservationOnAllKeysExceptFunctionsOnProto
      });
      proxiedObjects.set(_assertThisInitialized(_this), observable);
      proxies.add(observable);
      return _possibleConstructorReturn(_this, observable);
    }

    return ProxyArray;
  }( /*#__PURE__*/_wrapNativeSuper(Array));
}

module.exports = proxyArray;

/***/ }),

/***/ "./node_modules/can-observable-bindings/can-observable-bindings.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-observable-bindings/can-observable-bindings.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
const fromAttribute = __webpack_require__(/*! ./from-attribute */ "./node_modules/can-observable-bindings/from-attribute.js");

namespace.fromAttribute = fromAttribute;

module.exports = {
	fromAttribute: fromAttribute
};


/***/ }),

/***/ "./node_modules/can-observable-bindings/from-attribute.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-observable-bindings/from-attribute.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const value = __webpack_require__(/*! can-value */ "./node_modules/can-value/can-value.js");
const Bind = __webpack_require__(/*! can-bind */ "./node_modules/can-bind/can-bind.js");
const canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
const canString = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
const type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

//!steal-remove-start
if(true) {
	var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
}
//!steal-remove-end

const metaSymbol = Symbol.for("can.meta");

function isJSONLike (obj) {
	return (canReflect.isFunctionLike(obj.parse) &&
			canReflect.isFunctionLike(obj.stringify));
}

function initializeFromAttribute (propertyName, ctr, converter, attributeName) {
	if (ctr[metaSymbol] === undefined) {
		ctr[metaSymbol] = {};
	}
	// Create array for all attributes we want to listen to change events for
	if (ctr[metaSymbol]._observedAttributes === undefined) {
		ctr[metaSymbol]._observedAttributes = [];
	}
	// Create object for attributeChangedCallback for each prop
	if (ctr[metaSymbol]._attributeChangedCallbackHandler === undefined) {
		ctr[metaSymbol]._attributeChangedCallbackHandler = {};
	}

	if (attributeName === undefined) {
		attributeName = propertyName;
	}
	// Ensure the attributeName is hyphen case
	attributeName = canString.hyphenate(attributeName);

	// Modify the class prototype here
	if (!ctr[metaSymbol]._hasInitializedAttributeBindings) {
		// Set up the static getter for `observedAttributes`
		Object.defineProperty(ctr, "observedAttributes", {
			get() {
				return ctr[metaSymbol]._observedAttributes;
			}
		});

		ctr.prototype.attributeChangedCallback = function (prop) {
			ctr[metaSymbol]._attributeChangedCallbackHandler[prop].apply(this, arguments);
		};

		ctr[metaSymbol]._hasInitializedAttributeBindings = true;
	}
	// Push into `_observedAttributes` for `observedAttributes` getter
	ctr[metaSymbol]._observedAttributes.push(attributeName);

	// Create the attributeChangedCallback handler
	ctr[metaSymbol]._attributeChangedCallbackHandler[attributeName] = function (prop, oldVal, newVal) {
		if (this[metaSymbol] && this[metaSymbol]._attributeBindings && newVal !== oldVal) {
			canReflect.setValue(this[metaSymbol]._attributeBindings[prop], newVal);
		}
	};

	var lazyGetType = function() {
		var Type;
		var schema = canReflect.getSchema(ctr);
		if(schema) {
			Type = schema.keys[propertyName];
		}
		if(!Type) {
			Type = type.Any;
		}
		Type = type.convert(Type);
		lazyGetType = function() { return Type; };
		return Type;
	};
	function convertToValue(value) {
		if (converter) {
			value = converter.parse(value);
		}
		return canReflect.convert(value, lazyGetType());
	}

	return function fromAttributeBind (instance) {
		// Child binding used by `attributeChangedCallback` to update the value when an attribute change occurs
		const childValue = value.to(instance, propertyName);
		const intermediateValue = {};
		canReflect.assignSymbols(intermediateValue, {
			"can.setValue": function(value) {
				canReflect.setValue(childValue, convertToValue(value) );
			}
		});
		const parentValue = value.from(instance.hasAttribute(attributeName) ?  convertToValue(instance.getAttribute(attributeName)) : undefined);

		//!steal-remove-start
		if(true) {
			// Ensure pretty names for dep graph
			canReflect.assignSymbols(parentValue, {
				"can.getName": function getName() {
					return (
						"FromAttribute<" +
						instance.nodeName.toLowerCase() +
						"." +
						attributeName +
						">"
					);
				}
			});
			canReflect.assignSymbols(childValue, {
				"can.getName": function getName() {
					return (
						"Observation<" +
						canReflect.getName(parentValue) +
						">"
					);
				}
			});
			// Create temporary binding to initialize dep graph
			Observation.temporarilyBind(childValue);
		}
		//!steal-remove-end
		const bind = new Bind({
			parent: parentValue,
			child: intermediateValue,
			queue: "dom",
			// During initialization prevent update of child
			onInitDoNotUpdateChild: true
		});

		if (instance[metaSymbol] === undefined) {
			instance[metaSymbol] = {};
		}
		if (instance[metaSymbol]._attributeBindings === undefined) {
			instance[metaSymbol]._attributeBindings = {};
		}

		// Push binding so it can be used within `attributeChangedCallback`
		instance[metaSymbol]._attributeBindings[attributeName] = intermediateValue;

		return bind;
	};
}

module.exports = function fromAttribute (attributeName, ctr) {
	var converter;
	// Handle the class constructor
	if (arguments.length === 2 && canReflect.isConstructorLike(ctr) && !isJSONLike(ctr)) {
		return initializeFromAttribute(attributeName, ctr);
	} else if (arguments.length === 1 && typeof attributeName === 'object') {
		// Handle fromAttribute(JSON)
		converter = attributeName;
		attributeName = undefined;
	} else if (typeof ctr === 'object' && isJSONLike(ctr)) {
		// Handle the case where an attribute name
		// and JSON like converter is passed
		// fromAttribute('attr', JSON)
		converter = ctr;
	}
	//!steal-remove-start
	if(true) {
		if (converter && !isJSONLike(converter)) {
			throw new Error('The passed converter object is wrong! The object must have "parse" and "stringify" methods!');
		}
	}
	//!steal-remove-end
	return function (propertyName, ctr) {
		return initializeFromAttribute(propertyName, ctr, converter, attributeName);
	};
};


/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/create-constructor-function.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/create-constructor-function.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a constructor function from an ES2015 class, this is a workaround
 * needed to being able to extend a class from code that's transpiled by Babel.
 * See https://github.com/babel/babel/pull/8656
 * @param {*} Type The ES2015 base class used to create the constructor
 * @param {*} Parent The object where the prototype chain walk to copy over
 * symbols and static properties to the constructor stops. If not provided,
 * the chain stops at Object.
 * @returns {Function} Constructor function than can be safely subclassed from
 * transpiled code.
 */
function createConstructorFunction(Type, Parent) {
  if (typeof Parent === "undefined") {
    Parent = Object.getPrototypeOf(Object);
  }

  function TypeConstructor() {
    return Reflect.construct(Type, arguments, this.constructor);
  }

  TypeConstructor.prototype = Object.create(Type.prototype);
  TypeConstructor.prototype.constructor = TypeConstructor;
  /**
   * Add `prop` to TypeConstructor from `source` if not defined already
   * @param {{}} source The object that owns `prop`
   * @param {string} prop The name of the property to be defined
   */

  function copyIfMissing(source, prop) {
    if (!TypeConstructor[prop]) {
      Object.defineProperty(TypeConstructor, prop, Object.getOwnPropertyDescriptor(source, prop));
    }
  } // Walk up the prototype chain to copy over all Symbols and
  // static properties to the constructor function


  var Link = Type;

  while (Link !== Parent && Link !== null) {
    var props = Object.getOwnPropertyNames(Link);
    props.forEach(function (prop) {
      copyIfMissing(Link, prop);
    });
    var symbols = Object.getOwnPropertySymbols(Link);
    symbols.forEach(function (symbol) {
      copyIfMissing(Link, symbol);
    });
    Link = Object.getPrototypeOf(Link);
  }

  return TypeConstructor;
}

module.exports = createConstructorFunction;

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/define-helpers.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/define-helpers.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*jshint -W079 */

var define = __webpack_require__(/*! ./define */ "./node_modules/can-observable-mixin/dist/define.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var ensureMeta = __webpack_require__(/*! ./ensure-meta */ "./node_modules/can-observable-mixin/dist/ensure-meta.js");

var defineHelpers = {
  // returns `true` if the value was defined and set
  defineExpando: define.expando,
  reflectSerialize: function reflectSerialize(unwrapped) {
    var constructorDefinitions = this._define.definitions;
    var defaultDefinition = this._define.defaultDefinition;
    this.forEach(function (val, name) {
      var propDef = constructorDefinitions[name];

      if (propDef && typeof propDef.serialize === "function") {
        val = propDef.serialize.call(this, val, name);
      } else if (defaultDefinition && typeof defaultDefinition.serialize === "function") {
        val = defaultDefinition.serialize.call(this, val, name);
      } else {
        val = canReflect.serialize(val);
      }

      if (val !== undefined) {
        unwrapped[name] = val;
      }
    }, this);
    return unwrapped;
  },
  reflectUnwrap: function reflectUnwrap(unwrapped) {
    this.forEach(function (value, key) {
      if (value !== undefined) {
        unwrapped[key] = canReflect.unwrap(value);
      }
    });
    return unwrapped;
  },
  log: function log(key) {
    var instance = this;

    var quoteString = function quoteString(x) {
      return typeof x === "string" ? JSON.stringify(x) : x;
    };

    var meta = ensureMeta(instance);
    var allowed = meta.allowedLogKeysSet || new Set();
    meta.allowedLogKeysSet = allowed;

    if (key) {
      allowed.add(key);
    }

    meta._log = function (event, data) {
      var type = event.type;

      if (type === "can.onPatches" || key && !allowed.has(type) || type === "can.keys" || key && !allowed.has(type)) {
        return;
      }

      if (type === "add" || type === "remove") {
        dev.log(canReflect.getName(instance), "\n how   ", quoteString(type), "\n what  ", quoteString(data[0]), "\n index ", quoteString(data[1]));
      } else {
        // log `length` and `propertyName` events
        dev.log(canReflect.getName(instance), "\n key ", quoteString(type), "\n is  ", quoteString(data[0]), "\n was ", quoteString(data[1]));
      }
    };
  },
  deleteKey: function deleteKey(prop) {
    var instanceDefines = this._instanceDefinitions;

    if (instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {
      delete instanceDefines[prop];
      delete this[prop];
      queues.batch.start();
      this.dispatch({
        action: "can.keys",
        type: "can.keys",
        target: this
      });
      var oldValue = this._data[prop];

      if (oldValue !== undefined) {
        delete this._data[prop]; //delete this[prop];

        this.dispatch({
          action: "delete",
          key: prop,
          oldValue: oldValue,
          type: prop,
          target: this,
          patches: [{
            type: "delete",
            key: prop
          }]
        }, [undefined, oldValue]);
      }

      queues.batch.stop();
    } else {
      this.set(prop, undefined);
    }

    return this;
  }
};
module.exports = defineHelpers;

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/define.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var _define; //jshint ignore:line


var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ "./node_modules/can-simple-observable/async/async.js");

var SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");

var ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ "./node_modules/can-simple-observable/resolver/resolver.js");

var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");

var type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

var newSymbol = Symbol.for("can.new"),
    serializeSymbol = Symbol.for("can.serialize"),
    inSetupSymbol = Symbol.for("can.initializing"),
    isMemberSymbol = Symbol.for("can.isMember"),
    hasBeenDefinedSymbol = Symbol.for("can.hasBeenDefined"),
    canMetaSymbol = Symbol.for("can.meta"),
    baseTypeSymbol = Symbol.for("can.baseType");
var eventsProto, make, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod; // UTILITIES

function isDefineType(func) {
  return func && (func.canDefineType === true || func[newSymbol]);
}

function observableType() {
  throw new Error("This is not currently implemented.");
}

var AsyncFunction;

var browserSupportsAsyncFunctions = function () {
  try {
    AsyncFunction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })).constructor;
    return true;
  } catch (e) {
    return false;
  }
}();

function isAsyncFunction(fn) {
  if (!browserSupportsAsyncFunctions) {
    return false;
  }

  return fn && fn instanceof AsyncFunction;
}

var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
var Object_defineNamedPrototypeProperty = Object.defineProperty; //!steal-remove-start

if (true) {
  Object_defineNamedPrototypeProperty = function Object_defineNamedPrototypeProperty(obj, prop, definition) {
    if (definition.get) {
      Object.defineProperty(definition.get, "name", {
        value: "get " + canReflect.getName(obj) + "." + prop,
        writable: true,
        configurable: true
      });
    }

    if (definition.set) {
      Object.defineProperty(definition.set, "name", {
        value: "set " + canReflect.getName(obj) + "." + prop,
        configurable: true
      });
    }

    return Object.defineProperty(obj, prop, definition);
  };
} //!steal-remove-end


function defineConfigurableAndNotEnumerable(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: value
  });
}

function defineNotWritableAndNotEnumerable(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: false,
    writable: false
  });
}

function eachPropertyDescriptor(map, cb) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(map)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;

      if (map.hasOwnProperty(prop)) {
        cb.call.apply(cb, [map, prop, Object.getOwnPropertyDescriptor(map, prop)].concat(args));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function getEveryPropertyAndSymbol(obj) {
  var props = Object.getOwnPropertyNames(obj);
  var symbols = "getOwnPropertySymbols" in Object ? Object.getOwnPropertySymbols(obj) : [];
  return props.concat(symbols);
}

module.exports = _define = function define(typePrototype, defines, baseDefine) {
  var propertyDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // default property definitions on _data
  var prop,
      dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),
      // computed property definitions on _computed
  computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null),
      required = new Set();
  var result = getDefinitionsAndMethods(defines, baseDefine, typePrototype, propertyDefaults);
  result.dataInitializers = dataInitializers;
  result.computedInitializers = computedInitializers;
  result.required = required; // Goes through each property definition and creates
  // a `getter` and `setter` function for `Object.defineProperty`.

  canReflect.eachKey(result.definitions, function (definition, property) {
    // Add this as a required property
    if (definition.required === true) {
      required.add(property);
    }

    _define.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);
  }); // Places a `_data` on the prototype that when first called replaces itself
  // with a `_data` object local to the instance.  It also defines getters
  // for any value that has a default value.

  if (typePrototype.hasOwnProperty("_data")) {
    for (prop in dataInitializers) {
      defineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);
    }
  } else {
    defineLazyValue(typePrototype, "_data", function () {
      var map = this;
      var data = {};

      for (var _prop in dataInitializers) {
        defineLazyValue(data, _prop, dataInitializers[_prop].bind(map), true);
      }

      return data;
    });
  } // Places a `_computed` on the prototype that when first called replaces itself
  // with a `_computed` object local to the instance.  It also defines getters
  // that will create the property's compute when read.


  if (typePrototype.hasOwnProperty("_computed")) {
    for (prop in computedInitializers) {
      defineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));
    }
  } else {
    defineLazyValue(typePrototype, "_computed", function () {
      var map = this;
      var data = Object.create(null);

      for (var _prop2 in computedInitializers) {
        defineLazyValue(data, _prop2, computedInitializers[_prop2].bind(map));
      }

      return data;
    });
  } // Add necessary event methods to this object.


  getEveryPropertyAndSymbol(eventsProto).forEach(function (prop) {
    Object.defineProperty(typePrototype, prop, {
      enumerable: false,
      value: eventsProto[prop],
      configurable: true,
      writable: true
    });
  }); // also add any symbols
  // add so instance defs can be dynamically added

  Object.defineProperty(typePrototype, "_define", {
    enumerable: false,
    value: result,
    configurable: true,
    writable: true
  }); // Places Symbol.iterator or @@iterator on the prototype
  // so that this can be iterated with for/of and canReflect.eachIndex

  var iteratorSymbol = Symbol.iterator || Symbol.for("iterator");

  if (!typePrototype[iteratorSymbol]) {
    defineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function () {
      return new _define.Iterator(this);
    });
  }

  return result;
};

var onlyType = function onlyType(obj) {
  for (var prop in obj) {
    if (prop !== "type") {
      return false;
    }
  }

  return true;
};

var callAsync = function callAsync(fn) {
  return function asyncResolver(lastSet, resolve) {
    var newValue = fn.call(this, resolve, lastSet); // This should really be happening in can-simple-observable/async/
    // But that would be a breaking change so putting it here.

    if (canReflect.isPromise(newValue)) {
      newValue.then(resolve);
      return undefined;
    }

    return newValue;
  };
};

_define.extensions = function () {};

_define.isEnumerable = function (definition) {
  return _typeof(definition) !== "object" || ("serialize" in definition ? !!definition.serialize : !definition.get && !definition.async && !definition.value);
}; // typePrototype - the prototype of the type we are defining `prop` on.
// `definition` - the user provided definition


_define.property = function (typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {
  var propertyDefinition = _define.extensions.apply(this, arguments);

  if (propertyDefinition) {
    definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);
  }

  var type = definition.type; //!steal-remove-start

  if (true) {
    if (!definition.set && definition.get && definition.get.length === 0 && "default" in definition) {
      canLogDev.warn("can-observable-object: default value for property " + canReflect.getName(typePrototype) + "." + prop + " ignored, as its definition has a zero-argument getter and no setter");
    }

    if (!definition.set && definition.get && definition.get.length === 0 && definition.type && definition.type !== defaultDefinition.type) {
      canLogDev.warn("can-observable-object: type value for property " + canReflect.getName(typePrototype) + "." + prop + " ignored, as its definition has a zero-argument getter and no setter");
    }
  }

  for (var _i = 0, _arr = ['get', 'set', 'value']; _i < _arr.length; _i++) {
    var defFuncProp = _arr[_i];

    var propType = definition[defFuncProp] && _typeof(definition[defFuncProp]);

    if (propType && propType !== 'function') {
      canLogDev.error("can-observable-object: \"".concat(defFuncProp, "\" for property ").concat(canReflect.getName(typePrototype), ".").concat(prop) + " is expected to be a function, but it's a ".concat(propType, "."));
      return;
    }
  } //!steal-remove-end
  // Special case definitions that have only `type: "*"`.


  if (type && onlyType(definition) && type === type.Any) {
    Object_defineNamedPrototypeProperty(typePrototype, prop, {
      get: make.get.data(prop),
      set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
      enumerable: true,
      configurable: true
    });
    return;
  }

  definition.type = type; // Where the value is stored.  If there is a `get` the source of the value
  // will be a compute in `this._computed[prop]`.  If not, the source of the
  // value will be in `this._data[prop]`.

  var dataProperty = definition.get || definition.async || definition.value ? "computed" : "data",
      // simple functions that all read/get/set to the right place.
  // - reader - reads the value but does not observe.
  // - getter - reads the value and notifies observers.
  // - setter - sets the value.
  reader = make.read[dataProperty](prop),
      getter = make.get[dataProperty](prop),
      setter = make.set[dataProperty](prop),
      getInitialValue; //!steal-remove-start

  if (true) {
    if (definition.get) {
      Object.defineProperty(definition.get, "name", {
        value: canReflect.getName(typePrototype) + "'s " + prop + " getter",
        configurable: true
      });
    }

    if (definition.set) {
      Object.defineProperty(definition.set, "name", {
        value: canReflect.getName(typePrototype) + "'s " + prop + " setter",
        configurable: true
      });
    }

    if (definition.value) {
      Object.defineProperty(definition.value, "name", {
        value: canReflect.getName(typePrototype) + "'s " + prop + " value",
        configurable: true
      });
    }
  } //!steal-remove-end
  // Determine the type converter


  var typeConvert = function typeConvert(val) {
    return val;
  };

  if (type) {
    typeConvert = make.set.type(prop, type, typeConvert);
  } // make a setter that's going to fire of events


  var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));

  if (definition.value) {
    computedInitializers[prop] = make.resolver(prop, definition, typeConvert);
  } // Determine a function that will provide the initial property value.
  else if (definition.default !== undefined) {
      //!steal-remove-start
      if (true) {
        // If value is an object or array, give a warning
        if (definition.default !== null && _typeof(definition.default) === 'object') {
          canLogDev.warn("can-observable-object: The default value for " + canReflect.getName(typePrototype) + "." + prop + " is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.");
        } // If value is a constructor, give a warning


        if (definition.default && canReflect.isConstructorLike(definition.default)) {
          canLogDev.warn("can-observable-object: The \"default\" for " + canReflect.getName(typePrototype) + "." + prop + " is set to a constructor. Did you mean \"Default\" instead?");
        }
      } //!steal-remove-end


      getInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
    } // If property has a getter, create the compute that stores its data.


  if (definition.get) {
    computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
  } else if (definition.async) {
    computedInitializers[prop] = make.compute(prop, callAsync(definition.async), getInitialValue);
  } // If the property isn't a getter, but has an initial value, setup a
  // default value on `this._data[prop]`.
  else if (getInitialValue) {
      dataInitializers[prop] = getInitialValue;
    } // Define setter behavior.
  // If there's a `get` and `set`, make the setter get the `lastSetValue` on the
  // `get`'s compute.


  if (definition.get && definition.set) {
    // the compute will set off events, so we can use the basic setter
    setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
  } // If there's a `set` and no `get`,
  else if (definition.set) {
      // Add `set` functionality to the eventSetter.
      setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
    } // If there's neither `set` or `get` or `value` (resolver)
    else if (dataProperty === "data") {
        // make a set that produces events.
        setter = eventsSetter;
      } // If there's zero-arg `get` but not `set`, warn on all sets in dev mode
      else if (definition.get && definition.get.length < 1) {
          setter = function setter() {
            //!steal-remove-start
            if (true) {
              canLogDev.warn("can-observable-object: Set value for property " + canReflect.getName(typePrototype) + "." + prop + " ignored, as its definition has a zero-argument getter and no setter");
            } //!steal-remove-end

          };
        } // Add type behavior to the setter.


  if (type) {
    setter = make.set.type(prop, type, setter);
  } // Define the property.


  Object_defineNamedPrototypeProperty(typePrototype, prop, {
    get: getter,
    set: setter,
    enumerable: _define.isEnumerable(definition),
    configurable: true
  });
};

_define.makeDefineInstanceKey = function (constructor) {
  constructor[Symbol.for("can.defineInstanceKey")] = function (property, value) {
    _define.hooks.finalizeClass(this);

    var defineResult = this.prototype._define;

    if (value && typeof value.value !== "undefined") {
      value.default = value.value;
      value.type = type.Any;
      delete value.value;
    }

    var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);

    if (definition && _typeof(definition) === "object") {
      _define.property(this.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);

      defineResult.definitions[property] = definition;
    } else {
      defineResult.methods[property] = definition;
    }

    this.prototype.dispatch({
      action: "can.keys",
      type: "can.keys",
      target: this.prototype
    });
  };
}; // Makes a simple constructor function.


_define.Constructor = function (defines, sealed) {
  var constructor = function DefineConstructor(props) {
    Object.defineProperty(this, inSetupSymbol, {
      configurable: true,
      enumerable: false,
      value: true,
      writable: true
    });

    _define.setup.call(this, props, sealed);

    this[inSetupSymbol] = false;
  };

  var result = _define(constructor.prototype, defines);

  addTypeEvents(constructor);

  _define.makeDefineInstanceKey(constructor, result);

  return constructor;
}; // A bunch of helper functions that are used to create various behaviors.


make = {
  computeObj: function computeObj(map, prop, observable) {
    var computeObj = {
      oldValue: undefined,
      compute: observable,
      count: 0,
      handler: function handler(newVal) {
        var oldValue = computeObj.oldValue;
        computeObj.oldValue = newVal;
        map.dispatch({
          action: "prop",
          key: prop,
          value: newVal,
          oldValue: oldValue,
          type: prop,
          target: map
        }, [newVal, oldValue]);
      }
    };
    return computeObj;
  },
  resolver: function resolver(prop, definition, typeConvert) {
    var getDefault = make.get.defaultValue(prop, definition, typeConvert);
    return function () {
      var map = this;
      var defaultValue = getDefault.call(this);
      var computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue, {
        resetUnboundValueInGet: true
      })); //!steal-remove-start

      if (true) {
        Object.defineProperty(computeObj.handler, "name", {
          value: canReflect.getName(definition.value).replace('value', 'event emitter')
        });
      } //!steal-remove-end


      return computeObj;
    };
  },
  // Returns a function that creates the `_computed` prop.
  compute: function compute(prop, get, defaultValueFn) {
    return function () {
      var map = this;
      var defaultValue = defaultValueFn && defaultValueFn.call(this);
      var observable, computeObj;

      if (get.length === 0) {
        observable = new Observation(get, map);
      } else if (get.length === 1) {
        observable = new SettableObservable(get, map, defaultValue);
      } else {
        observable = new AsyncObservable(get, map, defaultValue);
      }

      computeObj = make.computeObj(map, prop, observable); //!steal-remove-start

      if (true) {
        Object.defineProperty(computeObj.handler, "name", {
          value: canReflect.getName(get).replace('getter', 'event emitter')
        });
      } //!steal-remove-end


      return computeObj;
    };
  },
  // Set related helpers.
  set: {
    data: function data(prop) {
      return function (newVal) {
        this._data[prop] = newVal;
      };
    },
    computed: function computed(prop) {
      return function (val) {
        canReflect.setValue(this._computed[prop].compute, val);
      };
    },
    events: function events(prop, getCurrent, setData
    /*, eventType*/
    ) {
      return function (newVal) {
        if (this[inSetupSymbol]) {
          setData.call(this, newVal);
        } else {
          var current = getCurrent.call(this);

          if (newVal !== current) {
            var dispatched;
            setData.call(this, newVal);
            dispatched = {
              patches: [{
                type: "set",
                key: prop,
                value: newVal
              }],
              action: "prop",
              key: prop,
              value: newVal,
              oldValue: current,
              type: prop,
              target: this
            }; //!steal-remove-start

            if (true) {
              dispatched.reasonLog = [canReflect.getName(this) + "'s", prop, "changed to", newVal, "from", current];
            } //!steal-remove-end


            this.dispatch(dispatched, [newVal, current]);
          }
        }
      };
    },
    eventDispatcher: function eventDispatcher(map, prop, current, newVal) {
      if (map[inSetupSymbol]) {
        return;
      } else {
        if (newVal !== current) {
          var dispatched = {
            patches: [{
              type: "set",
              key: prop,
              value: newVal
            }],
            action: "prop",
            key: prop,
            value: newVal,
            oldValue: current,
            type: prop,
            target: map
          }; //!steal-remove-start

          if (true) {
            dispatched.reasonLog = [canReflect.getName(this) + "'s", prop, "changed to", newVal, "from", current];
          } //!steal-remove-end


          eventQueue.dispatch.call(map, dispatched, [newVal, current]);
        }
      }
    },
    setter: function setter(prop, _setter, getCurrent, setEvents, hasGetter) {
      return function (value) {
        //!steal-remove-start
        var asyncTimer; //!steal-remove-end

        var self = this; // call the setter, if returned value is undefined,
        // this means the setter is async so we
        // do not call update property and return right away

        queues.batch.start();

        var setterCalled = false,
            current = getCurrent.call(this),
            setValue = _setter.call(this, value, current);

        if (setterCalled) {
          queues.batch.stop();
        } else {
          if (hasGetter) {
            // we got a return value
            if (setValue !== undefined) {
              // if the current `set` value is returned, don't set
              // because current might be the `lastSetVal` of the internal compute.
              if (current !== setValue) {
                setEvents.call(this, setValue);
              }

              queues.batch.stop();
            } // this is a side effect, it didn't take a value
            // so use the original set value
            else if (_setter.length === 0) {
                setEvents.call(this, value);
                queues.batch.stop();
                return;
              } // it took a value
              else if (_setter.length === 1) {
                  // if we have a getter, and undefined was returned,
                  // we should assume this is setting the getters properties
                  // and we shouldn't do anything.
                  queues.batch.stop();
                } // we are expecting something
                else {
                    //!steal-remove-start
                    if (true) {
                      asyncTimer = setTimeout(function () {
                        canLogDev.warn('can-observable-object: Setter "' + canReflect.getName(self) + "." + prop + '" did not return a value or call the setter callback.');
                      }, canLogDev.warnTimeout);
                    } //!steal-remove-end


                    queues.batch.stop();
                    return;
                  }
          } else {
            // we got a return value
            if (setValue !== undefined) {
              // if the current `set` value is returned, don't set
              // because current might be the `lastSetVal` of the internal compute.
              setEvents.call(this, setValue);
              queues.batch.stop();
            } // this is a side effect, it didn't take a value
            // so use the original set value
            else if (_setter.length === 0) {
                setEvents.call(this, value);
                queues.batch.stop();
                return;
              } // it took a value
              else if (_setter.length === 1) {
                  // if we don't have a getter, we should probably be setting the
                  // value to undefined
                  setEvents.call(this, undefined);
                  queues.batch.stop();
                } // we are expecting something
                else {
                    //!steal-remove-start
                    if (true) {
                      asyncTimer = setTimeout(function () {
                        canLogDev.warn('can/map/setter.js: Setter "' + canReflect.getName(self) + "." + prop + '" did not return a value or call the setter callback.');
                      }, canLogDev.warnTimeout);
                    } //!steal-remove-end


                    queues.batch.stop();
                    return;
                  }
          }
        }
      };
    },
    type: function type(prop, _type, set) {
      function setter(newValue) {
        return set.call(this, _type.call(this, newValue, prop));
      }

      if (isDefineType(_type)) {
        // TODO: remove this `canDefineType` check in a future release.
        if (_type.canDefineType) {
          return setter;
        } else {
          return function setter(newValue) {
            //!steal-remove-start
            if (true) {
              try {
                return set.call(this, canReflect.convert(newValue, _type));
              } catch (error) {
                if (error.type === 'can-type-error') {
                  var typeName = canReflect.getName(_type[baseTypeSymbol]);

                  var valueType = _typeof(newValue);

                  var message = '"' + newValue + '"' + ' (' + valueType + ') is not of type ' + typeName + '. Property ' + prop + ' is using "type: ' + typeName + '". ';
                  message += 'Use "' + prop + ': type.convert(' + typeName + ')" to automatically convert values to ' + typeName + 's when setting the "' + prop + '" property.';
                  error.message = message;
                }

                throw error;
              }
            } //!steal-remove-end


            return set.call(this, canReflect.convert(newValue, _type));
          };
        }
      }

      return setter;
    }
  },
  // Helpes that indicate what the event type should be.  These probably aren't needed.
  eventType: {
    data: function data(prop) {
      return function (newVal, oldVal) {
        return oldVal !== undefined || this._data.hasOwnProperty(prop) ? "set" : "add";
      };
    },
    computed: function computed() {
      return function () {
        return "set";
      };
    }
  },
  // Helpers that read the data in a non-observable way.
  read: {
    data: function data(prop) {
      return function () {
        return this._data[prop];
      };
    },
    computed: function computed(prop) {
      // might want to protect this
      return function () {
        return canReflect.getValue(this._computed[prop].compute);
      };
    },
    lastSet: function lastSet(prop) {
      return function () {
        var observable = this._computed[prop].compute;

        if (observable.lastSetValue) {
          return canReflect.getValue(observable.lastSetValue);
        }
      };
    }
  },
  // Helpers that read the data in an observable way.
  get: {
    // uses the default value
    defaultValue: function defaultValue(prop, definition, typeConvert, callSetter) {
      return function () {
        var value = definition.default;

        if (value !== undefined) {
          // call `get default() { ... }` but not `default() { ... }`
          if (typeof value === "function" && value.isAGetter) {
            value = value.call(this);
          }

          value = typeConvert.call(this, value);
        }

        if (definition.set) {
          // TODO: there's almost certainly a faster way of making this happen
          // But this is maintainable.
          var VALUE;
          var sync = true;
          var setter = make.set.setter(prop, definition.set, function () {}, function (value) {
            if (sync) {
              VALUE = value;
            } else {
              callSetter.call(this, value);
            }
          }, definition.get);
          setter.call(this, value);
          sync = false; // VALUE will be undefined if the callback is never called.

          return VALUE;
        }

        return value;
      };
    },
    data: function data(prop) {
      return function () {
        if (!this[inSetupSymbol]) {
          ObservationRecorder.add(this, prop);
        }

        return this._data[prop];
      };
    },
    computed: function computed(prop) {
      return function ()
      /*val*/
      {
        var compute = this._computed[prop].compute;

        if (ObservationRecorder.isRecording()) {
          ObservationRecorder.add(this, prop);

          if (!canReflect.isBound(compute)) {
            Observation.temporarilyBind(compute);
          }
        }

        return peek(compute);
      };
    }
  }
};
_define.behaviors = ["get", "set", "value", "type", "serialize"]; // This cleans up a particular behavior and adds it to the definition

var addBehaviorToDefinition = function addBehaviorToDefinition(definition, behavior, descriptor, def, prop, typePrototype) {
  if (behavior === "enumerable") {
    // treat enumerable like serialize
    definition.serialize = !!def[behavior];
  } else if (behavior === "type") {
    var behaviorDef = def[behavior];

    if (typeof behaviorDef !== 'undefined') {
      definition[behavior] = behaviorDef;
    }
  } else {
    // This is a good place to do warnings? This gets called for every behavior
    // Both by .define() and .property()
    var value = descriptor.get || descriptor.value;

    if (descriptor.get) {
      value.isAGetter = true;
    }

    if (behavior === "async") {
      if (value.length === 1 && isAsyncFunction(value)) {
        canLogDev.warn("".concat(canReflect.getName(typePrototype), ": async property [").concat(prop, "] should not be an async function and also use the resolve() argument. Remove the argument and return a value from the async function instead."));
      }
    }

    definition[behavior] = value;
  }
}; // This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)
// Currently, this is adding default behavior
// copying `type` over, and even cleaning up the final definition object


makeDefinition = function makeDefinition(prop, def, defaultDefinition, typePrototype) {
  var definition = {};
  eachPropertyDescriptor(def, function (behavior, descriptor) {
    addBehaviorToDefinition(definition, behavior, descriptor, def, prop, typePrototype);
  }); // only add default if it doesn't exist

  canReflect.eachKey(defaultDefinition, function (value, prop) {
    if (definition[prop] === undefined) {
      if (prop !== "type") {
        definition[prop] = value;
      }
    }
  });

  if (def.type) {
    var value = def.type;
    var serialize = value[serializeSymbol];

    if (serialize) {
      definition.serialize = function (val) {
        return serialize.call(val);
      };
    }

    definition.type = type.normalize(value);
  }

  var noTypeDefined = !definition.type && (!defaultDefinition.type || defaultDefinition.type && defaultDefinition.typeSetByDefault);

  if (definition.hasOwnProperty("default")) {
    if (typeof definition.default === "function" && !definition.default.isAGetter && noTypeDefined) {
      definition.type = type.normalize(Function);
    }

    if (canReflect.isPrimitive(definition.default) && noTypeDefined) {
      if (definition.default === null || typeof definition.default === 'undefined') {
        definition.type = type.Any;
      } else {
        definition.type = type.normalize(definition.default.constructor);
      }
    }
  } // if there's no type definition, take it from the defaultDefinition


  if (!definition.type) {
    var defaultsCopy = canReflect.assignMap({}, defaultDefinition);
    definition = canReflect.assignMap(defaultsCopy, definition);
  }

  if (canReflect.size(definition) === 0) {
    definition.type = type.Any; // `setByDefault` indicates that the default type can be
    // overridden by an inferred type

    definition.typeSetByDefault = true;
  }

  return definition;
}; // called by `can.defineInstanceKey` and `getDefinitionsAndMethods`
// returns the value or the definition object.
// calls makeDefinition
// This is dealing with a string value


getDefinitionOrMethod = function getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype) {
  // Clean up the value to make it a definition-like object
  var definition;
  var definitionType;

  if (canReflect.isPrimitive(value)) {
    if (value === null || typeof value === 'undefined') {
      definitionType = type.Any;
    } else {
      // only include type from defaultDefininition
      // if it came from propertyDefaults
      definitionType = defaultDefinition.typeSetByDefault ? type.normalize(value.constructor) : defaultDefinition.type;
    }

    definition = {
      default: value,
      type: definitionType
    };
  } // copies a `Type`'s methods over
  else if (value && (value[serializeSymbol] || value[newSymbol])) {
      if (value[isMemberSymbol]) {
        definition = {
          type: value
        };
      } else {
        definition = {
          type: type.normalize(value)
        };
      }
    } else if (typeof value === "function") {
      if (canReflect.isConstructorLike(value)) {
        definition = {
          type: type.normalize(value)
        };
      } else {
        definition = {
          default: value,
          type: Function
        };
      }
    } else if (Array.isArray(value)) {
      definition = {
        type: type.normalize(Array)
      };
    } else if (canReflect.isPlainObject(value)) {
      definition = value;
    }

  if (definition) {
    return makeDefinition(prop, definition, defaultDefinition, typePrototype);
  } else {
    return value;
  }
}; // called by can.define


getDefinitionsAndMethods = function getDefinitionsAndMethods(defines, baseDefines, typePrototype, propertyDefaults) {
  // make it so the definitions include base definitions on the proto
  var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
  var methods = {}; // first lets get a default if it exists

  var defaultDefinition;

  if (propertyDefaults) {
    defaultDefinition = getDefinitionOrMethod("*", propertyDefaults, {}, typePrototype);
  } else {
    defaultDefinition = Object.create(null);
  }

  function addDefinition(prop, propertyDescriptor, skipGetDefinitionForMethods) {
    var value;

    if (propertyDescriptor.get || propertyDescriptor.set) {
      value = {
        get: propertyDescriptor.get,
        set: propertyDescriptor.set
      };
    } else {
      value = propertyDescriptor.value;
    }

    if (prop === "constructor" || skipGetDefinitionForMethods && typeof value === "function") {
      methods[prop] = value;
      return;
    } else {
      var result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);

      var resultType = _typeof(result);

      if (result && resultType === "object" && canReflect.size(result) > 0) {
        definitions[prop] = result;
      } else {
        // Removed adding raw values that are not functions
        if (resultType === "function") {
          methods[prop] = result;
        } //!steal-remove-start
        else if (resultType !== 'undefined') {
            if (true) {
              // Ex: {prop: 0}
              canLogDev.error(canReflect.getName(typePrototype) + "." + prop + " does not match a supported definitionObject. See: https://canjs.com/doc/can-observable-object/object.types.definitionObject.html");
            }
          } //!steal-remove-end

      }
    }
  }

  eachPropertyDescriptor(typePrototype, addDefinition, true);
  eachPropertyDescriptor(defines, addDefinition);

  if (propertyDefaults) {
    // we should move this property off the prototype.
    defineConfigurableAndNotEnumerable(defines, "*", propertyDefaults);
  }

  return {
    definitions: definitions,
    methods: methods,
    defaultDefinition: defaultDefinition
  };
};

eventsProto = eventQueue({});

function setupComputed(instance, eventName) {
  var computedBinding = instance._computed && instance._computed[eventName];

  if (computedBinding && computedBinding.compute) {
    if (!computedBinding.count) {
      computedBinding.count = 1;
      canReflect.onValue(computedBinding.compute, computedBinding.handler, "notify");
      computedBinding.oldValue = peek(computedBinding.compute);
    } else {
      computedBinding.count++;
    }
  }
}

function teardownComputed(instance, eventName) {
  var computedBinding = instance._computed && instance._computed[eventName];

  if (computedBinding) {
    if (computedBinding.count === 1) {
      computedBinding.count = 0;
      canReflect.offValue(computedBinding.compute, computedBinding.handler, "notify");
    } else {
      computedBinding.count--;
    }
  }
}

assign(eventsProto, {
  _eventSetup: function _eventSetup() {},
  _eventTeardown: function _eventTeardown() {},
  addEventListener: function addEventListener(eventName
  /*, handler, queue*/
  ) {
    setupComputed(this, eventName);
    return eventQueue.addEventListener.apply(this, arguments);
  },
  // ### unbind
  // Stops listening to an event.
  // If this is the last listener of a computed property,
  // stop forwarding events of the computed property to this map.
  removeEventListener: function removeEventListener(eventName
  /*, handler*/
  ) {
    teardownComputed(this, eventName);
    return eventQueue.removeEventListener.apply(this, arguments);
  }
});
eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
var onKeyValueSymbol = Symbol.for("can.onKeyValue");
var offKeyValueSymbol = Symbol.for("can.offKeyValue");
canReflect.assignSymbols(eventsProto, {
  "can.onKeyValue": function canOnKeyValue(key) {
    setupComputed(this, key);
    return eventQueue[onKeyValueSymbol].apply(this, arguments);
  },
  "can.offKeyValue": function canOffKeyValue(key) {
    teardownComputed(this, key);
    return eventQueue[offKeyValueSymbol].apply(this, arguments);
  }
});
delete eventsProto.one;

_define.finalizeInstance = function () {
  defineNotWritableAndNotEnumerable(this, "constructor", this.constructor);
  defineNotWritableAndNotEnumerable(this, canMetaSymbol, Object.create(null));
};

_define.setup = function (props, sealed) {
  var requiredButNotProvided = new Set(this._define.required);
  var definitions = this._define.definitions;
  var instanceDefinitions = Object.create(null);
  var map = this;
  canReflect.eachKey(props, function (value, prop) {
    if (requiredButNotProvided.has(prop)) {
      requiredButNotProvided.delete(prop);
    }

    if (definitions[prop] !== undefined) {
      map[prop] = value;
    } else {
      if (sealed) {
        throw new Error("The type ".concat(canReflect.getName(map.constructor), " is sealed, but the property [").concat(prop, "] has no definition."));
      }

      _define.expando(map, prop, value);
    }
  });

  if (canReflect.size(instanceDefinitions) > 0) {
    defineConfigurableAndNotEnumerable(this, "_instanceDefinitions", instanceDefinitions);
  }

  if (requiredButNotProvided.size) {
    var msg;
    var missingProps = Array.from(requiredButNotProvided);
    var thisName = canReflect.getName(this);

    if (requiredButNotProvided.size === 1) {
      msg = "".concat(thisName, ": Missing required property [").concat(missingProps[0], "].");
    } else {
      msg = "".concat(thisName, ": Missing required properties [").concat(missingProps.join(", "), "].");
    }

    throw new Error(msg);
  }
};

var returnFirstArg = function returnFirstArg(arg) {
  return arg;
}; // TODO Why is this exported, does it need to be?


_define.normalizeTypeDefinition = type.normalize;

_define.expando = function (map, prop, value) {
  if (_define._specialKeys[prop]) {
    // ignores _data and _computed
    return true;
  } // first check if it's already a constructor define


  var constructorDefines = map._define.definitions;

  if (constructorDefines && constructorDefines[prop]) {
    return;
  } // next if it's already on this instances


  var instanceDefines = map._instanceDefinitions;

  if (!instanceDefines) {
    if (Object.isSealed(map)) {
      var errorMessage = "Cannot set property [".concat(prop, "] on sealed instance of ").concat(canReflect.getName(map));
      throw new Error(errorMessage);
    }

    Object.defineProperty(map, "_instanceDefinitions", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: {}
    });
    instanceDefines = map._instanceDefinitions;
  }

  if (!instanceDefines[prop]) {
    var defaultDefinition = map._define.defaultDefinition || {
      type: observableType
    };

    _define.property(map, prop, defaultDefinition, {}, {}); // possibly convert value to List or DefineMap


    if (defaultDefinition.type) {
      map._data[prop] = _define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);
    } else {
      map._data[prop] = observableType(value);
    }

    instanceDefines[prop] = defaultDefinition;

    if (!map[inSetupSymbol]) {
      queues.batch.start();
      map.dispatch({
        action: "can.keys",
        type: "can.keys",
        target: map
      });

      if (Object.prototype.hasOwnProperty.call(map._data, prop)) {
        map.dispatch({
          action: "add",
          key: prop,
          type: prop,
          value: map._data[prop],
          target: map,
          patches: [{
            type: "add",
            key: prop,
            value: map._data[prop]
          }]
        }, [map._data[prop], undefined]);
      } else {
        map.dispatch({
          action: "set",
          type: "set",
          value: map._data[prop],
          target: map,
          patches: [{
            type: "add",
            key: prop,
            value: map._data[prop]
          }]
        }, [map._data[prop], undefined]);
      }

      queues.batch.stop();
    }

    return true;
  }
};

_define.replaceWith = defineLazyValue;
_define.eventsProto = eventsProto;
_define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
_define.make = make;
_define.getDefinitionOrMethod = getDefinitionOrMethod;
_define._specialKeys = {
  _data: true,
  _computed: true
};
var simpleGetterSetters = {};

_define.makeSimpleGetterSetter = function (prop) {
  if (simpleGetterSetters[prop] === undefined) {
    var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
    simpleGetterSetters[prop] = {
      get: make.get.data(prop),
      set: function set(newVal) {
        return setter.call(this, observableType(newVal));
      },
      enumerable: true,
      configurable: true
    };
  }

  return simpleGetterSetters[prop];
};

_define.Iterator = function (obj) {
  this.obj = obj;
  this.definitions = Object.keys(obj._define.definitions);
  this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
  this.hasGet = typeof obj.get === "function";
};

_define.Iterator.prototype.next = function () {
  var key;

  if (this.definitions.length) {
    key = this.definitions.shift(); // Getters should not be enumerable

    var def = this.obj._define.definitions[key];

    if (def.get) {
      return this.next();
    }
  } else if (this.instanceDefinitions.length) {
    key = this.instanceDefinitions.shift();
  } else {
    return {
      value: undefined,
      done: true
    };
  }

  return {
    value: [key, this.hasGet ? this.obj.get(key) : this.obj[key]],
    done: false
  };
};

_define.updateSchemaKeys = function (schema, definitions) {
  for (var prop in definitions) {
    var definition = definitions[prop];

    if (definition.serialize !== false) {
      if (definition.type) {
        schema.keys[prop] = definition.type;
      } else {
        schema.keys[prop] = function (val) {
          return val;
        };
      } // some unknown type


      if (definitions[prop].identity === true) {
        schema.identity.push(prop);
      }
    }
  }

  return schema;
};

_define.hooks = {
  finalizeClass: function finalizeClass(Type) {
    var hasBeenDefined = Type.hasOwnProperty(hasBeenDefinedSymbol);

    if (!hasBeenDefined) {
      var prototypeObject = Type.prototype; // check for `static props = {}`
      // fall back to `static define = {}` if `props` doesn't exist

      var defines = _typeof(Type.props) === "object" ? Type.props : _typeof(Type.define) === "object" ? Type.define : {};

      _define(prototypeObject, defines, null, Type.propertyDefaults);

      Type[hasBeenDefinedSymbol] = true;
    }
  },
  initialize: function initialize(instance, props) {
    var firstInitialize = !instance.hasOwnProperty(canMetaSymbol);
    var sealed = instance.constructor.seal;

    if (firstInitialize) {
      _define.finalizeInstance.call(instance);
    }

    if (!instance[canMetaSymbol].initialized) {
      defineConfigurableAndNotEnumerable(instance, inSetupSymbol, true);

      _define.setup.call(instance, props, sealed); // set inSetup to false so events can be dispatched


      instance[inSetupSymbol] = false; // set instance as initialized so this is only called once

      instance[canMetaSymbol].initialized = true;
    } // only seal in dev mode for performance reasons.
    //!steal-remove-start


    if (true) {
      // only seal the first time initialize is called
      // even if meta.initialized is reset to false
      if (firstInitialize) {
        /* jshint -W030 */
        instance._data;
        instance._computed;

        if (sealed === true) {
          Object.seal(instance);
        }
      }
    } //!steal-remove-end

  },
  expando: _define.expando,
  normalizeTypeDefinition: type.normalize //define.normalizeTypeDefinition

};

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/ensure-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/ensure-meta.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js"); // Ensure the "obj" passed as an argument has an object on @@can.meta


module.exports = function ensureMeta(obj) {
  var metaSymbol = Symbol.for("can.meta");
  var meta = obj[metaSymbol];

  if (!meta) {
    meta = {};
    canReflect.setKeyValue(obj, metaSymbol, meta);
  }

  return meta;
};

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-element.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-element.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(/*! ./define */ "./node_modules/can-observable-mixin/dist/define.js"),
    hooks = _require.hooks,
    makeDefineInstanceKey = _require.makeDefineInstanceKey;

var mixinMapProps = __webpack_require__(/*! ./mixin-mapprops */ "./node_modules/can-observable-mixin/dist/mixin-mapprops.js");

var mixinProxy = __webpack_require__(/*! ./mixin-proxy */ "./node_modules/can-observable-mixin/dist/mixin-proxy.js");

var mixinTypeEvents = __webpack_require__(/*! ./mixin-typeevents */ "./node_modules/can-observable-mixin/dist/mixin-typeevents.js");

var constructorPropsSymbol = Symbol.for("can.constructorProps");
var renderedSymbol = Symbol.for("can.rendered");

module.exports = function mixinElement(BaseElement) {
  var Element = /*#__PURE__*/function (_mixinProxy) {
    _inherits(Element, _mixinProxy);

    var _super = _createSuper(Element);

    function Element(props) {
      var _this;

      _classCallCheck(this, Element);

      _this = _super.call(this);
      hooks.finalizeClass(_this.constructor);
      _this[constructorPropsSymbol] = props;
      return _this;
    }

    _createClass(Element, [{
      key: "initialize",
      value: function initialize(props) {
        if (_get(_getPrototypeOf(Element.prototype), "initialize", this)) {
          _get(_getPrototypeOf(Element.prototype), "initialize", this).call(this, props);
        }

        hooks.initialize(this, props || this[constructorPropsSymbol]);
      }
    }, {
      key: "render",
      value: function render(props) {
        if (_get(_getPrototypeOf(Element.prototype), "render", this)) {
          _get(_getPrototypeOf(Element.prototype), "render", this).call(this, props);
        }

        hooks.initialize(this, props || this[constructorPropsSymbol]);
        this[renderedSymbol] = true;
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (_get(_getPrototypeOf(Element.prototype), "connectedCallback", this)) {
          _get(_getPrototypeOf(Element.prototype), "connectedCallback", this).call(this);
        }

        if (!this[renderedSymbol]) {
          this.render();
        }
      }
    }]);

    return Element;
  }(mixinProxy(BaseElement));

  Element = mixinTypeEvents(mixinMapProps(Element));
  makeDefineInstanceKey(Element);
  return Element;
};

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-mapprops.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-mapprops.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var addDefinedProps = __webpack_require__(/*! ./define */ "./node_modules/can-observable-mixin/dist/define.js");

var updateSchemaKeys = addDefinedProps.updateSchemaKeys,
    hooks = addDefinedProps.hooks,
    isEnumerable = addDefinedProps.isEnumerable;

var defineHelpers = __webpack_require__(/*! ./define-helpers */ "./node_modules/can-observable-mixin/dist/define-helpers.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var getSchemaSymbol = Symbol.for("can.getSchema");

function keysForDefinition(definitions) {
  var keys = [];

  for (var prop in definitions) {
    if (isEnumerable(definitions[prop])) {
      keys.push(prop);
    }
  }

  return keys;
}

function _assign(source) {
  queues.batch.start();
  canReflect.assignMap(this, source || {});
  queues.batch.stop();
}

function _update(source) {
  queues.batch.start();

  if (canReflect.isListLike(source)) {
    canReflect.updateList(this, source);
  } else {
    canReflect.updateMap(this, source || {});
  }

  queues.batch.stop();
}

function _assignDeep(source) {
  queues.batch.start(); // TODO: we should probably just throw an error instead of cleaning

  canReflect.assignDeepMap(this, source || {});
  queues.batch.stop();
}

function _updateDeep(source) {
  queues.batch.start();

  if (canReflect.isListLike(source)) {
    canReflect.updateDeepList(this, source);
  } else {
    // TODO: we should probably just throw an error instead of cleaning
    canReflect.updateDeepMap(this, source || {});
  }

  queues.batch.stop();
}

function setKeyValue(key, value) {
  var defined = defineHelpers.defineExpando(this, key, value);

  if (!defined) {
    this[key] = value;
  }
}

function getKeyValue(key) {
  var value = this[key];

  if (value !== undefined || key in this || Object.isSealed(this)) {
    return value;
  } else {
    ObservationRecorder.add(this, key);
    return this[key];
  }
}

module.exports = function (Type) {
  return /*#__PURE__*/function (_Type) {
    _inherits(_class, _Type);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "get",
      value: function get(prop) {
        if (prop) {
          return getKeyValue.call(this, prop);
        } else {
          return canReflect.unwrap(this, Map);
        }
      }
    }, {
      key: "set",
      value: function set(prop, value) {
        if (_typeof(prop) === "object") {
          //!steal-remove-start
          if (true) {
            canLogDev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');
          } //!steal-remove-end


          if (value === true) {
            _updateDeep.call(this, prop);
          } else {
            _assignDeep.call(this, prop);
          }
        } else {
          setKeyValue.call(this, prop, value);
        }

        return this;
      }
    }, {
      key: "assignDeep",
      value: function assignDeep(prop) {
        _assignDeep.call(this, prop);

        return this;
      }
    }, {
      key: "updateDeep",
      value: function updateDeep(prop) {
        _updateDeep.call(this, prop);

        return this;
      }
    }, {
      key: "assign",
      value: function assign(prop) {
        _assign.call(this, prop);

        return this;
      }
    }, {
      key: "update",
      value: function update(prop) {
        _update.call(this, prop);

        return this;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        return canReflect.serialize(this, Map);
      }
    }, {
      key: "deleteKey",
      value: function deleteKey() {
        return defineHelpers.deleteKey.apply(this, arguments);
      }
    }, {
      key: "forEach",
      value: function forEach(cb, thisarg, observe) {
        function forEach(list, cb, thisarg) {
          return canReflect.eachKey(list, cb, thisarg);
        }

        if (observe === false) {
          ObservationRecorder.ignore(forEach)(this, cb, thisarg);
        } else {
          return forEach(this, cb, thisarg);
        }
      }
    }, {
      key: Symbol.for("can.getKeyValue"),
      value: function value() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return getKeyValue.apply(this, args);
      }
    }, {
      key: Symbol.for("can.deleteKeyValue"),
      value: function value() {
        var _defineHelpers$delete;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return (_defineHelpers$delete = defineHelpers.deleteKey).call.apply(_defineHelpers$delete, [this].concat(args));
      }
    }, {
      key: Symbol.for("can.getOwnKeys"),
      value: function value() {
        var keys = canReflect.getOwnEnumerableKeys(this);

        if (this._computed) {
          var computedKeys = canReflect.getOwnKeys(this._computed);
          var key;

          for (var i = 0; i < computedKeys.length; i++) {
            key = computedKeys[i];

            if (keys.indexOf(key) < 0) {
              keys.push(key);
            }
          }
        }

        return keys;
      }
    }, {
      key: Symbol.for("can.getOwnEnumerableKeys"),
      value: function value() {
        ObservationRecorder.add(this, 'can.keys');
        ObservationRecorder.add(Object.getPrototypeOf(this), 'can.keys');
        return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
      }
    }, {
      key: Symbol.for("can.serialize"),
      value: function value() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return defineHelpers.reflectSerialize.apply(this, args);
      }
    }, {
      key: Symbol.for("can.unwrap"),
      value: function value() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return defineHelpers.reflectUnwrap.apply(this, args);
      }
    }, {
      key: Symbol.for("can.hasKey"),
      value: function value(key) {
        return key in this._define.definitions || this._instanceDefinitions !== undefined && key in this._instanceDefinitions;
      }
    }, {
      key: Symbol.for("can.updateDeep"),
      value: function value() {
        return this.updateDeep.apply(this, arguments);
      }
    }, {
      key: Symbol.for("can.isMapLike"),
      get: function get() {
        return true;
      }
    }, {
      key: Symbol.for("can.isListLike"),
      get: function get() {
        return false;
      }
    }, {
      key: Symbol.for("can.isValueLike"),
      get: function get() {
        return false;
      }
    }], [{
      key: getSchemaSymbol,
      value: function value() {
        hooks.finalizeClass(this);
        var def = this.prototype._define;
        var definitions = def ? def.definitions : {};
        var schema = {
          type: "map",
          identity: [],
          keys: {}
        };
        return updateSchemaKeys(schema, definitions);
      }
    }, {
      key: Symbol.for("can.new"),
      value: function value() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return _construct(this, args);
      }
    }]);

    return _class;
  }(Type);
};

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-proxy.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-proxy.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defineBehavior = __webpack_require__(/*! ./define */ "./node_modules/can-observable-mixin/dist/define.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var eventDispatcher = defineBehavior.make.set.eventDispatcher;
var inSetupSymbol = canSymbol.for("can.initializing");

var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js"); // A bug in Safari means that __proto__ key is sent. This causes problems
// When addEventListener is called on a non-element.
// https://github.com/tc39/test262/pull/2203


var isProtoReadOnSuper = false;

(function () {
  if (typeof Proxy === "function") {
    var par = /*#__PURE__*/function () {
      function par() {
        _classCallCheck(this, par);
      }

      _createClass(par, [{
        key: "fn",
        value: function fn() {}
      }]);

      return par;
    }();

    var base = new Proxy(par, {
      get: function get(t, k, r) {
        if (k === "__proto__") {
          isProtoReadOnSuper = true;
        }

        return Reflect.get(t, k, r);
      }
    });

    var chi = /*#__PURE__*/function (_base) {
      _inherits(chi, _base);

      var _super = _createSuper(chi);

      function chi() {
        _classCallCheck(this, chi);

        return _super.apply(this, arguments);
      }

      _createClass(chi, [{
        key: "fn",
        value: function fn() {
          _get(_getPrototypeOf(chi.prototype), "fn", this).call(this);
        }
      }]);

      return chi;
    }(base);

    new chi().fn();
  }
})();

var wasLogged = false;

function logNotSupported() {
  if (!wasLogged && typeof Proxy !== "function") {
    wasLogged = true;
    canLogDev.warn("can-observable-mixin/mixin-proxy requires ES Proxies which are not supported by your JS runtime.");
  }
}

function proxyPrototype(Base) {
  var instances = new WeakSet();

  function LateDefined() {
    //!steal-remove-start
    if (true) {
      logNotSupported();
    } //!steal-remove-end


    var inst = Reflect.construct(Base, arguments, this instanceof LateDefined ? this.constructor : void 0);
    instances.add(inst);
    return inst;
  }

  LateDefined.instances = instances;
  var underlyingPrototypeObject = Object.create(Base.prototype);
  var getHandler = isProtoReadOnSuper ? function (target, key, receiver) {
    if (!this[inSetupSymbol] && _typeof(key) !== "symbol" && key !== "__proto__") {
      ObservationRecorder.add(receiver, key);
    }

    return Reflect.get(target, key, receiver);
  } : function (target, key, receiver) {
    if (!this[inSetupSymbol] && _typeof(key) !== "symbol") {
      ObservationRecorder.add(receiver, key);
    }

    return Reflect.get(target, key, receiver);
  };
  var proxyHandlers = {
    get: getHandler,
    set: function set(target, key, value, receiver) {
      // Symbols are not observable, so just set the value
      if (_typeof(key) === "symbol") {
        Reflect.set(target, key, value, receiver);
        return true;
      } // We decided to punt on making the prototype observable, so anything
      // set on a prototype just gets set.


      if (key in target || !instances.has(receiver)) {
        var current = Reflect.get(target, key, receiver);
        Reflect.set(target, key, value, receiver);
        eventDispatcher(receiver, key, current, value);
      } else {
        defineBehavior.expando(receiver, key, value);
      }

      return true;
    }
  };
  LateDefined.prototype = typeof Proxy === "function" ? new Proxy(underlyingPrototypeObject, proxyHandlers) : underlyingPrototypeObject;
  return LateDefined;
}

module.exports = proxyPrototype;

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-typeevents.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-typeevents.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");

var addMapEvents = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

function mixinTypeEvents(Type) {
  var Child = /*#__PURE__*/function (_Type) {
    _inherits(Child, _Type);

    var _super = _createSuper(Child);

    function Child() {
      _classCallCheck(this, Child);

      return _super.apply(this, arguments);
    }

    return Child;
  }(Type);

  addTypeEvents(Child);
  addMapEvents(Child);
  return Child;
}

module.exports = mixinTypeEvents;

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixins.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixins.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createConstructorFunction = __webpack_require__(/*! ./create-constructor-function */ "./node_modules/can-observable-mixin/dist/create-constructor-function.js");

var defineBehavior = __webpack_require__(/*! ./define */ "./node_modules/can-observable-mixin/dist/define.js");

var mixinElement = __webpack_require__(/*! ./mixin-element */ "./node_modules/can-observable-mixin/dist/mixin-element.js");

var mixinMapProps = __webpack_require__(/*! ./mixin-mapprops */ "./node_modules/can-observable-mixin/dist/mixin-mapprops.js");

var mixinProxy = __webpack_require__(/*! ./mixin-proxy */ "./node_modules/can-observable-mixin/dist/mixin-proxy.js");

var mixinTypeEvents = __webpack_require__(/*! ./mixin-typeevents */ "./node_modules/can-observable-mixin/dist/mixin-typeevents.js");

exports.createConstructorFunction = createConstructorFunction;
exports.makeDefineInstanceKey = defineBehavior.makeDefineInstanceKey;
exports.mixins = defineBehavior.hooks;
exports.mixinElement = mixinElement;
exports.mixinMapProps = mixinMapProps;
exports.mixinProxy = mixinProxy;
exports.mixinTypeEvents = mixinTypeEvents;

/***/ }),

/***/ "./node_modules/can-observable-object/dist/can-observable-object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-observable-object/dist/can-observable-object.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var _require = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    createConstructorFunction = _require.createConstructorFunction,
    makeDefineInstanceKey = _require.makeDefineInstanceKey,
    mixins = _require.mixins,
    mixinMapProps = _require.mixinMapProps,
    mixinProxy = _require.mixinProxy,
    mixinTypeEvents = _require.mixinTypeEvents;

var ObservableObject = /*#__PURE__*/function (_mixinProxy) {
  _inherits(ObservableObject, _mixinProxy);

  var _super = _createSuper(ObservableObject);

  function ObservableObject(props) {
    var _this;

    _classCallCheck(this, ObservableObject);

    _this = _super.call(this);
    mixins.finalizeClass(_this.constructor);
    mixins.initialize(_assertThisInitialized(_this), props); // Define class fields observables 
    //and return the proxy

    var proxiedInstance = new Proxy(_assertThisInitialized(_this), {
      defineProperty: function defineProperty(target, prop, descriptor) {
        var props = target.constructor.props;
        var value = descriptor.value; // do not create expando properties for special keys set by can-observable-mixin

        var specialKeys = ['_instanceDefinitions', '_data', '_computed'];

        if (specialKeys.indexOf(prop) >= 0) {
          return Reflect.defineProperty(target, prop, descriptor);
        }

        if (value) {
          // do not create expando properties for properties that are described
          // by `static props` or `static propertyDefaults`
          if (props && props[prop] || target.constructor.propertyDefaults) {
            target.set(prop, value);
            return true;
          } // create expandos to make all other properties observable


          return mixins.expando(target, prop, value);
        } // Prevent dispatching more than one event with canReflect.setKeyValue


        return Reflect.defineProperty(target, prop, descriptor);
      }
    }); // Adding the instance to observable-mixin 
    // prevents additional event dispatching 
    // https://github.com/canjs/can-observable-object/issues/35

    _this.constructor.instances.add(proxiedInstance);

    return _possibleConstructorReturn(_this, proxiedInstance);
  }

  return ObservableObject;
}(mixinProxy(Object));

ObservableObject = mixinTypeEvents(mixinMapProps(ObservableObject));
makeDefineInstanceKey(ObservableObject); // Export a constructor function to workaround an issue where ES2015 classes
// cannot be extended in code that's transpiled by Babel.

module.exports = namespace.ObservableObject = createConstructorFunction(ObservableObject);

/***/ }),

/***/ "./node_modules/can-observation-recorder/can-observation-recorder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-observation-recorder/can-observation-recorder.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

// Contains stack of observation records created by pushing with `.start`
// and popping with `.stop()`.
// The top of the stack is the "target" observation record - the record that calls
// to `ObservationRecorder.add` get added to.
var stack = [];

var addParentSymbol = canSymbol.for("can.addParent"),
	getValueSymbol = canSymbol.for("can.getValue");

var ObservationRecorder = {
	stack: stack,
	start: function(name) {
		var deps = {
			keyDependencies: new Map(),
			valueDependencies: new Set(),
			childDependencies: new Set(),

			// `traps` and `ignore` are here only for performance
			// reasons. They work with `ObservationRecorder.ignore` and `ObservationRecorder.trap`.
			traps: null,
			ignore: 0,
			name: name
		};

		stack.push(deps);

		return deps;
	},
	stop: function() {
		return stack.pop();
	},

	add: function(obj, event) {
		var top = stack[stack.length - 1];
		if (top && top.ignore === 0) {

			if (top.traps) {
				top.traps.push([obj, event]);
			} else {
				// Use `=== undefined` instead of `arguments.length` for performance.
				if (event === undefined) {
					top.valueDependencies.add(obj);
				} else {
					var eventSet = top.keyDependencies.get(obj);
					if (!eventSet) {
						eventSet = new Set();
						top.keyDependencies.set(obj, eventSet);
					}
					eventSet.add(event);
				}
			}
		}
	},

	addMany: function(observes) {
		var top = stack[stack.length - 1];
		if (top) {
			if (top.traps) {
				top.traps.push.apply(top.traps, observes);
			} else {
				for (var i = 0, len = observes.length; i < len; i++) {
					this.add(observes[i][0], observes[i][1]);
				}
			}
		}
	},
	created: function(obs) {
		var top = stack[stack.length - 1];
		if (top) {
			top.childDependencies.add(obs);
			if (obs[addParentSymbol]) {
				obs[addParentSymbol](top);
			}
		}
	},
	ignore: function(fn) {
		return function() {
			if (stack.length) {
				var top = stack[stack.length - 1];
				top.ignore++;
				var res = fn.apply(this, arguments);
				top.ignore--;
				return res;
			} else {
				return fn.apply(this, arguments);
			}
		};
	},
	peekValue: function(value) {
		if(!value || !value[getValueSymbol]) {
			return value;
		}
		if (stack.length) {
			var top = stack[stack.length - 1];
			top.ignore++;
			var res = value[getValueSymbol]();
			top.ignore--;
			return res;
		} else {
			return value[getValueSymbol]();
		}
	},
	isRecording: function() {
		var len = stack.length;
		var last = len && stack[len - 1];
		return last && (last.ignore === 0) && last;
	},
	// `can-observation` uses this to do diffs more easily.
	makeDependenciesRecord: function(name) {
		return {
			traps: null,
			keyDependencies: new Map(),
			valueDependencies: new Set(),
			//childDependencies: new Set(),
			ignore: 0,
			name: name
		};
	},
	// The following are legacy methods we should do away with.
	makeDependenciesRecorder: function() {
		return ObservationRecorder.makeDependenciesRecord();
	},
	// Traps should be replace by calling `.start()` and `.stop()`.
	// To do this, we'd need a method that accepts a dependency record.
	trap: function() {
		if (stack.length) {
			var top = stack[stack.length - 1];
			var oldTraps = top.traps;
			var traps = top.traps = [];
			return function() {
				top.traps = oldTraps;
				return traps;
			};
		} else {
			return function() {
				return [];
			};
		}
	},
	trapsCount: function() {
		if (stack.length) {
			var top = stack[stack.length - 1];
			return top.traps.length;
		} else {
			return 0;
		}
	}
};

if (namespace.ObservationRecorder) {
	throw new Error("You can't have two versions of can-observation-recorder, check your dependencies");
} else {
	module.exports = namespace.ObservationRecorder = ObservationRecorder;
}


/***/ }),

/***/ "./node_modules/can-observation/can-observation.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-observation/can-observation.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global require */
// # can-observation
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");

var recorderHelpers = __webpack_require__(/*! ./recorder-dependency-helpers */ "./node_modules/can-observation/recorder-dependency-helpers.js");
var temporarilyBind = __webpack_require__(/*! ./temporarily-bind */ "./node_modules/can-observation/temporarily-bind.js");

var dispatchSymbol = canSymbol.for("can.dispatch");
var getChangesSymbol = canSymbol.for("can.getChangesDependencyRecord");
var getValueDependenciesSymbol = canSymbol.for("can.getValueDependencies");

// ## Observation constructor
function Observation(func, context, options){
	this.deriveQueue = queues.deriveQueue;

	this.func = func;
	this.context = context;
	this.options = options || {priority: 0, isObservable: true};
	// A flag if we are bound or not
	this.bound = false;

	// Set _value to undefined so can-view-scope & can-compute can check for it
	this._value = undefined;

	// These properties will manage what our new and old dependencies are.
	this.newDependencies = ObservationRecorder.makeDependenciesRecord();
	this.oldDependencies = null;

	// Make functions we need to pass around and maintain `this`.
	var self = this;
	this.onDependencyChange = function(newVal){
		self.dependencyChange(this, newVal);
	};
	this.update = this.update.bind(this);


	// Add debugging names.
	//!steal-remove-start
	if (true) {
		this.onDependencyChange[getChangesSymbol] = function getChanges() {
			var s = new Set();
			s.add(self);
			return {
				valueDependencies: s
			};
		};
		Object.defineProperty(this.onDependencyChange, "name", {
			value: canReflect.getName(this) + ".onDependencyChange",
		});
		Object.defineProperty(this.update, "name", {
			value: canReflect.getName(this) + ".update",
		});
		this._name = canReflect.getName(this); // cached for performance
	}
	//!steal-remove-end
}

// ## Observation prototype methods

// Mixin value event bindings. This is where the following are added:
// - `.handlers` which call `onBound` and `onUnbound`
// - `.on` / `.off`
// - `can.onValue` `can.offValue`
// - `can.getWhatIChange`
valueEventBindings(Observation.prototype);

canReflect.assign(Observation.prototype, {
	// Starts observing changes and adds event listeners.
	onBound: function(){
		this.bound = true;

		// Store the old dependencies
		this.oldDependencies = this.newDependencies;
		// Start recording dependencies.
		ObservationRecorder.start(this._name);
		// Call the observation's function and update the new value.
		this._value = this.func.call(this.context);
		// Get the new dependencies.
		this.newDependencies = ObservationRecorder.stop();

		// Diff and update the bindings. On change, everything will call
		// `this.onDependencyChange`, which calls `this.dependencyChange`.
		recorderHelpers.updateObservations(this);
	},
	// This is called when any of the dependencies change.
	// It queues up an update in the `deriveQueue` to be run after all source
	// observables have had time to notify all observables that "derive" their value.
	dependencyChange: function(context, args){
		if(this.bound === true) {
			var queuesArgs = [];
			queuesArgs = [
				this.update,
				this,
				[],
				{
					priority: this.options.priority,
					element: this.options.element
				}
			];
			//!steal-remove-start
			if (true) {
				queuesArgs = [
					this.update,
					this,
					[],
					{
						priority: this.options.priority,
						element: this.options.element
						/* jshint laxcomma: true */
						, log: [ canReflect.getName(this.update) ]
						/* jshint laxcomma: false */
					}
					/* jshint laxcomma: true */
					, [canReflect.getName(context), "changed"]
					/* jshint laxcomma: false */
				];
			}
			//!steal-remove-end
			// Update this observation after all `notify` tasks have been run.
			this.deriveQueue.enqueue.apply(this.deriveQueue, queuesArgs);
		}
	},
	// Called to update its value as part of the `derive` queue.
	update: function() {
		if (this.bound === true) {
			// Keep the old value.
			var oldValue = this._value;
			this.oldValue = null;
			// Re-run `this.func` and update dependency bindings.
			this.onBound();
			// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.
			if (oldValue !== this._value) {
				this[dispatchSymbol](this._value, oldValue);
			}
		}
	},
	// Called when nothing is bound to this observation.
	// Removes all event listeners on all dependency observables.
	onUnbound: function(){
		this.bound = false;
		recorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);
		// Setup newDependencies in case someone binds again to this observable.
		this.newDependencies = ObservationRecorder.makeDependenciesRecord();
	},
	// Reads the value of the observation.
	get: function(){

		// If an external observation is tracking observables and
		// this compute can be listened to by "function" based computes ....
		if( this.options.isObservable && ObservationRecorder.isRecording() ) {

			// ... tell the tracking compute to listen to change on this observation.
			ObservationRecorder.add(this);
			// ... if we are not bound, we should bind so that
			// we don't have to re-read to get the value of this observation.
			if (this.bound === false) {
				Observation.temporarilyBind(this);
			}

		}


		if(this.bound === true ) {
			// It's possible that a child dependency of this observable might be queued
			// to change. Check all child dependencies and make sure they are up-to-date by
			// possibly running what they have registered in the derive queue.
			if(this.deriveQueue.tasksRemainingCount() > 0) {
				Observation.updateChildrenAndSelf(this);
			}

			return this._value;
		} else {
			// If we are not bound, just call the function.
			return this.func.call(this.context);
		}
	},

	hasDependencies: function(){
		var newDependencies = this.newDependencies;
		return this.bound ?
			(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :
			undefined;
	},
	log: function() {
		//!steal-remove-start
		if (true) {
			var quoteString = function quoteString(x) {
				return typeof x === "string" ? JSON.stringify(x) : x;
			};
			this._log = function(previous, current) {
				dev.log(
					canReflect.getName(this),
					"\n is  ", quoteString(current),
					"\n was ", quoteString(previous)
				);
			};
		}
		//!steal-remove-end
	}
});

Object.defineProperty(Observation.prototype, "value", {
	get: function() {
		return this.get();
	}
});

var observationProto = {
	"can.getValue": Observation.prototype.get,
	"can.isValueLike": true,
	"can.isMapLike": false,
	"can.isListLike": false,
	"can.valueHasDependencies": Observation.prototype.hasDependencies,
	"can.getValueDependencies": function(){
		if (this.bound === true) {
			// Only provide `keyDependencies` and `valueDependencies` properties
			// if there's actually something there.
			var deps = this.newDependencies,
				result = {};

			if (deps.keyDependencies.size) {
				result.keyDependencies = deps.keyDependencies;
			}

			if (deps.valueDependencies.size) {
				result.valueDependencies = deps.valueDependencies;
			}

			return result;
		}
		return undefined;
	},
	"can.getPriority": function(){
		return this.options.priority;
	},
	"can.setPriority": function(priority){
		this.options.priority = priority;
	},
	"can.setElement": function(element) {
		this.options.element = element;
		this.deriveQueue = queues.domQueue || queues.deriveQueue;
	}
};

//!steal-remove-start
if (true) {
	observationProto["can.getName"] = function() {
		return canReflect.getName(this.constructor) + "<" + canReflect.getName(this.func) + ">";
	};
}
//!steal-remove-end
canReflect.assignSymbols(Observation.prototype, observationProto);

// ## Observation.updateChildrenAndSelf
// This recursively checks if an observation's dependencies might be in the `derive` queue.
// If it is, we need to update that value so the reading of this value will be correct.
// This can happen if an observation suddenly switches to depending on something that has higher
// priority than itself.  We need to make sure that value is completely updated.
Observation.updateChildrenAndSelf = function(observation){
	// If the observable has an `update` method and it's enqueued, flush that task immediately so
	// the value is right.
	// > NOTE: This only works for `Observation` right now.  We need a way of knowing how
	// > to find what an observable might have in the `deriveQueue`.
	if(observation.update !== undefined && observation.deriveQueue.isEnqueued( observation.update ) === true) {
		// TODO: In the future, we should be able to send log information
		// to explain why this needed to be updated.
		observation.deriveQueue.flushQueuedTask(observation.update);
		return true;
	}

	// If we can get dependency values from this observable ...
	if(observation[getValueDependenciesSymbol]) {
		// ... Loop through each dependency and see if any of them (or their children) needed an update.
		var childHasChanged = false;
		var valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];
		valueDependencies.forEach(function(observable){
			if( Observation.updateChildrenAndSelf( observable ) === true) {
				childHasChanged = true;
			}
		});
		return childHasChanged;
	} else {
		return false;
	}
};

// ## Legacy Stuff
// Warn when `ObservationRecorder` methods are called on `Observation`.
var alias = {addAll: "addMany"};
["add","addAll","ignore","trap","trapsCount","isRecording"].forEach(function(methodName){
	Observation[methodName] = function(){
		var name = alias[methodName] ? alias[methodName] : methodName;
		console.warn("can-observation: Call "+name+"() on can-observation-recorder.");
		return ObservationRecorder[name].apply(this, arguments);
	};
});
Observation.prototype.start = function(){
	console.warn("can-observation: Use .on and .off to bind.");
	return this.onBound();
};
Observation.prototype.stop = function(){
	console.warn("can-observation: Use .on and .off to bind.");
	return this.onUnbound();
};

// ### temporarilyBind
// Will bind an observable value temporarily.  This should be part of queues probably.
Observation.temporarilyBind = temporarilyBind;


module.exports = namespace.Observation = Observation;


/***/ }),

/***/ "./node_modules/can-observation/recorder-dependency-helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-observation/recorder-dependency-helpers.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # Recorder Dependency Helpers
// This exposes two helpers:
// - `updateObservations` - binds and unbinds a diff of two observation records
//   (see can-observation-recorder for details on this data type).
// - `stopObserving` - unbinds an observation record.
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");



// ## Helpers
// The following helpers all use `this` to pass additional arguments. This
// is for performance reasons as it avoids creating new functions.

function addNewKeyDependenciesIfNotInOld(event) {
    // Expects `this` to have:
    // - `.observable` - the observable we might be binding to.
    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.
    // - `.onDependencyChange` - the handler we will call back when the key is changed.
    // If there wasn't any keys, or when we tried to delete we couldn't because the key
    // wasn't in the set, start binding.
    if(this.oldEventSet === undefined || this.oldEventSet["delete"](event) === false) {
        canReflect.onKeyValue(this.observable, event, this.onDependencyChange,"notify");
    }
}

// ### addObservablesNewKeyDependenciesIfNotInOld
// For each event in the `eventSet` of new observables,
// setup a binding (or delete the key).
function addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){
    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {
        onDependencyChange: this.onDependencyChange,
        observable: observable,
        oldEventSet: this.oldDependencies.keyDependencies.get(observable)
    });
}

function removeKeyDependencies(event) {
    canReflect.offKeyValue(this.observable, event, this.onDependencyChange,"notify");
}

function removeObservablesKeyDependencies(oldEventSet, observable){
    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});
}

function addValueDependencies(observable) {
    // If we were unable to delete the key in the old set, setup a binding.
    if(this.oldDependencies.valueDependencies.delete(observable) === false) {
        canReflect.onValue(observable, this.onDependencyChange,"notify");
    }
}
function removeValueDependencies(observable) {
    canReflect.offValue(observable, this.onDependencyChange,"notify");
}


module.exports = {
    // ## updateObservations
    //
    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in
    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`
    // left over is unbound.
    //
    // The algorthim works by:
    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.
    //    - If there is an equivalent binding, delete that dependency from `old`.
    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.
    // 2. Loop through the remaining `old` dependencies, teardown bindings.
    //
    // For performance, this method mutates the values in `.oldDependencies`.
    updateObservations: function(observationData){
        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);
        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);
        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);
        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);
    },
    stopObserving: function(observationReciever, onDependencyChange){
        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});
        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});
    }
};


/***/ }),

/***/ "./node_modules/can-observation/temporarily-bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observation/temporarily-bind.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var temporarilyBoundNoOperation = function(){};
// A list of temporarily bound computes
var observables;
// Unbinds all temporarily bound computes.
var unbindTemporarilyBoundValue = function () {
	for (var i = 0, len = observables.length; i < len; i++) {
		canReflect.offValue(observables[i], temporarilyBoundNoOperation);
	}
	observables = null;
};

// ### temporarilyBind
// Binds computes for a moment to cache their value and prevent re-calculating it.
function temporarilyBind(compute) {
	var computeInstance = compute.computeInstance || compute;
	canReflect.onValue(computeInstance, temporarilyBoundNoOperation);
	if (!observables) {
		observables = [];
		setTimeout(unbindTemporarilyBoundValue, 10);
	}
	observables.push(computeInstance);
}

module.exports = temporarilyBind;


/***/ }),

/***/ "./node_modules/can-observe/array/array.js":
/*!*************************************************!*\
  !*** ./node_modules/can-observe/array/array.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// ## can-observe/array/array
//
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var makeArray = __webpack_require__(/*! ../src/-make-array */ "./node_modules/can-observe/src/-make-array.js");
var makeObserve = __webpack_require__(/*! ../src/-make-observe */ "./node_modules/can-observe/src/-make-observe.js");
var eventMixin = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var typeEventMixin = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");
var helpers = __webpack_require__(/*! ../src/-helpers */ "./node_modules/can-observe/src/-helpers.js");
var observableStore = __webpack_require__(/*! ../src/-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");
var typeHelpers = __webpack_require__(/*! ../src/-type-helpers */ "./node_modules/can-observe/src/-type-helpers.js");

var definitionsSymbol = canSymbol.for("can.typeDefinitions");

// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue
var proxyKeys = helpers.assignEverything({},makeArray.proxyKeys());

var ObserveArray;
if ( /*helpers.supportsClass*/ false) {} else {

    var ObserveArray = function(items) {
        var prototype = Object.getPrototypeOf(this);

        computedHelpers.ensureDefinition(prototype);
        typeHelpers.ensureDefinition(prototype);

        var instance = this;
        var definitions = prototype[definitionsSymbol] || {};
        for (var key in definitions) {
            Object.defineProperty(instance, key, definitions[key]);
        }
        this.push.apply(this, items || []);

        var localProxyKeys = Object.create(proxyKeys);
        localProxyKeys.constructor = this.constructor;

        var observable = makeArray.observable(instance, {
            observe: makeObserve.observe,
            proxyKeys: localProxyKeys,
            shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
        });
        observableStore.proxiedObjects.set(instance, observable);
        observableStore.proxies.add(observable);
        return observable;
    };
    ObserveArray.prototype = Object.create(Array.prototype);
}

eventMixin(ObserveArray.prototype);
typeEventMixin(ObserveArray);
computedHelpers.addMethodsAndSymbols(ObserveArray);
typeHelpers.addMethodsAndSymbols(ObserveArray);

ObserveArray.extend = helpers.makeSimpleExtender(ObserveArray);



module.exports = ObserveArray;


/***/ }),

/***/ "./node_modules/can-observe/can-observe.js":
/*!*************************************************!*\
  !*** ./node_modules/can-observe/can-observe.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # can-observe.js
// Assembles the final observe export.
var makeObject = __webpack_require__(/*! ./src/-make-object */ "./node_modules/can-observe/src/-make-object.js");
var makeArray = __webpack_require__(/*! ./src/-make-array */ "./node_modules/can-observe/src/-make-array.js");
var makeFunction = __webpack_require__(/*! ./src/-make-function */ "./node_modules/can-observe/src/-make-function.js");
var makeObserve = __webpack_require__(/*! ./src/-make-observe */ "./node_modules/can-observe/src/-make-observe.js");
var makePrototype = __webpack_require__(/*! ./src/-make-prototype */ "./node_modules/can-observe/src/-make-prototype.js");
var ObserveObject = __webpack_require__(/*! ./object/object */ "./node_modules/can-observe/object/object.js");
var ObserveArray = __webpack_require__(/*! ./array/array */ "./node_modules/can-observe/array/array.js");

var computedHelpers = __webpack_require__(/*! ./src/-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");
var decorators = __webpack_require__(/*! ./decorators/decorators */ "./node_modules/can-observe/decorators/decorators.js");

makeObserve.object = function(object) {
	return makeObject.observable(object, makeObserve);
};
makeObserve.prototype = function(proto) {
	return makePrototype.observable(proto, makeObserve);
};
makeObserve.array = function(array) {
	return makeArray.observable(array, makeObserve);
};
makeObserve.function = function(fn) {
	return makeFunction.observable(fn, makeObserve);
};
makeObserve.observe.Object = ObserveObject;
makeObserve.observe.Array = ObserveArray;

module.exports = makeObserve.observe;

module.exports.defineProperty = function(prototype, prop, makeObservable) {
	computedHelpers.ensureDefinition(prototype)[prop] = makeObservable;
};

for (var key in decorators) {
	module.exports[key] = decorators[key];
}


/***/ }),

/***/ "./node_modules/can-observe/decorators/decorators.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/decorators/decorators.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ "./node_modules/can-simple-observable/async/async.js");
var ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ "./node_modules/can-simple-observable/resolver/resolver.js");

var computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");
function defineProperty(prototype, prop, makeObservable) {
	computedHelpers.ensureDefinition(prototype)[prop] = makeObservable;
}

function asyncBase(config) {
	return function(target, key, descriptor) {
		if (descriptor.get !== undefined) {
			var getter = descriptor.get;
			//!steal-remove-start
			if(true) {
				if (getter.length !== 0) {
					throw new Error("async decorated " + key + " on " + canReflect.getName(target) + ": getters should take no arguments.");
				}
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				function fn(lastSet, resolve) {
					if (!resolve) {
						return config.default;
					}

					var promise = getter.call(this, true);
					if (canReflect.isPromise(promise)) {
						promise.then(resolve);
						return config.default;
					}
					//!steal-remove-start
					else if (promise !== undefined) {
						if(true) {
							throw new Error("async decorated " + key + " on " + canReflect.getName(target) + ": getters must return undefined or a promise.");
						}
					}
					//!steal-remove-end
				}

				//!steal-remove-start
				if(true) {
					canReflect.assignSymbols(fn, {
						"can.getName": function() {
							return canReflect.getName(getter) + ": getter";
						},
					});
				}
				//!steal-remove-end

				return new AsyncObservable(fn, instance, config.default);
			});
		}

		if (descriptor.value !== undefined) {
			var method = descriptor.value;
			//!steal-remove-start
			if(true) {
				if (method.length !== 1) {
					throw new Error("async decorated " + key + " on " + canReflect.getName(target) + ": methods should take 1 argument (resolve).");
				}
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				return new AsyncObservable(function(lastSet, resolve) {
					return method.call(this, resolve);
				}, instance, config.default);
			});
		}

		//!steal-remove-start
		if(true) {
			throw new Error("async decorated " + key + " on " + canReflect.getName(target) + ": Unrecognized descriptor.");
		}
		//!steal-remove-end
	};
}

function resolverBase(config) {
	return function(target, key, descriptor) {
		if (descriptor.value !== undefined) {
			var method = descriptor.value;
			//!steal-remove-start
			if(true) {
				if (method.length !== 1) {
					throw new Error("resolver decorated " + key + " on " + canReflect.getName(target) + ": methods should take 1 argument (value).");
				}
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				return new ResolverObservable(method, instance);
			});
		}

		//!steal-remove-start
		if(true) {
			throw new Error("resolver decorated " + key + " on " + canReflect.getName(target) + ": Unrecognized descriptor.");
		}
		//!steal-remove-end
	};
}

function optionalConfig(decorator) {
	function wrapper(config) {
		if (arguments.length === 3) {
			return decorator({}).apply(null, arguments);
		}

		return decorator(config);
	}

	//!steal-remove-start
	if(true) {
		Object.defineProperty(wrapper, "name", {
			value: canReflect.getName(decorator.name)
		});
	}
	//!steal-remove-end

	return wrapper;
}

module.exports = {
	async: optionalConfig(asyncBase),
	resolver: optionalConfig(resolverBase),
};


/***/ }),

/***/ "./node_modules/can-observe/object/object.js":
/*!***************************************************!*\
  !*** ./node_modules/can-observe/object/object.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var makeObserve = __webpack_require__(/*! ../src/-make-observe */ "./node_modules/can-observe/src/-make-observe.js");
var eventMixin = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var typeEventMixin = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");
var helpers = __webpack_require__(/*! ../src/-helpers */ "./node_modules/can-observe/src/-helpers.js");
var makeObject = __webpack_require__(/*! ../src/-make-object */ "./node_modules/can-observe/src/-make-object.js");
var observableStore = __webpack_require__(/*! ../src/-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var definitionsSymbol = canSymbol.for("can.typeDefinitions");
var computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");
var typeHelpers = __webpack_require__(/*! ../src/-type-helpers */ "./node_modules/can-observe/src/-type-helpers.js");

// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue
var proxyKeys = helpers.assignEverything({},makeObject.proxyKeys());
computedHelpers.addKeyDependencies(proxyKeys);

// ## ObserveObject constructor function
// Works by returning the proxy-wrapped instance.
var ObserveObject = function(props) {
    var prototype = Object.getPrototypeOf(this);

    computedHelpers.ensureDefinition(prototype);
    typeHelpers.ensureDefinition(prototype);

    // Define expando properties from `can.defineInstanceProperty`
    var sourceInstance = this;
    var definitions = prototype[definitionsSymbol] || {};
    for (var key in definitions) {
        Object.defineProperty(sourceInstance, key, definitions[key]);
    }
    // Add properties passed to the constructor.
    if (props !== undefined) {
        canReflect.assign(sourceInstance, props);
    }
    // Create a copy of the proxy keys
    var localProxyKeys = Object.create(proxyKeys);

    // Make sure that the .constructor property isn't proxied.  If it was,
    // `this.constructor` would not be the type.
    localProxyKeys.constructor = this.constructor;

    // Wrap the sourceInstance
    var observable = makeObject.observable(sourceInstance, {
        observe: makeObserve.observe,
        proxyKeys: localProxyKeys,
        shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
    });
    // Add the proxy to the stores.
    observableStore.proxiedObjects.set(sourceInstance, observable);
    observableStore.proxies.add(observable);
    return observable;
};

eventMixin(ObserveObject.prototype);
typeEventMixin(ObserveObject);
computedHelpers.addMethodsAndSymbols(ObserveObject);
typeHelpers.addMethodsAndSymbols(ObserveObject);

// Allows this to be extended w/o `class`
ObserveObject.extend = helpers.makeSimpleExtender(ObserveObject);



module.exports = ObserveObject;


/***/ }),

/***/ "./node_modules/can-observe/src/-computed-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/src/-computed-helpers.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canMeta = canSymbol.for("can.meta");
var computedPropertyDefinitionSymbol = canSymbol.for("can.computedPropertyDefinitions");
var onKeyValueSymbol = canSymbol.for("can.onKeyValue");
var offKeyValueSymbol = canSymbol.for("can.offKeyValue");
// var getKeyDependenciesSymbol = canSymbol.for("can.getKeyDependencies");

// ## ComputedObjectObservationData
// Instances of this are created to wrap the observation.
// The `.bind` and `.unbind` methods should be called when the
// instance's prop is bound or unbound.
function ComputedObjectObservationData(instance, prop, observation){
	this.instance = instance;
    this.prop = prop;
    this.observation = observation;
	this.forward = this.forward.bind(this);
}

ComputedObjectObservationData.prototype.bind = function(){
    this.bindingCount++;
    if(this.bindingCount === 1) {
        this.observation.on(this.forward, "notify");
    }
};

ComputedObjectObservationData.prototype.unbind = function(){
    this.bindingCount--;
    if(this.bindingCount === 0) {
        this.observation.off(this.forward, "notify");
    }
};

ComputedObjectObservationData.prototype.forward = function(newValue, oldValue){
	mapBindings.dispatch.call(this.instance, {
		type: this.prop,
		target: this.instance

		// patches: [{
		// 	key: this.prop,
		// 	type: "set",
		// 	value: newValue
		// }]
		// keyChanged: undefined
	}, [newValue, oldValue]);
};

ComputedObjectObservationData.prototype.bindingCount = 0;

function findComputed(instance, key) {
	var meta = instance[canMeta];
	var target = meta.target;

	var computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];
	if (computedPropertyDefinitions === undefined) {
		return;
	}
	var computedPropertyDefinition = computedPropertyDefinitions[key];
	if (computedPropertyDefinition === undefined) {
		return;
	}

	if (meta.computedKeys[key] === undefined) {
		meta.computedKeys[key] = new ComputedObjectObservationData(
			instance, key,
			computedPropertyDefinition(instance, key)
		);
	}

	return meta.computedKeys[key];
}

var computedHelpers = module.exports = {
	get: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		ObservationRecorder.add(instance, key.toString());
		if(computedObj.bindingCount === 0 && ObservationRecorder.isRecording()) {
			Observation.temporarilyBind(computedObj.observation);
		}

		return {
			value: canReflect.getValue(computedObj.observation),
		};
	},
	set: function(instance, key, value) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return false;
		}

		//!steal-remove-start
		if(true) {
			if (computedObj.observation[canSymbol.for("can.setValue")] === undefined) {
				throw new Error("Cannot set \"" + key + "\" on " + canReflect.getName(instance));
			}
		}
		//!steal-remove-end

		canReflect.setValue(computedObj.observation, value);
		return true;
	},
	bind: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		computedObj.bind();
	},
	unbind: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		computedObj.unbind();
	},
	addKeyDependencies: function(proxyKeys) {
		var onKeyValue = proxyKeys[onKeyValueSymbol];
		var offKeyValue = proxyKeys[offKeyValueSymbol];
		// var getKeyDependencies = proxyKeys[getKeyDependenciesSymbol];

		canReflect.assignSymbols(proxyKeys, {
			"can.onKeyValue": function(key, handler, queue) {
				computedHelpers.bind(this, key);

				// var handlers = this[canMeta].handlers;
				// handlers.add([ key, "onKeyValue", queue || "notify", handler ]);

				return onKeyValue.apply(this, arguments);
			},
			"can.offKeyValue": function(key, handler, queue) {
				computedHelpers.unbind(this, key);

				// var handlers = this[canMeta].handlers;
				// handlers.delete([ key, "onKeyValue", queue || "notify", handler ]);

				return offKeyValue.apply(this, arguments);
			},
			"can.getKeyDependencies": function(key) {
				var computedObj = findComputed(this, key);
				if (computedObj === undefined) {
					return;
				}

				return {
					valueDependencies: new Set([ computedObj.observation ])
				};
			},
		});
	},
	addMethodsAndSymbols: function(Type) {
		Type.prototype.addEventListener = function(key, handler, queue) {
			computedHelpers.bind(this, key);
			return mapBindings.addEventListener.call(this, key, handler, queue);
		};

		Type.prototype.removeEventListener = function(key, handler, queue) {
			computedHelpers.unbind(this, key);
			return mapBindings.removeEventListener.call(this, key, handler, queue);
		};
	},
	ensureDefinition: function(prototype) {
		if (!prototype.hasOwnProperty(computedPropertyDefinitionSymbol)) {
			var parent = prototype[computedPropertyDefinitionSymbol];
			var definitions = prototype[computedPropertyDefinitionSymbol] = Object.create(parent || null);

			Object.getOwnPropertyNames(prototype).forEach(function(prop) {
				if (prop === "constructor") {
					return;
				}

				// auto-binding for getters
				var descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
				if(descriptor.get !== undefined) {
					var getter = descriptor.get;
					definitions[prop] = function(instance, property) {
						return new Observation(getter, instance);
					};
				}
			});
		}

		return prototype[computedPropertyDefinitionSymbol];
	},
};


/***/ }),

/***/ "./node_modules/can-observe/src/-helpers.js":
/*!**************************************************!*\
  !*** ./node_modules/can-observe/src/-helpers.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getGlobal = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var metaSymbol = canSymbol.for("can.meta");
var classTest = /^\s*class\s+/;

var helpers = {
	assignEverything: function(d, s) {
		Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s)).forEach(function(key) {
			Object.defineProperty(d, key, Object.getOwnPropertyDescriptor(s, key));
		});
		return d;
	},
	isBuiltInButNotArrayOrPlainObjectOrElement: function(obj) {
		if (obj instanceof getGlobal().Element) {
			return false;
		}
		return helpers.isBuiltInButNotArrayOrPlainObject(obj);
	},
	isBuiltInButNotArrayOrPlainObject: function(obj) {
		if (Array.isArray(obj)) {
			return false;
		}
		if (typeof obj === "function") {
			var fnCode = obj.toString();
			if (fnCode.indexOf("[native code]") > 0) {
				return true;
			} else {
				return false;
			}
		} else {
			var toString = Object.prototype.toString.call(obj);
			return toString !== '[object Object]' && toString.indexOf('[object ') !== -1;
		}

	},
	inheritsFromArray: function(obj) {
		var cur = obj;
		do {
			if (Array.isArray(cur)) {
				return true;
			}
			cur = Object.getPrototypeOf(cur);
		} while (cur);
		return false;
	},
	isClass: function(obj) {
		return typeof obj === 'function' && classTest.test(obj.toString());
	},
	supportsClass: (function() {
		try {
			eval('"use strict"; class A{};');
			return true;
		} catch (e) {
			return false;
		}
	})(),
	makeSimpleExtender: function(BaseType) {
		return function extend(name, staticProps, prototypeProps) {
		    var Type = function() {
		        var source = this;
				var instance = BaseType.apply(this, arguments);
		        if(source.init) {
		            // makes sure nothing can leak out
		            instance[metaSymbol].preventSideEffects++;
		            source.init.apply(instance, arguments);
		            instance[metaSymbol].preventSideEffects--;
		        }
		        return instance;
			};


			helpers.assignEverything(Type,BaseType);
			helpers.assignEverything(Type, staticProps || {});
			Type.extend = helpers.makeSimpleExtender(Type);
			Type.prototype = Object.create( BaseType.prototype );
			helpers.assignEverything(Type.prototype, prototypeProps || {});
			Type.prototype.constructor = Type;

			//!steal-remove-start
			if(true) {
				Object.defineProperty(Type, "name", {
					value: name
				});
			}
			//!steal-remove-end

			return Type;
		};
	},
	assignNonEnumerable: function(obj, key, value) {
		return Object.defineProperty(obj, key, {
		    enumerable: false,
		    writable: true,
		    configurable: true,
		    value: value
		});
	}
};


module.exports = helpers;


/***/ }),

/***/ "./node_modules/can-observe/src/-make-array.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-observe/src/-make-array.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # -make-array.js
// This module's `.observable` method proxies an Array to make it observable.
// The other exports are not used elsewhere.
// `.set` is the only proxy method that differs from `make-object`'s.
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var makeObject = __webpack_require__(/*! ./-make-object */ "./node_modules/can-observe/src/-make-object.js");
var symbols = __webpack_require__(/*! ./-symbols */ "./node_modules/can-observe/src/-symbols.js");
var observableStore = __webpack_require__(/*! ./-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var helpers = __webpack_require__(/*! ./-helpers */ "./node_modules/can-observe/src/-helpers.js");
var computedHelpers = __webpack_require__(/*! ./-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");

var isSymbolLike = canReflect.isSymbolLike;

// Returns if prop is an integer
var isInteger = Number.isInteger || function(value) {
  return typeof value === 'number' &&
    isFinite(value) &&
    Math.floor(value) === value;
};

// Returns `true` if the length was set and it deleted indexed
// properties.
function didLengthChangeCauseDeletions(key, value, old) {
	return key === "length" && value < old;
}


// ## Rewrite array methods
// The following rewrites array methods to generate events and
// for performance reasons.
//
// Array's methods that mutate are rewritten to generate patch events.
// Other methods on array are rewritten to:
// - Avoid calling `ObservationRecorder.add` on every property.
// - Make the returned result observable.
//
// ### Rewrite mutating methods
// The following defines a relationship between an array
// mutation method and the patch events that should be dispatched
// for that mutation.
var mutateMethods = {
	"push": function(arr, args) {
		return [{
			index: arr.length - args.length,
			deleteCount: 0,
			insert: args,
			type: "splice"
		}];
	},
	"pop": function(arr) {
		return [{
			index: arr.length,
			deleteCount: 1,
			insert: [],
			type: "splice"
		}];
	},
	"shift": function() {
		return [{
			index: 0,
			deleteCount: 1,
			insert: [],
			type: "splice"
		}];
	},
	"unshift": function(arr, args) {
		return [{
			index: 0,
			deleteCount: 0,
			insert: args,
			type: "splice"
		}];
	},
	"splice": function(arr, args) {
		return [{
			index: args[0],
			deleteCount: args[1],
			insert: args.slice(2),
			type: "splice"
		}];
	},
	"sort": function(arr) {
		// The array replaced everything.
		return [{
			index: 0,
			deleteCount: arr.length,
			insert: arr,
			type: "splice"
		}];
	},
	"reverse": function(arr, args, old) {
		// The array replaced everything.
		return [{
			index: 0,
			deleteCount: arr.length,
			insert: arr,
			type: "splice"
		}];
	}
};
// Overwrite Array's methods that mutate to:
// - prevent other events from being fired off (index events and length events.)
// - dispatch patches events.
canReflect.eachKey(mutateMethods, function(makePatches, prop){
	var protoFn = Array.prototype[prop];
	var mutateMethod = function() {
		var meta = this[symbols.metaSymbol],
			// Capture if this function should be making sideEffects
			makeSideEffects = meta.preventSideEffects === 0,
			oldLength = meta.target.length;

		// Prevent proxy from calling ObservationRecorder and sending events.
		meta.preventSideEffects++;

		// Call the function -- note that *this* is the Proxy here, so
		// accesses in the function still go through `get()` and `set()`.
		var ret = protoFn.apply(meta.target, arguments);
		var patches = makePatches(meta.target, Array.from(arguments), oldLength);

		if (makeSideEffects === true) {
			//!steal-remove-start
			var reasonLog = [canReflect.getName(meta.proxy)+"."+prop+" called with", arguments];
			//!steal-remove-end
			var dispatchArgs = {
				type: "length",
				patches: patches
			};

			//!steal-remove-start
			if(true) {
				dispatchArgs.reasonLog = reasonLog;
			}
			//!steal-remove-end

			mapBindings.dispatch.call( meta.proxy, dispatchArgs , [meta.target.length, oldLength]);
		}

		meta.preventSideEffects--;
		return ret;
	};
	//!steal-remove-start
	if(true) {
		Object.defineProperty(mutateMethod, "name", {
			value: prop
		});
	}
	//!steal-remove-end

	// Store the proxied method so it will be used instead of the
	// prototype method.
	observableStore.proxiedObjects.set(protoFn, mutateMethod);
	observableStore.proxies.add(mutateMethod);
});

// ### Rewrite non-mutating methods
// The following rewrites the Array methods to signal
// to `ObservationRecorder` to bind on patches events.
// It also prevents the proxy handlers calling `ObservationRecorder`
// themselves.
Object.getOwnPropertyNames(Array.prototype).forEach(function(prop) {
	var protoFn = Array.prototype[prop];
	if (observableStore.proxiedObjects.has(protoFn)) {
		return;
	}

	if (prop !== "constructor" && typeof protoFn === "function") {
		var arrayMethod = function() {
			ObservationRecorder.add(this, symbols.patchesSymbol);
			var meta = this[symbols.metaSymbol];
			meta.preventSideEffects++;
			var ret = protoFn.apply(this, arguments);
			meta.preventSideEffects--;
			return meta.options.observe(ret);
		};
		//!steal-remove-start
		if(true) {
			Object.defineProperty(arrayMethod, "name", {
				value: prop
			});
		}
		//!steal-remove-end
		observableStore.proxiedObjects.set(protoFn, arrayMethod);
		observableStore.proxies.add(arrayMethod);
	}
});


// Array's have the same proxy keys as objects.
var proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());


var makeArray = {
	// Returns a proxied version of the array.
	// - `array` - An array to proxy.
	// - `options` - Configurable behaviors.
	//   - `proxyKeys` - Keys that will override any keys on `array`. Defaults to `makeObject.proxyKeys`.
	//   - `observe(nonObservable)` - A function that converts a nested value to an observable.
	//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`
	//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.
	observable: function(array, options) {
		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}
		var meta = {
			target: array,
			proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray.proxyKeys()),
			computedKeys: Object.create(null),
			options: options,
			// `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
			// function (like `Array.splice`) wants to handle event dispatching and/or calling
			// `ObservationRecorder` itself for performance reasons.
			preventSideEffects: 0
		};
		meta.proxyKeys[symbols.metaSymbol] = meta;
		meta.proxy = new Proxy(array, {
			get: makeObject.get.bind(meta),
			set: makeArray.set.bind(meta),
			ownKeys: makeObject.ownKeys.bind(meta),
			deleteProperty: makeObject.deleteProperty.bind(meta),
			meta: meta
		});
		mapBindings.addHandlers(meta.proxy, meta);
		return meta.proxy;
	},
	proxyKeys: function() {
		return proxyKeys;
	},
	// `set` is called when a property is set on the proxy or an object
	// that has the proxy on its prototype.
	set: function(target, key, value, receiver) {
		// If the receiver is not this observable (the observable might be on the proto chain),
		// set the key on the reciever.
		if (receiver !== this.proxy) {
			return makeObject.setKey(receiver, key, value, this);
		}

		// If it has a defined property definiition
		var computedValue = computedHelpers.set(receiver, key, value);
		if(computedValue === true ) {
			return true;
		}

		// Gets the observable value to set.
		value = makeObject.getValueToSet(key, value, this);
		var startingLength = target.length;

		// Sets the value on the target.  If there
		// is a change, calls the callback.
		makeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {

			// Determine the patches this change should dispatch
			var patches = [{
				key: key,
				type: hadOwn ? "set" : "add",
				value: value
			}];

			var numberKey = !isSymbolLike(key) && +key;

			// If we are adding an indexed value like `arr[5] =value` ...
			if ( isInteger(numberKey) ) {
				// If we set an enumerable property after the length ...
				if (!hadOwn && numberKey > startingLength) {
					// ... add patches for those values.
					patches.push({
						index: startingLength,
						deleteCount: 0,
						insert: target.slice(startingLength),
						type: "splice"
					});
				} else {
					// Otherwise, splice the value into the array.
					patches.push.apply(patches, mutateMethods.splice(target, [numberKey, 1, value]));
				}
			}

			// In the case of deleting items by setting the length of the array,
			// add patches that splice the items removed.
			// (deleting individual items from an array doesn't change the length; it just creates holes)
			if (didLengthChangeCauseDeletions(key, value, old, meta)) {
				patches.push({
					index: value,
					deleteCount: old - value,
					insert: [],
					type: "splice"
				});
			}
			//!steal-remove-start
			var reasonLog = [canReflect.getName(meta.proxy)+" set", key,"to", value];
			//!steal-remove-end

			var dispatchArgs = {
				type: key,
				patches: patches,
				keyChanged: !hadOwn ? key : undefined
			};

			//!steal-remove-start
			if(true) {
				dispatchArgs.reasonLog = reasonLog;
			}
			//!steal-remove-end

			mapBindings.dispatch.call( meta.proxy, dispatchArgs, [value, old]);

		});

		return true;
	}
};


module.exports = makeArray;


/***/ }),

/***/ "./node_modules/can-observe/src/-make-function.js":
/*!********************************************************!*\
  !*** ./node_modules/can-observe/src/-make-function.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # -make-function.js
// This module's `.observable` method proxies an function to make it an any instances
// created by it observable.
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var makeObject = __webpack_require__(/*! ./-make-object */ "./node_modules/can-observe/src/-make-object.js");
var makeObserve = __webpack_require__(/*! ./-make-observe */ "./node_modules/can-observe/src/-make-observe.js");
var symbols = __webpack_require__(/*! ./-symbols */ "./node_modules/can-observe/src/-symbols.js");
var observableStore = __webpack_require__(/*! ./-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var typeBindings = __webpack_require__(/*! can-event-queue/type/type */ "./node_modules/can-event-queue/type/type.js");
var helpers = __webpack_require__(/*! ./-helpers */ "./node_modules/can-observe/src/-helpers.js");

// ## proxyKeys
// A function's proxyKeys is a combination of:
// - object's symbols (`.onKeyValue`)
// - type event symbols (`.onInstancePatches`, `.onInstanceBound`)
// - type definition symbols (`.defineInstanceKey`)
var proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());
typeBindings(proxyKeys);
canReflect.assignSymbols(proxyKeys, {
	"can.defineInstanceKey": function(prop, value) {
		this[symbols.metaSymbol].definitions[prop] = value;
	}
});

var makeFunction = {

	observable: function(object, options) {

		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}
		var proxyKeys = Object.create(makeFunction.proxyKeys());

		var meta = {
			target: object,
			proxyKeys: proxyKeys,
			computedKeys: Object.create(null),
			options: options,
			definitions: {},
			isClass: helpers.isClass(object),
			preventSideEffects: 0
		};

		proxyKeys[symbols.metaSymbol] = meta;
		meta.proxy = new Proxy(object, {
			get: makeObject.get.bind(meta),
			set: makeObject.set.bind(meta),
			ownKeys: makeObject.ownKeys.bind(meta),
			deleteProperty: makeObject.deleteProperty.bind(meta),
			construct: makeFunction.construct.bind(meta),
			apply: makeFunction.apply.bind(meta),
			meta: meta
		});

		mapBindings.addHandlers(meta.proxy, meta);
		typeBindings.addHandlers(meta.proxy, meta);

		// Store the function and its proxy now, before we
		// convert the prototype and its constructor to proxies.
		observableStore.proxiedObjects.set(object, meta.proxy);
		observableStore.proxies.add(meta.proxy);

		// Change prototype and its constructor
		if (meta.target.prototype && meta.target.prototype.constructor === meta.target) {
			var newPrototype = makeObject.observable(meta.target.prototype, {
				getPrototypeOf: function(){
					return meta.target.prototype;
				},
				observe: makeObserve.observe
			});

			observableStore.proxiedObjects.set(meta.target.prototype, newPrototype);
			observableStore.proxies.add(newPrototype);

			var prototype = meta.proxy.prototype;
			prototype.constructor = meta.proxy;
		}

		return meta.proxy;
	},
	// `construct` is called when the `new` operator is used.
	// It needs to return an observable instance.
	construct: function(target, argumentsList, newTarget) {
		var instanceTarget, key;
		if (this.isClass) {
			// If the `target` a class, we can't call the function without new. We
			// can create the instance with `Reflect.construct`.
			instanceTarget = Reflect.construct(target, argumentsList, newTarget);
			// Support `can.defineInstanceKey`.
			for (key in this.definitions) {
				Object.defineProperty(instanceTarget, key, this.definitions[key]);
			}
			return this.options.observe(instanceTarget);
		} else {
			// Create an empty object that inherits from the constructor function.
			instanceTarget = Object.create(this.proxy.prototype);
			// Support `can.defineInstanceKey`.
			for (key in this.definitions) {
				Object.defineProperty(instanceTarget, key, this.definitions[key]);
			}
			var instance = this.options.observe(instanceTarget);
			instance[symbols.metaSymbol].preventSideEffects++;
			var res = target.apply(instance, argumentsList);
			instance[symbols.metaSymbol].preventSideEffects--;
			if (res) {
				return res;
			} else {
				return instance;
			}
		}
	},
	// `apply` makes sure the function returns an observable.
	apply: function(target, thisArg, argumentsList) {
		var ret = this.target.apply(thisArg, argumentsList);
		return this.options.observe(ret);
	},
	proxyKeys: function() {
		return proxyKeys;
	}
};

module.exports = makeFunction;


/***/ }),

/***/ "./node_modules/can-observe/src/-make-object.js":
/*!******************************************************!*\
  !*** ./node_modules/can-observe/src/-make-object.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # -make-object.js
// This module's `.observable` method proxies an object to make it observable.
// The other exports are used by other make-TYPE modules.
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

var symbols = __webpack_require__(/*! ./-symbols */ "./node_modules/can-observe/src/-symbols.js");
var observableStore = __webpack_require__(/*! ./-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var helpers = __webpack_require__(/*! ./-helpers */ "./node_modules/can-observe/src/-helpers.js");
var computedHelpers = __webpack_require__(/*! ./-computed-helpers */ "./node_modules/can-observe/src/-computed-helpers.js");

var hasOwn = Object.prototype.hasOwnProperty;
var isSymbolLike = canReflect.isSymbolLike;

// These are the "overwrites" for the proxy.
// Copy the symbols from the map bindings mixin.
var proxyKeys = Object.create(null);
Object.getOwnPropertySymbols(mapBindings).forEach(function(symbol){
	helpers.assignNonEnumerable(proxyKeys, symbol, mapBindings[symbol]);
});

computedHelpers.addKeyDependencies(proxyKeys);

var makeObject = {
	// Returns a proxied version of the object.
	// - `object` - An object to proxy.
	// - `options` - Configurable behaviors.
	//   - `proxyKeys` - Keys that will override any keys on `object`. Defaults to `makeObject.proxyKeys`.
	//   - `observe(nonObservable)` - A function that converts a nested value to an observable.
	//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`
	//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.
	observable: function(object, options) {
		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}

		var meta = {
			target: object,
			proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),
			computedKeys: Object.create(null),
			options: options,
			// `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
			// function (like `Array.splice`) wants to handle event dispatching and/or calling
			// `ObservationRecorder` itself for performance reasons.
			preventSideEffects: 0
		};

		helpers.assignNonEnumerable(meta.proxyKeys, symbols.metaSymbol, meta);

		// We `bind` so the `meta` is immediately available as `this`.
		var traps = {
			get: makeObject.get.bind(meta),
			set: makeObject.set.bind(meta),
			ownKeys: makeObject.ownKeys.bind(meta),
			deleteProperty: makeObject.deleteProperty.bind(meta),
			getOwnPropertyDescriptor: makeObject.getOwnPropertyDescriptor.bind(meta),
			meta: meta
		};

		if(options.getPrototypeOf) {
			traps.getPrototypeOf = options.getPrototypeOf;
		}

		meta.proxy = new Proxy(object, traps);
		mapBindings.addHandlers(meta.proxy, meta);
		return meta.proxy;
	},
	proxyKeys: function() {
		return proxyKeys;
	},
	// `get` checks the target for un-proxied objects.
	// If it finds an un-proxied object:
	//   - it creates one (which registers itself in the observableStore) and
	//   - returns the proxied value without modifying the underlying target
	get: function(target, key, receiver) {
		// If getting a key for the proxy, return that value.
		var proxyKey = this.proxyKeys[key];
		if (proxyKey !== undefined) {
			return proxyKey;
		}

		// Symbols are not observable and their values are not made observable.
		if (isSymbolLike(key)) {
			return target[key];
		}

		// If it has a defined property definiition
		var computedValue = computedHelpers.get(receiver, key);
		if(computedValue !== undefined ) {
			return computedValue.value;
		}

		// Gets information about the key on `target` or on `target`'s prototype.
		var keyInfo = makeObject.getKeyInfo(target, key, receiver, this);
		var value = keyInfo.targetValue;

		// If the return value can be changed ...
		if (!keyInfo.valueIsInvariant) {
			// Convert the value into an observable
			// or get it if already converted from the store.
			value = makeObject.getValueFromStore(key, value, this);
		}

		if (this.options.shouldRecordObservation(keyInfo, this)) {
			ObservationRecorder.add(this.proxy, key.toString());
		}

		// if the parent object is observable, we need to observe there too.
		if (keyInfo.parentObservableGetCalledOn) {
			ObservationRecorder.add(keyInfo.parentObservableGetCalledOn, key.toString());
		}
		return value;
	},
	// `set` is called when a property is set on the proxy or an object
	// that has the proxy on its prototype.
	set: function(target, key, value, receiver) {
		// If the receiver is not this observable (the observable might be on the proto chain),
		// set the key on the reciever.
		if (receiver !== this.proxy && this.options.proxiedPrototype !== true) {
			return makeObject.setKey(receiver, key, value, this);
		}

		// If it has a defined property definiition
		var computedValue = computedHelpers.set(receiver, key, value);
		if(computedValue === true ) {
			return true;
		}

		// Gets the observable value to set.
		value = makeObject.getValueToSet(key, value, this);

		// Sets the value on the target.  If there
		// is a change, calls the callback.
		makeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {

			//!steal-remove-start
			var reasonLog = [canReflect.getName(meta.proxy) + " set", key, "to", value];
			//!steal-remove-end

			var dispatchArgs = {
				type: key,
				patches: [{
					key: key,
					type: hadOwn ? "set" : "add",
					value: value
				}],
				keyChanged: !hadOwn ? key : undefined
			};

			//!steal-remove-start
			if(true) {
				dispatchArgs.reasonLog = reasonLog;
			}				
			//!steal-remove-end

			// Fire event handlers for this key change.
			mapBindings.dispatch.call(meta.proxy, dispatchArgs, [value, old]);

		});

		return true;
	},
	// `deleteProperty` is called when a property is deleted on the proxy.
	deleteProperty: function(target, key) {

		var old = this.target[key],
			deleteSuccessful = delete this.target[key];

		// Fire event handlers if we were able to delete and the value changed.
		if (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {
			//!steal-remove-start
			var reasonLog = [canReflect.getName(this.proxy)+" deleted", key];
			//!steal-remove-end
			// wrapping in process.env.NODE_ENV !== 'production' causes out of scope error
			var dispatchArgs = {
				type: key,
				patches: [{
					key: key,
					type: "delete"
				}],
				keyChanged: key
			};
			//!steal-remove-start
			if(true) {
				dispatchArgs.reasonLog = reasonLog;
			}
			//!steal-remove-end

			mapBindings.dispatch.call( this.proxy, dispatchArgs,[undefined, old]);

		}
		return deleteSuccessful;
	},
	// `ownKeys` returns the proxies keys.
	// Proxies should return the keys and symbols from proxyOnly
	// as well as from the target, so operators like `in` and
	// functions like `hasOwnProperty` can be used to determine
	// that the Proxy is observable.
	ownKeys: function(target) {
		ObservationRecorder.add(this.proxy, symbols.keysSymbol);

		return Object.getOwnPropertyNames(this.target)
			.concat(Object.getOwnPropertySymbols(this.target))
			.concat(Object.getOwnPropertySymbols(this.proxyKeys));
	},
	getOwnPropertyDescriptor: function(target, key) {
		var desc = Object.getOwnPropertyDescriptor(target, key);

		if(!desc && (key in this.proxyKeys)) {
			return Object.getOwnPropertyDescriptor(this.proxyKeys, key);
		}

		return desc;
	},
	// Returns a `keyInfo` object with useful information about the key
	// and its value.  This function is _heavily_ optimized.
	getKeyInfo: function(target, key, receiver, meta) {
		var descriptor = Object.getOwnPropertyDescriptor(target, key);
		var propertyInfo = {
			// The key being read.
			key: key,
			// The property descriptor.
			descriptor: descriptor,
			// If the `target` has the key.
			targetHasOwnKey: Boolean(descriptor),
			// If the proxy is on the proto chain.
			getCalledOnParent: receiver !== meta.proxy,
			// If the prototype of the target has this key.
			protoHasKey: false,
			// If the property is sealed or not.
			valueIsInvariant: false,
			// The value of the key wherever it is found.
			targetValue: undefined,
			// If reading the key went through a getter.
			isAccessor: false
		};
		if (propertyInfo.getCalledOnParent === true) {
			propertyInfo.parentObservableGetCalledOn = observableStore.proxiedObjects.get(receiver);
		}
		if (descriptor !== undefined) {
			propertyInfo.valueIsInvariant = descriptor.writable === false;
			if (descriptor.get !== undefined) {
				propertyInfo.targetValue = descriptor.get.call( propertyInfo.parentObservableGetCalledOn || receiver);
				propertyInfo.isAccessor = true;
			} else {
				propertyInfo.targetValue = descriptor.value;
			}
		} else {
			propertyInfo.targetValue = meta.target[key];
			propertyInfo.protoHasKey = propertyInfo.targetValue !== undefined ? true : (key in target);
		}

		return propertyInfo;
	},
	// Returns `true` if `ObservationRecorder.add` should be called.
	// This is the default `options.shouldRecordObservation` behavior.
	// `observe.Object` changes this to record all keys except functions on the
	// proto chain.
	shouldRecordObservationOnOwnAndMissingKeys: function(keyInfo, meta) {
		return meta.preventSideEffects === 0 &&
			// The read is not a getter AND ...
			!keyInfo.isAccessor &&
			(
				// (the read is on the proxy OR
				(// it's not on the proto chain and we are not sealed).
                keyInfo.targetHasOwnKey || !keyInfo.protoHasKey && !Object.isSealed(meta.target))
			);
	},
	// `setKey` sets a value on an object. Use `Object.defineProperty`
	// because it won't try setting up the proto chain.
	setKey: function(receiver, key, value) {
		Object.defineProperty(receiver, key, {
			value: value,
			configurable: true,
			enumerable: true,
			writable: true
		});
		return true;
	},
	// `getValueToSet` gets the value we will set on the object.  It only
	// converts set values to observables if we have actually bound.
	getValueToSet: function(key, value, meta) {
		if (!canReflect.isSymbolLike(key) && meta.handlers.getNode([key])) {
			return makeObject.getValueFromStore(key, value, meta);
		}
		return value;
	},
	// Get a value from the store if we can.
	getValueFromStore: function(key, value, meta) {
		// We never convert primitives or things that are already observable.
		// However, there are some builtIns that we premptively convert, namely
		// Array.prototype methods.
		if (!canReflect.isPrimitive(value) &&
			!canReflect.isObservableLike(value) &&
			// Do nothing if the value is already a converted proxy.
			!observableStore.proxies.has(value)) {

			// If the `value` already been made into a proxy, use the value.
			if (observableStore.proxiedObjects.has(value)) {
				value = observableStore.proxiedObjects.get(value);
			}
			else if (!helpers.isBuiltInButNotArrayOrPlainObject(value)) {
				value = meta.options.observe(value);
			}
		}
		return value;
	},

	// `setValueAndOnChange` sets the value.  If the value changed,
	// calls the `onChange` callback.
	setValueAndOnChange: function(key, value, data, onChange) {
		var old, change;
		var hadOwn = hasOwn.call(data.target, key);

		var descriptor = Object.getOwnPropertyDescriptor(data.target, key);
		// call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)
		// -- setters do not return values, so it is unnecessary to check for changes.
		if (descriptor && descriptor.set) {
			descriptor.set.call(data.proxy, value);
		} else {
			// otherwise check for a changed value
			old = data.target[key];
			change = old !== value;
			if (change) {
				data.target[key] = value;
				if (data.preventSideEffects === 0) {
					onChange(key, value, data, hadOwn, old);
				}
			}
		}
	}
};


module.exports = makeObject;


/***/ }),

/***/ "./node_modules/can-observe/src/-make-observe.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-observe/src/-make-observe.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getGlobal = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var observables = __webpack_require__(/*! ./-observable-store */ "./node_modules/can-observe/src/-observable-store.js");
var helpers = __webpack_require__(/*! ./-helpers */ "./node_modules/can-observe/src/-helpers.js");

var makeObserve = {
	observe: function(value) {
		if (canReflect.isPrimitive(value)) {
			return value;
		}
		var observable = observables.proxiedObjects.get(value);
		if (observable) {
			return observable;
		}
		if (observables.proxies.has(value)) {
			return value;
		}
		if (helpers.isBuiltInButNotArrayOrPlainObjectOrElement(value)) {
			return value;
		}
		if (typeof value === "function") {
			observable = makeObserve.function(value);
		} else if (helpers.inheritsFromArray(value)) {
			observable = makeObserve.array(value);
		} else if (value instanceof getGlobal().Element) {
			observable = makeObserve.prototype(value);
		} else {
			observable = makeObserve.object(value);
		}
		observables.proxiedObjects.set(value, observable);
		observables.proxies.add(observable);
		return observable;
	},
	// Set to a function that converts non-observable
	// objects to observable objects
	"object": null,
	// Set to a function that converts non-observable
	// arrays to observable arrays
	"array": null,
	// Set to a function that converts non-observable
	// functions to observable functions
	"function": null
};

module.exports = makeObserve;


/***/ }),

/***/ "./node_modules/can-observe/src/-make-prototype.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-observe/src/-make-prototype.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeObject = __webpack_require__(/*! ./-make-object */ "./node_modules/can-observe/src/-make-object.js");
var helpers = __webpack_require__(/*! ./-helpers */ "./node_modules/can-observe/src/-helpers.js");
var symbols = __webpack_require__(/*! ./-symbols */ "./node_modules/can-observe/src/-symbols.js");
var mapBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var isSymbolLike = canReflect.isSymbolLike;
var proxyMetaSymbol = canSymbol.for("can.proxyMeta");

function getMetadata(instance, options) {
	if (instance.hasOwnProperty(proxyMetaSymbol)) {
		return instance[proxyMetaSymbol];
	}

	if(options.shouldRecordObservation === undefined) {
		options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
	}

	// tell makeObject.set to allow setting on meta.target
	// when the receiver is the prototype of meta.instance
	options.proxiedPrototype = true;

	var meta = {
		// store keys on a side-object instead of directly on the instance
		// so that gets and sets will always hit the prototype
		target: makeObject.observable({}, options),
		proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),
		computedKeys: Object.create(null),
		options: options,
		// `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
		// function (like `Array.splice`) wants to handle event dispatching and/or calling
		// `ObservationRecorder` itself for performance reasons.
		preventSideEffects: 0,
		proxy: instance
	};

	// add can.meta symbol to proxyKeys so reading can.meta from the instance
	// will return the meta object (makeObject.get checks proxyKeys first)
	helpers.assignNonEnumerable(meta.proxyKeys, symbols.metaSymbol, meta);

	// set up handlers
	mapBindings.addHandlers(meta.proxy, meta);

	// store meta so it can be retrieved next time
	instance[proxyMetaSymbol] = meta;

	return meta;
}

// # -make-element.js
// This module's `.observable` method proxies a prototype
// in order to make all instances observable.
var makePrototype = {
	observable: function(proto, options) {
		var protoProxy = new Proxy(proto, {
			set: function(target, key, value, receiver) {
				// setting symbols should not trigger events
				// (since that would cause infinite loops becase getMetadata sets symbols)
				//
				// keys in the prototype should just be set (things like innerHTML)
				if (isSymbolLike(key) || key in target) {
					return Reflect.set(target, key, value, receiver);
				}

				var meta = getMetadata(receiver, options);
				return makeObject.set.call(meta, target, key, value, receiver);
			},
			get: function(target, key, receiver) {
				// keys on the prototype should just be returned (things like appendChild, etc)
				if (key in target) {
					return Reflect.get(target, key, receiver);
				}

				var meta = getMetadata(receiver, options);
				return makeObject.get.call(meta, target, key, receiver);
			}
		});

		return protoProxy;
	}
};

module.exports = makePrototype;


/***/ }),

/***/ "./node_modules/can-observe/src/-observable-store.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/src/-observable-store.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";

module.exports = {
	proxiedObjects: new WeakMap(),
	proxies: new WeakSet()
};

/***/ }),

/***/ "./node_modules/can-observe/src/-symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/can-observe/src/-symbols.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

module.exports = {
	metaSymbol: canSymbol.for("can.meta"),
	// not an actual symbol. This is so it can be enumerable
	// by default. We could create a KeyTree with a type where symbols are
	// enumerable.
	patchesSymbol: "can.patches",
	keysSymbol: "can.keys"
};


/***/ }),

/***/ "./node_modules/can-observe/src/-type-helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-observe/src/-type-helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canMeta = canSymbol.for("can.meta");
var typeDefinitionsSymbol = canSymbol.for("can.typeDefinitions");

var helpers = module.exports = {
	ensureDefinition: function(prototype) {
		var typeDefs = prototype[typeDefinitionsSymbol];
		if (!typeDefs) {
			var parent = prototype[typeDefinitionsSymbol];
			typeDefs = prototype[typeDefinitionsSymbol] = Object.create(parent || null);
		}

		return typeDefs;
	},
	addMethodsAndSymbols: function(Type) {
		canReflect.assignSymbols(Type, {
			"can.defineInstanceKey": function(prop, value) {
				helpers.ensureDefinition(this.prototype)[prop] = value;
			},
			"can.dispatchInstanceBoundChange": function(obj, isBound) {
				var meta = this[canMeta];
				if (meta) {
					var lifecycleHandlers = meta.lifecycleHandlers;
					if (lifecycleHandlers) {
						queues.enqueueByQueue(lifecycleHandlers.getNode([]), this, [obj, isBound]);
					}
				}
			},
		});
	},
	shouldRecordObservationOnAllKeysExceptFunctionsOnProto: function(keyInfo, meta){
		return meta.preventSideEffects === 0 && !keyInfo.isAccessor && (
			// it's on us
			(// it's on our proto, but not a function
            (keyInfo.targetHasOwnKey ) ||
			// it's "missing", and we are not sealed
			(!keyInfo.protoHasKey && !Object.isSealed(meta.target)) || keyInfo.protoHasKey && (typeof targetValue !== "function"))
		);
	},
};


/***/ }),

/***/ "./node_modules/can-param/can-param.js":
/*!*********************************************!*\
  !*** ./node_modules/can-param/can-param.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

function buildParam(prefix, obj, add) {
	if (Array.isArray(obj)) {
		for (var i = 0, l = obj.length; i < l; ++i) {
			var inner = obj[i];
			var shouldIncludeIndex = typeof inner === 'object';
			var arrayIndex = shouldIncludeIndex ? '[' + i + ']' : '[]';
			buildParam(prefix + arrayIndex, inner, add);
		}
	} else if ( obj && typeof obj === "object" ) {
		for (var name in obj) {
			buildParam(prefix + '[' + name + ']', obj[name], add);
		}
	} else {
		add(prefix, obj);
	}
}

module.exports = namespace.param = function param(object) {
	var pairs = [],
		add = function (key, value) {
			pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
		};
	for (var name in object) {
		buildParam(name, object[name], add);
	}
	return pairs.join('&')
		.replace(/%20/g, '+');
};


/***/ }),

/***/ "./node_modules/can-parse-uri/can-parse-uri.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-parse-uri/can-parse-uri.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * @module {function} can-parse-uri can-parse-uri
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @package ./package.json
 * @signature `parseURI(url)`
 *
 * Parse a URI into its components.
 *
 * ```js
 * import {parseURI} from "can"
 * parseURI("http://foo:8080/bar.html?query#change")
 * //-> {
 * //  authority: "//foo:8080",
 * //  hash: "#change",
 * //  host: "foo:8080",
 * //  hostname: "foo",
 * //  href: "http://foo:8080/bar.html?query#change",
 * //  pathname: "/bar.html",
 * //  port: "8080",
 * //  protocol: "http:",
 * //  search: "?query"
 * // }
 * ```
 *
 * @param {String} url The URL you want to parse.
 *
 * @return {Object} Returns an object with properties for each part of the URL. `null`
 * is returned if the url can not be parsed.
 */
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
module.exports = namespace.parseURI = function(url){
		var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
			// authority = '//' + user + ':' + pass '@' + hostname + ':' port
		return (m ? {
			href     : m[0] || '',
			protocol : m[1] || '',
			authority: m[2] || '',
			host     : m[3] || '',
			hostname : m[4] || '',
			port     : m[5] || '',
			pathname : m[6] || '',
			search   : m[7] || '',
			hash     : m[8] || ''
		} : null);
	};


/***/ }),

/***/ "./node_modules/can-query-logic/can-query-logic.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-query-logic/can-query-logic.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ./src/set */ "./node_modules/can-query-logic/src/set.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var makeBasicQueryConvert = __webpack_require__(/*! ./src/serializers/basic-query */ "./node_modules/can-query-logic/src/serializers/basic-query.js");
var BasicQuery = __webpack_require__(/*! ./src/types/basic-query */ "./node_modules/can-query-logic/src/types/basic-query.js");
var valueComparisons = __webpack_require__(/*! ./src/types/comparisons */ "./node_modules/can-query-logic/src/types/comparisons.js");
var schemaSymbol = canSymbol.for("can.getSchema");
var newSymbol = canSymbol.for("can.new");
var makeEnum = __webpack_require__(/*! ./src/types/make-enum */ "./node_modules/can-query-logic/src/types/make-enum.js");


// Creates an algebra used to convert primitives to types and back
function QueryLogic(Type, options){
    Type = Type || {};
    var passedHydrator = options && options.toQuery;
    var passedSerializer = options && options.toParams;
    var schema;
    if(Type[schemaSymbol]) {
        schema = Type[schemaSymbol]();
    } else {
        schema = Type;
    }

    // check that the basics are here

    var id = schema.identity && schema.identity[0];
    if(!id) {
        //console.warn("can-query given a type without an identity schema.  Using `id` as the identity id.");
        schema.identity = ["id"];
    }

    var converter = makeBasicQueryConvert(schema),
        hydrate,
        serialize;

    if(passedHydrator) {
        hydrate = function(query){
            return converter.hydrate(passedHydrator(query));
        };
    } else {
        hydrate = converter.hydrate;
    }

    if(passedSerializer) {
        serialize = function(query){
            return passedSerializer(converter.serializer.serialize(query));
        };
    } else {
        serialize = converter.serializer.serialize;
    }
    this.hydrate = hydrate;
    this.serialize = serialize;
    this.schema = schema;

}

function makeNewSet(prop){
    return function(qA, qB){
        var queryA = this.hydrate(qA),
            queryB = this.hydrate(qB);
        var unionQuery = set[prop](queryA , queryB );
        return this.serialize( unionQuery );
    };
}

function makeReturnValue(prop) {
    return function(qA, qB){
        var queryA = this.hydrate(qA),
            queryB = this.hydrate(qB);
        return set[prop](queryA , queryB );
    };
}

canReflect.assignSymbols(QueryLogic.prototype,{
    "can.getSchema": function(){
        return this.schema;
    }
});

canReflect.assign(QueryLogic.prototype,{
    union: makeNewSet("union"),
    difference: makeNewSet("difference"),
    intersection: makeNewSet("intersection"),

    isEqual: makeReturnValue("isEqual"),
    isProperSubset: makeReturnValue("isProperSubset"),
    isSubset: makeReturnValue("isSubset"),

    isSpecial: set.isSpecial,
    isDefinedAndHasMembers: set.isDefinedAndHasMembers,

    count: function(a){
        var queryA = this.hydrate(a);
        return queryA.page.end - queryA.page.start + 1;
    },

    // identity keys
    identityKeys: function(){
        //console.warn("you probably can get the identity keys some other way");
        return this.schema.identity;
    },

    filterMembers: function(a, b, bData){
        var queryA = this.hydrate(a);
        if(arguments.length >= 3) {
            var queryB = this.hydrate(b);
            return queryA.filterFrom(bData, queryB);
        } else {
            return queryA.filterFrom(b);
        }

    },
    // filterMembersAndGetCount
    filterMembersAndGetCount: function(a, b, bData) {
        var queryA = this.hydrate(a),
            queryB = this.hydrate(b);
        return queryA.filterMembersAndGetCount(bData, queryB);
    },
    // unionMembers
    unionMembers: function(a, b, aData, bData) {
        var queryA = this.hydrate(a),
            queryB = this.hydrate(b);

        var schema = this.schema;
        return queryA.merge(queryB, aData, bData, function(obj){
            return canReflect.getIdentity(obj, schema);
        });
    },
    // isMember
    isMember: function(query, props) {
        return this.hydrate(query).isMember(props);
    },

    memberIdentity: function(props) {
        // console.warn("you probably can get the member identity some other way");
        return canReflect.getIdentity(props, this.schema);
    },
    index: function(query, items, props){
        return this.hydrate(query).index(props, items);
    },

    insert: function(query, items, item){
    	var index = this.index(query, items, item);
    	if(index === undefined) {
    		index = items.length;
    	}

    	var copy = items.slice(0);
    	copy.splice(index, 0, item);

    	return copy;
    },

    isPaginated: function(query) {
        var basicQuery = this.hydrate(query);
        return !set.isEqual(basicQuery.page, set.UNIVERSAL);
    },
    removePagination: function(query) {
        var basicQuery = this.hydrate(query);
        basicQuery.removePagination();
        return this.serialize( basicQuery );
    },

});

// Copy everything on `set` to QueryLogic
for(var prop in set) {
    if(QueryLogic[prop] === undefined) {
        QueryLogic[prop] = set[prop];
    }
}



QueryLogic.makeEnum = function(values){
    var Type = function(){};
		Type[newSymbol] = function(val) { return val; };
    makeEnum(Type, values);
    return Type;
};



QueryLogic.KeysAnd = BasicQuery.KeysAnd;
QueryLogic.ValuesOr = BasicQuery.Or;



QueryLogic.In = valueComparisons.In;
QueryLogic.NotIn = valueComparisons.NotIn;
QueryLogic.GreaterThan = valueComparisons.GreaterThan;
QueryLogic.GreaterThanEqual = valueComparisons.GreaterThanEqual;
QueryLogic.LessThan = valueComparisons.LessThan;
QueryLogic.LessThanEqual = valueComparisons.LessThanEqual;
QueryLogic.ValueAnd = valueComparisons.And;
QueryLogic.ValueOr = valueComparisons.Or;

module.exports = QueryLogic;


/***/ }),

/***/ "./node_modules/can-query-logic/src/array-union-intersection-difference.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/can-query-logic/src/array-union-intersection-difference.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SET = __webpack_require__(/*! ./set */ "./node_modules/can-query-logic/src/set.js");


function getValue(value){
    return value == null ? value : value.valueOf();
}

module.exports = function arrayUnionIntersectionDifference(arr1, arr2){
    var set = new Set();

    var intersection = [];
    var union = [];
    var difference = arr1.slice(0);


    arr1.forEach(function(value){
        set.add(getValue(value));
        union.push(value);
    });

    arr2.forEach(function(value){
        if(set.has(getValue(value))) {
            intersection.push(value);
            var index = SET.indexWithEqual(difference, value);
            if(index !== -1) {
                difference.splice(index, 1);
            }
        } else {
            union.push(value);
        }
    });

    return {
        intersection: intersection,
        union: union,
        difference: difference
    };
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/helpers.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-query-logic/src/helpers.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// mongo puts these first https://docs.mongodb.com/manual/reference/bson-type-comparison-order/#bson-types-comparison-order
var typeNumber = {"undefined": 0, "null": 1, "number": 3, "string": 4, "object": 5, "boolean": 6};
var getTypeNumber = function(obj) {
	var type = typeof obj;
	if(obj === null) {
		type = "null";
	}
	return typeNumber[type];
};

var typeCompare = {
	$gt: function(valueA, valueB) {
		return getTypeNumber(valueA) > getTypeNumber(valueB);
	},
	$lt: function(valueA, valueB) {
		return getTypeNumber(valueA) < getTypeNumber(valueB);
	}
};

var defaultCompare = {
	$gt: function(valueA, valueB) {
		if(valueA == null || valueB == null) {
			return typeCompare.$gt(valueA, valueB);
		}
		return valueA > valueB;
	},
	$lt: function(valueA, valueB) {
		if(valueA == null || valueB == null) {
			return typeCompare.$gt(valueA, valueB);
		}
		return valueA < valueB;
	}
};

var helpers = {

	// given two arrays of items, combines and only returns the unique ones
	uniqueConcat: function(itemsA, itemsB, getId) {
		var ids = new Set();
		return itemsA.concat(itemsB).filter(function(item) {
			var id = getId(item);
			if (!ids.has(id)) {
				ids.add(id);
				return true;
			} else {
				return false;
			}
		});
	},
	// Get the index of an item by it's identity
	// Starting from the middle of the items
	// return the index of match in the right direction
	// or in the left direction
	// otherwise return the last index
	// see getIdentityIndexByDirection
	getIdentityIndex: function(compare, items, props, startIndex, schema) {
		var identity = canReflect.getIdentity(props, schema),
			starterItem = items[startIndex];
		// check if the middle has a match
		if (compare(props, starterItem) === 0) {
			if (identity === canReflect.getIdentity(starterItem, schema)) {
				return startIndex;
			}
		}
		
		var rightResult = this.getIdentityIndexByDirection(compare, items, props, startIndex+1, 1, schema),
			leftResult;
		if(rightResult.index) {
			return rightResult.index;
		} else {
			leftResult = this.getIdentityIndexByDirection(compare, items, props, startIndex-1, -1, schema);
		}
		if(leftResult.index !== undefined) {
			return leftResult.index;
		}
		// put at the last index item that doesn't match an identity
		return rightResult.lastIndex;
	},
	// Get the index of an item by it's identity
	// for a given direction (right or left)
	// 1 for right
	// -1 for left
	getIdentityIndexByDirection: function(compare, items, props, startIndex, direction, schema) {
		var currentIndex = startIndex;
		var identity = canReflect.getIdentity(props, schema);
		while(currentIndex >= 0 && currentIndex < items.length) {
			var currentItem = items[currentIndex];
			var computed = compare(props, currentItem);
			if(computed === 0) {
				if( identity === canReflect.getIdentity(currentItem, schema)) {
					return {index: currentIndex};
				}
			} else {
				return {lastIndex: currentIndex - direction};
			}
			currentIndex = currentIndex + direction;
		}
		return {lastIndex: currentIndex - direction};
	},
	//
	getIndex: function(compare, items, props, schema) {
		if (!items || !items.length) {
			return undefined;
		}
		// check the start and the end
		if (compare(props, items[0]) === -1) {
			return 0;
		} else if (compare(props, items[items.length - 1]) === 1) {
			return items.length;
		}

		var low = 0,
			high = items.length;

		// From lodash lodash 4.6.1 <https://lodash.com/>
		// Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
		while (low < high) {
			var mid = (low + high) >>> 1,
				item = items[mid],
				computed = compare(props, item);
			if (computed === 0) {
				return this.getIdentityIndex(compare, items, props, mid, schema);
			} else if (computed === -1) {
				high = mid;
			} else {
				low = mid + 1;
			}
		}
		return high;
		// bisect by calling sortFunc
	},
	sortData: function(sortPropValue) {
		if (sortPropValue[0] === "-") {
			return {
				prop: sortPropValue.slice(1),
				desc: true
			};
		} else {
			return {
				prop: sortPropValue,
				desc: false
			};
		}
	},
	defaultCompare: defaultCompare,
	typeCompare: typeCompare,
	sorter: function(sortPropValue, sorters) {
		var data = helpers.sortData(sortPropValue);
		var compare;
		if (sorters && sorters[data.prop]) {
			compare = sorters[data.prop];
		} else {
			compare = defaultCompare;
		}
		return function(item1, item2) {
			var item1Value = canReflect.getKeyValue(item1, data.prop);
			var item2Value = canReflect.getKeyValue(item2, data.prop);
			var temp;

			if (data.desc) {
				temp = item1Value;
				item1Value = item2Value;
				item2Value = temp;
			}

			if (compare.$lt(item1Value, item2Value)) {
				return -1;
			}

			if (compare.$gt(item1Value, item2Value)) {
				return 1;
			}

			return 0;
		};
	},
	valueHydrator: function(value) {
		if (canReflect.isBuiltIn(value)) {
			return value;
		} else {
			throw new Error("can-query-logic doesn't support comparison operator: " + JSON.stringify(value));
		}
	}
};
module.exports = helpers;


/***/ }),

/***/ "./node_modules/can-query-logic/src/schema-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/can-query-logic/src/schema-helpers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var set = __webpack_require__(/*! ./set */ "./node_modules/can-query-logic/src/set.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var schemaHelpers;
module.exports = schemaHelpers = {

    // Number is a ranged type
    isRangedType: function(Type){
        return Type && canReflect.isConstructorLike(Type) &&
            !set.hasComparisons(Type) &&
            !Type[canSymbol.for("can.SetType")] &&
            Type.prototype.valueOf && Type.prototype.valueOf !== Object.prototype.valueOf;
    },
    categorizeOrValues: function categorizeOrValues(values){

    	var categories = {
    		primitives: [],
    		valueOfTypes: [],
    		others: []
    	};

    	values.forEach(function(value){
    		if( canReflect.isPrimitive( value ) ) {
    			categories.primitives.push(value);
    		}
    		else if( schemaHelpers.isRangedType(value) ) {
    			categories.valueOfTypes.push(value);
    		}
    		else {
    			categories.others.push(value);
    		}
    	});
    	return categories;
    }
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/serializer.js":
/*!********************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializer.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Serializer = function(entries){
	var serializers = this.serializers = new Map();
	if (entries) {
		entries.forEach(function(entry) {
			var key = entry[0], value = entry[1];
			serializers.set(key, value);
		});
	}
    this.serialize = this.serialize.bind(this);
};
Serializer.prototype.add = function(serializers){
    canReflect.assign( this.serializers, serializers instanceof Serializer ? serializers.serializers : serializers );
};


Serializer.prototype.serialize = function(item) {
    if(!item) {
        return item;
    }
    var Type = item.constructor;
    var serializer = this.serializers.get(Type);
    if(!serializer) {
        return canReflect.serialize(item);
    } else {
        return serializer(item, this.serialize);
    }
};

module.exports = Serializer;


/***/ }),

/***/ "./node_modules/can-query-logic/src/serializers/basic-query.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializers/basic-query.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var BasicQuery = __webpack_require__(/*! ../types/basic-query */ "./node_modules/can-query-logic/src/types/basic-query.js");
var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var comparisonsConverter = __webpack_require__(/*! ../serializers/comparisons */ "./node_modules/can-query-logic/src/serializers/comparisons.js");
var Serializer = __webpack_require__(/*! ../serializer */ "./node_modules/can-query-logic/src/serializer.js");
var is = __webpack_require__(/*! ../types/comparisons */ "./node_modules/can-query-logic/src/types/comparisons.js");
var makeMaybe = __webpack_require__(/*! ../types/make-maybe */ "./node_modules/can-query-logic/src/types/make-maybe.js");
var makeEnum = __webpack_require__(/*! ../types/make-enum */ "./node_modules/can-query-logic/src/types/make-enum.js");
var logDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-query-logic/src/helpers.js");

var setTypeSymbol = canSymbol.for("can.SetType");
var schemaSymbol = canSymbol.for("can.getSchema");

var defaultQuery = new BasicQuery({});


function getSchemaProperties(value) {
	var constructor = value.constructor;
	if (constructor && constructor[schemaSymbol]) {
		var schema = constructor[schemaSymbol]();
		return schema.keys || {};
	} else {
		return {};
	}
}

function hydrateFilter(values, schemaProperties, hydrateUnknown) {
	var valuesIsObject = values && typeof values === "object";
	if (valuesIsObject && ("$or" in values)) {
		return hydrateOrs(values.$or, schemaProperties, hydrateUnknown);
	} else if(valuesIsObject && ("$and" in values)) {
		return hydrateAnds(values.$and, schemaProperties, hydrateUnknown);
	} else {
		return hydrateAndValues(values, schemaProperties, hydrateUnknown);
	}
}

var setTypeMap = new WeakMap();

// This is used to hydrate a value directly within a `filter`'s And.
function hydrateAndValue(value, prop, SchemaType, hydrateChild) {
	// The `SchemaType` is the type of value on `instances` of
	// the schema. `Instances` values are different from `Set` values.
	if (SchemaType) {
		// If there's a `SetType`, we will use that
		var SetType = SchemaType[setTypeSymbol];
		if (SetType) {
			/// If it exposes a hydrate, this means it can use the current hydrator to
			// hydrate its children.
			// I'm not sure why it's not taking the `unknown` hydrator instead.
			if (SetType.hydrate) {
				return SetType.hydrate(value, comparisonsConverter.hydrate);
			}
			// If the SetType implemented `union`, `intersection`, `difference`
			// We can create instances of it directly.
			else if (set.hasComparisons(SetType)) {
				// Todo ... canReflect.new
				return new SetType(value);
			}
			// If the SetType did not implement the comparison methods,
			// it's probably just a "Value" comparison type. We will hydrate
			// as a comparison converter, but create an instance of this `"Value"`
			// comparison type within the comparison converter.
			else {
				// inner types
				return comparisonsConverter.hydrate(value, function(value) {
					return new SetType(value);
				});
			}

		} else {
			// There is a `SchemaType`, but it doesn't have a `SetType`.
			// Can we create the SetType from the `SchemaType`?
			if (makeEnum.canMakeEnumSetType(SchemaType)) {
				if (!setTypeMap.has(SchemaType)) {
					setTypeMap.set(SchemaType, makeEnum.makeEnumSetType(SchemaType));
				}
				SetType = setTypeMap.get(SchemaType);
				return new SetType(value);
			}
			// It could also have a `ComparisonSetType` which are the values
			// within the Maybe type.
			else if (makeMaybe.canMakeMaybeSetType(SchemaType)) {
				if (!setTypeMap.has(SchemaType)) {
					setTypeMap.set(SchemaType, makeMaybe.makeMaybeSetTypes(SchemaType));
				}
				SetType = setTypeMap.get(SchemaType).Maybe;
				return SetType.hydrate(value, comparisonsConverter.hydrate);
			}
			// We can't create the `SetType`, so lets hydrate with the default behavior.
			else {
				return comparisonsConverter.hydrate(value, hydrateChild);
			}
		}
	} else {
		// HERE {$gt: 1} -> new is.GreaterThan(1)
		return comparisonsConverter.hydrate(value, hydrateChild);
	}
}

function hydrateAndValues(values, schemaProperties, hydrateUnknown) {
	schemaProperties = schemaProperties || {};

	function hydrateChild(value) {
		if (value) {
			if (Array.isArray(value)) {
				return value.map(hydrateUnknown);
			} else if (canReflect.isPlainObject(value)) {
				// lets try to get the schema ...
				return hydrateAndValues(value, getSchemaProperties(value));
			}
		}
		if (hydrateUnknown) {
			return hydrateUnknown(value);
		} else {
			return value;
		}
	}
	var clone = {};
	canReflect.eachKey(values, function(value, prop) {
		clone[prop] = hydrateAndValue(value, prop, schemaProperties[prop], hydrateChild);
	});

	return new BasicQuery.KeysAnd(clone);

}
// This tries to combine a bunch of OR-ed ANDS into a single AND.
// Example: [{name: "j", age: 3},{name: "j", age: 4}] //-> {name: "j", age: in[3,4]}
function combineAnds(ands) {
	var firstKeys = Object.keys(ands[0].values);
	var keys = {};

	var keysCompare = new is.In(firstKeys);

	firstKeys.map(function(key) {
		keys[key] = [];
	});

	var sameKeys = ands.every(function(and) {
		// have to have the same keys
		if (!set.isEqual(keysCompare, new is.In(Object.keys(and.values)))) {
			return false;
		}
		canReflect.eachKey(and.values, function(value, key) {
			keys[key].push(value);
		});
		return true;
	});
	if (!sameKeys) {
		return;
	}
	// now try to union everything and see if it simplifies ...
	var unequalKeys = [];
	firstKeys.forEach(function(key) {
		var isEqual = keys[key].reduce(function(newSet, lastSetOrFalse) {
			if (lastSetOrFalse === false) {
				return false;
			}
			if (lastSetOrFalse === undefined) {
				return newSet;
			}
			var res = set.isEqual(newSet, lastSetOrFalse);
			return res ? newSet : false;
		});
		if (!isEqual) {
			unequalKeys.push(key);
		}
	});

	if (unequalKeys.length !== 1) {
		return;
	}
	var unionKey = unequalKeys[0];
	// lets see if we can union that one value
	var unioned = keys[unionKey].reduce(function(cur, last) {
		return set.union(cur, last);
	}, set.EMPTY);

	var result = {};
	firstKeys.map(function(key) {
		result[key] = keys[key][0];
	});
	result[unionKey] = unioned;
	return new BasicQuery.KeysAnd(result);
}

function hydrateOrs(values, schemaProperties, hydrateUnknown) {
	var comparisons = values.map(function(value) {
		return hydrateAndValues(value, schemaProperties, hydrateUnknown);
	});
	var combined = combineAnds(comparisons);
	if (combined) {
		return combined;
	}
	return new BasicQuery.Or(comparisons);
}

function hydrateAnds(values, schemaProperties, hydrateUnknown) {
	var comparisons = values.map(function(value) {
		return hydrateAndValues(value, schemaProperties, hydrateUnknown);
	});
	return new BasicQuery.And(comparisons);
}

function recursivelyAddOrs(ors, value, serializer, key){
    value.orValues().forEach(function(orValue){
        if(typeof orValue.orValues === "function") {
            recursivelyAddOrs(ors, orValue, serializer, key);
        } else {
            var result = {};
            result[key] = serializer(orValue);
            ors.push( result );
        }
    });
}

module.exports = function(schema) {

	var id = schema.identity && schema.identity[0];
	var keys = schema.keys;

	var serializeMap = [
		[BasicQuery.Or, function(or, serializer) {
			return or.values.map(function(value) {
				return serializer(value);
			});
		}],
		[BasicQuery.And, function(and, serializer) {
			return { $and: and.values.map(function(value) {
				return serializer(value);
			}) };
		}],
		[BasicQuery.Not, function(nots, serializer) {
			return { $not: serializer(nots.value) };
		}],
		// this destructures ANDs with OR-like clauses
		[BasicQuery.KeysAnd, function(and, serializer) {
			var ors = [];
			var result = {};
			canReflect.eachKey(and.values, function(value, key) {
				// is value universal ... if not, we don't need to add anything

				if (typeof value.orValues === "function") {
					recursivelyAddOrs(ors, value, serializer, key);
				} else {
					result[key] = serializer(value);
				}
			});

			if (ors.length) {
				if (ors.length === 1) {
					return ors[0];
				} else {
					return {
						$or: ors.map(function(orPart) {
							return canReflect.assign(canReflect.serialize(result), orPart);
						})
					};
				}
			} else {
				return result;
			}

		}],
		[BasicQuery.RecordRange, function(range) {
			return {
				start: range.start,
				end: range.end
			};
		}],
		[BasicQuery, function(basicQuery, childSerializer) {

			var filter = set.isEqual(basicQuery.filter, set.UNIVERSAL) ? {} : childSerializer(basicQuery.filter);

			var res = {};
			if (canReflect.size(filter) !== 0) {
				res.filter = filter;
			}

			if (!set.isEqual(basicQuery.page, defaultQuery.page)) {
				// we always provide the start, even if it's 0
				res.page = {
					start: basicQuery.page.start
				};
				if (basicQuery.page.end !== defaultQuery.page.end) {
					res.page.end = basicQuery.page.end;
				}
			}

			if (basicQuery.sort.key !== id) {
				res.sort = basicQuery.sort.key;
			}
			return res;

		}]
	];



	// Makes a sort type that can make a compare function using the SetType
	var Sort = BasicQuery.makeSort(schema, hydrateAndValue);
	var serializer = new Serializer(serializeMap);
	serializer.add(comparisonsConverter.serializer);

	return {
		hydrate: function(data) {

			//!steal-remove-start
			if (true) {
				var AcceptedFields = makeEnum(function() {}, ["filter", "sort", "page"]);
				var diff = set.difference(new AcceptedFields(Object.keys(data)), AcceptedFields.UNIVERSAL);
				if (diff.values && diff.values.length) {
					logDev.warn(
						"can-query-logic: Ignoring keys: " + diff.values.join(", ") + "."
					);
				}
			}
			//!steal-remove-end


			var filter = canReflect.serialize(data.filter);

			// this mutates
			var filterAnd = hydrateFilter(filter, keys, helpers.valueHydrator);

			// Conver the filter arguments

			var query = {
				filter: filterAnd
			};
			if (data.page) {
				query.page = new BasicQuery.RecordRange(data.page.start, data.page.end);
			}
			if (data.sort) {
				query.sort = new Sort(data.sort);
			} else {
				query.sort = new Sort(id);
			}
			return new BasicQuery(query);
		},
		serializer: serializer
	};
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/serializers/comparisons.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializers/comparisons.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var is = __webpack_require__(/*! ../types/comparisons */ "./node_modules/can-query-logic/src/types/comparisons.js");
var Serializer = __webpack_require__(/*! ../serializer */ "./node_modules/can-query-logic/src/serializer.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ValuesNot = __webpack_require__(/*! ../types/values-not */ "./node_modules/can-query-logic/src/types/values-not.js");

function makeNew(Constructor) {
	return function(value) {
		return new Constructor(value);
	};
}
var hydrateMap = {};
function addHydrateFrom(key, hydrate) {
	hydrateMap[key] = function(value, unknownHydrator) {
		return hydrate( unknownHydrator ? unknownHydrator(value[key]) : value[key]);
	};
	Object.defineProperty(hydrateMap[key], "name", {
		value: "hydrate "+key,
		writable: true
	});
}

function addHydrateFromValues(key, hydrate) {
	hydrateMap[key] = function(value, unknownHydrator) {
		var clones = value[key];
		if(unknownHydrator) {
			clones = clones.map(function(value) {
				return unknownHydrator(value);
			});
		}
		return hydrate( clones );
	};
	Object.defineProperty(hydrateMap[key], "name", {
		value: "hydrate "+key,
		writable: true
	});
}

// https://docs.mongodb.com/manual/reference/operator/query-comparison/
addHydrateFrom("$eq", function(value) {
	return new is.In([value]);
});
addHydrateFrom("$ne", function(value) {
	return new is.NotIn([value]);
});

addHydrateFrom("$gt", makeNew(is.GreaterThan));
addHydrateFrom("$gte", makeNew(is.GreaterThanEqual));
addHydrateFromValues("$in", makeNew(is.In));
addHydrateFrom("$lt", makeNew(is.LessThan));
addHydrateFrom("$lte", makeNew(is.LessThanEqual));

addHydrateFromValues("$all", makeNew(is.All));

// This is a mapping of types to their opposite. The $not hydrator
// uses this to create a more specific type, since they are logical opposites.
var oppositeTypeMap = {
	LessThan: { Type: is.GreaterThanEqual, prop: "value" },
	LessThanEqual: { Type: is.GreaterThan, prop: "value" },
	GreaterThan: { Type: is.LessThanEqual, prop: "value" },
	GreaterThanEqual: { Type: is.LessThan, prop: "value" },
	In: { Type: is.NotIn, prop: "values" },
	NotIn: { Type: is.In, prop: "values" }
};

hydrateMap.$not = function(value, unknownHydrator) {
	// Many nots can be hydrated to their opposite.
	var hydratedValue = hydrateValue(value.$not, unknownHydrator);
	var typeName = hydratedValue.constructor.name || hydratedValue.constructor.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

	if(oppositeTypeMap[typeName]) {
		var options = oppositeTypeMap[typeName];
		var OppositeConstructor = options.Type;
		var prop = options.prop;

		return new OppositeConstructor(hydratedValue[prop]);
	}

	return new ValuesNot(hydratedValue);
};

addHydrateFromValues("$nin", makeNew(is.NotIn));


var serializer = new Serializer([
	[is.In,function(isIn, serialize) {
		return isIn.values.length === 1 ?
			serialize(isIn.values[0]) :
			{$in: isIn.values.map(serialize)};
	}],
	[is.NotIn,function(notIn, serialize) {
		return notIn.values.length === 1 ?
			{$ne: serialize(notIn.values[0])} : {$nin: notIn.values.map(serialize)};
	}],
	[is.GreaterThan, function(gt, serialize) { return {$gt: serialize(gt.value) }; }],
	[is.GreaterThanEqual, function(gte, serialize) { return {$gte: serialize(gte.value) }; }],
	[is.LessThan, function(lt, serialize) { return {$lt: serialize(lt.value) }; }],
	[is.LessThanEqual, function(lt, serialize) { return {$lte: serialize(lt.value) }; }],
	[is.And, function(and, serialize) {
		var obj = {};
		and.values.forEach(function(clause) {
			canReflect.assignMap(obj, serialize(clause) );
		});
		return obj;
	}],
	[is.All, function(all, serialize) {
		return {
			$all: serialize(all.values)
		};
	}]
	/*[is.Or, function(or, serialize) {
		return {
			$or: or.values.map(function(value) {
				return serialize(value, serialize);
			})
		};
	}]*/
]);

function hydrateValue(value, hydrateUnknown) {
	if(!hydrateUnknown) {
		hydrateUnknown = function() {
			throw new Error("can-query-logic doesn't recognize operator: "+JSON.stringify(value));
		};
	}
	if(Array.isArray(value)) {
		return new is.In(value.map(function(value) {
			return hydrateUnknown(value);
		}));
	}
	else if(value && typeof value === "object") {
		var keys = Object.keys(value);
		var allKeysAreComparisons = keys.every(function(key) {
			return hydrateMap[key];
		});
		if(allKeysAreComparisons) {
			var andClauses = keys.map(function(key) {
				var part = {};
				part[key] = value[key];
				var hydrator = hydrateMap[key];
				return hydrator(part, hydrateUnknown);
			});
			if(andClauses.length > 1) {
				return new is.And(andClauses);
			} else {
				return andClauses[0];
			}
		} else {
			return hydrateUnknown(value);
		}
	} else {
		return new is.In([hydrateUnknown(value)]);
	}
}

module.exports = {
	// value - something from a query, for example {$in: [1,2]}
	hydrate: hydrateValue,
	serializer: serializer
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/set.js":
/*!*************************************************!*\
  !*** ./node_modules/can-query-logic/src/set.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// # can-query-logic/set.js
// This file defines the set mechanics of types.
// It provides ways for types to define how to perform
// `union`, `difference`, `intersection` operations.
//
// It also derives other operators (`isEqual`, `isSubset`, etc) from these
// core operators.
//
// `.memberOf` is a property that defines if a value is within the set. It's
// currently a different thing.

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");


// This is what we are defining
var set;

// ## HELPERS =========
//
// Used to make sure an object serializes to itself.
// This makes sure the empty object won't try to clone itself.
var addSerializeToThis = function(obj) {
	return canReflect.assignSymbols(obj, {
		"can.serialize": function() {
			return this;
		}
	});
};

// Reverses the arguments of a function.
function reverseArgs(fn) {
	return function(first, second) {
		return fn.call(this, second, first);
	};
}

// This symbol is put on constructor functions to track the comparator operators
// available to that type.
var setComparisonsSymbol = canSymbol.for("can.setComparisons");

// Adds comparators to a type. They are stored like:
// Type[@can.setComparisons] = Map({
//    [type1]: Map({[type2]: {union, different, intersection}})
// })
//
// Why do we need the outer object?
function addComparators(type1, type2, comparators) {
	var comparisons = type1[setComparisonsSymbol];
	if (!type1[setComparisonsSymbol]) {
		comparisons = type1[setComparisonsSymbol] = new Map();
	}
	var subMap = comparisons.get(type1);

	if (!subMap) {
		subMap = new Map();
		comparisons.set(type1, subMap);
	}
	var existingComparators = subMap.get(type2);
	if (existingComparators) {
		for (var prop in comparators) {
			if (existingComparators.hasOwnProperty(prop)) {
				console.warn("Overwriting " + type1.name + " " + prop + " " + type2.name + " comparitor");
			}
			existingComparators[prop] = comparators[prop];
		}
	} else {
		subMap.set(type2, comparators);
	}
}


// This type is used for primitives in JS, but it can be used for
// any value that should only === itself.
function Identity() {}

var typeMap = {
	"number": Identity,
	"string": Identity,
	"undefined": Identity,
	"boolean": Identity
};

// `get.intersection`, etc is used to look within the types
// maps and get the right comparator operators.
var get = {};
/*
var algebraSymbol = {
    "intersection": "∩",
    "union": "∪",
    "difference": "\\"
};
*/

["intersection", "difference", "union"].forEach(function(prop) {
	get[prop] = function(forwardComparators, value1, value2) {

		if (value2 === set.UNIVERSAL) {
			if (prop === "intersection") {
				return value1;
			}
			if (prop === "union") {
				return set.UNIVERSAL;
			}
			if (prop === "difference") {
				return set.EMPTY;
			}
		}
		if (value1 === set.UNIVERSAL) {
			if (prop === "intersection") {
				return value1;
			}
			if (prop === "union") {
				return set.UNIVERSAL;
			}
		}

		if (forwardComparators && forwardComparators[prop]) {
			var result = forwardComparators[prop](value1, value2);
			// console.log("",/*name1,*/ value1, algebraSymbol[prop], /*name2,*/ value2,"=", result);
			if (result === undefined && forwardComparators.undefinedIsEmptySet === true) {
				return set.EMPTY;
			} else {
				return result;
			}
		} else {
			throw new Error("Unable to perform " + prop + " between " + set.getType(value1).name + " and " + set.getType(value2).name);
		}

	};
});



set = {
	// The special types

	// All values within the "universe". Other sets can equal UNIVERSAL.
	UNIVERSAL: canReflect.assignSymbols({
		name: "UNIVERSAL"
	}, {
		"can.serialize": function() {
			return this;
		},
		"can.isMember": function(){
			return true;
		}
	}),
	// Nothing
	EMPTY: canReflect.assignSymbols({
		name: "EMPTY"
	}, {
		"can.serialize": function() {
			return this;
		},
		"can.isMember": function(){
			return false;
		}
	}),
	// The set exists, but we lack the language to represent it.
	UNDEFINABLE: addSerializeToThis({
		name: "UNDEFINABLE"
	}),
	// We don't know if this exists. Intersection between two paginated sets.
	UNKNOWABLE: addSerializeToThis({
		name: "UNKNOWABLE"
	}),
	Identity: Identity,
	isSpecial: function(setA) {
		return setA === set.UNIVERSAL || setA === set.EMPTY ||
			setA === set.UNDEFINABLE || setA === set.UNKNOWABLE;
	},
	isDefinedAndHasMembers: function(setA) {
		if (setA !== set.EMPTY && setA !== set.UNDEFINABLE && setA !== set.UNKNOWABLE) {
			return !!setA;
		} else {
			return false;
		}
	},
	getType: function(value) {
		if (value === set.UNIVERSAL) {
			return set.UNIVERSAL;
		}
		if (value === set.EMPTY) {
			return set.EMPTY;
		}
		if (value === set.UNKNOWABLE) {
			return set.UNKNOWABLE;
		}
		if (value === null) {
			return Identity;
		}
		if (typeMap.hasOwnProperty(typeof value)) {
			return typeMap[typeof value];
		}
		return value.constructor;
	},
	// This tries to get two comparable values from objects.
	// In many ways this is similar to what JavaScript does if it sees
	// `new Date() > new Date()`, it tries to coerce one value into the other value.
	ownAndMemberValue: function(startOwnValue, startMemberValue) {
		// If either side has a value, then try to type-coerse.
		if (startOwnValue != null || startMemberValue != null) {
			// First try to get `.valueOf` from either side
			var ownValue = startOwnValue != null ? startOwnValue.valueOf() : startOwnValue,
				memberValue = startMemberValue != null ? startMemberValue.valueOf() : startMemberValue;

			// If we ot passed a null on either side, return extracted values
			if (startOwnValue == null || startMemberValue == null) {
				return {
					own: ownValue,
					member: memberValue
				};
			}
			// If we read the values, but they aren't the same type ...
			// we will try to convert the member to the same type as the `startOwnValue`'s type.
			// And then read `.valueOf()` from that.
			if (ownValue == null || ownValue.constructor !== memberValue.constructor) {
				memberValue = new startOwnValue.constructor(memberValue).valueOf();
			}
			return {
				own: ownValue,
				member: memberValue
			};
		}
		return {
			own: startMemberValue,
			member: startOwnValue
		};
	},
	getComparisons: function(Type1, Type2) {
		var comparisons = Type1[setComparisonsSymbol];
		if (comparisons) {
			var subMap = comparisons.get(Type1);

			if (subMap) {
				return subMap.get(Type2);
			}
		}
	},
	hasComparisons: function(Type) {
		return !!Type[setComparisonsSymbol];
	},
	defineComparison: function(type1, type2, comparators) {
		addComparators(type1, type2, comparators);
		if (type1 !== type2) {
			var reverse = {};
			for (var prop in comparators) {
				// difference can not be reversed
				if (prop !== "difference") {
					reverse[prop] = reverseArgs(comparators[prop]);
				}

			}
			addComparators(type2, type1, reverse);
		}
	},
	/**
	 * Checks if A is a subset of B.  If A is a subset of B if:
	 * - A \ B = EMPTY (A has nothing outside what's in B)
	 * - A ∩ B = defined
	 */
	isSubset: function(value1, value2) {
		// check primary direction
		if (value1 === value2) {
			return true;
		}
		var Type1 = set.getType(value1),
			Type2 = set.getType(value2);
		var forwardComparators = set.getComparisons(Type1, Type2);
		if (forwardComparators) {
			// A set is a subset, if it intersects with the set, and it has nothing
			// outside the other set.
			var intersection = get.intersection(forwardComparators, value1, value2);
			// [a, b] \ [a, b, c]
			var difference = get.difference(forwardComparators, value1, value2);
			// they intersect, but value2 has nothing value1 outside value2
			if (intersection === set.UNKNOWABLE || difference === set.UNKNOWABLE) {
				// {sort: "a", page: 0-2} E {sort: "b", page: 2-3}
				return undefined;
			} else if (intersection !== set.EMPTY && difference === set.EMPTY) {
				return true;
			} else {
				return false;
			}
		} else {
			throw new Error("Unable to perform subset comparison between " + Type1.name + " and " + Type2.name);
		}
	},
	isProperSubset: function(setA, setB) {
		return set.isSubset(setA, setB) && !set.isEqual(setA, setB);
	},
	isEqual: function(value1, value2) {
		if (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {
			return set.UNKNOWABLE;
		}
		//console.group("is", value1, "==", value2);
		var isSpecial1 = set.isSpecial(value1),
			isSpecial2 = set.isSpecial(value2);

		// Both have to be specail because some other sets will be equal to UNIVERSAL without being UNIVERSAL
		if (isSpecial1 && isSpecial2) {
			return isSpecial1 === isSpecial2;
		}
		var Type1 = set.getType(value1),
			Type2 = set.getType(value2);
		if (value1 === value2) {
			return true;
		}
		var forwardComparators = set.getComparisons(Type1, Type2);
		var reverseComparators = set.getComparisons(Type2, Type1);
		if (forwardComparators && reverseComparators) {

			// Two sets are equal if there's an intersection, but not difference
			var intersection = get.intersection(forwardComparators, value1, value2);
			var difference = get.difference(forwardComparators, value1, value2);
			if (intersection !== set.EMPTY && difference === set.EMPTY) {
				var reverseIntersection = get.intersection(reverseComparators, value2, value1);
				var reverseDifference = get.difference(reverseComparators, value2, value1);
				//console.groupEnd();
				return reverseIntersection !== set.EMPTY && reverseDifference === set.EMPTY;
			} else {
				//console.groupEnd();
				return false;
			}
		} else {
			var values = set.ownAndMemberValue(value1, value2);
			if (canReflect.isPrimitive(values.own) && canReflect.isPrimitive(values.member)) {
				return values.own === values.member;
			} else {
				// try to convert ...
				throw new Error("Unable to perform equal comparison between " + Type1.name + " and " + Type2.name);
			}

		}
	},

	union: function(value1, value2) {
		if (value1 === set.UNIVERSAL || value2 === set.UNIVERSAL) {
			return set.UNIVERSAL;
		}
		if (value1 === set.EMPTY) {
			return value2;
		} else if (value2 === set.EMPTY) {
			return value1;
		}
		if (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {
			return set.UNKNOWABLE;
		}
		var Type1 = set.getType(value1),
			Type2 = set.getType(value2);
		var forwardComparators = set.getComparisons(Type1, Type2);
		return get.union(forwardComparators, value1, value2);
	},

	intersection: function(value1, value2) {
		if (value1 === set.UNIVERSAL) {
			return value2;
		}
		if (value2 === set.UNIVERSAL) {
			return value1;
		}
		if (value1 === set.EMPTY || value2 === set.EMPTY) {
			return set.EMPTY;
		}
		if (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {
			return set.UNKNOWABLE;
		}
		var Type1 = set.getType(value1),
			Type2 = set.getType(value2);
		var forwardComparators = set.getComparisons(Type1, Type2);
		if (forwardComparators) {
			return get.intersection(forwardComparators, value1, value2);
		} else {
			throw new Error("Unable to perform intersection comparison between " + Type1.name + " and " + Type2.name);
		}
	},
	difference: function(value1, value2) {
		if (value1 === set.EMPTY) {
			return set.EMPTY;
		}
		if (value2 === set.EMPTY) {
			return value1;
		}
		if (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {
			return set.UNKNOWABLE;
		}
		var Type1 = set.getType(value1),
			Type2 = set.getType(value2);
		var forwardComparators = set.getComparisons(Type1, Type2);
		if (forwardComparators) {
			return get.difference(forwardComparators, value1, value2);
		} else {
			throw new Error("Unable to perform difference comparison between " + Type1.name + " and " + Type2.name);
		}
	},

	indexWithEqual: function(arr, value) {
		for (var i = 0, len = arr.length; i < len; i++) {
			if (set.isEqual(arr[i], value)) {
				return i;
			}
		}
		return -1;
	}

};



function identityIntersection(v1, v2) {
	return v1 === v2 ? v1 : set.EMPTY;
}

function identityDifference(v1, v2) {
	return v1 === v2 ? set.EMPTY : v1;
}

function identityUnion(v1, v2) {
	return v1 === v2 ? v1 : set.UNDEFINABLE;
}
var identityComparitor = {
	intersection: identityIntersection,
	difference: identityDifference,
	union: identityUnion
};
set.defineComparison(Identity, Identity, identityComparitor);

set.defineComparison(set.UNIVERSAL, set.UNIVERSAL, identityComparitor);

module.exports = set;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/and-or-not.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/and-or-not.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ValuesOr = __webpack_require__(/*! ./values-or */ "./node_modules/can-query-logic/src/types/values-or.js");
var ValuesNot = __webpack_require__(/*! ./values-not */ "./node_modules/can-query-logic/src/types/values-not.js");
var ValuesAnd = __webpack_require__(/*! ./values-and */ "./node_modules/can-query-logic/src/types/values-and.js");
var KeysAnd = __webpack_require__(/*! ./keys-and */ "./node_modules/can-query-logic/src/types/keys-and.js");

module.exports = {
    KeysAnd: KeysAnd,
    ValuesOr: ValuesOr,
    ValuesNot: ValuesNot,
	ValuesAnd: ValuesAnd
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/array-comparisons.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/array-comparisons.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var common = __webpack_require__(/*! ./comparisons-common */ "./node_modules/can-query-logic/src/types/comparisons-common.js");
var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var ValuesNot = __webpack_require__(/*! ./values-not */ "./node_modules/can-query-logic/src/types/values-not.js");

var comparisons = {
	All: function(values){
		this.values = values;
	}
};

comparisons.All.prototype.isMember = common.isMemberThatUsesTestOnValues;

var is = comparisons;

comparisons.All.test = function(allValues, recordValues) {
	return allValues.every(function(allValue) {
		return recordValues.some(function(recordValue){
			var values = set.ownAndMemberValue(allValue, recordValue);
			return values.own === values.member;
		});
	});
};

function makeThrowCannotCompare(type, left, right) {
	return function() {
		throw new Error("can-query-logic: Cannot perform " + type + " between " + left + " and " + right);
	};
}

function throwComparatorAllTypes(type1, type2) {
	return {
		union: makeThrowCannotCompare("union", type1,  type2),
		difference: makeThrowCannotCompare("difference", type1, type2),
		intersection: makeThrowCannotCompare("intersection", type1, type2)
	};
}

function throwComparatorDifference(type1, type2) {
	return {
		difference: makeThrowCannotCompare("difference", type1, type2)
	};
}

var comparators = {
	UNIVERSAL_All: {
		difference: function(universe, all) {
			return new ValuesNot(all);
		}
	},
	All_UNIVERSAL: {
		difference: function() {
			return set.EMPTY;
		}
	},
	All_All: {
		union: function(a, b) {
			return new is.Or([a, b]);
		}
	},
	In_All: throwComparatorDifference("In", "All"),
	All_In: throwComparatorAllTypes("All", "In"),
	NotIn_All: throwComparatorDifference("NotIn", "All"),
	All_NotIn: throwComparatorAllTypes("All", "NotIn"),
	GreaterThan_All: throwComparatorDifference("GreaterThan", "All"),
	All_GreaterThan: throwComparatorAllTypes("All", "GreaterThan"),
	GreaterThanEqual_All: throwComparatorDifference("GreaterThanEqual", "All"),
	All_GreaterThanEqual: throwComparatorAllTypes("All", "GreaterThanEqual"),
	LessThan_All: throwComparatorDifference("LessThan", "All"),
	All_LessThan: throwComparatorAllTypes("All", "LessThan"),
	LessThanEqual_All: throwComparatorDifference("LessThanEqual", "All"),
	All_LessThanEqual: throwComparatorAllTypes("All", "LessThanEqual"),
	All_And: throwComparatorDifference("All", "And"),
	And_All: throwComparatorAllTypes("And",	 "All"),
	All_Or: throwComparatorDifference("All", "Or"),
	Or_All: throwComparatorAllTypes("Or", "All")
};

exports.comparisons = comparisons;
exports.comparators = comparators;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/basic-query.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/basic-query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var makeRealNumberRangeInclusive = __webpack_require__(/*! ./make-real-number-range-inclusive */ "./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var andOrNot = __webpack_require__(/*! ./and-or-not */ "./node_modules/can-query-logic/src/types/and-or-not.js");
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-query-logic/src/helpers.js");
var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");

// TYPES FOR FILTERING
var KeysAnd = andOrNot.KeysAnd,
	Or = andOrNot.ValuesOr,
	Not = andOrNot.ValuesNot,
	And = andOrNot.ValuesAnd;

// TYPES FOR PAGINATION
var RecordRange = makeRealNumberRangeInclusive(0, Infinity);


// ## makeSort
// Takes:
// - `schemaKeys` - a schema
// - `hydrateAndValue` - Useful to create something like `new GreaterThan( new MaybeDate("10-20-82") )`
//
// Makes a `new Sort(key)` constructor function. This constructor function is used like:
//
// ```
// new Sort("dueDate")
// ```
//
// That constructor function has all the comparison methods (union, intersection, difference)
// built to compare against the `key` value.
//
// Instances of `Sort` have a `compare` method that will
// return a function that can be passed to `Array.prototype.sort`.
//
// That compare function will read the right property and return `-1` or `1`

// WILL MAKE A TYPE FOR SORTING
function makeSort(schema, hydrateAndValue) {
	var schemaKeys = schema.keys;
	// Makes gt and lt functions that `helpers.sorter` can use
	// to make a `compare` function for `Array.sort(compare)`.`
	var sorters = {};
	canReflect.eachKey(schemaKeys, function(schemaProp, key) {

		sorters[key] = {
			// valueA is GT valueB
			$gt: function(valueA, valueB) {
				// handle sorting with null / undefined values
				if(valueA == null || valueB == null) {
					return helpers.typeCompare.$gt(valueA, valueB);
				}
				// The following can certainly be done faster
				var $gt = hydrateAndValue({
						$gt: valueB
					}, key, schemaProp,
					helpers.valueHydrator);

				var $eq = hydrateAndValue({
						$eq: valueA
					}, key, schemaProp,
					helpers.valueHydrator);

				return set.isEqual( set.union($gt, $eq), $gt );
				/*
				var hydratedIn =  hydrateAndValue({
						$eq: valueA
					}, key, schemaProp,
					helpers.valueHydrator);
				return $gt[require("can-symbol").for("can.isMember")](hydratedIn.values[0]);*/
			},
			$lt: function(valueA, valueB) {
				if(valueA == null || valueB == null) {
					return helpers.typeCompare.$lt(valueA, valueB);
				}


				var $lt = hydrateAndValue({
						$lt: valueB
					}, key, schemaProp,
					helpers.valueHydrator);

				var $eq = hydrateAndValue({
						$eq: valueA
					}, key, schemaProp,
					helpers.valueHydrator);

				return set.isEqual( set.union($lt, $eq), $lt );
				/*
				// This doesn't work because it will try to create new SetType(new In([]))
				var hydratedValue =  hydrateAndValue({
						$eq: valueA
					}, key, schemaProp,
					helpers.valueHydrator);
				return $lt[require("can-symbol").for("can.isMember")](hydratedValue);*/

				/*
				// This doesn't work because of maybe types.
				var hydratedIn =  hydrateAndValue({
						$eq: valueA
					}, key, schemaProp,
					helpers.valueHydrator);
				return $lt[require("can-symbol").for("can.isMember")](hydratedIn.values[0]); */
			}
		};
	});

	function Sort(key) {
		this.key = key;
		this.schema = schema;
		this.compare = helpers.sorter(key, sorters);
	}

	function identityIntersection(v1, v2) {
		return v1.key === v2.key ? v1 : set.EMPTY;
	}

	function identityDifference(v1, v2) {
		return v1.key === v2.key ? set.EMPTY : v1;
	}

	function identityUnion(v1, v2) {
		return v1.key === v2.key ? v1 : set.UNDEFINABLE;
	}
	set.defineComparison(Sort, Sort, {
		intersection: identityIntersection,
		difference: identityDifference,
		union: identityUnion
	});
	return Sort;
}

var DefaultSort = makeSort({ keys: {}, identity: ["id"] });


// Define the BasicQuery type
function BasicQuery(query) {
	assign(this, query);
	if (!this.filter) {
		this.filter = set.UNIVERSAL;
	}
	if (!this.page) {
		this.page = new RecordRange();
	}
	if (!this.sort) {
		this.sort = "id";
	}
	if (typeof this.sort === "string") {
		this.sort = new DefaultSort(this.sort);
	}
}

// BasicQuery's static properties
BasicQuery.KeysAnd = KeysAnd;
BasicQuery.Or = Or;
BasicQuery.Not = Not;
BasicQuery.And = And;
BasicQuery.RecordRange = RecordRange;
BasicQuery.makeSort = makeSort;

// BasicQuery's prototype methods.
// These are "additional" features beyond what `set` provides.
// These typically pertain to actual data results of a query.
canReflect.assignMap(BasicQuery.prototype, {
	count: function() {
		return this.page.end - this.page.start + 1;
	},
	sortData: function(data) {
		return data.slice(0).sort(this.sort.compare);
	},
	filterMembersAndGetCount: function(bData, parentQuery) {
		var parentIsUniversal;
		if (parentQuery) {
			parentIsUniversal = set.isEqual(parentQuery.page, set.UNIVERSAL);
			if ((parentIsUniversal &&
				!set.isEqual(parentQuery.filter, set.UNIVERSAL)) &&
				!set.isSubset(this, parentQuery)) {
				throw new Error("can-query-logic: Unable to get members from a set that is not a superset of the current set.");
			}
		} else {
			parentQuery = new BasicQuery();
		}

		// reduce response to items in data that meet where criteria
		var aData = bData.filter(function(data) {
			return this.filter.isMember(data);
		}, this);

		var count = aData.length;

		// sort the data if needed
		if (count && (this.sort.key !== parentQuery.sort.key)) {
			aData = this.sortData(aData);
		}

		var thisIsUniversal = set.isEqual(this.page, set.UNIVERSAL);
		if(parentIsUniversal == null) {
			parentIsUniversal = set.isEqual(parentQuery.page, set.UNIVERSAL);
		}

		if (parentIsUniversal) {
			if (thisIsUniversal) {
				return {
					data: aData,
					count: count
				};
			} else {
				return {
					data: aData.slice(this.page.start, this.page.end + 1),
					count: count
				};
			}
		}
		// everything but range is equal
		else if (this.sort.key === parentQuery.sort.key && set.isEqual(parentQuery.filter, this.filter)) {
			return {
				data: aData.slice(this.page.start - parentQuery.page.start, this.page.end - parentQuery.page.start + 1),
				count: count
			};
		} else {
			// parent starts at something ...
			throw new Error("can-query-logic: Unable to get members from the parent set for this subset.");
		}
	},
	filterFrom: function(bData, parentQuery) {
		return this.filterMembersAndGetCount(bData, parentQuery).data;
	},
	merge: function(b, aItems, bItems, getId) {
		var union = set.union(this, b);

		if (union === set.UNDEFINABLE) {
			return undefined;
		} else {
			var combined = helpers.uniqueConcat(aItems, bItems, getId);
			return union.sortData(combined);
		}
	},
	index: function(props, items) {
		// make sure we have the property
		var data = helpers.sortData(this.sort.key);
		if (!canReflect.hasOwnKey(props, data.prop)) {
			return undefined;
		}
		// use the passed sort's compare function
		return helpers.getIndex(this.sort.compare, items, props, this.sort.schema);
	},
	isMember: function(props) {
		// Use the AND type for it's isMember method
		return this.filter.isMember(props);
	},
	removePagination: function() {
		this.page = new RecordRange();
	}
});

// Helpers used for the `set` comparators
var CLAUSE_TYPES = ["filter", "page", "sort"];

function getDifferentClauseTypes(queryA, queryB) {
	var differentTypes = [];

	CLAUSE_TYPES.forEach(function(clause) {
		if (!set.isEqual(queryA[clause], queryB[clause])) {
			differentTypes.push(clause);
		}
	});

	return differentTypes;
}

function isSubset(subLetter, superLetter, meta) {
	if (meta[subLetter + "FilterIsSubset"]) {
		if (meta[superLetter + "PageIsUniversal"]) {
			return true;
		} else {
			return meta[subLetter + "PageIsSubset"] && meta.sortIsEqual;
		}
	} else {
		return false;
	}
}

// This type contains a bunch of lazy getters that
// cache their value after being read.
// This helps performance.
function MetaInformation(queryA, queryB) {
	this.queryA = queryA;
	this.queryB = queryB;
}

canReflect.eachKey({
	"pageIsEqual": function() {
		return set.isEqual(this.queryA.page, this.queryB.page);
	},
	"aPageIsUniversal": function() {
		return set.isEqual(this.queryA.page, set.UNIVERSAL);
	},
	"bPageIsUniversal": function() {
		return set.isEqual(this.queryB.page, set.UNIVERSAL);
	},
	"pagesAreUniversal": function() {
		return this.pageIsEqual && this.aPageIsUniversal;
	},
	"sortIsEqual": function() {
		return this.queryA.sort.key === this.queryB.sort.key;
	},
	"aFilterIsSubset": function() {
		return set.isSubset(this.queryA.filter, this.queryB.filter);
	},
	"bFilterIsSubset": function() {
		return set.isSubset(this.queryB.filter, this.queryA.filter);
	},
	"aPageIsSubset": function() {
		return set.isSubset(this.queryA.page, this.queryB.page);
	},
	"bPageIsSubset": function() {
		return set.isSubset(this.queryB.page, this.queryA.page);
	},
	"filterIsEqual": function() {
		return set.isEqual(this.queryA.filter, this.queryB.filter);
	},
	"aIsSubset": function() {
		return isSubset("a", "b", this);
	},
	"bIsSubset": function() {
		return isSubset("b", "a", this);
	}
}, function(def, prop) {
	defineLazyValue(MetaInformation.prototype, prop, def);
});

function metaInformation(queryA, queryB) {
	var meta = new MetaInformation(queryA, queryB);
	return meta;
}


// Define comparators
set.defineComparison(BasicQuery, BasicQuery, {
	union: function(queryA, queryB) {

		var meta = metaInformation(queryA, queryB);


		var filterUnion = set.union(queryA.filter, queryB.filter);

		if (meta.pagesAreUniversal) {
			// We ignore the sort.
			return new BasicQuery({
				filter: filterUnion,
				sort: meta.sortIsEqual ? queryA.sort.key : undefined
			});
		}


		if (meta.filterIsEqual) {
			if (meta.sortIsEqual) {
				return new BasicQuery({
					filter: queryA.filter,
					sort: queryA.sort.key,
					page: set.union(queryA.page, queryB.page)
				});
			} else {
				if (meta.aIsSubset) {
					return queryB;
				} else if (meta.bIsSubset) {
					return queryA;
				}
				// we can't specify which pagination would bring in everything.
				// but a union does exist.
				return set.UNDEFINABLE;
			}
		} else {
			throw new Error("different filters, non-universal pages");
		}
	},
	intersection: function(queryA, queryB) {

		// {age: 35} U {name: "JBM"} -> {age: 35, name: "JBM"}

		// { filter: {age: 35},
		//   page: {0, 10},
		//   sort: "foo" }
		// U
		// { filter: {name: "JBM"},
		//   page: {0, 10},
		//   sort: "foo" }

		var meta = metaInformation(queryA, queryB);

		if (meta.pagesAreUniversal) {
			// We ignore the sort.
			var filterResult = set.intersection(queryA.filter, queryB.filter);
			if (set.isDefinedAndHasMembers(filterResult)) {
				return new BasicQuery({
					filter: filterResult,
					sort: meta.sortIsEqual ? queryA.sort.key : undefined
				});

			} else {
				return filterResult;
			}
		}



		// check if disjoint wheres
		if (set.intersection(queryA.filter, queryB.filter) === set.EMPTY) {
			return set.EMPTY;
		}

		if (meta.filterIsEqual) {
			if (meta.sortIsEqual) {
				return new BasicQuery({
					filter: queryA.filter,
					sort: queryA.sort.key,
					page: set.intersection(queryA.page, queryB.page)
				});
			} else {
				if (meta.aIsSubset) {
					return queryA;
				} else if (meta.bIsSubset) {
					return queryB;
				}
				return set.UNKNOWABLE;
				//throw new Error("same filter, different sorts, non universal pages");
			}
		} else {
			if (meta.aIsSubset) {
				return queryA;
			} else if (meta.bIsSubset) {
				return queryB;
			} else {
				// filters are different, both pagination isn't universal
				return set.UNDEFINABLE;
			}

		}

	},
	difference: function(queryA, queryB) {

		var differentClauses = getDifferentClauseTypes(queryA, queryB);
		var meta = metaInformation(queryA, queryB);
		var clause;
		if (differentClauses.length > 1) {
			if (meta.aIsSubset) {
				return set.EMPTY;
			}
			if (meta.pagesAreUniversal) {
				return new BasicQuery({
					filter: set.difference(queryA.filter, queryB.filter),
					sort: queryA.sort.key
				});
			}

			return set.UNDEFINABLE;
		} else {
			switch (clause = differentClauses[0]) {
				// if all the clauses are the same, then there can't be a difference
				case undefined:
					{
						return set.EMPTY;
					}
				case "sort":
					{
						// if order is the only difference, then there can't be a difference
						// if items are paged but the order is different, though, the sets are not comparable
						// Either way, the result is false
						if (meta.pagesAreUniversal) {
							return set.EMPTY;
						} else {
							return set.UNKNOWABLE;
						}


					}
					break;
				case "page":
				case "filter":
					{
						// if there's only one clause to evaluate or the clauses are where + id,
						// then we can try to determine the difference set.
						// Note that any difference in the ID clause will cause the result to be
						// true (if A has no ID but B has ID) or false (any case where A has ID)
						var result = set.difference(queryA[clause],
							queryB[clause]);

						if (set.isSpecial(result)) {
							return result;
						} else {
							var query = {
								filter: queryA.filter,
								page: queryA.page,
								sort: queryA.sort.key
							};
							query[clause] = result;
							return new BasicQuery(query);
						}
					}
			}
		}
	}
});


module.exports = BasicQuery;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/comparisons-common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/comparisons-common.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

function isMemberThatUsesTestOnValues(value) {
	return this.constructor.test(this.values, value);
}

exports.isMemberThatUsesTestOnValues = isMemberThatUsesTestOnValues;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/comparisons.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/comparisons.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ "./node_modules/can-query-logic/src/array-union-intersection-difference.js");
var common = __webpack_require__(/*! ./comparisons-common */ "./node_modules/can-query-logic/src/types/comparisons-common.js");
var arrayComparisons = __webpack_require__(/*! ./array-comparisons */ "./node_modules/can-query-logic/src/types/array-comparisons.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var isMemberSymbol = canSymbol.for("can.isMember");
// $ne	Matches all values that are not equal to a specified value.
// $eq	Matches values that are equal to a specified value.
//
// $gt	Matches values that are greater than a specified value.
// $gte	Matches values that are greater than or equal to a specified value.

// $lt	Matches values that are less than a specified value.
// $lte	Matches values that are less than or equal to a specified value.

// $in	Matches any of the values specified in an array.
// $nin	Matches none of the values specified in an array.

var comparisons = canReflect.assign(arrayComparisons.comparisons, {
	In: function In(values) {
		// TODO: change this to store as `Set` later.
		this.values = values;
	},
	NotIn: function NotIn(values) {
		this.values = values;
	},
	GreaterThan: function GreaterThan(value) {
		this.value = value;
	},
	GreaterThanEqual: function GreaterThanEqual(value) {
		this.value = value;
	},
	LessThan: function LessThan(value) {
		this.value = value;
	},
	LessThanEqual: function LessThanEqual(value) {
		this.value = value;
	},
	// This is used to And something like `GT(3)` n `LT(4)`.
	// These are all value comparisons.
	And: function ValueAnd(ands) {
		this.values = ands;
	},
	// This is used to OR something like `GT(4)` n `LT(3)`.
	// These are all value comparisons.
	Or: function ValueOr(ors) {
		this.values = ors;
	}
});

comparisons.Or.prototype.orValues = function() {
	return this.values;
};

comparisons.In.test = function(values, b) {
	return values.some(function(value) {
		var values = set.ownAndMemberValue(value, b);
		return values.own === values.member;
	});
};

comparisons.NotIn.test = function(values, b) {
	return !comparisons.In.test(values, b);
};
comparisons.NotIn.testValue = function(value, b) {
	return !comparisons.In.testValue(value, b);
};

function nullIsFalse(test) {
	return function(arg1, arg2) {
		if (arg1 == null || arg2 == null) {
			return false;
		} else {
			return test(arg1, arg2);
		}
	};
}

function nullIsFalseTwoIsOk(test) {
	return function(arg1, arg2) {
		if (arg1 === arg2) {
			return true;
		} else if (arg1 == null || arg2 == null) {
			return false;
		} else {
			return test(arg1, arg2);
		}
	};
}

comparisons.GreaterThan.test = nullIsFalse(function(a, b) {
	return a > b;
});
comparisons.GreaterThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {
	return a >= b;
});
comparisons.LessThan.test = nullIsFalse(function(a, b) {
	return a < b;
});
comparisons.LessThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {
	return a <= b;
});

function isMemberThatUsesTest(value) {
	var values = set.ownAndMemberValue(this.value, value);
	return this.constructor.test(values.member, values.own);
}
[comparisons.GreaterThan, comparisons.GreaterThanEqual, comparisons.LessThan, comparisons.LessThanEqual, comparisons.LessThan].forEach(function(Type) {
	Type.prototype.isMember = isMemberThatUsesTest;
});

[comparisons.In, comparisons.NotIn].forEach(function(Type) {
	Type.prototype.isMember = common.isMemberThatUsesTestOnValues;
});

comparisons.And.prototype.isMember = function(value) {
	return this.values.every(function(and) {
		return and.isMember(value);
	});
};
comparisons.Or.prototype.isMember = function(value) {
	return this.values.some(function(and) {
		return and.isMember(value);
	});
};
Object.keys(comparisons).forEach(function(name) {
	comparisons[name].prototype[isMemberSymbol] = comparisons[name].prototype.isMember;
});

var is = comparisons;

function makeNot(Type) {
	return {
		test: function(vA, vB) {
			return !Type.test(vA, vB);
		}
	};
}


function makeEnum(type, Type, emptyResult) {
	return function(a, b) {
		var result = arrayUnionIntersectionDifference(a.values, b.values);
		if (result[type].length) {
			return new Type(result[type]);
		} else {
			return emptyResult || set.EMPTY;
		}
	};
}

function swapArgs(fn) {
	return function(a, b) {
		return fn(b, a);
	};
}


function makeSecondValue(Type, prop) {
	return function(universe, value) {
		return new Type(value[prop || "value"]);
	};
}

function returnBiggerValue(gtA, gtB) {
	if (gtA.value < gtB.value) {
		return gtB;
	} else {
		return gtA;
	}
}

function returnSmallerValue(gtA, gtB) {
	if (gtA.value > gtB.value) {
		return gtB;
	} else {
		return gtA;
	}
}

function makeAndIf(Comparison, Type) {
	return function(ltA, ltB) {
		if (Comparison.test(ltA.value, ltB.value)) {
			return makeAnd([ltA, new Type(ltB.value)]);
		} else {
			return set.EMPTY;
		}
	};
}

function make_InIfEqual_else_andIf(Comparison, Type) {
	var elseCase = makeAndIf(Comparison, Type);
	return function(a, b) {
		if (a.value === b.value) {
			return new is.In([a.value]);
		} else {
			return elseCase(a, b);
		}
	};
}

function make_filterFirstValueAgainstSecond(Comparison, Type, defaultReturn) {
	return function(inSet, gt) {
		var values = inSet.values.filter(function(value) {
			return Comparison.test(gt, value);
		});
		return values.length ?
			new Type(values) : defaultReturn || set.EMPTY;
	};
}

var isMemberTest = {
	test: function isMemberTest(set, value) {
		return set.isMember(value);
	}
};

function isOr(value) {
	return (value instanceof is.Or);
}

function isAnd(value) {
	return (value instanceof is.And);
}

function isAndOrOr(value) {
	return isAnd(value) || isOr(value);
}


// `value` - has a test function to check values
// `with` - the type we use to combined with the "other" value.
// `combinedUsing` - If there are values, how do we stick it together with `with`

function combineFilterFirstValuesAgainstSecond(options) {
	return function(inSet, gt) {
		var values = inSet.values.filter(function(value) {
			return options.values.test(gt, value);
		});
		var range;
		if (options.complement) {
			range = set.difference(set.UNIVERSAL, gt);
		} else if (options.with) {
			range = new options.with(gt.value);
		} else {
			range = gt;
		}
		return values.length ?
			options.combinedUsing([new options.arePut(values), range]) : range;
	};
}

function makeOrUnless(Comparison, result) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return result || set.UNIVERSAL;
		} else {
			return makeOr([setA, setB]);
		}
	};
}

function makeAndUnless(Comparison, result) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return result || set.EMPTY;
		} else {
			return makeAnd([setA, setB]);
		}
	};
}

function makeComplementSecondArgIf(Comparison) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return set.difference(set.UNIVERSAL, setB);
		} else {
			return setA;
		}
	};
}


function makeAnd(ands) {
	return comparisons.And ? new comparisons.And(ands) : set.UNDEFINABLE;
}

function makeOr(ors) {
	return comparisons.Or ? new comparisons.Or(ors) : set.UNDEFINABLE;
}

function combineValueWithRangeCheck(inSet, rangeSet, RangeOrEqType) {
	var gte = new RangeOrEqType(rangeSet.value);
	var leftValues = inSet.values.filter(function(value) {
		return !gte.isMember(value);
	});
	if (!leftValues.length) {
		return gte;
	}

	if (leftValues.length < inSet.values.length) {
		return makeOr([new is.In(leftValues), gte]);
	} else {
		return makeOr([inSet, rangeSet]);
	}
}

// This tries to unify In([1]) with GT(1) -> GTE(1)
function makeOrWithInAndRange(inSet, rangeSet) {
	if (rangeSet instanceof is.Or) {
		var firstResult = makeOrWithInAndRange(inSet, rangeSet.values[0]);
		if ( !(firstResult instanceof is.Or) ) {
			return set.union(firstResult, rangeSet.values[1]);
		}
		var secondResult = makeOrWithInAndRange(inSet, rangeSet.values[1]);
		if ( !(secondResult instanceof is.Or) ) {
			return set.union(secondResult, rangeSet.values[0]);
		}
		return makeOr([inSet, rangeSet]);
	} else {
		if (rangeSet instanceof is.GreaterThan) {
			return combineValueWithRangeCheck(inSet, rangeSet, is.GreaterThanEqual);
		}
		if (rangeSet instanceof is.LessThan) {
			return combineValueWithRangeCheck(inSet, rangeSet, is.LessThanEqual);
		}
		return makeOr([inSet, rangeSet]);
	}
}

var In_RANGE = {
	union: combineFilterFirstValuesAgainstSecond({
		values: makeNot(isMemberTest),
		arePut: is.In,
		combinedUsing: function(ors) {
			return makeOrWithInAndRange(ors[0], ors[1]);
		}
	}),
	intersection: make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY),
	difference: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.In, set.EMPTY)
};
var RANGE_IN = {
	difference: swapArgs(combineFilterFirstValuesAgainstSecond({
		values: isMemberTest,
		arePut: is.NotIn,
		combinedUsing: makeAnd
	}))
};

var NotIn_RANGE = function() {
	return {
		union: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.NotIn, set.UNIVERSAL),
		intersection: combineFilterFirstValuesAgainstSecond({
			values: isMemberTest,
			arePut: is.NotIn,
			combinedUsing: makeAnd
		}),
		difference: combineFilterFirstValuesAgainstSecond({
			values: makeNot(isMemberTest),
			arePut: is.NotIn,
			combinedUsing: makeAnd,
			complement: true
		})
	};
};
var RANGE_NotIn = {
	difference: swapArgs(make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY))
};

var RANGE_And_Union = function(gt, and) {

	var union1 = set.union(gt, and.values[0]);
	var union2 = set.union(gt, and.values[1]);

	if (!isAndOrOr(union1) && !isAndOrOr(union2)) {
		return set.intersection(union1, union2);
	} else {
		return new is.Or([gt, and]);
	}
};
var RANGE_And_Intersection = function(gt, and) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var intersection1 = set.intersection(gt, and1);
	var intersection2 = set.intersection(gt, and2);
	if (intersection1 === set.EMPTY || intersection2 === set.EMPTY) {
		return set.EMPTY;
	}
	if (!isAndOrOr(intersection1)) {
		return new set.intersection(intersection1, and2);
	}

	if (!isAndOrOr(intersection2)) {
		return new set.intersection(intersection2, and1);
	} else {
		return new is.And([gt, and]);
	}

};

var RANGE_And_Difference = function(gt, and) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var difference1 = set.difference(gt, and1);
	var difference2 = set.difference(gt, and2);
	if (difference1 === set.EMPTY) {
		return difference2;
	}
	if (difference2 === set.EMPTY) {
		return difference1;
	}
	return new is.Or([difference1, difference2]);
};

var And_RANGE_Difference = function(and, gt) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var difference1 = set.difference(and1, gt);
	var difference2 = set.difference(and2, gt);

	return set.intersection(difference1, difference2);
};

var RANGE_Or = {
	union: function(gt, or) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var union1 = set.union(gt, or1);
		if (!isAndOrOr(union1)) {
			return set.union(union1, or2);
		}
		var union2 = set.union(gt, or2);
		if (!isAndOrOr(union2)) {
			return set.union(or1, union2);
		} else {
			return new is.Or([gt, or]);
		}
	},
	intersection: function(gt, or) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var intersection1 = set.intersection(gt, or1);
		var intersection2 = set.intersection(gt, or2);
		if (intersection1 === set.EMPTY) {
			return intersection2;
		}
		if (intersection2 === set.EMPTY) {
			return intersection1;
		}
		return set.union(intersection1, intersection2);
	},
	// v \ (a || b) -> (v \ a) n (v \ b)
	difference: function(gt, or) {

		var or1 = or.values[0],
			or2 = or.values[1];
		var difference1 = set.difference(gt, or1);
		var difference2 = set.difference(gt, or2);
		return set.intersection(difference1, difference2);
	}
};

var Or_RANGE = {
	// ( a || b ) \ v -> (a \ v) U (b \ v)
	difference: function(or, gt) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var difference1 = set.difference(or1, gt);
		var difference2 = set.difference(or2, gt);
		return set.union(difference1, difference2);
	}
};

var comparators = canReflect.assign(arrayComparisons.comparators, {
	// In
	In_In: {
		union: makeEnum("union", is.In),
		intersection: makeEnum("intersection", is.In),
		difference: makeEnum("difference", is.In)
	},
	UNIVERSAL_In: {
		difference: makeSecondValue(is.NotIn, "values")
	},

	In_NotIn: {
		union: swapArgs(makeEnum("difference", is.NotIn, set.UNIVERSAL)),
		// what does In have on its own
		intersection: makeEnum("difference", is.In),
		difference: makeEnum("intersection", is.In)
	},
	NotIn_In: {
		difference: makeEnum("union", is.NotIn)
	},

	In_GreaterThan: In_RANGE,
	GreaterThan_In: RANGE_IN,

	In_GreaterThanEqual: In_RANGE,
	GreaterThanEqual_In: RANGE_IN,

	In_LessThan: In_RANGE,
	LessThan_In: RANGE_IN,

	In_LessThanEqual: In_RANGE,
	LessThanEqual_In: RANGE_IN,
	In_And: In_RANGE,
	And_In: RANGE_IN,

	In_Or: In_RANGE,
	Or_In: RANGE_IN,

	// NotIn ===============================
	NotIn_NotIn: {
		union: makeEnum("intersection", is.NotIn, set.UNIVERSAL),
		intersection: makeEnum("union", is.NotIn),
		difference: makeEnum("difference", is.In)
	},
	UNIVERSAL_NotIn: {
		difference: makeSecondValue(is.In, "values")
	},

	NotIn_GreaterThan: NotIn_RANGE(),
	GreaterThan_NotIn: RANGE_NotIn,

	NotIn_GreaterThanEqual: NotIn_RANGE(),
	GreaterThanEqual_NotIn: RANGE_NotIn,

	NotIn_LessThan: NotIn_RANGE(),
	LessThan_NotIn: RANGE_NotIn,

	NotIn_LessThanEqual: NotIn_RANGE(),
	LessThanEqual_NotIn: RANGE_NotIn,

	NotIn_And: NotIn_RANGE(),
	And_NotIn: RANGE_NotIn,

	NotIn_Or: NotIn_RANGE(),
	Or_NotIn: RANGE_NotIn,

	// GreaterThan ===============================
	GreaterThan_GreaterThan: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {$gt:5} \ {gt: 6} -> AND( {$gt:5}, {$lte: 6} )
		difference: makeAndIf(is.LessThan, is.LessThanEqual)
	},
	UNIVERSAL_GreaterThan: {
		difference: makeSecondValue(is.LessThanEqual)
	},

	GreaterThan_GreaterThanEqual: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {$gt:5} \ {gte: 6} -> AND( {$gt:5}, {$lt: 6} )
		difference: makeAndIf(is.LessThan, is.LessThan)
	},
	GreaterThanEqual_GreaterThan: {
		difference: make_InIfEqual_else_andIf(is.LessThan, is.LessThanEqual)
	},

	GreaterThan_LessThan: {
		union: (function() {
			var makeOrUnlessLessThan = makeOrUnless(is.LessThan);
			return function greaterThan_lessThan_union(a, b) {
				if ( comparisons.In.test([a.value], b.value) ) {
					return new is.NotIn([a.value]);
				} else {
					return makeOrUnlessLessThan(a, b);
				}
			};
		})(),
		intersection: makeAndUnless(is.GreaterThan),
		difference: makeComplementSecondArgIf(is.LessThan)
	},
	LessThan_GreaterThan: {
		difference: makeComplementSecondArgIf(is.GreaterThan)
	},

	GreaterThan_LessThanEqual: {
		union: makeOrUnless(is.LessThanEqual),
		intersection: makeAndUnless(is.GreaterThanEqual),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThanEqual_GreaterThan: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThan_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_GreaterThan: {
		difference: And_RANGE_Difference
	},
	GreaterThan_Or: RANGE_Or,
	Or_GreaterThan: Or_RANGE,

	// GreaterThanEqual =========
	GreaterThanEqual_GreaterThanEqual: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {gte: 2} \ {gte: 3} = {gte: 2} AND {lt: 3}
		difference: makeAndIf(is.LessThan, is.LessThan)
	},
	UNIVERSAL_GreaterThanEqual: {
		difference: makeSecondValue(is.LessThan)
	},

	GreaterThanEqual_LessThan: {
		union: makeOrUnless(is.LessThanEqual),
		intersection: makeAndUnless(is.GreaterThanEqual),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThan_GreaterThanEqual: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThanEqual_LessThanEqual: {
		union: makeOrUnless(is.LessThanEqual),
		// intersect on a number
		intersection: (function() {
			var makeAnd = makeAndUnless(is.GreaterThan);
			return function gte_lte_intersection(gte, lte) {
				var inSet = new is.In([gte.value]);
				if (inSet.isMember(lte.value)) {
					return inSet;
				} else {
					return makeAnd(gte, lte);
				}
			};
		})(),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThanEqual_GreaterThanEqual: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThanEqual_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_GreaterThanEqual: {
		difference: And_RANGE_Difference
	},
	GreaterThanEqual_Or: RANGE_Or,
	Or_GreaterThanEqual: Or_RANGE,

	// LessThan
	LessThan_LessThan: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		difference: makeAndIf(is.GreaterThan, is.GreaterThanEqual)
	},
	UNIVERSAL_LessThan: {
		difference: makeSecondValue(is.GreaterThanEqual)
	},

	LessThan_LessThanEqual: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		// {lt: 3} \ {lte: 2} -> {lt: 3} AND {gt: 2}
		difference: makeAndIf(is.GreaterThan, is.GreaterThan)
	},
	LessThanEqual_LessThan: {
		difference: make_InIfEqual_else_andIf(is.GreaterThanEqual, is.GreaterThanEqual)
	},

	LessThan_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_LessThan: {
		difference: And_RANGE_Difference
	},
	LessThan_Or: RANGE_Or,
	Or_LessThan: Or_RANGE,

	// LessThanEqual
	LessThanEqual_LessThanEqual: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		difference: function(lteA, lteB) {
			if (lteA.value >= lteB.value) {
				return makeAnd([lteA, new is.GreaterThan(lteB.value)]);
			} else {
				return set.EMPTY;
			}
		}
	},
	UNIVERSAL_LessThanEqual: {
		difference: makeSecondValue(is.GreaterThan)
	},

	LessThanEqual_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_LessThanEqual: {
		difference: And_RANGE_Difference
	},
	LessThanEqual_Or: RANGE_Or,
	Or_LessThanEqual: Or_RANGE,

	// AND =====
	And_And: {
		// (a n b) U (c n d) => (a U c) n (b U d)?
		// union both ways ... if one is unviersal, the other is the result.
		// (a ∩ b) ∪ (c ∩ d) where Z = (a ∩ b)
		// -> Z ∪ (c ∩ d)
		// -> (Z ∪ c) ∩ (Z ∪ d)
		// -> ((a ∩ b) ∪ c) ∪ ((a ∩ b) ∪ d)
		union: function(and1, and2) {
			var union1 = set.union(and1, and2.values[0]);
			var union2 = set.union(and1, and2.values[1]);

			if (isAndOrOr(union1) || isAndOrOr(union2)) {
				// try the other direction
				union1 = set.union(and2, and1.values[0]);
				union2 = set.union(and2, and1.values[1]);
			}
			if (isAndOrOr(union1) || isAndOrOr(union2)) {
				return new is.Or([and1, and2]);
			} else {
				return set.intersection(union1, union2);
			}

			/*
			var combo1 = [
					set.union(and1.values[0], and2.values[0]),
					set.union(and1.values[1], and2.values[1])
				],
				combo2 = [
					set.union(and1.values[0], and2.values[1]),
					set.union(and1.values[1], and2.values[0])
				];
			if (combo1.every(function(aSet) {
				return set.isEqual(set.UNIVERSAL, aSet);
			})) {
				return set.intersection.apply(set, combo2);
			}
			if (combo2.every(function(aSet) {
				return set.isEqual(set.UNIVERSAL, aSet);
			})) {
				return set.intersection.apply(set, combo1);
			}
			return new is.Or([and1, and2]);*/
		},

		intersection: function(and1, and2) {
			var intersection1 = set.intersection(and1.values[0], and2.values[0]);
			var intersection2 = set.intersection(and1.values[1], and2.values[1]);

			if (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {
				return set.intersection(intersection1, intersection2);
			}
			intersection1 = set.intersection(and1.values[0], and2.values[1]);
			intersection2 = set.intersection(and1.values[1], and2.values[0]);

			if (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {
				return set.intersection(intersection1, intersection2);
			} else {
				return new is.And([and1, and2]);
			}
		},
		// (a ∩ b) \ (c ∩ d) where Z = (a ∩ b)
		// -> Z \ (c ∩ d)
		// -> (Z \ c) ∪ (Z \ d)
		// -> ((a ∩ b) \ c) ∪ ((a ∩ b) \ d)
		difference: (function() {

			return function(and1, and2) {
				var d1 = set.difference(and1, and2.values[0]);
				var d2 = set.difference(and1, and2.values[1]);
				return set.union(d1, d2);
			};
			/*
			function getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, diffedAnd) {
				var diff;
				if (inOrderDiffs[0] === set.EMPTY) {
					diff = inOrderDiffs[1];
				}
				if (inOrderDiffs[1] === set.EMPTY) {
					diff = inOrderDiffs[0];
				}
				if (diff) {
					// check if a diff equals itself (and therefor is disjoint)

					if (set.isEqual(diffedAnd.values[0], reverseOrderDiffs[0] ) ) {
						// is disjoint
						return diffedAnd;
					}
					if ( set.isEqual(diffedAnd.values[1], reverseOrderDiffs[1] ) ) {
						return diffedAnd;
					}
					return diff;
				}
			}
			return function(and1, and2) {
				var inOrderDiffs = [
						set.difference(and1.values[0], and2.values[0]),
						set.difference(and1.values[1], and2.values[1])
					],
					reverseOrderDiffs = [
						set.difference(and1.values[0], and2.values[1]),
						set.difference(and1.values[1], and2.values[0])
					];

				var diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, and1);
				if (diff) {
					return diff;
				}
				diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(reverseOrderDiffs, inOrderDiffs, and1);
				if (diff) {
					return diff;
				} else {
					// if one is a double And ... that's the outer \\ inner
					if (isAndOrOr(inOrderDiffs[0]) && isAndOrOr(inOrderDiffs[1])) {
						return new is.Or([inOrderDiffs[0], inOrderDiffs[1]]);
					} else if ( isAndOrOr(reverseOrderDiffs[0]) && isAndOrOr(reverseOrderDiffs[1]) ) {
						return new is.Or([reverseOrderDiffs[0], reverseOrderDiffs[1]]);
					}
					return set.UNKNOWABLE;
				}
			};*/
		})()
	},
	And_Or: {
		// (a ∩ b) ∪ (c u d) where Z = (c u d)
		// -> Z u (a ∩ b)
		// -> (Z u a) ∩ (Z u b)
		// -> ((c u d) u a) ∩ ((c u d) u b)
		union: function(and, or) {
			var aUnion = set.union(and.values[0], or);
			var bUnion = set.union(and.values[1], or);

			if (!isAndOrOr(aUnion) || !isAndOrOr(bUnion)) {
				return set.intersection(aUnion, bUnion);
			}

			return new is.Or([and, or]);
		},
		// (a ∩ b) ∩ (c u d) where Z = (a ∩ b)
		// -> Z ∩ (c u d)
		// -> (Z ∩ c) u (Z ∩ d)
		// -> (a ∩ b ∩ c) u (a ∩ b ∩ d)
		intersection: function(and, or) {
			var aIntersection = set.intersection(and, or.values[0]);
			var bIntersection = set.intersection(and, or.values[1]);
			if (!isOr(aIntersection) && !isOr(bIntersection)) {
				return set.union(aIntersection, bIntersection);
			}
			return new is.And([and, or]);
		},
		// (a ∩ b) \ (c u d) where Z = (a ∩ b)
		// -> Z \ (c u d)
		// -> (Z \ c) ∩ (Z \ d)
		// -> ((a ∩ b) \ c) ∩ ((a ∩ b) \ d)
		difference: function(and, or) {
			var aDiff = set.difference(and, or.values[0]);
			var bDiff = set.difference(and, or.values[1]);
			return set.intersection(aDiff, bDiff);
		}
	},
	Or_And: {
		// (a ∪ b) \ (c ∩ d) where Z = (a ∪ b)
		// -> Z \ (c ∩ d)
		// -> (Z \ c) ∪ (Z \ d)
		// -> ((a ∪ b) \ c) ∪ ((a ∪ b) \ d)
		difference: function(or, and) {
			var aDiff = set.difference(or, and.values[0]);
			var bDiff = set.difference(or, and.values[1]);
			return set.union(aDiff, bDiff);
		}
	},
	UNIVERSAL_And: {
		difference: function(universe, and) {
			var inverseFirst = set.difference(universe, and.values[0]),
				inverseSecond = set.difference(universe, and.values[1]);
			return set.union(inverseFirst, inverseSecond);
		}
	},
	Or_Or: {
		// (a ∪ b) ∪ (c ∪ d)
		union: function(or1, or2) {
			var union1 = set.union(or1.values[0], or2.values[0]);
			var union2 = set.union(or1.values[1], or2.values[1]);

			if (!isAndOrOr(union1) || !isAndOrOr(union2)) {
				return set.union(union1, union2);
			}
			union1 = set.union(or1.values[0], or2.values[1]);
			union2 = set.union(or1.values[1], or2.values[0]);

			if (!isAndOrOr(union1) || !isAndOrOr(union2)) {
				return set.union(union1, union2);
			} else {
				return new is.Or([or1, or2]);
			}
		},
		// (a ∪ b) ∩ (c ∪ d) where Z = (a ∪ b)
		// -> Z ∩ (c ∪ d)
		// -> (Z ∩ c) ∪ (Z ∪ d)
		// -> ((a ∪ b) ∩ c) ∪ ((a ∪ b) ∩ d)
		intersection: function(or1, or2) {
			var c = or2.values[0],
				d = or2.values[1];

			var intersection1 = set.intersection(or1, c);
			var intersection2 = set.intersection(or1, d);

			if (!isOr(intersection1) || !isOr(intersection2)) {
				return set.union(intersection1, intersection2);
			}
			intersection1 = set.union(or2, or1.values[0]);
			intersection2 = set.union(or2, or1.values[1]);

			if (!isOr(intersection1) || !isOr(intersection2)) {
				return set.union(intersection1, intersection2);
			} else {
				return new is.Or([or1, or2]);
			}
		},
		// (a ∪ b) \ (c ∪ d) where Z = (a ∪ b)
		// -> Z \ (c ∪ d)
		// -> (Z \ c) ∩ (Z \ d)
		// -> ((a ∪ b) \ c) ∩ ((a ∪ b) \ d)
		difference: function(or1, or2) {
			var d1 = set.difference(or1, or2.values[0]);
			var d2 = set.difference(or1, or2.values[1]);
			return set.intersection(d1, d2);
		}
	},
	UNIVERSAL_Or: {
		difference: function(universe, or) {
			var inverseFirst = set.difference(universe, or.values[0]),
				inverseSecond = set.difference(universe, or.values[1]);
			return set.intersection(inverseFirst, inverseSecond);
		}
	}
});

// Registers all the comparisons above
var names = Object.keys(comparisons);
names.forEach(function(name1, i) {
	if (!comparators[name1 + "_" + name1]) {
		console.warn("no " + name1 + "_" + name1);
	} else {
		set.defineComparison(comparisons[name1], comparisons[name1], comparators[name1 + "_" + name1]);
	}

	if (!comparators["UNIVERSAL_" + name1]) {
		console.warn("no UNIVERSAL_" + name1);
	} else {
		set.defineComparison(set.UNIVERSAL, comparisons[name1], comparators["UNIVERSAL_" + name1]);
	}

	for (var j = i + 1; j < names.length; j++) {
		var name2 = names[j];
		if (!comparators[name1 + "_" + name2]) {
			console.warn("no " + name1 + "_" + name2);
		} else {
			set.defineComparison(comparisons[name1], comparisons[name2], comparators[name1 + "_" + name2]);
		}
		if (!comparators[name2 + "_" + name1]) {
			console.warn("no " + name2 + "_" + name1);
		} else {
			set.defineComparison(comparisons[name2], comparisons[name1], comparators[name2 + "_" + name1]);
		}
	}
});

module.exports = comparisons;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/keys-and.js":
/*!************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/keys-and.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ "./node_modules/can-query-logic/src/array-union-intersection-difference.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canGet = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var keysLogic = __webpack_require__(/*! ./types */ "./node_modules/can-query-logic/src/types/types.js");

// Define the sub-types that BasicQuery will use
function KeysAnd(values) {
	var vals = this.values = {};
	canReflect.eachKey(values, function(value, key) {
		if (canReflect.isPlainObject(value) && !set.isSpecial(value)) {
			vals[key] = new KeysAnd(value);
		} else {
			vals[key] = value;
		}
	});
}

var isMemberSymbol = canSymbol.for("can.isMember");


KeysAnd.prototype.isMember = function(props, root, rootKey) {
	var equal = true;
	var preKey = rootKey ? rootKey + "." : "";
	canReflect.eachKey(this.values, function(value, key) {
		var isMember = value && (value[isMemberSymbol] || value.isMember);
		if (isMember) {
			if (!isMember.call(value, canGet(props, key), root || props, preKey + key)) {
				equal = false;
			}
		} else {
			if (value !== canGet(props, key)) {
				equal = false;
			}
		}
	});
	return equal;
};


// ====== DEFINE COMPARISONS ========

// Helpers ----------------------------
function checkIfUniversalAndReturnUniversal(setA) {
	return set.isEqual(setA, set.UNIVERSAL) ? set.UNIVERSAL : setA;
}

var MISSING = {};

function eachInUnique(a, acb, b, bcb, defaultReturn) {
	var bCopy = assign({}, b),
		res;
	for (var prop in a) {
		res = acb(prop, a[prop], (prop in b) ? b[prop] : MISSING, a, b);
		if (res !== undefined) {
			return res;
		}
		delete bCopy[prop];
	}
	for (prop in bCopy) {
		res = bcb(prop, MISSING, b[prop], a, b);
		if (res !== undefined) {
			return res;
		}
	}
	return defaultReturn;
}

function keyDiff(valuesA, valuesB) {
	var keyResults = arrayUnionIntersectionDifference(
		Object.keys(valuesA),
		Object.keys(valuesB));
	return {
		aOnlyKeys: keyResults.difference,
		aAndBKeys: keyResults.intersection,
		bOnlyKeys: arrayUnionIntersectionDifference(
			Object.keys(valuesB),
			Object.keys(valuesA)).difference
	};
}

function notEmpty(value) {
	return value !== set.EMPTY;
}

// Difference of two ANDs is used two places
function difference(objA, objB) {

	var valuesA = objA.values,
		valuesB = objB.values,
		diff = keyDiff(valuesA, valuesB),
		aOnlyKeys = diff.aOnlyKeys,
		aAndBKeys = diff.aAndBKeys,
		bOnlyKeys = diff.bOnlyKeys;

	// check if all aAndB are equal

	// With the shared keys, perform vA \ vB difference. If the DIFFERENCE is:
	// - EMPTY: vA has nothing outside vB. vA is equal or subset of vB.
	//   - IF sB has keys not in sA, the shared keys will be part of the result;
	//     OTHERWISE, if all empty, sA is subset of sB, EMPTY will be returned
	//                (even if sA has some extra own keys)
	// - NON-EMPTY: something in sA that is not in sB
	//   Now we need to figure out if it's "product-able" or not.
	//   Product-able -> some part of B is in A.
	//   Perform B ∩ A intersection.  INTERSECTION is:
	//   - EMPTY: NOT "product-able". DISJOINT.  Must return something.
	//   - non-EMPTY: Use to performa  product (in the future.)
	var sharedKeysAndValues = {},
		productAbleKeysAndData = {},
		disjointKeysAndValues = {};
	aAndBKeys.forEach(function(key) {
		var difference = set.difference(valuesA[key], valuesB[key]);
		if (difference === set.EMPTY) {
			sharedKeysAndValues[key] = valuesA[key];
		} else {
			var intersection = set.intersection(valuesA[key], valuesB[key]);
			var isProductable = intersection !== set.EMPTY;
			if (isProductable) {
				productAbleKeysAndData[key] = {
					// Products with `difference U intersection` would be subtracted
					// from produts with `intersection`
					difference: difference,
					intersection: intersection
				};
			} else {
				disjointKeysAndValues[key] = valuesA[key];
			}
		}
	});
	var productAbleKeys = Object.keys(productAbleKeysAndData);
	var singleProductKeyAndValue;
	if (productAbleKeys.length === 1) {
		singleProductKeyAndValue = {};
		singleProductKeyAndValue[productAbleKeys[0]] = productAbleKeysAndData[productAbleKeys[0]].difference;
	}

	// Now that we've got the shared keys organized
	// we can make decisions based on this information
	// and A-only and B-only keys.

	// if we have any disjoint keys, these sets can not intersect
	// {age: 21, ...} \ {age: 22, ...} ->  {age: 21, ...}
	if (Object.keys(disjointKeysAndValues).length) {
		return objA;
	}

	// contain all the same keys
	if ((aOnlyKeys.length === 0) && (bOnlyKeys.length === 0)) {
		if (productAbleKeys.length > 1) {
			return set.UNDEFINABLE;
		}
		// {color: [RED, GREEN], ...X...} \ {color: [RED], ...X...} -> {color: [GREEN], ...X...}
		else if (productAbleKeys.length === 1) {
			assign(sharedKeysAndValues, singleProductKeyAndValue);
			return new KeysAnd(sharedKeysAndValues);
		} else {
			// {...X...} \ {...X...} -> EMPTY
			return set.EMPTY;
		}
	}
	// sA is likely a subset of sB
	if (aOnlyKeys.length > 0 && bOnlyKeys.length === 0) {
		if (productAbleKeys.length > 1) {
			return set.UNDEFINABLE;
		}
		// {age: 35, color: [RED, GREEN], ...X...} \ {color: [RED], ...X...} -> {age: 35, color: [GREEN], ...X...}
		else if (productAbleKeys.length === 1) {
			assign(sharedKeysAndValues, singleProductKeyAndValue);
			aOnlyKeys.forEach(function(key) {
				sharedKeysAndValues[key] = valuesA[key];
			});
			return new KeysAnd(sharedKeysAndValues);
		} else {
			// sharedKeysAndValues
			return set.EMPTY;
		}
	}
	// sB is likely subset of sA
	// {}, {foo: "bar"} -> {foo: NOT("bar")}
	if (aOnlyKeys.length === 0 && bOnlyKeys.length > 0) {
		// Lets not figure out productAbleKeys right now.
		// Example:
		// {color: [RED, GREEN], ...X...}
		// \ {age: 35, color: [RED], ...X...}
		// = OR( {color: [GREEN], ...X...}, {age: NOT(35), color: [RED], ...X...} )
		if (productAbleKeys.length > 1) {
			return set.UNDEFINABLE;
		}
		var productAbleOr;
		if (productAbleKeys.length === 1) {
			// we add the intersection to the AND
			// the difference is the or
			var productableKey = productAbleKeys[0];
			productAbleOr = assign({}, sharedKeysAndValues);
			productAbleOr[productableKey] = productAbleKeysAndData[productableKey].difference;
			sharedKeysAndValues[productableKey] = productAbleKeysAndData[productableKey].intersection;
		}

		var ands = bOnlyKeys.map(function(key) {
			var shared = assign({}, sharedKeysAndValues);
			var result = shared[key] = set.difference(set.UNIVERSAL, valuesB[key]);
			return result === set.EMPTY ? result : new KeysAnd(shared);
		}).filter(notEmpty);

		if (productAbleOr) {
			ands.push(new KeysAnd(productAbleOr));
		}

		// {c: "g"}
		// \ {c: "g", age: 22, name: "justin"}
		// = OR[ AND(name: NOT("justin"), c:"g"), AND(age: NOT(22), c: "g") ]
		if (ands.length > 1) {
			return new keysLogic.ValuesOr(ands);
		} else if (ands.length === 1) {
			// {c: "g"}
			// \ {c: "g", age: 22}
			// = AND(age: NOT(22), c: "g")
			return ands[0];
		} else {
			return set.EMPTY;
		}
	}

	// {name: "Justin"} \\ {age: 35} -> {name: "Justin", age: NOT(35)}
	if (aOnlyKeys.length > 0 && bOnlyKeys.length > 0) {
		if (productAbleKeys.length) {
			throw new Error("Can't handle any productable keys right now");
		}
		// add everything in sA into the result:
		aOnlyKeys.forEach(function(key) {
			sharedKeysAndValues[key] = valuesA[key];
		});

		if (bOnlyKeys.length === 1) {
			// TODO: de-duplicate below
			var key = bOnlyKeys[0];
			var shared = assign({}, sharedKeysAndValues);
			shared[key] = set.difference(set.UNIVERSAL, valuesB[key]);
			return new KeysAnd(shared);
		}
		// {foo: "bar"} \\ {name: "Justin", age: 35} -> UNDEFINABLE
		else {
			return set.UNDEFINABLE;
		}

	}
}

// KeysAnd comaprisons




set.defineComparison(KeysAnd, KeysAnd, {
	// {name: "Justin"} or {age: 35} -> new OR[{name: "Justin"},{age: 35}]
	// {age: 2} or {age: 3} -> {age: new OR[2,3]}
	// {age: 3, name: "Justin"} OR {age: 4} -> {age: 3, name: "Justin"} OR {age: 4}
	union: function(objA, objB) {
		// first see if we can union a single property
		// {age: 21, color: ["R"]} U {age: 21, color: ["B"]} -> {age: 21, color: ["R","B"]}

		var diff = keyDiff(objA.values, objB.values);


		// find the different keys
		var aAndBKeysThatAreNotEqual = [],
			sameKeys = {};

		diff.aAndBKeys.forEach(function(key) {
			if (!set.isEqual(objA.values[key], objB.values[key])) {
				aAndBKeysThatAreNotEqual.push(key);
			} else {
				sameKeys[key] = objA.values[key];
			}
		});
		var aUnequal = {}, bUnequal = {};
		aAndBKeysThatAreNotEqual.forEach(function(key){
			aUnequal[key] = objA.values[key];
			bUnequal[key] = objB.values[key];
		});

		// if all keys are shared
		if (!diff.aOnlyKeys.length && !diff.bOnlyKeys.length) {

			if (aAndBKeysThatAreNotEqual.length === 1) {
				var keyValue = aAndBKeysThatAreNotEqual[0];

				var result = sameKeys[keyValue] = set.union(objA.values[keyValue], objB.values[keyValue]);

				// if there is only one property, we can just return the universal set
				return canReflect.size(sameKeys) === 1 && set.isEqual(result, set.UNIVERSAL) ?
					set.UNIVERSAL : new KeysAnd(sameKeys);
			} else if (aAndBKeysThatAreNotEqual.length === 0) {
				// these things are equal
				return objA;
			}
		}
		// If everything shared is the same
		if (aAndBKeysThatAreNotEqual.length === 0) {
			// the set with the extra keys is a subset
			if (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {
				return checkIfUniversalAndReturnUniversal(objB);
			} else if (diff.aOnlyKeys.length === 0 && diff.bOnlyKeys.length > 0) {
				return checkIfUniversalAndReturnUniversal(objA);
			}
		}
		// (count > 5 && age > 25 ) || (count > 7 && age > 35 && name > "Justin" )
		//
		// ( age > 25 ) || ( name > "Justin" && age > 35)  A U (B & C) => (A U B) & (A U C)
		// ( age > 25 || name > "Justin" ) && (age > 25)
		// lets see if one side is different
		if (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {
			// collect shared value
			if( set.isSubset(new KeysAnd(aUnequal), new KeysAnd(bUnequal) )) {
				return objB;
			}
		}
		if (diff.bOnlyKeys.length > 0 && diff.aOnlyKeys.length === 0) {
			// collect shared value
			if( set.isSubset(new KeysAnd(bUnequal),  new KeysAnd(aUnequal) )) {
				return objA;
			}
		}

		return new keysLogic.ValuesOr([objA, objB]);
	},
	// {foo: zed, abc: d}
	intersection: function(objA, objB) {
		// combine all properties ... if the same property, try to take
		// an intersection ... if an intersection isn't possible ... freak out?
		var valuesA = objA.values,
			valuesB = objB.values,
			foundEmpty = false;
		var resultValues = {};
		eachInUnique(valuesA,
			function(prop, aVal, bVal) {
				resultValues[prop] = bVal === MISSING ? aVal : set.intersection(aVal, bVal);
				if (resultValues[prop] === set.EMPTY) {
					foundEmpty = true;
				}
			},
			valuesB,
			function(prop, aVal, bVal) {
				resultValues[prop] = bVal;
				if (resultValues[prop] === set.EMPTY) {
					foundEmpty = true;
				}
			});
		if (foundEmpty) {
			return set.EMPTY;
		} else {
			return new KeysAnd(resultValues);
		}

	},
	// A \ B -> what's in A, but not in B
	difference: difference
});

set.defineComparison(set.UNIVERSAL, KeysAnd, {
	// A \ B -> what's in A, but not in B
	difference: function(universe, and) {
		return difference({
			values: {}
		}, and);
	}
});


module.exports = keysLogic.KeysAnd = KeysAnd;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-enum.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-enum.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ "./node_modules/can-query-logic/src/array-union-intersection-difference.js");
var schemaHelpers = __webpack_require__(/*! ../schema-helpers */ "./node_modules/can-query-logic/src/schema-helpers.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var setTypeSymbol = canSymbol.for("can.SetType"),
	isMemberSymbol = canSymbol.for("can.isMember"),
	newSymbol = canSymbol.for("can.new");

function makeEnumSetType(allValues, hydrate) {
	function Enum(values) {
		var arr = Array.isArray(values) ? values : [values];
		this.values = hydrate ? arr.map(hydrate) : arr;
	}
	canReflect.assignSymbols(Enum.prototype, {
		"can.serialize": function() {
			return this.values.length === 1 ? this.values[0] : this.values;
		}
	});

	Enum.prototype[isMemberSymbol] = function(value) {
		return this.values.some(function(val) {
			return set.isEqual(val, value);
		});
	};

	Enum.UNIVERSAL = new Enum(allValues);

	var difference = function(enum1, enum2) {
		var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
		if (result.difference.length) {
			return new Enum(result.difference);
		} else {
			return set.EMPTY;
		}
	};

	set.defineComparison(Enum, Enum, {
		union: function(enum1, enum2) {
			var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
			if (result.union.length) {
				return new Enum(result.union);
			} else {
				return set.EMPTY;
			}
		},
		intersection: function(enum1, enum2) {
			var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
			if (result.intersection.length) {
				return new Enum(result.intersection);
			} else {
				return set.EMPTY;
			}
		},
		difference: difference
	});

	set.defineComparison(Enum, set.UNIVERSAL, {
		difference: function(enumA) {
			return difference(enumA, {
				values: allValues.slice(0)
			});
		}
	});

	set.defineComparison(set.UNIVERSAL, Enum, {
		difference: function(universe, enumB) {
			return difference({
				values: allValues.slice(0)
			}, enumB);
		}
	});

	return Enum;
}

function makeEnum(Type, allValues, hydrate) {

	var Enum = makeEnumSetType(allValues, hydrate);

	Type[setTypeSymbol] = Enum;
	Type[isMemberSymbol] = function(value) {
		return allValues.some(function(val) {
			return set.isEqual(val, value);
		});
	};

	return Enum;
}

makeEnum.canMakeEnumSetType = function(Type) {
	var schema = canReflect.getSchema(Type);
	if (schema && schema.type === "Or") {
		var categories = schemaHelpers.categorizeOrValues(schema.values);
		return categories.primitives.length === schema.values.length;
	}
	return false;
};

makeEnum.makeEnumSetType = function(Type) {
	var schema = canReflect.getSchema(Type);
	var categories = schemaHelpers.categorizeOrValues(schema.values);
	var hydrate = Type[newSymbol] ? Type[newSymbol].bind(Type) : undefined;
	return makeEnumSetType(categories.primitives, hydrate);
};

module.exports = makeEnum;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-maybe.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-maybe.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var is = __webpack_require__(/*! ./comparisons */ "./node_modules/can-query-logic/src/types/comparisons.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var schemaHelpers = __webpack_require__(/*! ../schema-helpers */ "./node_modules/can-query-logic/src/schema-helpers.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var comparisonSetTypeSymbol = canSymbol.for("can.ComparisonSetType");
var isMemberSymbol = canSymbol.for("can.isMember");

// This helper function seperates out sets that relate to the "maybe" values
// like `null` or `undefined`. For example, if `rangeToBeSplit`
// is `In([null, 3])`, it will produce `{enum: In([null]), range: In(3)}`
function splitByRangeAndEnum(maybeUniverse, rangeToBeSplit) {
	var enumSet;

	// If it's an AND
	if (rangeToBeSplit instanceof is.And) {
		// recursively split each value
		var sets = rangeToBeSplit.values.map(function(setInAnd) {
			return splitByRangeAndEnum(maybeUniverse, setInAnd);
		});
		// take the intersections
		return sets.reduce(function(last, maybe) {
			return {
				range: set.intersection(last.range, maybe.range),
				enum: set.intersection(last.enum, maybe.enum)
			};
		}, {
			range: set.UNIVERSAL,
			enum: maybeUniverse
		});

	} else if (rangeToBeSplit instanceof is.In) {

		var shouldBeInValues = rangeToBeSplit.values.filter(function(value) {
			return maybeUniverse.isMember(value);
		});
		if (shouldBeInValues.length) {
			var valuesCopy = rangeToBeSplit.values.slice(0);
			canReflect.removeValues(valuesCopy, shouldBeInValues);

			return {
				enum: new is.In(shouldBeInValues),
				range: valuesCopy.length ? new is.In(valuesCopy) : set.EMPTY
			};
		} else {
			return {
				enum: set.EMPTY,
				range: rangeToBeSplit
			};
		}
	} else if (rangeToBeSplit instanceof is.NotIn) {

		// Gets the 'maybe' values in the range
		enumSet = set.intersection(maybeUniverse, rangeToBeSplit);

		// We should remove all the values within $in matching an in values.
		var rangeValues = rangeToBeSplit.values.filter(function(value) {
			return !maybeUniverse.isMember(value);
		});
		return {
			range: rangeValues.length ? new is.NotIn(rangeValues) : set.UNIVERSAL,
			enum: enumSet
		};
	} else {
		return {
			enum: set.EMPTY,
			range: rangeToBeSplit
		};
	}
}

// Builds a type for ranged values plus some other enum values.
// This is great for 'maybe' values. For example, it might be a string OR `null` OR `undefined`
// `makeMaybe([null, undefined])`
function makeMaybe(inValues, makeChildType) {


	var maybeUniverse = new is.In(inValues);

	function Maybe(values) {

		// Maybe has two sub-sets:
		// - `.range` - Selects the non-enum values. Ex: `GreaterThan(3)`
		// - `.enum` - Selects the enum values. This is ALWAYS an `In`. Ex: `In([null])`.
		// Maybe is effectively an OR with these two properties.
		var result = splitByRangeAndEnum(maybeUniverse, values.range);
		this.range = result.range || set.EMPTY;
		if (values.enum) {
			if (result.enum !== set.EMPTY) {
				this.enum = set.union(result.enum, values.enum);
			} else {
				this.enum = values.enum;
			}
		} else {
			this.enum = result.enum;
		}
		if(this.enum === set.EMPTY && this.range === set.EMPTY) {
			return set.EMPTY;
		}
	}
	Maybe.prototype.orValues = function() {
		var values = [];
		if( this.range !== set.EMPTY ) {
			values.push(this.range);
		}
		if( this.enum !== set.EMPTY ) {
			values.push(this.enum);
		}
		return values;
	};
	Maybe.prototype[isMemberSymbol] = function isMember() {
		var rangeIsMember = this.range[isMemberSymbol] || this.range.isMember,
			enumIsMember = this.enum[isMemberSymbol] || this.enum.isMember;
		return rangeIsMember.apply(this.range, arguments) || enumIsMember.apply(this.enum, arguments);
	};



	set.defineComparison(Maybe, Maybe, {
		union: function(maybeA, maybeB) {
			var enumSet = set.union(maybeA.enum, maybeB.enum);
			var range = set.union(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		},
		difference: function(maybeA, maybeB) {
			var enumSet = set.difference(maybeA.enum, maybeB.enum);
			var range = set.difference(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		},
		intersection: function(maybeA, maybeB) {
			var enumSet = set.intersection(maybeA.enum, maybeB.enum);
			var range = set.intersection(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		}
	});
	Maybe.inValues = inValues;

	set.defineComparison(set.UNIVERSAL, Maybe, {
		difference: function(universe, maybe) {
			var primary,
				secondary;

			if (maybe.range === set.UNIVERSAL) {
				// there is only the enum
				return new Maybe({
					range: maybe.range,
					enum: set.difference(maybeUniverse, maybe.enum)
				});
			}
			// there is only a primary
			if (maybe.enum === set.EMPTY) {
				var rangeSet = set.difference(set.UNIVERSAL, maybe.range);
				var notPresent = set.difference(maybeUniverse, maybe.range);
				// make sure they are included
				var enumSet = set.difference(notPresent, rangeSet);


				return new Maybe({
					range: rangeSet,
					enum: enumSet
				});
				// check enum things that aren't included in primary

			} else {
				primary = set.difference(universe, maybe.range);
				secondary = set.difference(maybeUniverse, maybe.enum);
			}
			return new Maybe({
				enum: secondary,
				range: primary
			});
		}
	});
	makeChildType = makeChildType || function(v) {
		return v;
	};

	Maybe.hydrate = function(value, childHydrate) {
		return new Maybe({
			range: childHydrate(value, makeChildType)
		});
	};

	return Maybe;
}



makeMaybe.canMakeMaybeSetType = function(Type) {
	var schema = canReflect.getSchema(Type);
	if (schema && schema.type === "Or") {
		var categories = schemaHelpers.categorizeOrValues(schema.values);

		return categories.valueOfTypes.length === 1 &&
			(categories.valueOfTypes.length + categories.primitives.length === schema.values.length);
	}
	return false;
};

// Given an __Or__ type like:
// ```
// var MaybeString = {
//   "can.new"(val){ ... },
// 	 "can.getSchema"(){ return  { type: "Or", values: [String, undefined, null] }
// });
// ```
//
// This creates two types:
// - `Value` - A value type used for what's within `GreaterThan`, etc.
// - `Maybe` - A SetType for this property. It will have `GreaterThan` within its
//            `{enum, range}` sub values.
//
// This creates the outer `SetType` and the innermost `Value` type while the Comparisons
// are used inbetween.
//
// The `MaybeString` could probably be directly used to hydrate values to what they should be.
makeMaybe.makeMaybeSetTypes = function(Type) {
	var schema = canReflect.getSchema(Type);
	var categories = schemaHelpers.categorizeOrValues(schema.values);
	var ComparisonSetType;

	// No need to build the comparison type if we are given it.
	if (Type[comparisonSetTypeSymbol]) {
		ComparisonSetType = Type[comparisonSetTypeSymbol];
	} else {

		ComparisonSetType = function(value) {
			this.value = canReflect.new(Type, value);
		};
		ComparisonSetType.prototype.valueOf = function() {
			return this.value;
		};
		canReflect.assignSymbols(ComparisonSetType.prototype, {
			"can.serialize": function() {
				return this.value;
			}
		});
		//!steal-remove-start
		if(true) {
			Object.defineProperty(ComparisonSetType, "name", {
				value: "Or[" + categories.valueOfTypes[0].name + "," + categories.primitives.map(String).join(" ") + "]"
			});
		}
		//!steal-remove-end
	}

	return {
		Maybe: makeMaybe(categories.primitives, function hydrateMaybesValueType(value) {
			return new ComparisonSetType(value);
		}),
		ComparisonSetType: ComparisonSetType
	};
};


module.exports = makeMaybe;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js":
/*!************************************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var is = __webpack_require__(/*! ./comparisons */ "./node_modules/can-query-logic/src/types/comparisons.js");

// THIS IS REALLY INTEGERS!!!

module.exports = function(min, max) {




    function RealNumberRangeInclusive(start, end){

        this.start =  arguments.length > 0 ? +start : min;
        this.end = arguments.length > 1 ? +end : max;
		this.range = new is.And([
			new is.GreaterThanEqual( this.start ),
			new is.LessThanEqual( this.end )
		]);
    }

	var universeRange = new RealNumberRangeInclusive( min , max );

    function isUniversal(range) {
        return set.isSubset(universeRange.range, range.range);
    }

	function rangeFromAnd(aSet) {
		var values = {};
		aSet.values.forEach(function(value){
			if(value instanceof is.GreaterThanEqual) {
				values.start = value.value;
			}
			if(value instanceof is.GreaterThan) {
				values.start = value.value+1;
			}
			if(value instanceof is.LessThanEqual) {
				values.end = value.value;
			}
			if(value instanceof is.LessThan) {
				values.end = value.value-1;
			}
		});
		if("start" in values && "end" in values) {
			return new RealNumberRangeInclusive(values.start, values.end );
		}
	}

	function toRange(aSet) {
		var range;
		if(aSet instanceof is.And) {
			range = rangeFromAnd(aSet);
		}
		if(aSet instanceof is.Or) {
			// check if next to each other ...
			var first = rangeFromAnd(aSet.values[0]),
				second = rangeFromAnd(aSet.values[1]);
			if(first && second) {
				var firstValues = first.range.values,
					secondValues = second.range.values;
				if(firstValues[1].value + 1 === secondValues[0].value) {
					range = new RealNumberRangeInclusive(firstValues[0].value, secondValues[1].value );
				}
				else if(secondValues[1].value + 1 === firstValues[0].value) {
					range = new RealNumberRangeInclusive(secondValues[0].value, firstValues[1].value );
				} else {
					return set.UNDEFINABLE;
				}
			} else {
				return set.UNDEFINABLE;
			}
		}
		if(range && isUniversal(range)) {
			return set.UNIVERSAL;
		} else {
			return range;
		}
	}

    function intersection(range1, range2){
		var intersection = toRange(set.intersection(range1.range, range2.range));
		if(intersection) {
			return intersection;
		} else {
            return set.EMPTY;
        }
    }

    function difference(range1, range2){

		var difference = toRange( set.difference(range1.range, range2.range) );
		if(difference) {
			return difference;
		} else {
            return set.EMPTY;
        }
    }

    set.defineComparison(RealNumberRangeInclusive, RealNumberRangeInclusive,{
        union: function(range1, range2){
			var union = toRange( set.union(range1.range, range2.range) );
			if(union) {
				return union;
			} else {
	            return set.EMPTY;
	        }
        },
        intersection: intersection,
        difference: difference
    });

    set.defineComparison(set.UNIVERSAL,RealNumberRangeInclusive, {
        difference: function(universe, range){
            if(isUniversal(range)) {
                return set.EMPTY;
            } else {
                return difference(universeRange, range);
            }
        }
    });

    return RealNumberRangeInclusive;
};


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/types.js ***!
  \*********************************************************/
/***/ ((module) => {

/*
 * # types
 * This folder is for SetTypes that are used to compare against a single value.
 * For example, `new comparisons.GreaterThan(5)` is used to compare against 
 */



// this is a placeholder for types that have cycle dependencies
module.exports = {};


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-and.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-and.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var keysLogic = __webpack_require__(/*! ./types */ "./node_modules/can-query-logic/src/types/types.js");
var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");

function ValuesAnd(values) {
	this.values = values;
}

ValuesAnd.prototype.isMember = function(props) {
	return this.values.every(function(value){
            return value && value.isMember ?
                value.isMember( props ) : value === props;
    });
};

// Or comparisons
set.defineComparison(set.UNIVERSAL, ValuesAnd, {
    difference: function(){
        return set.UNDEFINABLE;
    }
});

module.exports = keysLogic.ValuesAnd = ValuesAnd;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-not.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-not.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var keysLogic = __webpack_require__(/*! ./types */ "./node_modules/can-query-logic/src/types/types.js");

function NotIdentity(value) {
    this.value = value;
}

// Not comparisons ---------
var Identity = set.Identity;

// Only difference is needed w/ universal
set.defineComparison(set.UNIVERSAL, Identity,{
    // A \ B -> what's in b, but not in A
    difference: function(universe, value){
        return new NotIdentity(value);
    }
});

// Only difference is needed w/ universal
set.defineComparison(set.UNIVERSAL, NotIdentity,{
    // A \ B -> what's in b, but not in A
    difference: function(universe, not){
        return not.value;
    }
});

set.defineComparison(NotIdentity, NotIdentity,{
    /*
    // not 5 and not 6
    union: function(obj1, obj2){
        // must unroll the value

    },
    // {foo: zed, abc: d}
    intersection: function(obj1, obj2){

    },
    // A \ B -> what's in b, but not in A
    difference: function(obj1, obj2){

    }
    */
});



set.defineComparison(NotIdentity, Identity,{
    // not 5 and not 6
    union: function(not, primitive){
        // NOT(5) U 5
        if( set.isEqual( not.value, primitive) ) {
            return set.UNIVERSAL;
        }
        // NOT(4) U 6
        else {
            throw new Error("Not,Identity Union is not filled out");
        }
    },
    // {foo: zed, abc: d}
    intersection: function(not, primitive){
        return set.isEqual( !not.value, primitive ) ? primitive: set.EMPTY;
    },
    // A \ B -> what's in b, but not in A
    difference: function difference(not, primitive){
        // NOT(5) \ 3 -> UNDEFINABLE
        // NOT(3) \ 3 -> NOT(3)
        if(set.isEqual( not.value, primitive )) {
            return not;
        } else {
            return set.UNDEFINABLE;
        }
    }
});

set.defineComparison(Identity, NotIdentity,{
    difference: function(primitive, not){
        if(set.isEqual(primitive, not.value)) {
            return primitive;
        } else {
            return set.UNDEFINABLE;
        }
    }
});

NotIdentity.prototype.isMember = function(value){
	if(this.value  && typeof this.value.isMember === "function") {
		return !this.value.isMember(value);
	} else {
		var values = set.ownAndMemberValue(this.value, value);
		return values.own !== values.member;
	}

};

module.exports = keysLogic.Not = NotIdentity;


/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-or.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-or.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var set = __webpack_require__(/*! ../set */ "./node_modules/can-query-logic/src/set.js");
var types = __webpack_require__(/*! ./types */ "./node_modules/can-query-logic/src/types/types.js");

// this is intended to be used for $or ... it
// ors expected key values
// `{age: 22}` U `{name: "Justin"}`
function ValuesOr(values) {
    // the if values can be unioned into a single value
    this.values = values;
}

ValuesOr.prototype.isMember = function(props){
    return this.values.some(function(value){
            return value && value.isMember ?
                value.isMember( props ) : value === props;
    });
};


// Or comparisons
set.defineComparison(set.UNIVERSAL, ValuesOr,{
    difference: function(){
        return set.UNDEFINABLE;
    }
});


module.exports = types.ValuesOr = ValuesOr;


/***/ }),

/***/ "./node_modules/can-queues/can-queues.js":
/*!***********************************************!*\
  !*** ./node_modules/can-queues/can-queues.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canDev = __webpack_require__( /*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js" );
var Queue = __webpack_require__( /*! ./queue */ "./node_modules/can-queues/queue.js" );
var PriorityQueue = __webpack_require__( /*! ./priority-queue */ "./node_modules/can-queues/priority-queue.js" );
var queueState = __webpack_require__( /*! ./queue-state */ "./node_modules/can-queues/queue-state.js" );
var CompletionQueue = __webpack_require__( /*! ./completion-queue */ "./node_modules/can-queues/completion-queue.js" );
var DomOrderQueue = __webpack_require__(/*! ./dom-order-queue */ "./node_modules/can-queues/dom-order-queue.js");
var ns = __webpack_require__( /*! can-namespace */ "./node_modules/can-namespace/can-namespace.js" );

// How many `batch.start` - `batch.stop` calls have been made.
var batchStartCounter = 0;
// If a task was added since the last flush caused by `batch.stop`.
var addedTask = false;
// If we are flushing due to a `batch.stop`.
var isFlushing = false;

// Legacy values for the old batchNum.
var batchNum = 0;
var batchData;

// Used by `.enqueueByQueue` to know the property names that might be passed.
var queueNames = ["notify", "derive", "domUI", "dom","mutate"];
// Create all the queues so that when one is complete,
// the next queue is flushed.
var NOTIFY_QUEUE,
	DERIVE_QUEUE,
	DOM_UI_QUEUE,
	DOM_QUEUE,
	MUTATE_QUEUE;

// This is for immediate notification. This is where we teardown (remove childNodes)
// immediately.
NOTIFY_QUEUE = new Queue( "NOTIFY", {
	onComplete: function () {
		DERIVE_QUEUE.flush();
	},
	onFirstTask: function () {
		// Flush right away if we aren't in a batch.
		if ( !batchStartCounter ) {
			NOTIFY_QUEUE.flush();
		} else {
			addedTask = true;
		}
	}
});

// For observations not connected to the DOM
DERIVE_QUEUE = new PriorityQueue( "DERIVE", {
	onComplete: function () {
		DOM_QUEUE.flush();
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

// DOM_DERIVE comes next so that any prior derives have a chance
// to settle before the derives that actually affect the DOM
// are re-caculated.
// See the `Child bindings are called before the parent` can-stache test.
// All stache-related observables should update in DOM order.

// Observations that are given an element update their value here.
DOM_QUEUE = new DomOrderQueue( "DOM   " ,{
	onComplete: function () {
		DOM_UI_QUEUE.flush();
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

// The old DOM_UI queue ... we should seek to remove this.
DOM_UI_QUEUE = new CompletionQueue( "DOM_UI", {
	onComplete: function () {
		MUTATE_QUEUE.flush();
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

// Update
MUTATE_QUEUE = new Queue( "MUTATE", {
	onComplete: function () {
		queueState.lastTask = null;
		isFlushing = false;
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

var queues = {
	Queue: Queue,
	PriorityQueue: PriorityQueue,
	CompletionQueue: CompletionQueue,
	DomOrderQueue: DomOrderQueue,
	notifyQueue: NOTIFY_QUEUE,
	deriveQueue: DERIVE_QUEUE,
	domQueue: DOM_QUEUE,
	domUIQueue: DOM_UI_QUEUE,
	mutateQueue: MUTATE_QUEUE,
	batch: {
		start: function () {
			batchStartCounter++;
			if ( batchStartCounter === 1 ) {
				batchNum++;
				batchData = {number: batchNum};
			}
		},
		stop: function () {
			batchStartCounter--;
			if ( batchStartCounter === 0 ) {
				if ( addedTask ) {
					addedTask = false;
					isFlushing = true;
					NOTIFY_QUEUE.flush();
				}
			}
		},
		// Legacy method to return if we are between start and stop calls.
		isCollecting: function () {
			return batchStartCounter > 0;
		},
		// Legacy method provide a number for each batch.
		number: function () {
			return batchNum;
		},
		// Legacy method to provide batch information.
		data: function () {
			return batchData;
		}
	},
	runAsTask: function(fn, reasonLog){
		//!steal-remove-start
		if(true) {
			return function(){
				queueState.lastTask = {
					fn: fn,
					context: this,
					args: arguments,
					meta: {
						reasonLog: typeof reasonLog === "function" ? reasonLog.apply(this, arguments): reasonLog,
						parentTask: queueState.lastTask,
						stack: {name: "RUN_AS"}
					}
				};
				var ret = fn.apply(this, arguments);
				queueState.lastTask = queueState.lastTask && queueState.lastTask.meta.parentTask;
				return ret;
			};
		}
		//!steal-remove-end
		return fn;
	},
	enqueueByQueue: function enqueueByQueue ( fnByQueue, context, args, makeMeta, reasonLog ) {
		if ( fnByQueue ) {
			queues.batch.start();
			// For each queue, check if there are tasks for it.
			queueNames.forEach( function ( queueName ) {
				var name = queueName + "Queue";
				var QUEUE = queues[name];
				var tasks = fnByQueue[queueName];
				if ( tasks !== undefined ) {
					// For each task function, setup the meta and enqueue it.
					tasks.forEach( function ( fn ) {
						var meta = makeMeta != null ? makeMeta( fn, context, args ) : {};
						meta.reasonLog = reasonLog;
						QUEUE.enqueue( fn, context, args, meta );
					});
				}
			});
			queues.batch.stop();
		}
	},
	lastTask: function(){
		return queueState.lastTask;
	},
	// Currently an internal method that provides the task stack.
	// Returns an array with the first task as the first item.
	stack: function (task) {
		var current = task || queueState.lastTask;
		var stack = [];
		while ( current ) {
			stack.unshift( current );
			// Queue.prototype._logEnqueue ensures
			// that the `parentTask` is always set.
			current = current.meta.parentTask;
		}
		return stack;
	},
	logStack: function (task) {
		var stack = this.stack(task);
		stack.forEach( function ( task, i ) {
			var meta = task.meta;
			if( i === 0 && meta && meta.reasonLog) {
				canDev.log.apply( canDev, meta.reasonLog);
			}
			var log = meta && meta.log ? meta.log : [task.fn.name, task];
			canDev.log.apply( canDev, [task.meta.stack.name + " ran task:"].concat( log ));
		});
	},
	// A method that is not used.  It should return the number of tasks
	// remaining, but doesn't seem to actually work.
	taskCount: function () {
		return NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;
	},
	// A shortcut for flushign the notify queue.  `batch.start` and `batch.stop` should be
	// used instead.
	flush: function () {
		NOTIFY_QUEUE.flush();
	},
	log: function () {
		NOTIFY_QUEUE.log.apply( NOTIFY_QUEUE, arguments );
		DERIVE_QUEUE.log.apply( DERIVE_QUEUE, arguments );
		DOM_UI_QUEUE.log.apply( DOM_UI_QUEUE, arguments );
		DOM_QUEUE.log.apply( DOM_QUEUE, arguments );
		MUTATE_QUEUE.log.apply( MUTATE_QUEUE, arguments );
	}
};

if ( ns.queues ) {
	throw new Error( "You can't have two versions of can-queues, check your dependencies" );
} else {
	module.exports = ns.queues = queues;
}


/***/ }),

/***/ "./node_modules/can-queues/completion-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-queues/completion-queue.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Queue = __webpack_require__( /*! ./queue */ "./node_modules/can-queues/queue.js" );

// This queue does not allow another task to run until this one is complete
var CompletionQueue = function () {
	Queue.apply( this, arguments );
	this.flushCount = 0;
};
CompletionQueue.prototype = Object.create( Queue.prototype );
CompletionQueue.prototype.constructor = CompletionQueue;

CompletionQueue.prototype.flush = function () {
	if ( this.flushCount === 0 ) {
		this.flushCount ++;
		while ( this.index < this.tasks.length ) {
			var task = this.tasks[this.index++];
			//!steal-remove-start
			if (true) {
				this._logFlush( task );
			}
			//!steal-remove-end
			task.fn.apply( task.context, task.args );
		}
		this.index = 0;
		this.tasks = [];
		this.flushCount--;
		this.callbacks.onComplete( this );
	}
};

module.exports = CompletionQueue;


/***/ }),

/***/ "./node_modules/can-queues/dom-order-queue.js":
/*!****************************************************!*\
  !*** ./node_modules/can-queues/dom-order-queue.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Queue = __webpack_require__( /*! ./queue */ "./node_modules/can-queues/queue.js" );
var sortedIndexBy = __webpack_require__(/*! ./sorted-index-by */ "./node_modules/can-queues/sorted-index-by.js");
var elementSort = __webpack_require__(/*! ./element-sort */ "./node_modules/can-queues/element-sort.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var canElementSymbol = canSymbol.for("can.element");

// TODO: call sortable queue and take how it should be sorted ...
function sortTasks(taskA, taskB){
	// taskA - in the document?
	// taskA - given a number?
	//
	return elementSort.sortOrder(taskA.meta.element, taskB.meta.element);
}

var DomOrderQueue = function () {
	Queue.apply( this, arguments );
	// A map of a task's function to the task for that function.
	// This is so we can prevent duplicate functions from being enqueued
	// and so `flushQueuedTask` can find the task and run it.
	this.taskMap = new Map();

	this.unsortable = [];
	this.isFlushing = false;
};
DomOrderQueue.prototype = Object.create( Queue.prototype );
DomOrderQueue.prototype.constructor = DomOrderQueue;

DomOrderQueue.prototype.enqueue = function ( fn, context, args, meta ) {
	var task;
	// Only allow the enqueing of a given function once.
	if ( !this.taskMap.has( fn ) ) {

		if(!meta) {
			meta = {};
		}
		if(!meta.element) {
			meta.element = fn[canElementSymbol];
		}

		task = {
			fn: fn,
			context: context,
			args: args,
			meta: meta
		};

		//!steal-remove-start
		if(true) {
			if( !meta.element ) {
				throw new Error("DomOrderQueue tasks must be created with a meta.element.");
			}
		}
		//!steal-remove-end

		this.taskMap.set( fn, task );

		var index = sortedIndexBy(sortTasks, this.tasks, task);

		this.tasks.splice(index, 0, task);

		//!steal-remove-start
		if(true) {
			this._logEnqueue( task );
		}
		//!steal-remove-end

		if ( this.tasks.length === 1 ) {
			this.callbacks.onFirstTask( this );
		}
	} else {
		// update the task with the new data
		// TODO: ideally this would key off the mutation instead of the function.
		// We could make it key off the element and function,  not just function.
		task = this.taskMap.get( fn );
		task.context = context;
		task.args = args;

		if(!meta) {
			meta = {};
		}

		if(!meta.element) {
			meta.element = fn[canElementSymbol];
		}

		task.meta = meta;

		//!steal-remove-start
		if(true) {
			this._logEnqueue( task );
		}
		//!steal-remove-end
	}
};


DomOrderQueue.prototype.flush = function () {
	// Only allow one task to run at a time.
	if ( this.isFlushing ) {
		return;
	}
	this.isFlushing = true;

	while ( this.tasks.length ) {
		var task = this.tasks.shift();
		//!steal-remove-start
		if(true) {
			this._logFlush( task );
		}
		//!steal-remove-end
		this.taskMap["delete"]( task.fn );
		task.fn.apply( task.context, task.args );
	}
	this.isFlushing = false;
	this.callbacks.onComplete( this );
};

DomOrderQueue.prototype.isEnqueued = function ( fn ) {
	return this.taskMap.has( fn );
};

DomOrderQueue.prototype.flushQueuedTask = function ( fn ) {
	var task = this.dequeue(fn);
	if(task) {
		//!steal-remove-start
		if(true) {
			this._logFlush( task );
		}
		//!steal-remove-end
		task.fn.apply( task.context, task.args );
	}
};
DomOrderQueue.prototype.dequeue = function(fn){
	var task = this.taskMap.get( fn );
	if ( task ) {

		var index = this.tasks.indexOf(task);

		if ( index >= 0 ) {
			this.tasks.splice( index, 1 );
			this.taskMap["delete"]( task.fn );
			return task;
		} else {
			console.warn("Task", fn, "has already run");
		}
	}
};

DomOrderQueue.prototype.tasksRemainingCount = function () {
	return this.tasks.length;
};

module.exports = DomOrderQueue;


/***/ }),

/***/ "./node_modules/can-queues/element-sort.js":
/*!*************************************************!*\
  !*** ./node_modules/can-queues/element-sort.js ***!
  \*************************************************/
/***/ ((module) => {

// Taken from jQuery
var hasDuplicate,
	sortInput,
	sortStable = true,
	indexOf = Array.prototype.indexOf;

function sortOrder( a, b ) {

	// Flag for duplicate removal
	if ( a === b ) {
		hasDuplicate = true;
		return 0;
	}

	// Sort on method existence if only one input has compareDocumentPosition
	var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
	if ( compare ) {
		return compare;
	}

	// Calculate position if both inputs belong to the same document
	compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
		a.compareDocumentPosition( b ) :

		// Otherwise we know they are disconnected
		1;

	// Disconnected nodes
	if ( compare & 1 ) {

		// Choose the first element that is related to our preferred document
		if ( a === document || a.ownerDocument === document &&
			document.documentElement.contains(a) ) {
			return -1;
		}
		if ( b === document || b.ownerDocument === document &&
			document.documentElement.contains(b) ) {
			return 1;
		}

		// Maintain original order
		return sortInput ?
			( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
			0;
	}

	return compare & 4 ? -1 : 1;
}

function uniqueSort( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	hasDuplicate = false;
	sortInput = !sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
}

module.exports = {
	uniqueSort: uniqueSort,
	sortOrder: sortOrder
};


/***/ }),

/***/ "./node_modules/can-queues/priority-queue.js":
/*!***************************************************!*\
  !*** ./node_modules/can-queues/priority-queue.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Queue = __webpack_require__( /*! ./queue */ "./node_modules/can-queues/queue.js" );

var PriorityQueue = function () {
	Queue.apply( this, arguments );
	// A map of a task's function to the task for that function.
	// This is so we can prevent duplicate functions from being enqueued
	// and so `flushQueuedTask` can find the task and run it.
	this.taskMap = new Map();
	// An "array-of-arrays"-ish data structure that stores
	// each task organized by its priority.  Each object in this list
	// looks like `{tasks: [...], index: 0}` where:
	// - `tasks` - the tasks for a particular priority.
	// - `index` - the index of the task waiting to be prioritized.
	this.taskContainersByPriority = [];

	// The index within `taskContainersByPriority` of the first `taskContainer`
	// which has tasks that have not been run.
	this.curPriorityIndex = Infinity;
	// The index within `taskContainersByPriority` of the last `taskContainer`
	// which has tasks that have not been run.
	this.curPriorityMax = 0;

	this.isFlushing = false;

	// Manage the number of tasks remaining to keep
	// this lookup fast.
	this.tasksRemaining = 0;
};
PriorityQueue.prototype = Object.create( Queue.prototype );
PriorityQueue.prototype.constructor = PriorityQueue;

PriorityQueue.prototype.enqueue = function ( fn, context, args, meta ) {
	// Only allow the enqueing of a given function once.
	if ( !this.taskMap.has( fn ) ) {

		this.tasksRemaining++;

		var isFirst = this.taskContainersByPriority.length === 0;

		var task = {
			fn: fn,
			context: context,
			args: args,
			meta: meta || {}
		};

		var taskContainer = this.getTaskContainerAndUpdateRange( task );
		taskContainer.tasks.push( task );
		this.taskMap.set( fn, task );

		//!steal-remove-start
		if(true) {
			this._logEnqueue( task );
		}
		//!steal-remove-end

		if ( isFirst ) {
			this.callbacks.onFirstTask( this );
		}
	}
};

// Given a task, updates the queue's cursors so that `flush`
// will be able to run the task.
PriorityQueue.prototype.getTaskContainerAndUpdateRange = function ( task ) {
	var priority = task.meta.priority || 0;

	if ( priority < this.curPriorityIndex ) {
		this.curPriorityIndex = priority;
	}

	if ( priority > this.curPriorityMax ) {
		this.curPriorityMax = priority;
	}

	var tcByPriority = this.taskContainersByPriority;
	var taskContainer = tcByPriority[priority];
	if ( !taskContainer ) {
		taskContainer = tcByPriority[priority] = {tasks: [], index: 0};
	}
	return taskContainer;
};

PriorityQueue.prototype.flush = function () {
	// Only allow one task to run at a time.
	if ( this.isFlushing ) {
		return;
	}
	this.isFlushing = true;
	while ( true ) {
		// If the first prioritized taskContainer with tasks remaining
		// is before the last prioritized taskContainer ...
		if ( this.curPriorityIndex <= this.curPriorityMax ) {
			var taskContainer = this.taskContainersByPriority[this.curPriorityIndex];

			// If that task container actually has tasks remaining ...
			if ( taskContainer && ( taskContainer.tasks.length > taskContainer.index ) ) {

				// Run the task.
				var task = taskContainer.tasks[taskContainer.index++];
				//!steal-remove-start
				if(true) {
					this._logFlush( task );
				}
				//!steal-remove-end
				this.tasksRemaining--;
				this.taskMap["delete"]( task.fn );
				task.fn.apply( task.context, task.args );

			} else {
				// Otherwise, move to the next taskContainer.
				this.curPriorityIndex++;
			}
		} else {
			// Otherwise, reset the state for the next `.flush()`.
			this.taskMap = new Map();
			this.curPriorityIndex = Infinity;
			this.curPriorityMax = 0;
			this.taskContainersByPriority = [];
			this.isFlushing = false;
			this.callbacks.onComplete( this );
			return;
		}
	}
};

PriorityQueue.prototype.isEnqueued = function ( fn ) {
	return this.taskMap.has( fn );
};

PriorityQueue.prototype.flushQueuedTask = function ( fn ) {
	var task = this.dequeue(fn);
	if(task) {
		//!steal-remove-start
		if(true) {
			this._logFlush( task );
		}
		//!steal-remove-end
		task.fn.apply( task.context, task.args );
	}
};
PriorityQueue.prototype.dequeue = function(fn){
	var task = this.taskMap.get( fn );
	if ( task ) {
		var priority = task.meta.priority || 0;
		var taskContainer = this.taskContainersByPriority[priority];
		var index = taskContainer.tasks.indexOf( task, taskContainer.index );

		if ( index >= 0 ) {
			taskContainer.tasks.splice( index, 1 );
			this.tasksRemaining--;
			this.taskMap["delete"]( task.fn );
			return task;
		} else {
			console.warn("Task", fn, "has already run");
		}
	}
};

PriorityQueue.prototype.tasksRemainingCount = function () {
	return this.tasksRemaining;
};

module.exports = PriorityQueue;


/***/ }),

/***/ "./node_modules/can-queues/queue-state.js":
/*!************************************************!*\
  !*** ./node_modules/can-queues/queue-state.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";

module.exports = {
	lastTask: null
};


/***/ }),

/***/ "./node_modules/can-queues/queue.js":
/*!******************************************!*\
  !*** ./node_modules/can-queues/queue.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var queueState = __webpack_require__(/*! ./queue-state */ "./node_modules/can-queues/queue-state.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

function noOperation () {}

var Queue = function ( name, callbacks ) {
	this.callbacks = assign( {
		onFirstTask: noOperation,
		// The default behavior is to clear the lastTask state.
		// This is overwritten by `can-queues.js`.
		onComplete: function () {
			queueState.lastTask = null;
		}
	}, callbacks || {});
	this.name = name;
	this.index = 0;
	this.tasks = [];
	this._log = false;
};

Queue.prototype.constructor = Queue;

Queue.noop = noOperation;

Queue.prototype.enqueue = function ( fn, context, args, meta ) {
	var len = this.tasks.push({
		fn: fn,
		context: context,
		args: args,
		meta: meta || {}
	});
	//!steal-remove-start
	if(true) {
		this._logEnqueue( this.tasks[len - 1] );
	}
	//!steal-remove-end

	if ( len === 1 ) {
		this.callbacks.onFirstTask( this );
	}
};

Queue.prototype.flush = function () {
	while ( this.index < this.tasks.length ) {
		var task = this.tasks[this.index++];
		//!steal-remove-start
		if(true) {
			this._logFlush( task );
		}

		//!steal-remove-end
		task.fn.apply( task.context, task.args );
	}
	this.index = 0;
	this.tasks = [];
	this.callbacks.onComplete( this );
};

Queue.prototype.log = function () {
	this._log = arguments.length ? arguments[0] : true;
};

//The following are removed in production.
//!steal-remove-start
if(true) {
	Queue.prototype._logEnqueue = function ( task ) {
		// For debugging, set the parentTask to the last
		// run task.
		task.meta.parentTask = queueState.lastTask;
		// Also let the task know which stack it was run within.
		task.meta.stack = this;

		if ( this._log === true || this._log === "enqueue" ) {
			var log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];
			canDev.log.apply( canDev, [this.name + " enqueuing:"].concat( log ));
		}
	};
	// `_logFlush` MUST be called by all queues prior to flushing in
	// development.
	Queue.prototype._logFlush = function ( task ) {
		if ( this._log === true || this._log === "flush" ) {
			var log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];
			canDev.log.apply( canDev, [this.name + " running  :"].concat( log ));
		}
		// Update the state to mark this as the task that was run last.
		queueState.lastTask = task;
	};
}
//!steal-remove-end

module.exports = Queue;


/***/ }),

/***/ "./node_modules/can-queues/sorted-index-by.js":
/*!****************************************************!*\
  !*** ./node_modules/can-queues/sorted-index-by.js ***!
  \****************************************************/
/***/ ((module) => {

module.exports = function(compare, array, value) {
	if (!array || !array.length) {
		return undefined;
	}
	// check the start and the end
	if (compare(value, array[0]) === -1) {
		return 0;
	} else if (compare(value, array[array.length - 1]) === 1) {
		return array.length;
	}
	var low = 0,
		high = array.length;

	// From lodash lodash 4.6.1 <https://lodash.com/>
	// Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	while (low < high) {
		var mid = (low + high) >>> 1,
			item = array[mid],
			computed = compare(value, item);
		if (computed === -1) {
			high = mid;
		} else {
			low = mid + 1;
		}
	}
	return high;
	// bisect by calling sortFunc
};


/***/ }),

/***/ "./node_modules/can-realtime-rest-model/can-realtime-rest-model.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-realtime-rest-model/can-realtime-rest-model.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! can-connect */ "./node_modules/can-connect/can-connect.js");

var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! can-connect/can/map/map */ "./node_modules/can-connect/can/map/map.js");
var constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
var dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! can-connect/data/url/url */ "./node_modules/can-connect/data/url/url.js");
var ObservableArray = __webpack_require__(/*! can-observable-array */ "./node_modules/can-observable-array/dist/can-observable-array.js");
var ObservableObject = __webpack_require__(/*! can-observable-object */ "./node_modules/can-observable-object/dist/can-observable-object.js");
var realTime = __webpack_require__(/*! can-connect/real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");
var callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

function realtimeRestModel(optionsOrUrl) {

	// If optionsOrUrl is a string, make options = {url: optionsOrUrl}
	var options = (typeof optionsOrUrl === "string") ? {url: optionsOrUrl} : optionsOrUrl;

	// If options.ObjectType or .ArrayType aren’t provided, define them
	if (typeof options.ObjectType === "undefined") {
		options.ObjectType = class DefaultObjectType extends ObservableObject {};
	}
	if (typeof options.ArrayType === "undefined") {
		options.ArrayType = class DefaultArrayType extends ObservableArray {
			static get items() {
				return type.convert(options.ObjectType);
			}
		};
	}

	var behaviors = [
		constructor,
		canMap,
		constructorStore,
		dataCallbacks,
		dataParse,
		dataUrl,
		realTime,
		callbacksOnce
	];

	return connect(behaviors,options);
}

module.exports = namespace.realtimeRestModel = realtimeRestModel;


/***/ }),

/***/ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/can-reflect-dependencies.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var addMutatedBy = __webpack_require__(/*! ./src/add-mutated-by */ "./node_modules/can-reflect-dependencies/src/add-mutated-by.js");
var deleteMutatedBy = __webpack_require__(/*! ./src/delete-mutated-by */ "./node_modules/can-reflect-dependencies/src/delete-mutated-by.js");
var getDependencyDataOf = __webpack_require__(/*! ./src/get-dependency-data-of */ "./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js");

// mutatedByMap :: WeakMap<obj, {
//	mutateDependenciesForKey:   Map<key, DependencyRecord>,
//	mutateDependenciesForValue: DependencyRecord
// }>
var mutatedByMap = new WeakMap();

module.exports = {
	// Track mutations between observable as dependencies
	// addMutatedBy(obs, obs2);
	// addMutatedBy(obs, key, obs2);
	// addMutatedBy(obs, { valueDependencies: Set, keyDependencies: Map })
	// addMutatedBy(obs, key, { valueDependencies: Set, keyDependencies: Map })
	addMutatedBy: addMutatedBy(mutatedByMap),

	// Call this method with the same arguments as `addMutatedBy`
	// to unregister the mutation dependency
	deleteMutatedBy: deleteMutatedBy(mutatedByMap),

	// Returns an object with the dependecies of the given argument
	//	{
	//		whatIChange: { mutate: DependencyRecord, derive: DependencyRecord },
	//		whatChangesMe: { mutate: DependencyRecord, derive: DependencyRecord }
	//	}
	getDependencyDataOf: getDependencyDataOf(mutatedByMap)
};


/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/add-mutated-by.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/add-mutated-by.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// DependencyRecord :: { keyDependencies: Map, valueDependencies: Set }
var makeDependencyRecord = function makeDependencyRecord() {
	return {
		keyDependencies: new Map(),
		valueDependencies: new Set()
	};
};

var makeRootRecord = function makeRootRecord() {
	return {
		// holds mutated key dependencies of a key-value like object, e.g:
		// if person.first is mutated by other observable, this map will have a
		// key `first` (the mutated property) mapped to a DependencyRecord
		mutateDependenciesForKey: new Map(),

		// holds mutated value dependencies of value-like objects
		mutateDependenciesForValue: makeDependencyRecord()
	};
};

module.exports = function(mutatedByMap) {
	return function addMutatedBy(mutated, key, mutator) {
		var gotKey = arguments.length === 3;

		// normalize arguments
		if (arguments.length === 2) {
			mutator = key;
			key = undefined;
		}

		// normalize mutator when shorthand is used
		if (!mutator.keyDependencies && !mutator.valueDependencies) {
			var s = new Set();
			s.add(mutator);
			mutator = { valueDependencies:s };
		}

		// retrieve root record from the state map or create a new one
		var root = mutatedByMap.get(mutated);
		if (!root) {
			root = makeRootRecord();
			mutatedByMap.set(mutated, root);
		}

		// create a [key] DependencyRecord if [key] was provided
		// and Record does not already exist
		if (gotKey && !root.mutateDependenciesForKey.get(key)) {
			root.mutateDependenciesForKey.set(key, makeDependencyRecord());
		}

		// retrieve DependencyRecord
		var dependencyRecord = gotKey ?
			root.mutateDependenciesForKey.get(key) :
			root.mutateDependenciesForValue;

		if (mutator.valueDependencies) {
			canReflect.addValues(
				dependencyRecord.valueDependencies,
				mutator.valueDependencies
			);
		}

		if (mutator.keyDependencies) {
			canReflect.each(mutator.keyDependencies, function(keysSet, obj) {
				var entry = dependencyRecord.keyDependencies.get(obj);

				if (!entry) {
					entry = new Set();
					dependencyRecord.keyDependencies.set(obj, entry);
				}

				canReflect.addValues(entry, keysSet);
			});
		}
	};
};


/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/delete-mutated-by.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/delete-mutated-by.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function(mutatedByMap) {
	return function deleteMutatedBy(mutated, key, mutator) {
		var gotKey = arguments.length === 3;
		var root = mutatedByMap.get(mutated);

		// normalize arguments
		if (arguments.length === 2) {
			mutator = key;
			key = undefined;
		}

		// normalize mutator when shorthand is used
		if (!mutator.keyDependencies && !mutator.valueDependencies) {
			var s = new Set();
			s.add(mutator);
			mutator = { valueDependencies: s };
		}

		var dependencyRecord = gotKey ?
			root.mutateDependenciesForKey.get(key) :
			root.mutateDependenciesForValue;

		if (mutator.valueDependencies) {
			canReflect.removeValues(
				dependencyRecord.valueDependencies,
				mutator.valueDependencies
			);
		}

		if (mutator.keyDependencies) {
			canReflect.each(mutator.keyDependencies, function(keysSet, obj) {
				var entry = dependencyRecord.keyDependencies.get(obj);

				if (entry) {
					canReflect.removeValues(entry, keysSet);
					if (!entry.size) {
						dependencyRecord.keyDependencies.delete(obj);
					}
				}
			});
		}
	};
};


/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var isFunction = __webpack_require__(/*! ./is-function */ "./node_modules/can-reflect-dependencies/src/is-function.js");
var canAssign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

var getWhatIChangeSymbol = canSymbol.for("can.getWhatIChange");
var getKeyDependenciesSymbol = canSymbol.for("can.getKeyDependencies");
var getValueDependenciesSymbol = canSymbol.for("can.getValueDependencies");

var getKeyDependencies = function getKeyDependencies(obj, key) {
	if (isFunction(obj[getKeyDependenciesSymbol])) {
		return canReflect.getKeyDependencies(obj, key);
	}
};

var getValueDependencies = function getValueDependencies(obj) {
	if (isFunction(obj[getValueDependenciesSymbol])) {
		return canReflect.getValueDependencies(obj);
	}
};

var getMutatedKeyDependencies =
	function getMutatedKeyDependencies(mutatedByMap, obj, key) {
		var root = mutatedByMap.get(obj);
		var dependencyRecord;

		if (root && root.mutateDependenciesForKey.has(key)) {
			dependencyRecord = root.mutateDependenciesForKey.get(key);
		}

		return dependencyRecord;
	};

var getMutatedValueDependencies =
	function getMutatedValueDependencies( mutatedByMap, obj) {
		var result;
		var root = mutatedByMap.get(obj);

		if (root) {
			var	dependencyRecord = root.mutateDependenciesForValue;

			if (dependencyRecord.keyDependencies.size) {
				result = result || {};
				result.keyDependencies = dependencyRecord.keyDependencies;
			}

			if (dependencyRecord.valueDependencies.size) {
				result = result || {};
				result.valueDependencies = dependencyRecord.valueDependencies;
			}
		}

		return result;
	};

var getWhatIChange = function getWhatIChange(obj, key) {
	if (isFunction(obj[getWhatIChangeSymbol])) {
		var gotKey = arguments.length === 2;

		return gotKey ?
			canReflect.getWhatIChange(obj, key) :
			canReflect.getWhatIChange(obj);
	}
};

var isEmptyRecord = function isEmptyRecord(record) {
	return (
		record == null ||
		!Object.keys(record).length ||
		(record.keyDependencies && !record.keyDependencies.size) &&
		(record.valueDependencies && !record.valueDependencies.size)
	);
};

var getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {
	var gotKey = arguments.length === 3;

	var mutate = gotKey ?
		getMutatedKeyDependencies(mutatedByMap, obj, key) :
		getMutatedValueDependencies(mutatedByMap, obj);

	var derive = gotKey ?
		getKeyDependencies(obj, key) :
		getValueDependencies(obj);

	if (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {
		return canAssign(
			canAssign(
				{},
				mutate ? { mutate: mutate } : null
			),
			derive ? { derive: derive } : null
		);
	}
};

module.exports = function(mutatedByMap) {
	return function getDependencyDataOf(obj, key) {
		var gotKey = arguments.length === 2;

		var whatChangesMe = gotKey ?
			getWhatChangesMe(mutatedByMap, obj, key) :
			getWhatChangesMe(mutatedByMap, obj);

		var whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);

		if (whatChangesMe || whatIChange) {
			return canAssign(
				canAssign(
					{},
					whatIChange ? { whatIChange: whatIChange } : null
				),
				whatChangesMe ? { whatChangesMe: whatChangesMe } : null
			);
		}
	};
};


/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/is-function.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/is-function.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function isFunction(value) {
	return typeof value === "function";
};


/***/ }),

/***/ "./node_modules/can-reflect-promise/can-reflect-promise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect-promise/can-reflect-promise.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");


var getKeyValueSymbol = canSymbol.for("can.getKeyValue"),
	observeDataSymbol = canSymbol.for("can.meta");

var promiseDataPrototype = {
	isPending: true,
	state: "pending",
	isResolved: false,
	isRejected: false,
	value: undefined,
	reason: undefined
};

function setVirtualProp(promise, property, value) {
	var observeData = promise[observeDataSymbol];
	var old = observeData[property];
	observeData[property] = value;
	queues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [value,old], function() {
		return {};
	},["Promise", promise, "resolved with value", value, "and changed virtual property: "+property]);
}

function initPromise(promise) {
	var observeData = promise[observeDataSymbol];
	if(!observeData) {
		Object.defineProperty(promise, observeDataSymbol, {
			enumerable: false,
			configurable: false,
			writable: false,
			value: Object.create(promiseDataPrototype)
		});
		observeData = promise[observeDataSymbol];
		observeData.handlers = new KeyTree([Object, Object, Array]);
	}
	promise.then(function(value){
		queues.batch.start();
		setVirtualProp(promise, "isPending", false);
		setVirtualProp(promise, "isResolved", true);
		setVirtualProp(promise, "value", value);
		setVirtualProp(promise, "state", "resolved");
		queues.batch.stop();
	}, function(reason){
		queues.batch.start();
		setVirtualProp(promise, "isPending", false);
		setVirtualProp(promise, "isRejected", true);
		setVirtualProp(promise, "reason", reason);
		setVirtualProp(promise, "state", "rejected");
		queues.batch.stop();

		//!steal-remove-start
		if (true) {
			dev.error("Failed promise:", reason);
		}
		//!steal-remove-end
	});
}

function setupPromise(value) {
	var oldPromiseFn;
	var proto = "getPrototypeOf" in Object ? Object.getPrototypeOf(value) : value.__proto__; //jshint ignore:line

	if(value[getKeyValueSymbol] && value[observeDataSymbol]) {
		// promise has already been set up.  Don't overwrite.
		return;
	}

	if(proto === null || proto === Object.prototype) {
		// promise type is a plain object or dictionary.  Set up object instead of proto.
		proto = value;

		if(typeof proto.promise === "function") {
			// Duck-type identification as a jQuery.Deferred;
			// In that case, the promise() function returns a new object
			//  that needs to be decorated.
			oldPromiseFn = proto.promise;
			proto.promise = function() {
				var result = oldPromiseFn.call(proto);
				setupPromise(result);
				return result;
			};
		}
	}

	canReflect.assignSymbols(proto, {
		"can.getKeyValue": function(key) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}

			ObservationRecorder.add(this, key);
			switch(key) {
				case "state":
				case "isPending":
				case "isResolved":
				case "isRejected":
				case "value":
				case "reason":
				return this[observeDataSymbol][key];
				default:
				return this[key];
			}
		},
		"can.getValue": function() {
			return this[getKeyValueSymbol]("value");
		},
		"can.isValueLike": false,
		"can.onKeyValue": function(key, handler, queue) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}
			this[observeDataSymbol].handlers.add([key, queue || "mutate", handler]);
		},
		"can.offKeyValue": function(key, handler, queue) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}
			this[observeDataSymbol].handlers.delete([key, queue || "mutate", handler]);
		},
		"can.hasOwnKey": function(key) {
			if (!this[observeDataSymbol]) {
				initPromise(this);
			}
			return (key in this[observeDataSymbol]);
		}
	});
}

module.exports = setupPromise;


/***/ }),

/***/ "./node_modules/can-reflect/can-reflect.js":
/*!*************************************************!*\
  !*** ./node_modules/can-reflect/can-reflect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var functionReflections = __webpack_require__(/*! ./reflections/call/call */ "./node_modules/can-reflect/reflections/call/call.js");
var getSet = __webpack_require__(/*! ./reflections/get-set/get-set */ "./node_modules/can-reflect/reflections/get-set/get-set.js");
var observe = __webpack_require__(/*! ./reflections/observe/observe */ "./node_modules/can-reflect/reflections/observe/observe.js");
var shape = __webpack_require__(/*! ./reflections/shape/shape */ "./node_modules/can-reflect/reflections/shape/shape.js");
var schema = __webpack_require__(/*! ./reflections/shape/schema/schema */ "./node_modules/can-reflect/reflections/shape/schema/schema.js");
var type = __webpack_require__(/*! ./reflections/type/type */ "./node_modules/can-reflect/reflections/type/type.js");
var getName = __webpack_require__(/*! ./reflections/get-name/get-name */ "./node_modules/can-reflect/reflections/get-name/get-name.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var reflect = {};
[
	functionReflections,
	getSet,
	observe,
	shape,
	type,
	getName,
	schema
].forEach(function(reflections){
	for(var prop in reflections) {
		reflect[prop] = reflections[prop];
		//!steal-remove-start
		if(true) {
			if(typeof reflections[prop] === "function") {
				var propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');
				if (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {
					Object.defineProperty(reflections[prop],"name",{
						value: "canReflect."+prop
					});
				}
			}
		}
		//!steal-remove-end
	}
});

__webpack_require__(/*! ./types/map */ "./node_modules/can-reflect/types/map.js");
__webpack_require__(/*! ./types/set */ "./node_modules/can-reflect/types/set.js");

module.exports = namespace.Reflect = reflect;


/***/ }),

/***/ "./node_modules/can-reflect/reflections/call/call.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/call/call.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var typeReflections = __webpack_require__(/*! ../type/type */ "./node_modules/can-reflect/reflections/type/type.js");

module.exports = {
	/**
	 * @function {function(...), Object, ...} can-reflect/call.call call
	 * @parent can-reflect/call
	 * @description  Call a callable, with a context object and parameters
	 *
	 * @signature `call(func, context, ...rest)`
	 *
	 * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters
	 * occurring after `context` set to the positional parameters.
	 *
	 * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],
	 * or have a callable `apply` property to work with `canReflect.call`
	 *
	 * ```js
	 * var compute = canCompute("foo");
	 *
	 * canReflect.call(compute, null, "bar");
	 * canReflect.call(compute, null); // -> "bar"
	 * ```
	 *
	 * @param  {function(...)} func the function to call with the supplied arguments
	 * @param  {Object} context the context object to set as `this` on the function call
	 * @param  {*} rest any arguments after `context` will be passed to the function call
	 * @return {*}  return types and values are determined by the call to `func`
	 */
	call: function(func, context){
		var args = [].slice.call(arguments, 2);
		var apply = func[canSymbol.for("can.apply")];
		if(apply) {
			return apply.call(func, context, args);
		} else {
			return func.apply(context, args);
		}
	},
	/**
	 * @function {function(...), Object, ...} can-reflect/call.apply apply
	 * @parent can-reflect/call
	 * @description  Call a callable, with a context object and a list of parameters
	 *
	 * @signature `apply(func, context, args)`
	 *
	 * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters
	 * contained in the Array-like `args`
	 *
	 * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],
	 * or have a callable `apply` property to work with `canReflect.apply`
	 *
	 * ```js
	 * var compute = canCompute("foo");
	 *
	 * canReflect.apply(compute, null, ["bar"]);
	 * canReflect.apply(compute, null, []); // -> "bar"
	 * ```
	 *
	 * @param  {function(...)} func the function to call
	 * @param  {Object} context the context object to set as `this` on the function call
	 * @param  {*} args arguments to be passed to the function call
	 * @return {*}  return types and values are determined by the call to `func`
	 */
	apply: function(func, context, args){
		var apply = func[canSymbol.for("can.apply")];
		if(apply) {
			return apply.call(func, context, args);
		} else {
			return func.apply(context, args);
		}
	},
	/**
	 * @function {function(...), ...} can-reflect/call.new new
	 * @parent can-reflect/call
	 * @description  Construct a new instance of a callable constructor
	 *
	 * @signature `new(func, ...rest)`
	 *
	 * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional
	 * parameters occurring after `func` set to the positional parameters.
	 *
	 * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],
	 * or have a callable `apply` property *and* a prototype to work with `canReflect.new`
	 *
	 * ```js
	 * canReflect.new(DefineList, ["foo"]); // -> ["foo"]<DefineList>
	 * ```
	 *
	 * @param  {function(...)} func a constructor
	 * @param  {*} rest arguments to be passed to the constructor
	 * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`
	 */
	"new": function(func){
		var args = [].slice.call(arguments, 1);
		var makeNew = func[canSymbol.for("can.new")];
		if(makeNew) {
			return makeNew.apply(func, args);
		} else {
			var context = Object.create(func.prototype);
			var ret = func.apply(context, args);
			if(typeReflections.isPrimitive(ret)) {
				return context;
			} else {
				return ret;
			}
		}
	}
};


/***/ }),

/***/ "./node_modules/can-reflect/reflections/get-name/get-name.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/get-name/get-name.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var typeReflections = __webpack_require__(/*! ../type/type */ "./node_modules/can-reflect/reflections/type/type.js");

var getNameSymbol = canSymbol.for("can.getName");

/**
 * @function {Object, String} can-reflect.setName setName
 * @parent can-reflect/shape
 * @description Set a human-readable name of an object.
 *
 * @signature `setName(obj, value)`
 *
 * ```js
 * var f = function() {};
 *
 * canReflect.setName(f, "myFunction")
 * f.name //-> "myFunction"
 * ```
 *
 * @param {Object} obj   the object to set on
 * @param {String} value the value to set for the object
 */
function setName(obj, nameGetter) {
	if (typeof nameGetter !== "function") {
		var value = nameGetter;
		nameGetter = function() {
			return value;
		};
	}

	Object.defineProperty(obj, getNameSymbol, {
		value: nameGetter
	});
}

/**
 * @function {Object} can-reflect.getName getName
 * @parent can-reflect/shape
 * @description Get the name of an object.
 *
 * @signature `getValue(obj)`
 *
 * @body
 *
 * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to
 * provide objects human readable names; the main goal of these names is to help
 * users get a glance of what the object does and what it is used for.
 *
 * There are no hard rules to define names but CanJS uses the following convention
 * for consistent names across its observable types:
 *
 * - The name starts with the observable constructor name
 * - The constructor name is decorated with the following characters based on its type:
 *		- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`
 *		- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`
 *		- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`
 * - Any property that makes the instance unique (like ids) are printed inside
 *    the chars mentioned before.
 *
 * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),
 * in a value-like observable (similar to [can-simple-observable]).
 *
 * ```js
 * var canReflect = require("can-reflect");
 *
 * function MySimpleObservable(value) {
 *		this.value = value;
 * }
 *
 * canReflect.assignSymbols(MySimpleObservable.prototype, {
 *		"can.getName": function() {
 *			//!steal-remove-start
 *			if (process.env.NODE_ENV !== 'production') {
 *				var value = JSON.stringify(this.value);
 *				return canReflect.getName(this.constructor) + "<" + value + ">";
 *			}
 *			//!steal-remove-end
 *		}
 * });
 * ```
 *
 * With that in place, `MySimpleObservable` can be used like this:
 *
 * ```js
 * var one = new MySimpleObservable(1);
 * canReflect.getName(one); // MySimpleObservable<1>
 * ```
 *
 * @param  {Object} obj The object to get from
 * @return {String} The human-readable name of the object
 */
var anonymousID = 0;
function getName(obj) {
	var type = typeof obj;
	if(obj === null || (type !== "object" && type !== "function")) {
		return ""+obj;
	}
	var nameGetter = obj[getNameSymbol];
	if (nameGetter) {
		return nameGetter.call(obj);
	}

	if (type === "function") {
		if (!("name" in obj)) {
			// IE doesn't support function.name natively
			obj.name = "functionIE" + anonymousID++;
		}
		return obj.name;
	}

	if (obj.constructor && obj !== obj.constructor) {
		var parent = getName(obj.constructor);
		if (parent) {
			if (typeReflections.isValueLike(obj)) {
				return parent + "<>";
			}

			if (typeReflections.isMoreListLikeThanMapLike(obj)) {
				return parent + "[]";
			}

			if (typeReflections.isMapLike(obj)) {
				return parent + "{}";
			}
		}
	}

	return undefined;
}

module.exports = {
	setName: setName,
	getName: getName
};


/***/ }),

/***/ "./node_modules/can-reflect/reflections/get-set/get-set.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/get-set/get-set.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var typeReflections = __webpack_require__(/*! ../type/type */ "./node_modules/can-reflect/reflections/type/type.js");

var setKeyValueSymbol = canSymbol.for("can.setKeyValue"),
	getKeyValueSymbol = canSymbol.for("can.getKeyValue"),
	getValueSymbol = canSymbol.for("can.getValue"),
	setValueSymbol = canSymbol.for("can.setValue");

var reflections = {
	/**
	 * @function {Object, String, *} can-reflect.setKeyValue setKeyValue
	 * @parent can-reflect/get-set
	 * @description Set the value of a named property on a MapLike object.
	 *
	 * @signature `setKeyValue(obj, key, value)`
	 *
	 * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.
	 * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],
	 * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.setKeyValue(foo, "bar", "quux");
	 * foo[bar]; // -> "quux"
	 * ```
	 * @param  {Object} obj   the object to set on
	 * @param  {String} key   the key for the property to set
	 * @param  {*} value      the value to set on the object
	 */
	setKeyValue: function(obj, key, value){
		if( typeReflections.isSymbolLike(key) ) {
			if(typeof key === "symbol") {
				obj[key] = value;
			} else {
				Object.defineProperty(obj, key, {
					enumerable: false,
					configurable: true,
					value: value,
					writable: true
				});
			}
			return;
		}
		var setKeyValue = obj[setKeyValueSymbol];
		if(setKeyValue !== undefined) {
			return setKeyValue.call(obj, key, value);
		} else {
			obj[key] = value;
		}
	},
	/**
	 * @function {Object, String} can-reflect.getKeyValue getKeyValue
	 * @parent can-reflect/get-set
	 * @description Get the value of a named property on a MapLike object.
	 *
	 * @signature `getKeyValue(obj, key)`
	 *
	 * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior
	 * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],
	 * otherwise native named property access is used.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.getKeyValue(foo, "bar"); // -> "baz"
	 * ```
	 *
	 * @param  {Object} obj   the object to get from
	 * @param  {String} key   the key of the property to get
	 */
	getKeyValue: function(obj, key) {
		var getKeyValue = obj[getKeyValueSymbol];
		if(getKeyValue) {
			return getKeyValue.call(obj, key);
		}
		return obj[key];
	},
	/**
	 * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue
	 * @parent can-reflect/get-set
	 * @description Delete a named property from a MapLike object.
	 *
	 * @signature `deleteKeyValue(obj, key)`
	 *
	 * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.
	 * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot
	 * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it
	 * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 * var quux = new CanMap({ thud: "jeek" });
	 *
	 * canReflect.deleteKeyValue(foo, "bar");
	 * canReflect.deleteKeyValue(quux, "thud");
	 *
	 * "bar" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined
	 * foo.bar // -> undefined    --  but set values to undefined when deleting
	 *
	 * "thud" in quux; // -> false
	 * quux.thud; // -> undefined
	 * ```
	 *
	 * @param  {Object} obj   the object to delete on
	 * @param  {String} key   the key for the property to delete
	 */
	deleteKeyValue: function(obj, key) {
		var deleteKeyValue = obj[canSymbol.for("can.deleteKeyValue")];
		if(deleteKeyValue) {
			return deleteKeyValue.call(obj, key);
		}
		delete obj[key];
	},
	/**
	 * @function {Object} can-reflect.getValue getValue
	 * @parent can-reflect/get-set
	 * @description Get the value of an object with a gettable value
	 *
	 * @signature `getValue(obj)`
	 *
	 * Return the value of the Value-like object `obj`.  Unless `obj` implements
	 * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on
	 * `obj` will always be `obj`.  Observable Map-like objects may want to implement
	 * `@@@@can.getValue` to return non-observable or plain representations of themselves.
	 *
	 * ```js
	 * var compute = canCompute("foo");
	 * var primitive = "bar";
	 *
	 * canReflect.getValue(compute); // -> "foo"
	 * canReflect.getValue(primitive); // -> "bar"
	 * ```
	 *
	 * @param  {Object} obj   the object to get from
	 * @return {*} the value of the object via `@@can.getValue`, or the value itself.
	 */
	getValue: function(value){
		if(typeReflections.isPrimitive(value)) {
			return value;
		}
		var getValue = value[getValueSymbol];
		if(getValue) {
			return getValue.call(value);
		}
		return value;
	},
	/**
	 * @function {Object, *} can-reflect.setValue setValue
	 * @parent can-reflect/get-set
	 * @description Set the value of a mutable object.
	 *
	 * @signature `setValue(obj, value)`
	 *
	 * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement
	 * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.
	 * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties
	 * into themselves.
	 *
	 * ```js
	 * var compute = canCompute("foo");
	 * var plain = {};
	 *
	 * canReflect.setValue(compute, "bar");
	 * compute(); // -> bar
	 *
	 * canReflect.setValue(plain, { quux: "thud" }); // throws "can-reflect.setValue - Can not set value."
	 * ```
	 *
	 * @param  {Object} obj   the object to set on
	 * @param  {*} value      the value to set for the object
	 */
	setValue: function(item, value){
		var setValue = item && item[setValueSymbol];
		if(setValue) {
			return setValue.call(item, value);
		} else {
			throw new Error("can-reflect.setValue - Can not set value.");
		}
	},

	splice: function(obj, index, removing, adding){
		var howMany;
		if(typeof removing !== "number") {
			var updateValues = obj[canSymbol.for("can.updateValues")];
			if(updateValues) {
				return updateValues.call(obj, index, removing, adding);
			}
			howMany = removing.length;
		} else {
			howMany = removing;
		}

		if(arguments.length <= 3){
			adding = [];
		}

		var splice = obj[canSymbol.for("can.splice")];
		if(splice) {
			return splice.call(obj, index, howMany, adding);
		}
		return [].splice.apply(obj, [index, howMany].concat(adding) );
	},
	addValues: function(obj, adding, index) {
		var add = obj[canSymbol.for("can.addValues")];
		if(add) {
			return add.call(obj, adding, index);
		}
		if(Array.isArray(obj) && index === undefined) {
			return obj.push.apply(obj, adding);
		}
		return reflections.splice(obj, index, [], adding);
	},
	removeValues: function(obj, removing, index) {
		var removeValues = obj[canSymbol.for("can.removeValues")];
		if(removeValues) {
			return removeValues.call(obj, removing, index);
		}
		if(Array.isArray(obj) && index === undefined) {
			removing.forEach(function(item){
				var index = obj.indexOf(item);
				if(index >=0) {
					obj.splice(index, 1);
				}
			});
			return;
		}
		return reflections.splice(obj, index, removing, []);
	}
};
/**
 * @function {Object, String} can-reflect.get get
 * @hide
 * @description an alias for [can-reflect.getKeyValue getKeyValue]
 */
reflections.get = reflections.getKeyValue;
/**
 * @function {Object, String} can-reflect.set set
 * @hide
 * @description an alias for [can-reflect.setKeyValue setKeyValue]
 */
reflections.set = reflections.setKeyValue;
/**
 * @function {Object, String} can-reflect.delete delete
 * @hide
 * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]
 */
reflections["delete"] = reflections.deleteKeyValue;

module.exports = reflections;


/***/ }),

/***/ "./node_modules/can-reflect/reflections/helpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/helpers.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

module.exports = {
	makeGetFirstSymbolValue: function(symbolNames){
		var symbols = symbolNames.map(function(name){
			return canSymbol.for(name);
		});
		var length = symbols.length;

		return function getFirstSymbol(obj){
			var index = -1;

			while (++index < length) {
				if(obj[symbols[index]] !== undefined) {
					return obj[symbols[index]];
				}
			}
		};
	},
	// The `in` check is from jQuery’s fix for an iOS 8 64-bit JIT object length bug:
	// https://github.com/jquery/jquery/pull/2185
	hasLength: function(list){
		var type = typeof list;
		if(type === "string" || Array.isArray(list)) {
			return true;
		}
		var length = list && (type !== 'boolean' && type !== 'number' && "length" in list) && list.length;

		// var length = "length" in obj && obj.length;
		return typeof list !== "function" &&
			( length === 0 || typeof length === "number" && length > 0 && ( length - 1 ) in list );
	}
};


/***/ }),

/***/ "./node_modules/can-reflect/reflections/observe/observe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/observe/observe.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var slice = [].slice;

function makeFallback(symbolName, fallbackName) {
	return function(obj, event, handler, queueName){
		var method = obj[canSymbol.for(symbolName)];
		if(method !== undefined) {
			return method.call(obj, event, handler, queueName);
		}
		return this[fallbackName].apply(this, arguments);
	};
}

function makeErrorIfMissing(symbolName, errorMessage){
	return function(obj){
		var method = obj[canSymbol.for(symbolName)];
		if(method !== undefined) {
			var args = slice.call(arguments, 1);
			return method.apply(obj, args);
		}
		throw new Error(errorMessage);
	};
}

module.exports = {
	// KEY
	/**
	 * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, based on a key change
	 *
	 * @signature `onKeyValue(obj, key, handler, [queueName])`
	 *
	 * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.
	 * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with
	 * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property
	 * as the first argument, and the previous value of the property as the second argument.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeyValue(obj, "foo", function(newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * });
	 *
	 * obj.foo = "baz";  // -> logs "foo is now baz , was bar"
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {String} key  the key to listen to
	 * @param {function(*, *)} handler a callback function that recieves the new value
	 * @param {String} [queueName]  the queue to dispatch events to
	 */
	onKeyValue: makeFallback("can.onKeyValue", "onEvent"),
	/**
	 * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue
	 * @parent can-reflect/observe
	 * @description  Unregister an event handler on a MapLike object, based on a key change
	 *
	 * @signature `offKeyValue(obj, key, handler, [queueName])`
	 *
	 * Unregister a handler from the Map-like object `obj` that had previously been registered with
	 * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called
	 * when the value of `key` on `obj` changes.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * var handler = function(newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onKeyValue(obj, "foo", handler);
	 * canReflect.offKeyValue(obj, "foo", handler);
	 *
	 * obj.foo = "baz";  // -> nothing is logged
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {String} key  the key to stop listening to
	 * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`
	 * @param {String} [queueName]  the queue that the handler was set to receive events from
	 */
	offKeyValue: makeFallback("can.offKeyValue","offEvent"),

	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on the key set changing
	 *
	 * @signature `onKeys(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.
	 * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with
	 * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see
	 * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeys(obj, function(diffs) {
	 * 	console.log(diffs);
	 * });
	 *
	 * obj.set("baz", "quux");  // -> logs '[{"property": "baz", "type": "add", "value": "quux"}]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the diffs in the key set
	 */
	// any key change (diff would normally happen)
	onKeys: makeErrorIfMissing("can.onKeys","can-reflect: can not observe an onKeys event"),
	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on new keys being added.
	 *
	 * @signature `onKeysAdded(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on
	 * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with
	 * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one
	 * argument.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeysAded(obj, function(newKeys) {
	 * 	console.log(newKeys);
	 * });
	 *
	 * foo.set("baz", "quux");  // -> logs '["baz"]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the array of added keys
	 */
	// keys added at a certain point {key: 1}, index
	onKeysAdded: makeErrorIfMissing("can.onKeysAdded","can-reflect: can not observe an onKeysAdded event"),
	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on keys being deleted.
	 *
	 * @signature `onKeysRemoved(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from
	 * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be
	 * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of
	 * Strings as its one argument.
	 *
	 * ```js
	 * var obj = new CanMap({ foo: "bar" });
	 * canReflect.onKeys(obj, function(diffs) {
	 * 	console.log(JSON.stringify(diffs));
	 * });
	 *
	 * foo.removeAttr("foo");  // -> logs '["foo"]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the array of removed keys
	 */
	onKeysRemoved: makeErrorIfMissing("can.onKeysRemoved","can-reflect: can not unobserve an onKeysRemoved event"),

	/**
	 * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies
	 * @parent can-reflect/observe
	 * @description  Return the observable objects that compute to the value of a named property on an object
	 *
	 * @signature `getKeyDependencies(obj, key)`
	 *
	 * Return the observable objects that provide input values to generate the computed value of the
	 * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.
	 * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that
	 * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a
	 * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.
	 *
	 * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with
	 * `canReflect.getKeyDependencies`.
	 *
	 *
	 * ```js
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = new (DefineMap.extend({
	 * 	 baz: {
	 * 	   get: function() {
	 * 	     return foo.bar;
	 * 	   }
	 * 	 }
	 * }))();
	 *
	 * canReflect.getKeyDependencies(obj, "baz");  // -> { valueDependencies: CIDSet }
	 * ```
	 *
	 * @param {Object} obj the object to check for key dependencies
	 * @param {String} key the key on the object to check
	 * @return {Object} the observable values that this keyed value depends on
	 */
	getKeyDependencies: makeErrorIfMissing("can.getKeyDependencies", "can-reflect: can not determine dependencies"),

	/**
	 * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange
	 * @hide
	 * @parent can-reflect/observe
	 * @description Return the observable objects that derive their value from the
	 * obj, passed in.
	 *
	 * @signature `getWhatIChange(obj, key)`
	 *
	 * `obj` *must* implement `@@@@can.getWhatIChange` to work with
	 * `canReflect.getWhatIChange`.
	 *
	 * @param {Object} obj the object to check for what it changes
	 * @param {String} [key] the key on the object to check
	 * @return {Object} the observable values that derive their value from `obj`
	 */
	getWhatIChange: makeErrorIfMissing(
		"can.getWhatIChange",
		"can-reflect: can not determine dependencies"
	),

	/**
	 * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord
	 * @hide
	 * @parent can-reflect/observe
	 * @description Return the observable objects that are mutated by the handler
	 * passed in as argument.
	 *
	 * @signature `getChangesDependencyRecord(handler)`
	 *
	 * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with
	 * `canReflect.getChangesDependencyRecord`.
	 *
	 * ```js
	 * var one = new SimpleObservable("one");
	 * var two = new SimpleObservable("two");
	 *
	 * var handler = function() {
	 *	two.set("2");
	 * };
	 *
	 * canReflect.onValue(one, handler);
	 * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }
	 * ```
	 *
	 * @param {Function} handler the event handler to check for what it changes
	 * @return {Object} the observable values that are mutated by the handler
	 */
	getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
		var fn = handler[canSymbol.for("can.getChangesDependencyRecord")];

		if (typeof fn === "function") {
			return fn();
		}
	},

	/**
	 * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies
	 * @parent can-reflect/observe
	 * @description  Determine whether the value for a named property on an object is bound to other events
	 *
	 * @signature `keyHasDependencies(obj, key)`
	 *
	 * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.
	 * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not
	 * a computed value on `obj`, returns `undefined`.
	 *
	 * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with
	 * `canReflect.keyHasDependencies`.
	 *
	 * ```js
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = new (DefineMap.extend({
	 * 	 baz: {
	 * 	   get: function() {
	 * 	     return foo.bar;
	 * 	   }
	 * 	 },
	 * 	 quux: {
	 * 	 	 get: function() {
	 * 	 	   return "thud";
	 * 	 	 }
	 * 	 }
	 * }))();
	 *
	 * canReflect.keyHasDependencies(obj, "baz");  // -> true
	 * canReflect.keyHasDependencies(obj, "quux");  // -> false
	 * canReflect.keyHasDependencies(foo, "bar");  // -> undefined
	 * ```
	 *
	 * @param {Object} obj the object to check for key dependencies
	 * @param {String} key the key on the object to check
	 * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise
	 *
	 */
	// TODO: use getKeyDeps once we know what that needs to look like
	keyHasDependencies: makeErrorIfMissing("can.keyHasDependencies","can-reflect: can not determine if this has key dependencies"),

	// VALUE
	/**
	 * @function {Object, function(*)} can-reflect/observe.onValue onValue
	 * @parent can-reflect/observe
	 * @description  Register an event handler on an observable ValueLike object, based on a change in its value
	 *
	 * @signature `onValue(handler, [queueName])`
	 *
	 * Register an event handler on the Value-like object `obj` to trigger when its value changes.
	 * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with
	 * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`
	 * as the first argument, and the previous value of `obj` as the second argument.
	 *
	 * ```js
	 * var obj = canCompute("foo");
	 * canReflect.onValue(obj, function(newVal, oldVal) {
	 * 	console.log("compute is now", newVal, ", was", oldVal);
	 * });
	 *
	 * obj("bar");  // -> logs "compute is now bar , was foo"
	 * ```
	 *
	 * @param {*} obj  any object implementing @@can.onValue
	 * @param {function(*, *)} handler  a callback function that receives the new and old values
	 */
	onValue: makeErrorIfMissing("can.onValue","can-reflect: can not observe value change"),
	/**
	 * @function {Object, function(*)} can-reflect/observe.offValue offValue
	 * @parent can-reflect/observe
	 * @description  Unregister an value change handler from an observable ValueLike object
	 *
	 * @signature `offValue(handler, [queueName])`
	 *
	 * Unregister an event handler from the Value-like object `obj` that had previously been registered with
	 * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called
	 * when the value of `obj` changes.
	 *
	 * ```js
	 * var obj = canCompute( "foo" );
	 * var handler = function(newVal, oldVal) {
	 * 	console.log("compute is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onKeyValue(obj, handler);
	 * canReflect.offKeyValue(obj, handler);
	 *
	 * obj("baz");  // -> nothing is logged
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 */
	offValue: makeErrorIfMissing("can.offValue","can-reflect: can not unobserve value change"),

	/**
	 * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies
	 * @parent can-reflect/observe
	 * @description  Return all the events that bind to the value of an observable, Value-like object
	 *
	 * @signature `getValueDependencies(obj)`
	 *
	 * Return the observable objects that provide input values to generate the computed value of the
	 * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.
	 * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that
	 * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a
	 * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.
	 *
	 * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with
	 * `canReflect.getValueDependencies`.
	 *
	 *
	 * ```js
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = canCompute(function() {
	 * 	 return foo.bar;
	 * });
	 *
	 * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by
	 * a [can-observation]
	 * ```
	 *
	 * @param {Object} obj the object to check for value dependencies
	 * @return {Object} the observable objects that `obj`'s value depends on
	 *
	 */
	getValueDependencies: makeErrorIfMissing("can.getValueDependencies","can-reflect: can not determine dependencies"),

	/**
	 * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies
	 * @parent can-reflect/observe
	 * @description  Determine whether the value of an observable object is bound to other events
	 *
	 * @signature `valueHasDependencies(obj)`
	 *
	 * Returns `true` if the computed value of the Value-like object `obj` derives from other values.
	 * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not
	 * a computed value, returns `undefined`.
	 *
	 * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with
	 * `canReflect.valueHasDependencies`.
	 *
	 * ```js
	 * var foo = canCompute( "bar" );
	 * var baz = canCompute(function() {
	 * 	 return foo();
	 * });
	 * var quux = "thud";
	 * var jeek = canCompute(function(plonk) {
	 * 	 if(argument.length) {
	 * 	 	  quux = plonk;
	 * 	 }
	 * 	 return quux;
	 * });
	 *
	 * canReflect.valueHasDependencies(baz);  // -> true
	 * canReflect.valueHasDependencies(jeek);  // -> false
	 * canReflect.valueHasDependencies(foo);  // -> undefined
	 * ```
	 *
	 * @param {Object} obj the object to check for dependencies
	 * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise
	 *
	 */
	valueHasDependencies: makeErrorIfMissing("can.valueHasDependencies","can-reflect: can not determine if value has dependencies"),

	// PATCHES
	/**
	 * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches
	 * @parent can-reflect/observe
	 * @description  Register an handler on an observable that listens to any key changes
	 *
	 * @signature `onPatches(obj, handler, [queueName])`
	 *
	 * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,
	 * an existing key has is value changed, or a key is deleted from the object.
	 *
	 * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific
	 * patches in addition to object-style patches
	 *
	 * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].
	 *
	 * ```js
	 * var obj = new DefineMap({});
	 * var handler = function(patches) {
	 * 	console.log(patches);
	 * };
	 *
	 * canReflect.onPatches(obj, handler);
	 * obj.set("foo", "bar");  // logs [{ type: "add", property: "foo", value: "bar" }]
	 * obj.set("foo", "baz");  // logs [{ type: "set", property: "foo", value: "baz" }]
	 *
	 * var arr = new DefineList([]);
	 * canReflect.onPatches(arr, handler);
	 * arr.push("foo");  // logs [{type: "add", property:"0", value: "foo"},
	 *                            {index: 0, deleteCount: 0, insert: ["foo"]}]
   * arr.pop();  // logs [{type: "remove", property:"0"},
	 *                            {index: 0, deleteCount: 1, insert: []}]
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue
	 */
	onPatches: makeErrorIfMissing("can.onPatches", "can-reflect: can not observe patches on object"),
	/**
	 * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches
	 * @parent can-reflect/observe
	 * @description  Unregister an object patches handler from an observable object
	 *
	 * @signature `offPatches(obj, handler, [queueName])`
	 *
	 * Unregister an event handler from the object `obj` that had previously been registered with
	 * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called
	 * when `obj` has key or index changes.
	 *
	 * ```js
	 * var obj = new DefineMap({});
	 * var handler = function(patches) {
	 * 	console.log(patches);
	 * };
	 *
	 * canReflect.onPatches(obj, handler);
	 * canReflect.offPatches(obj, handler);
	 *
	 * obj.set("foo", "bar");  // nothing is logged
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under
	 */
	offPatches: makeErrorIfMissing("can.offPatches", "can-reflect: can not unobserve patches on object"),

	/**
	 * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches
	 * @parent can-reflect/observe
	 *
	 * @description Registers a handler that listens to patch events on any instance
	 *
	 * @signature `onInstancePatches(Type, handler(instance, patches))`
	 *
	 * Listens to patch changes on any instance of `Type`. This is used by [can-connect]
	 * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,
	 * the instance can be moved into the store while it is being saved. E.g:
	 *
	 * ```js
	 * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {
	 *	patches.forEach(function(patch) {
	 *		if (
	 *			(patch.type === "add" || patch.type === "set") &&
	 *			patch.key === connection.idProp &&
	 *			canReflect.isBound(instance)
	 *		) {
	 *			connection.addInstanceReference(instance);
	 *		}
	 *	});
	 *});
	 * ```
	 *
	 * @param {*} Type
	 * @param {function(*)} handler
	 */
	onInstancePatches: makeErrorIfMissing(
		"can.onInstancePatches",
		"can-reflect: can not observe onInstancePatches on Type"
	),

	/**
	 * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches
	 * @parent can-reflect/observe
	 *
	 * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]
	 *
	 * @signature `offInstancePatches(Type, handler(instance, patches))`
	 *
	 * ```js
	 * canReflect.offInstancePatches(Map, onInstancePatches);
	 * ```
	 *
	 * @param {*} Type
	 * @param {function(*)} handler
	 */
	offInstancePatches: makeErrorIfMissing(
		"can.offInstancePatches",
		"can-reflect: can not unobserve onInstancePatches on Type"
	),

	// HAS BINDINGS VS DOES NOT HAVE BINDINGS
	/**
	 * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange
	 * @parent can-reflect/observe
	 * @description Listen to when observables of a type are bound and unbound.
	 *
	 * @signature `onInstanceBoundChange(Type, handler, [queueName])`
	 *
	 * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)
	 * or unbound (the last remaining handler is removed). The function passed as `handler` will be called
	 * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,
	 * and called with `false` when `instance` loses its
	 * last binding.
	 *
	 * ```js
	 * Person = DefineMap.extend({ ... });
	 *
	 * var person = Person({});
	 * var handler = function(instance, newVal) {
	 * 	console.log(instance, "bound state is now", newVal);
	 * };
	 * var keyHandler = function() {};
	 *
	 * canReflect.onInstanceBoundChange(Person, handler);
	 * canReflect.onKeyValue(obj, "name", keyHandler);  // logs person Bound state is now true
	 * canReflect.offKeyValue(obj, "name", keyHandler);  // logs person Bound state is now false
	 * ```
	 *
	 * @param {function} Type A constructor function
	 * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.
	 * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue
	 */
	onInstanceBoundChange: makeErrorIfMissing("can.onInstanceBoundChange", "can-reflect: can not observe bound state change in instances."),
	/**
	 * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange
	 * @parent can-reflect/observe
	 * @description Stop listening to when observables of a type are bound and unbound.
	 *
	 * @signature `offInstanceBoundChange(Type, handler, [queueName])`
	 *
	 * Unregister an event handler from the type `Type` that had previously been registered with
	 * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called
	 * when instances of `Type` gains its first or loses its last binding.
	 *
	 * ```js
	 * Person = DefineMap.extend({ ... });
	 *
	 * var person = Person({});
	 * var handler = function(instance, newVal) {
	 * 	console.log(instance, "bound state is now", newVal);
	 * };
	 * var keyHandler = function() {};
	 *
	 * canReflect.onInstanceBoundChange(Person, handler);
	 * canReflect.offInstanceBoundChange(Person, handler);
	 * canReflect.onKeyValue(obj, "name", keyHandler);  // nothing is logged
	 * canReflect.offKeyValue(obj, "name", keyHandler); // nothing is logged
	 * ```
	 *
	 * @param {function} Type A constructor function
	 * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.
	 * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under
	 */
	offInstanceBoundChange: makeErrorIfMissing("can.offInstanceBoundChange", "can-reflect: can not unobserve bound state change"),
	/**
	 * @function {Object} can-reflect/observe.isBound isBound
	 * @parent can-reflect/observe
	 * @description  Determine whether any listeners are bound to the observable object
	 *
	 * @signature `isBound(obj)`
	 *
	 * `isBound` queries an observable object to find out whether any listeners have been set on it using
	 * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]
	 *
	 * ```js
	 * var obj = new DefineMap({});
	 * var handler = function() {};
	 * canReflect.isBound(obj); // -> false
	 * canReflect.onKeyValue(obj, "foo", handler);
	 * canReflect.isBound(obj); // -> true
	 * canReflect.offKeyValue(obj, "foo", handler);
	 * canReflect.isBound(obj); // -> false
	 * ```
	 *
	 * @param {*} obj
	 * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise
	 */
	isBound: makeErrorIfMissing("can.isBound", "can-reflect: cannot determine if object is bound"),

	// EVENT
	/**
	 * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent
	 * @parent can-reflect/observe
	 * @description  Register a named event handler on an observable object
	 *
	 * @signature `onEvent(obj, eventName, callback)`
	 *
	 *
	 * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.
	 * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible
	 * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first
	 * argument, and any data passed to the event dispatch as subsequent arguments.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onEvent(obj, "foo", function(ev, newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * });
	 *
	 * canEvent.dispatch.call(obj, "foo", ["baz", "quux"]);  // -> logs "foo is now baz , was quux"
	 * ```
	 *
	 * @param {Object} obj the object to bind a new event handler to
	 * @param {String} eventName the name of the event to bind the handler to
	 * @param {function(*)} callback  the handler function to bind to the event
	 */
	onEvent: function(obj, eventName, callback, queue){
		if(obj) {
			var onEvent = obj[canSymbol.for("can.onEvent")];
			if(onEvent !== undefined) {
				return onEvent.call(obj, eventName, callback, queue);
			} else if(obj.addEventListener) {
				obj.addEventListener(eventName, callback, queue);
			}
		}
	},
	/**
	 * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent
	 * @parent can-reflect/observe
	 * @description  Unregister an event handler on a MapLike object, based on a key change
	 *
	 * @signature `offEvent(obj, eventName, callback)`
	 *
	 * Unregister an event handler from the object `obj` that had previously been registered with
	 * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called
	 * when the event named `eventName` is dispatched on `obj`.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * var handler = function(ev, newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onEvent(obj, "foo", handler);
	 * canReflect.offEvent(obj, "foo", handler);
	 *
	 * canEvent.dispatch.call(obj, "foo", ["baz", "quux"]);  // -> nothing is logged
	 * ```
	 *
	 * @param {Object} obj the object to unbind an event handler from
	 * @param {String} eventName the name of the event to unbind the handler from
	 * @param {function(*)} callback the handler function to unbind from the event
	 */
	offEvent: function(obj, eventName, callback, queue){
		if(obj) {
			var offEvent = obj[canSymbol.for("can.offEvent")];
			if(offEvent !== undefined) {
				return offEvent.call(obj, eventName, callback, queue);
			}  else if(obj.removeEventListener) {
				obj.removeEventListener(eventName, callback, queue);
			}
		}

	},
	/**
	 * @function {function} can-reflect/setPriority setPriority
	 * @parent can-reflect/observe
	 * @description  Provide a priority for when an observable that derives its
	 * value should be re-evaluated.
	 *
	 * @signature `setPriority(obj, priority)`
	 *
	 * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.
	 * Returns `true` if a priority was set, `false` if otherwise.
	 *
	 * Lower priorities (`0` being the lowest), will be an indication to run earlier than
	 * higher priorities.
	 *
	 * ```js
	 * var obj = canReflect.assignSymbols({},{
	 *   "can.setPriority": function(priority){
	 *     return this.priority = priority;
	 *   }
	 * });
	 *
	 * canReflect.setPriority(obj, 0) //-> true
	 * obj.priority //-> 0
	 *
	 * canReflect.setPriority({},20) //-> false
	 * ```
	 *
	 * @param {Object} obj An observable that will update its priority.
	 * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),
	 * indicate to run earlier than higher priorities.
	 * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * There's often a need to specify the order of re-evaluation for
	 * __observables__ that derive (or compute) their value from other observables.
	 *
	 * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:
	 *
	 * ```js
	 * {{#if value}}
	 *   {{value}}
	 * {{/if}}
	 * ```
	 *
	 * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before
	 * the `{{value}}` magic tags updated. We can do that by setting priorities:
	 *
	 * ```js
	 * canReflect.setPriority(magicIfObservable, 0);
	 * canReflect.setPriority(magicValueObservable,1);
	 * ```
	 *
	 * Internally, those observables will use that `priority` to register their
	 * re-evaluation with the `derive` queue in [can-queues].
	 *
	 */
	setPriority: function(obj, priority) {
		if(obj) {
			var setPriority =  obj[canSymbol.for("can.setPriority")];
			if(setPriority !== undefined) {
				setPriority.call(obj, priority);
			 	return true;
			}
		}
		return false;
	},
	/**
	 * @function {function} can-reflect/getPriority getPriority
	 * @parent can-reflect/observe
	 * @description  Read the priority for an observable that derives its
	 * value.
	 *
	 * @signature `getPriority(obj)`
	 *
	 * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists
	 * and returns its value. Read [can-reflect/setPriority] for more information.
	 *
	 *
	 *
	 * @param {Object} obj An observable.
	 * @return {Undefined|Number} Returns the priority number if
	 * available, undefined if this object does not support the `can.getPriority`
	 * symbol.
	 *
	 * @body
	 *
	 */
	getPriority: function(obj) {
		if(obj) {
			var getPriority =  obj[canSymbol.for("can.getPriority")];
			if(getPriority !== undefined) {
				return getPriority.call(obj);
			}
		}
		return undefined;
	}
};


/***/ }),

/***/ "./node_modules/can-reflect/reflections/shape/schema/schema.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/shape/schema/schema.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var typeReflections = __webpack_require__(/*! ../../type/type */ "./node_modules/can-reflect/reflections/type/type.js");
var getSetReflections = __webpack_require__(/*! ../../get-set/get-set */ "./node_modules/can-reflect/reflections/get-set/get-set.js");
var shapeReflections = __webpack_require__(/*! ../shape */ "./node_modules/can-reflect/reflections/shape/shape.js");

var getSchemaSymbol = canSymbol.for("can.getSchema"),
    isMemberSymbol = canSymbol.for("can.isMember"),
    newSymbol = canSymbol.for("can.new");

function comparator(a, b) {
    return a.localeCompare(b);
}

function sort(obj) {
    if(typeReflections.isPrimitive(obj) || obj instanceof Date) {
        return obj;
    }
    var out;
    if (typeReflections.isListLike(obj)) {
        out = [];
        shapeReflections.eachKey(obj, function(item){
            out.push(sort(item));
        });
        return out;
    }
    if( typeReflections.isMapLike(obj) ) {

        out = {};

        shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {
            out[key] = sort( getSetReflections.getKeyValue(obj, key) );
        });

        return out;
    }


    return obj;
}

function isPrimitiveConverter(Type){
    return Type === Number || Type === String || Type === Boolean;
}

var schemaReflections =  {
    /**
	 * @function can-reflect.getSchema getSchema
	 * @parent can-reflect/shape
	 * @description Returns the schema for a type or value.
	 *
	 * @signature `getSchema(valueOrType)`
	 *
     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and
     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`
     * and returns the result.
     *
     * ```js
     * import canReflect from "can-reflect";
     *
     * var Type = DefineMap.extend({
     *   name: "string",
     *   id: "number"
     * });
     *
     * canReflect.getSchema( Type ) //-> {
     * //   type: "map",
     * //   keys: {
     * //     name: MaybeString
     * //     id: MaybeNumber
     * //   }
     * // }
     * ```
	 *
	 *
	 * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.
	 * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:
     *
     *
     * ```js
     * {
     *   type: "map",
     *   identity: ["id"],
     *   keys: {
     *     id: Number,
     *     name: String,
     *     complete: Boolean,
     *     owner: User
     *   }
     * }
     * ```
     *
     * A schema for a list looks like:
     *
     * ```js
     * {
     *   type: "list",
     *   values: String
     *   keys: {
     *     count: Number
     *   }
     * }
     * ```
     *
	 */
    getSchema: function(type){
        if (type === undefined) {
            return undefined;
        }
        var getSchema = type[getSchemaSymbol];
        if(getSchema === undefined ) {
            type = type.constructor;
            getSchema = type && type[getSchemaSymbol];
        }
        return getSchema !== undefined ? getSchema.call(type) : undefined;
    },
    /**
	 * @function can-reflect.getIdentity getIdentity
	 * @parent can-reflect/shape
	 * @description Get a unique primitive representing an object.
	 *
	 * @signature `getIdentity( object [,schema] )`
	 *
	 * This uses the object's schema, or the provided schema to return a unique string or number that
     * represents the object.
     *
     * ```js
     * import canReflect from "can-reflect";
     *
     * canReflect.getIdentity({id: 5}, {identity: ["id"]}) //-> 5
     * ```
     *
     * If the schema has multiple identity keys, the identity keys and values
     * are return stringified (and sorted):
     *
     * ```js
     * canReflect.getIdentity(
     *   {z: "Z", a: "A", foo: "bar"},
     *   {identity: ["a","b"]}) //-> '{"a":"A","b":"B"}'
     * ```
	 *
	 * @param  {Object|Function} object A map-like object.
     * @param {Object} [schema] A schema object with an `identity` array of the unique
     * keys of the object like:
     *   ```js
     *   {identity: ["id"]}
     *   ```
	 * @return {Number|String} A value that uniquely represents the object.
	 */
    getIdentity: function(value, schema){
        schema = schema || schemaReflections.getSchema(value);
        if(schema === undefined) {
            throw new Error("can-reflect.getIdentity - Unable to find a schema for the given value.");
        }

        var identity = schema.identity;
        if(!identity || identity.length === 0) {
            throw new Error("can-reflect.getIdentity - Provided schema lacks an identity property.");
        } else if(identity.length === 1) {
            return getSetReflections.getKeyValue(value, identity[0]);
        } else {
            var id = {};
            identity.forEach(function(key){
                id[key] = getSetReflections.getKeyValue(value, key);
            });
            return JSON.stringify(schemaReflections.cloneKeySort(id));
        }
    },
    /**
	 * @function can-reflect.cloneKeySort cloneKeySort
	 * @parent can-reflect/shape
	 * @description Copy a value while sorting its keys.
	 *
	 * @signature `cloneKeySort(value)`
	 *
     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]
     * key values sorted. If you just want a copy of a value,
     * use [can-reflect.serialize].
     *
     * ```js
     * import canRefect from "can-reflect";
     *
     * canReflect.cloneKeySort({z: "Z", a: "A"}) //-> {a:"A",z:"Z"}
     * ```
     *
     * Nested objects are also sorted.
	 *
     * This is useful if you need to store a representation of an object that can be used as a
     * key.
	 *
	 * @param  {Object} value An object or array.
	 * @return {Object} A copy of the object with its keys sorted.
	 */
    cloneKeySort: function(obj) {
        return sort(obj);
    },
    /**
	 * @function can-reflect.convert convert
	 * @parent can-reflect/shape
	 * @description Convert one value to another type.
	 *
	 * @signature `convert(value, Type)`
	 *
     * `convert` attempts to convert `value` to the type specified by `Type`.
     *
     * ```js
     * import canRefect from "can-reflect";
     *
     * canReflect.convert("1", Number) //-> 1
     * ```
     *
     * `convert` works by performing the following logic:
     *
     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the
     *    `value` will be passed to the `Type` function and the result returned.
     *    ```js
     *    return Type(value);
     *    ```
     * 2. The value will be checked if it is already an instance of the type
     *    by performing the following:
     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used
     *       to determine if the `value` is already an instance.
     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`
     *       will be used to check if `value` is already an instance.
     * 3. If `value` is already an instance, `value` will be returned.
     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result
     *    returned.
     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be
     *    called the the result returned.
     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.
     * 7. If a value hasn't been returned, an error is thrown.
	 *
	 * @param  {Object|Primitive} value A value to be converted.
     * @param  {Object|Function} Type A constructor function or an object that implements the
     * necessary symbols.
	 * @return {Object} The `value` converted to a member of `Type`.
	 */
    convert: function(value, Type){
        if(isPrimitiveConverter(Type)) {
            return Type(value);
        }
        // check if value is already a member
        var isMemberTest = Type[isMemberSymbol],
            isMember = false,
            type = typeof Type,
            createNew = Type[newSymbol];
        if(isMemberTest !== undefined) {
            isMember = isMemberTest.call(Type, value);
        } else if(type === "function") {
            if(typeReflections.isConstructorLike(Type)) {
                isMember = (value instanceof Type);
            }
        }
        if(isMember) {
            return value;
        }
        if(createNew !== undefined) {
            return createNew.call(Type, value);
        } else if(type === "function") {
            if(typeReflections.isConstructorLike(Type)) {
                return new Type(value);
            } else {
                // call it like a normal function
                return Type(value);
            }
        } else {
            throw new Error("can-reflect: Can not convert values into type. Type must provide `can.new` symbol.");
        }
    }
};
module.exports = schemaReflections;


/***/ }),

/***/ "./node_modules/can-reflect/reflections/shape/shape.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/shape/shape.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var getSetReflections = __webpack_require__(/*! ../get-set/get-set */ "./node_modules/can-reflect/reflections/get-set/get-set.js");
var typeReflections = __webpack_require__(/*! ../type/type */ "./node_modules/can-reflect/reflections/type/type.js");
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-reflect/reflections/helpers.js");


// IE-remove-start
var getPrototypeOfWorksWithPrimitives = true;
try {
	Object.getPrototypeOf(1);
} catch(e) {
	getPrototypeOfWorksWithPrimitives = false;
}
// IE-remove-end

var ArrayMap;
if(typeof Map === "function") {
	ArrayMap = Map;
} else {
	// IE-remove-start
	var isEven = function isEven(num) {
		return num % 2 === 0;
	};

	// A simple map that stores items in an array.
	// like [key, value]
	// You can find the value by searching for the key and then +1.
	ArrayMap = function(){
		this.contents = [];
	};

	ArrayMap.prototype = {
		/**
		 * Get an index of a key. Because we store boths keys and values in
		 * a flat array, we ensure we are getting a key by checking that it is an
		 * even number index (all keys are even number indexed).
		 **/
		_getIndex: function(key) {
			var idx;
			do {
				idx = this.contents.indexOf(key, idx);
			} while(idx !== -1 && !isEven(idx));
			return idx;
		},
		has: function(key){
			return this._getIndex(key) !== -1;
		},
		get: function(key){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				return this.contents[idx + 1];
			}
		},
		set: function(key, value){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				// Key already exists, replace the value.
				this.contents[idx + 1] = value;
			} else {
				this.contents.push(key);
				this.contents.push(value);
			}
		},
		"delete": function(key){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				// Key already exists, replace the value.
				this.contents.splice(idx, 2);
			}
		}
	};
	// IE-remove-end
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var shapeReflections;

var shiftFirstArgumentToThis = function(func){
	return function(){
		var args = [this];
		args.push.apply(args, arguments);
		return func.apply(null,args);
	};
};

var getKeyValueSymbol = canSymbol.for("can.getKeyValue");
var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
var setKeyValueSymbol = canSymbol.for("can.setKeyValue");
var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);

var sizeSymbol = canSymbol.for("can.size");

var hasUpdateSymbol = helpers.makeGetFirstSymbolValue(["can.updateDeep","can.assignDeep","can.setKeyValue"]);
var shouldUpdateOrAssign = function(obj){
	return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
};

// is the value itself its serialized value
function isSerializedHelper(obj){
	if (typeReflections.isPrimitive(obj)) {
		return true;
	}
	if(hasUpdateSymbol(obj)) {
		return false;
	}
	return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj) && !typeReflections.isObservableLike(obj);
}

// IE11 doesn't support primitives
var Object_Keys;
try{
	Object.keys(1);
	Object_Keys = Object.keys;
} catch(e) {
	Object_Keys = function(obj){
		if(typeReflections.isPrimitive(obj)) {
			return [];
		} else {
			return Object.keys(obj);
		}
	};
}

function createSerializeMap(Type) {
	var MapType = Type || ArrayMap;
	return {
		unwrap: new MapType(),
		serialize: new MapType() ,
		isSerializing: {
			unwrap: new MapType(),
			serialize: new MapType()
		},
		circularReferenceIsSerializing: {
			unwrap: new MapType(),
			serialize: new MapType()
		}
	};
}

function makeSerializer(methodName, symbolsToCheck){
	// A local variable that is shared with all operations that occur withing a single
	// outer call to serialize()
	var serializeMap = null;

	// Holds the value of running serialize(), preserving the same map for all
	// internal instances.
	function SerializeOperation(MapType) {
		this.first = !serializeMap;

		if(this.first) {
			serializeMap = createSerializeMap(MapType);
		}

		this.map = serializeMap;
		this.result = null;
	}

	SerializeOperation.prototype.end = function(){
		// If this is the first, outer call, clean up the serializeMap.
		if(this.first) {
			serializeMap = null;
		}
		return this.result;
	};

	return function serializer(value, MapType){
		if (isSerializedHelper(value)) {
			return value;
		}

		var operation = new SerializeOperation(MapType);

		if(typeReflections.isValueLike(value)) {
			operation.result = this[methodName](getSetReflections.getValue(value));

		} else {
			// Date, RegEx and other Built-ins are handled above
			// only want to do something if it's intended to be serialized
			// or do nothing for a POJO

			var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
			operation.result = isListLike ? [] : {};

			// handle maping to what is serialized
			if( operation.map[methodName].has(value) ) {
				// if we are in the process of serializing the first time, setup circular reference detection.
				if(operation.map.isSerializing[methodName].has(value)) {
					operation.map.circularReferenceIsSerializing[methodName].set(value, true);
				}
				return operation.map[methodName].get(value);
			} else {
				operation.map[methodName].set(value, operation.result);
			}

			for(var i = 0, len = symbolsToCheck.length ; i< len;i++) {
				var serializer = value[symbolsToCheck[i]];
				if(serializer) {
					// mark that we are serializing
					operation.map.isSerializing[methodName].set(value, true);
					var oldResult = operation.result;
					operation.result = serializer.call(value, oldResult);
					operation.map.isSerializing[methodName].delete(value);

					// if the result differs, but this was circular, blow up.
					if(operation.result !== oldResult) {
						// jshint -W073
						if(operation.map.circularReferenceIsSerializing[methodName].has(value)) {
							// Circular references should use a custom serializer
							// that sets the serialized value on the object
							// passed to it as the first argument e.g.
							// function(proto){
							//   return proto.a = canReflect.serialize(this.a);
							// }
							operation.end();
							throw new Error("Cannot serialize cirular reference!");
						}
						operation.map[methodName].set(value, operation.result);
					}
					return operation.end();
				}
			}

			if (typeof obj ==='function') {
				operation.map[methodName].set(value, value);

				operation.result = value;
			} else if( isListLike ) {
				this.eachIndex(value,function(childValue, index){
					operation.result[index] = this[methodName](childValue);
				},this);
			} else {
				this.eachKey(value,function(childValue, prop){
					operation.result[prop] = this[methodName](childValue);
				},this);
			}
		}

		return operation.end();
	};
}

// returns a Map type of the keys mapped to true
var makeMap;
if(typeof Map !== "undefined") {
	makeMap = function(keys) {
		var map = new Map();
		shapeReflections.eachIndex(keys, function(key){
			map.set(key, true);
		});
		return map;
	};
} else {
	makeMap = function(keys) {
		var map = {};
		keys.forEach(function(key){
			map[key] = true;
		});

		return {
			get: function(key){
				return map[key];
			},
			set: function(key, value) {
				map[key] = value;
			},
			keys: function(){
				return keys;
			}
		};
	};
}

// creates an optimized hasOwnKey lookup.
// If the object has hasOwnKey, then we just use that.
// Otherwise, try to put all keys in a map.
var fastHasOwnKey = function(obj){
	var hasOwnKey = obj[canSymbol.for("can.hasOwnKey")];
	if(hasOwnKey) {
		return hasOwnKey.bind(obj);
	} else {
		var map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );
		return function(key) {
			return map.get(key);
		};
	}
};


// combines patches if it makes sense
function addPatch(patches, patch) {
	var lastPatch = patches[patches.length -1];
	if(lastPatch) {
		// same number of deletes and counts as the index is back
		if(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {
			lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
			lastPatch.deleteCount += patch.deleteCount;
			return;
		}
	}
	patches.push(patch);
}

function updateDeepList(target, source, isAssign) {
	var sourceArray = this.toArray(source); // jshint ignore:line

	var patches = [],
		lastIndex = -1;
	this.eachIndex(target, function(curVal, index){ // jshint ignore:line
		lastIndex = index;
		// If target has more items than the source.
		if(index >= sourceArray.length) {
			if(!isAssign) {
				// add a patch that removes the last items
				addPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});
			}
			return false;
		}
		var newVal = sourceArray[index];
		if( typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
			addPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});
		} else {
			if(isAssign === true) {
				this.assignDeep(curVal, newVal);
			} else {
				this.updateDeep(curVal, newVal);
			}

		}
	}, this); // jshint ignore:line
	// add items at the end
	if(sourceArray.length > lastIndex) {
		addPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});
	}
	for(var i = 0, patchLen = patches.length; i < patchLen; i++) {
		var patch = patches[i];
		getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
	}
	return target;
}

shapeReflections = {
	/**
	 * @function {Object, function(*), [Object]} can-reflect.each each
	 * @parent can-reflect/shape
	 * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property
	 *
	 * @signature `each(obj, callback, context)`
	 *
	 * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],
	 * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and
	 * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as
	 * [can-reflect.eachKey eachKey],
	 * iterating over every key on `obj` and calling `callback` on each one.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 * var quux = new DefineList([ "thud", "jeek" ]);
	 *
	 * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'
	 * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'
	 * ```
	 *
	 * @param  {Object}   obj     The object to iterate over
	 * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike
	 * @param  {[Object]}   context  an optional `this` context for calling the callback
	 * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,
	 * or [can-reflect.eachKey `eachKey`] if a MapLike.
	 */
	each: function(obj, callback, context){

		// if something is more "list like" .. use eachIndex
		if(typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj) ) {
			return shapeReflections.eachIndex(obj,callback,context);
		} else {
			return shapeReflections.eachKey(obj,callback,context);
		}
	},

	/**
	 * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex
	 * @parent can-reflect/shape
	 * @description  Iterate a ListLike calling `callback` on each numerically indexed element
	 *
	 * @signature `eachIndex(list, callback, context)`
	 *
	 * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current
	 * property value, the current index, and `list`, and optionally setting `this` as `context`
	 * if specified (otherwise use the current property value).
	 *
	 * ```js
	 * var foo = new DefineList([ "bar", "baz" ]);
	 *
	 * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'
	 * ```
	 *
	 * @param  {ListLike}   list     The list to iterate over
	 * @param  {Function(*, Number)} callback a function that receives each item
	 * @param  {[Object]}   context  an optional `this` context for calling the callback
	 * @return {ListLike}   the original list
	 */
	eachIndex: function(list, callback, context){
		// each index in something list-like. Uses iterator if it has it.
		if(Array.isArray(list)) {
			return shapeReflections.eachListLike(list, callback, context);
		} else {
			var iter, iterator = list[canSymbol.iterator];
			if(typeReflections.isIteratorLike(list)) {
				// we are looping through an iterator
				iter = list;
			} else if(iterator) {
				iter = iterator.call(list);
			}
			// fast-path arrays
			if(iter) {
				var res, index = 0;

				while(!(res = iter.next()).done) {
					if( callback.call(context || list, res.value, index++, list) === false ){
						break;
					}
				}
			} else {
				shapeReflections.eachListLike(list, callback, context);
			}
		}
		return list;
	},
	eachListLike: function(list, callback, context){
		var index = -1;
		var length = list.length;
		if( length === undefined ) {
			var size = list[sizeSymbol];
			if(size) {
				length = size.call(list);
			} else {
				throw new Error("can-reflect: unable to iterate.");
			}
		}

		while (++index < length) {
			var item = list[index];
			if (callback.call(context || item, item, index, list) === false) {
				break;
			}
		}

		return list;
	},
	/**
	 * @function can-reflect.toArray toArray
	 * @parent can-reflect/shape
	 * @description  convert the values of any MapLike or ListLike into an array
	 *
	 * @signature `toArray(obj)`
	 *
	 * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,
	 * key data is discarded and only value data is preserved.
	 *
	 * ```js
	 * var foo = new DefineList(["bar", "baz"]);
	 * var quux = new DefineMap({ thud: "jeek" });
	 * ```
	 *
	 * canReflect.toArray(foo); // -> ["bar", "baz"]
	 * canReflect.toArray(quux): // -> ["jeek"]
	 *
	 * @param  {Object} obj Any object, whether MapLike or ListLike
	 * @return {Array}  an array of the values of `obj`
	 */
	toArray: function(obj){
		var arr = [];
		shapeReflections.each(obj, function(value){
			arr.push(value);
		});
		return arr;
	},
	/**
	 * @function can-reflect.eachKey eachKey
	 * @parent can-reflect/shape
	 * @description Iterate over a MapLike, calling `callback` on each enumerable property
	 *
	 * @signature `eachKey(obj, callback, context)`
	 *
	 * Iterate all own enumerable properties on Map-like `obj`
	 * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call
	 * `callback` with the property value, the property key, and `obj`, and optionally setting
	 * `this` on the callback as `context` if provided, `obj` otherwise.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'
	 * ```
	 *
	 * @param  {Object}   obj   The object to iterate over
	 * @param  {Function(*, String)} callback The callback to call on each enumerable property value
	 * @param  {[Object]}   context  an optional `this` context for calling `callback`
	 * @return {Array}    the enumerable keys of `obj` as an Array
	 */
	eachKey: function(obj, callback, context){
		// each key in something map like
		// eachOwnEnumerableKey
		if(obj) {
			var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);

			// cache getKeyValue method if we can
			var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;

			return shapeReflections.eachIndex(enumerableKeys, function(key){
				var value = getKeyValue.call(obj, key);
				return callback.call(context || obj, value, key, obj);
			});
		}
		return obj;
	},
	/**
	 * @function can-reflect.hasOwnKey hasOwnKey
	 * @parent can-reflect/shape
	 * @description  Determine whether an object contains a key on itself, not only on its prototype chain
	 *
	 * @signature `hasOwnKey(obj, key)`
	 *
	 * Return `true` if an object's own properties include the property key `key`, `false` otherwise.
	 * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.
	 * By default, `canReflect.hasOwnKey` will first look for
	 * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and
	 * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.
	 *
	 * ```js
	 * var foo = new DefineMap({ "bar": "baz" });
	 *
	 * canReflect.hasOwnKey(foo, "bar"); // -> true
	 * canReflect.hasOwnKey(foo, "each"); // -> false
	 * foo.each // -> function each() {...}
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @param  {String} key The key to look up on `obj`
	 * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise
	 */
	"hasOwnKey": function(obj, key){
		// if a key or index
		// like has own property
		var hasOwnKey = obj[canSymbol.for("can.hasOwnKey")];
		if(hasOwnKey) {
			return hasOwnKey.call(obj, key);
		}
		var getOwnKeys = obj[canSymbol.for("can.getOwnKeys")];
		if( getOwnKeys ) {
			var found = false;
			shapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){
				if(objKey === key) {
					found = true;
					return false;
				}
			});
			return found;
		}
		return hasOwnProperty.call(obj, key);
	},
	/**
	 * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys
	 * @parent can-reflect/shape
	 * @description Return the list of keys which can be iterated over on an object
	 *
	 * @signature `getOwnEnumerableKeys(obj)`
	 *
	 * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting
	 * `enumerable` on the property descriptor, or by using `=` to set the value of the property without
	 * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The
	 * default behavior can be overridden by implementing
	 * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,
	 * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to
	 * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]
	 * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`
	 * is used.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz", [canSymbol.for("quux")]: "thud" });
	 * Object.defineProperty(foo, "jeek", {
	 *   enumerable: true,
	 *   value: "plonk"
	 * });
	 *
	 * canReflect.getOwnEnumerableKeys(foo); // -> ["bar", "jeek"]
	 * ```
	 *
	 * @param  {Object} obj Any Map-like object
	 * @return {Array} the Array of all enumerable keys from the object, either using
	 * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering
	 * `obj`'s own keys for those which are enumerable.
	 */
	getOwnEnumerableKeys: function(obj){
		// own enumerable keys (aliased as keys)
		var getOwnEnumerableKeys = obj[canSymbol.for("can.getOwnEnumerableKeys")];
		if(getOwnEnumerableKeys) {
			return getOwnEnumerableKeys.call(obj);
		}
		if( obj[canSymbol.for("can.getOwnKeys")] && obj[canSymbol.for("can.getOwnKeyDescriptor")] ) {
			var keys = [];
			shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){
				var descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);
				if(descriptor.enumerable) {
					keys.push(key);
				}
			}, this);

			return keys;
		} /*else if(obj[canSymbol.iterator]){
			var iter = obj[canSymbol.iterator](obj);
			var index = 0;
			var keys;
			return {
				next: function(){
					var res = iter.next();
					if(index++)
				}
			}
			while(!().done) {

				if( callback.call(context || list, res.value, index++, list) === false ){
					break;
				}
			}
		}*/ else {
			return Object_Keys(obj);
		}
	},
	/**
	 * @function can-reflect.getOwnKeys getOwnKeys
	 * @parent can-reflect/shape
	 * @description Return the list of keys on an object, whether or not they can be iterated over
	 *
	 * @signature `getOwnKeys(obj)`
	 *
	 * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If
	 * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return
	 * the keys; otherwise, `Object.getOwnPropertyNames()` is used.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz", [canSymbol.for("quux")]: "thud" });
	 * Object.defineProperty(foo, "jeek", {
	 *   enumerable: false,
	 *   value: "plonk"
	 * });
	 *
	 * canReflect.getOwnKeys(foo); // -> ["bar", "jeek"]
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @return {Array} the Array of all String keys from the object.
	 */
	getOwnKeys: function(obj){
		// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)
		var getOwnKeys = obj[canSymbol.for("can.getOwnKeys")];
		if(getOwnKeys) {
			return getOwnKeys.call(obj);
		} else {
			return Object.getOwnPropertyNames(obj);
		}
	},
	/**
	 * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor
	 * @parent can-reflect/shape
	 * @description Return a property descriptor for a named property on an object.
	 *
	 * @signature `getOwnKeyDescriptor(obj, key)`
	 *
	 *	Return the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor
	 *	is specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,
	 *	as well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.
	 *
	 * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]
	 * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.
	 *
	 * ```js
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * getOwnKeyDescriptor(foo, "bar"); // -> {configurable: true, writable: true, enumerable: true, value: "baz"}
	 * ```
	 *
	 * @param  {Object} obj Any object with named properties
	 * @param  {String} key The property name to look up on `obj`
	 * @return {Object}   A key descriptor object
	 */
	getOwnKeyDescriptor: function(obj, key){
		var getOwnKeyDescriptor = obj[canSymbol.for("can.getOwnKeyDescriptor")];
		if(getOwnKeyDescriptor) {
			return getOwnKeyDescriptor.call(obj, key);
		} else {
			return Object.getOwnPropertyDescriptor(obj, key);
		}
	},
	/**
	 * @function can-reflect.unwrap unwrap
	 * @parent can-reflect/shape
	 * @description Unwraps a map-like or array-like value into an object or array.
	 *
	 *
	 * @signature `unwrap(obj)`
	 *
	 * Recursively unwraps a map-like or list-like object.
	 *
	 * ```js
	 * import canReflect from "can-reflect";
	 *
	 * var map = new DefineMap({foo: "bar"});
	 * canReflect.unwrap(map) //-> {foo: "bar"}
	 * ```
	 *
	 * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe
	 * objects.  For example, an object with a `Date` instance property value will not be expected to
	 * serialize the date instance:
	 *
	 * ```js
	 * var date = new Date();
	 * var map = new DefineMap({date: date});
	 * canReflect.unwrap(map) //-> {date: date}
	 * ```
	 *
	 * @param {Object} obj A map-like or array-like object.
	 * @return {Object} Returns objects and arrays.
	 */
	unwrap: makeSerializer("unwrap",[canSymbol.for("can.unwrap")]),
	/**
	 * @function can-reflect.serialize serialize
	 * @parent can-reflect/shape
	 * @description Serializes an object to a value that can be passed to JSON.stringify.
	 *
	 *
	 * @signature `serialize(obj)`
	 *
	 * Recursively serializes a map-like or list-like object.
	 *
	 * ```js
	 * import canReflect from "can-reflect";
	 * canReflect.serialize({foo: "bar"}) //-> {foo: "bar"}
	 * ```
	 *
	 * It does this by recursively:
	 *
	 *  - Checking if `obj` is a primitive, if it is, returns the value.
	 *  - If `obj` is an object:
	 *    - calling the `@can.serialize` property on the value if it exists.
	 *    - If the `@can.serialize` value doesn't exist, walks through every key-value
	 *      on `obj` and copy to a new object.
	 *
	 * @param {Object} obj A map-like or array-like object.
	 * @return {Object} Returns a plain object or array.
	 */
	serialize: makeSerializer("serialize",[canSymbol.for("can.serialize"), canSymbol.for("can.unwrap")]),

	assignMap: function(target, source) {
		// read each key and set it on target
		var hasOwnKey = fastHasOwnKey(target);
		var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
		var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
		shapeReflections.eachKey(source,function(value, key){
			// if the target doesn't have this key or the keys are not the same
			if(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {
				setKeyValue.call(target, key, value);
			}
		});
		return target;
	},
	assignList: function(target, source) {
		var inserting = shapeReflections.toArray(source);
		getSetReflections.splice(target, 0, inserting, inserting );
		return target;
	},
	/**
	 * @function can-reflect.assign assign
	 * @parent can-reflect/shape
	 * @description Assign one objects values to another
	 *
	 * @signature `.assign(target, source)`
	 *
	 * Copies the values (and properties if map-like) from `source` onto `target`.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {};
	 * var source = {key : "value"};
	 * var restult = canReflect.assign(target, source);
	 * result === target //-> true
	 * target //-> {key : "value"}
	 * ```
	 *
	 * For Arrays, enumerated values are copied over, but the length of the array will not be
	 * trunkated.  Use [can-reflect.update] for trunkating.
	 *
	 * ```js
	 * var target = ["a","b","c"];
	 * var source = ["A","B"];
	 * canReflect.assign(target, source);
	 * target //-> ["A","B","c"]
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	assign: function(target, source) {
		if(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {
			// copy to array and add these keys in place
			shapeReflections.assignList(target, source);
		} else {
			shapeReflections.assignMap(target, source);
		}
		return target;
	},
	assignDeepMap: function(target, source) {

		var hasOwnKey = fastHasOwnKey(target);
		var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
		var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;

		shapeReflections.eachKey(source, function(newVal, key){
			if(!hasOwnKey(key)) {
				// set no matter what
				getSetReflections.setKeyValue(target, key, newVal);
			} else {
				var curVal = getKeyValue.call(target, key);

				// if either was primitive, no recursive update possible
				if(newVal === curVal) {
					// do nothing
				} else if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
					setKeyValue.call(target, key, newVal);
				} else {
					shapeReflections.assignDeep(curVal, newVal);
				}
			}
		}, this);
		return target;
	},
	assignDeepList: function(target, source) {
		return updateDeepList.call(this, target, source, true);
	},
	/**
	 * @function can-reflect.assignDeep assignDeep
	 * @parent can-reflect/shape
	 * @description Assign one objects values to another, and performs the same action for all child values.
	 *
	 * @signature `.assignDeep(target, source)`
	 *
	 * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child
	 * values.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}};
	 * var source = {name: {last: "Meyer"}};
	 * var restult = canReflect.assignDeep(target, source);
	 * target //->  {name: {first: "Justin", last: "Meyer"}}
	 * ```
	 *
	 * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	assignDeep: function(target, source){
		var assignDeep = target[canSymbol.for("can.assignDeep")];
		if(assignDeep) {
			assignDeep.call(target, source);
		} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {
			// list-like
			shapeReflections.assignDeepList(target, source);
		} else {
			// map-like
			shapeReflections.assignDeepMap(target, source);
		}
		return target;
	},
	updateMap: function(target, source) {
		var sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );

		var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
		var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;

		shapeReflections.eachKey(target, function(curVal, key){
			if(!sourceKeyMap.get(key)) {
				getSetReflections.deleteKeyValue(target, key);
				return;
			}
			sourceKeyMap.set(key, false);
			var newVal = sourceGetKeyValue.call(source, key);

			// if either was primitive, no recursive update possible
			if(newVal !== curVal) {
				targetSetKeyValue.call(target, key, newVal);
			}
		}, this);

		shapeReflections.eachIndex(sourceKeyMap.keys(), function(key){
			if(sourceKeyMap.get(key)) {
				targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );
			}
		});

		return target;
	},
	updateList: function(target, source) {
		var inserting = shapeReflections.toArray(source);

		getSetReflections.splice(target, 0, target, inserting );
		return target;
	},
	/**
	 * @function can-reflect.update update
	 * @parent can-reflect/shape
	 * @description Updates the values of an object match the values of an other object.
	 *
	 * @signature `.update(target, source)`
	 *
	 * Updates the values (and properties if map-like) of `target` to match the values of `source`.
	 * Properties of `target` that are not on `source` will be removed. This does
	 * not recursively update.  For that, use [can-reflect.updateDeep].
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}, age: 34};
	 * var source = {name: {last: "Meyer"}};
	 * var result = canReflect.update(target, source);
	 * target //->  {name: {last: "Meyer"}}
	 * ```
	 *
	 * With Arrays all items of the source will be replaced with the new items.
	 *
	 * ```js
	 * var target = ["a","b","c"];
	 * var source = ["A","B"];
	 * canReflect.update(target, source);
	 * target //-> ["A","B"]
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	update: function(target, source) {
		if(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {
			// copy to array and add these keys in place
			shapeReflections.updateList(target, source);
		} else {
			shapeReflections.updateMap(target, source);
		}
		return target;
	},
	updateDeepMap: function(target, source) {
		var sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );

		var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
		var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;

		shapeReflections.eachKey(target, function(curVal, key){

			if(!sourceKeyMap.get(key)) {
				getSetReflections.deleteKeyValue(target, key);
				return;
			}
			sourceKeyMap.set(key, false);
			var newVal = sourceGetKeyValue.call(source, key);

			// if either was primitive, no recursive update possible
			if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
				targetSetKeyValue.call(target, key, newVal);
			} else {
				shapeReflections.updateDeep(curVal, newVal);
			}

		}, this);

		shapeReflections.eachIndex(sourceKeyMap.keys(), function(key){
			if(sourceKeyMap.get(key)) {
				targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );
			}
		});
		return target;
	},
	updateDeepList: function(target, source) {
		return updateDeepList.call(this,target, source);
	},
	/**
	 * @function can-reflect.updateDeep updateDeep
	 * @parent can-reflect/shape
	 * @description Makes the values of an object match the values of an other object including all children values.
	 *
	 * @signature `.updateDeep(target, source)`
	 *
	 * Updates the values (and properties if map-like) of `target` to match the values of `source`.
	 * Removes properties from `target` that are not on `source`.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}, age: 34};
	 * var source = {name: {last: "Meyer"}};
	 * var result = canReflect.updateDeep(target, source);
	 * target //->  {name: {last: "Meyer"}}
	 * ```
	 *
	 * An object can control the behavior of `updateDeep` using the [can-symbol/symbols/updateDeep] symbol.
	 *
	 * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	updateDeep: function(target, source){
		var updateDeep = target[canSymbol.for("can.updateDeep")];
		if(updateDeep) {
			updateDeep.call(target, source);
		} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {
			// list-like
			shapeReflections.updateDeepList(target, source);
		} else {
			// map-like
			shapeReflections.updateDeepMap(target, source);
		}
		return target;
	},
	// walks up the whole prototype chain
	/**
	 * @function can-reflect.hasKey hasKey
	 * @parent can-reflect/shape
	 * @description Determine whether an object contains a key on itself or its prototype chain
	 *
	 * @signature `hasKey(obj, key)`
	 *
	 * Return `true` if an object's properties include the property key `key` or an object on its prototype
	 * chain's properties include the key `key`, `false` otherwise.
	 * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.
	 * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.
	 * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.
	 *
	 * ```js
	 * var foo = new DefineMap({ "bar": "baz" });
	 *
	 * canReflect.in(foo, "bar"); // -> true
	 * canReflect.in(foo, "each"); // -> true
	 * foo.each // -> function each() {...}
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @param  {String} key The key to look up on `obj`
	 * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise
	 */
	hasKey: function(obj, key) {
		if( obj == null ) {
			return false;
		}
		if (typeReflections.isPrimitive(obj)) {
			if (hasOwnProperty.call(obj, key)) {
				return true;
			} else {
				var proto;
				if(getPrototypeOfWorksWithPrimitives) {
					proto = Object.getPrototypeOf(obj);
				} else {
					// IE-remove-start
					proto = obj.__proto__; // jshint ignore:line
					// IE-remove-end
				}
				if(proto !== undefined) {
					return key in proto;
				} else {
					// IE-remove-start
					return obj[key] !== undefined;
					// IE-remove-end
				}
			}
		}
		var hasKey = obj[canSymbol.for("can.hasKey")];
		if(hasKey) {
			return hasKey.call(obj, key);
		}

		var found = shapeReflections.hasOwnKey(obj, key);

		return found || key in obj;
	},
	getAllEnumerableKeys: function(){},
	getAllKeys: function(){},
	/**
	 * @function can-reflect.assignSymbols assignSymbols
	 * @parent can-reflect/shape
	 * @description Assign well known symbols and values to an object.
	 *
	 * @signature `.assignSymbols(target, source)`
	 *
	 * Converts each property name on the `source` object to a [can-symbol.for well known symbol]
	 * and uses that symbol to set the corresponding value on target.
	 *
	 * This is used to easily set symbols correctly even when symbol isn't natively supported.
	 *
	 * ```js
	 * canReflect.assignSymbols(Map.prototype, {
	 *   "can.getKeyValue": Map.prototype.get
	 * })
	 * ```
	 *
	 * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),
	 * that symbol will be used:
	 *
	 * ```js
	 * canReflect.assignSymbols(ArrayLike.prototype, {
	 *   "iterator": function() { ... }
	 * })
	 * ArrayLike.prototype[Symbol.iterator] = function(){ ... }
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s symbols and values.
	 * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.
	 * @return {Object} The target.
	 */
	assignSymbols: function(target, source){
		shapeReflections.eachKey(source, function(value, key){
			var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
			getSetReflections.setKeyValue(target, symbol, value);
		});
		return target;
	},
	isSerialized: isSerializedHelper,
	/**
	 * @function can-reflect.size size
	 * @parent can-reflect/shape
	 * @description Return the number of items in the collection.
	 *
	 * @signature `.size(target)`
	 *
	 * Returns the number of items contained in `target`. Target can
	 * provide the size using the [can-symbol/symbols/size] symbol.
	 *
	 * If the `target` has a numeric `length` property that is greater than or equal to 0, that
	 * `length` will be returned.
	 *
	 * ```js
	 * canReflect.size([1,2,3]) //-> 3
	 * ```
	 *
	 * If the `target` is [can-reflect.isListLike], the values of the list will be counted.
	 *
	 * If the `target` is a plain JS object, the number of enumerable properties will be returned.
	 *
	 * ```js
	 * canReflect.size({foo:"bar"}) //-> 1
	 * ```
	 *
	 * If the `target` is anything else, `undefined` is returned.
	 *
	 * @param  {Object} target The container object.
	 * @return {Number} The number of values in the target.
	 */
	size: function(obj){
		if(obj == null) {
			return 0;
		}
		var size = obj[sizeSymbol];
		var count = 0;
		if(size) {
			return size.call(obj);
		}
		else if(helpers.hasLength(obj)){
			return obj.length;
		}
		else if(typeReflections.isListLike(obj)){

			shapeReflections.eachIndex(obj, function(){
				count++;
			});
			return count;
		}
		else if( obj ) {
			return shapeReflections.getOwnEnumerableKeys(obj).length;
		}
		else {
			return undefined;
		}
	},
	/**
	 * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey
	 * @parent can-reflect/shape
	 * @description Create a key for all instances of a constructor.
	 *
	 * @signature `defineInstanceKey(cls, key, properties)`
	 *
	 * Define the property `key` on the prototype of the constructor `cls` using the symbolic
	 * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise
	 * use `Object.defineProperty()` to define the property.  The property definition
	 *
	 * @param  {Function} cls  a Constructor function
	 * @param  {String} key     the String or Symbol key to set.
	 * @param  {Object} properties a JavaScript property descriptor
	 */
	defineInstanceKey: function(cls, key, properties) {
		var defineInstanceKey = cls[canSymbol.for("can.defineInstanceKey")];
		if(defineInstanceKey) {
			return defineInstanceKey.call(cls, key, properties);
		}
		var proto = cls.prototype;
		defineInstanceKey = proto[canSymbol.for("can.defineInstanceKey")];
		if(defineInstanceKey) {
			defineInstanceKey.call(proto, key, properties);
		} else {
			Object.defineProperty(
				proto,
				key,
				shapeReflections.assign({
					configurable: true,
					enumerable: !typeReflections.isSymbolLike(key),
					writable: true
				}, properties)
			);
		}
	}
};

shapeReflections.isSerializable = shapeReflections.isSerialized;
shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
module.exports = shapeReflections;


/***/ }),

/***/ "./node_modules/can-reflect/reflections/type/type.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/type/type.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var helpers = __webpack_require__(/*! ../helpers */ "./node_modules/can-reflect/reflections/helpers.js");

var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);
var plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );
/**
 * @function can-reflect.isConstructorLike isConstructorLike
 * @parent can-reflect/type
 *
 * @description Test if a value looks like a constructor function.
 *
 * @signature `isConstructorLike(func)`
 *
 * Return `true` if `func` is a function and has a non-empty prototype, or implements
 *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.
 *
 * ```js
 * canReflect.isConstructorLike(function() {}); // -> false
 *
 * function Construct() {}
 * Construct.prototype = { foo: "bar" };
 * canReflect.isConstructorLike(Construct); // -> true
 *
 * canReflect.isConstructorLike({}); // -> false
 * !!canReflect.isConstructorLike({ [canSymbol.for("can.new")]: function() {} }); // -> true
 * ```
 *
 * @param  {*}  func maybe a function
 * @return {Boolean} `true` if a constructor; `false` if otherwise.
 */
function isConstructorLike(func){
	/* jshint unused: false */
	// if you can new it ... it's a constructor
	var value = func[canSymbol.for("can.new")];
	if(value !== undefined) {
		return value;
	}

	if(typeof func !== "function") {
		return false;
	}
	// If there are any properties on the prototype that don't match
	// what is normally there, assume it's a constructor
	var prototype = func.prototype;
	if(!prototype) {
		return false;
	}
	// Check if the prototype's proto doesn't point to what it normally would.
	// If it does, it means someone is messing with proto chains
	if( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {
		return true;
	}

	var propertyNames = Object.getOwnPropertyNames(prototype);
	if(propertyNames.length === plainFunctionPrototypePropertyNames.length) {
		for(var i = 0, len = propertyNames.length; i < len; i++) {
			if(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
				return true;
			}
		}
		return false;
	} else {
		return true;
	}
}

/**
 * @function can-reflect.isFunctionLike isFunctionLike
 * @parent can-reflect/type
 * @description Test if a value looks like a function.
 * @signature `isFunctionLike(obj)`
 *
 *  Return `true` if `func` is a function, or implements
 *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.
 *
 * ```js
 * canReflect.isFunctionLike(function() {}); // -> true
 * canReflect.isFunctionLike({}); // -> false
 * canReflect.isFunctionLike({ [canSymbol.for("can.apply")]: function() {} }); // -> true
 * ```
 *
 * @param  {*}  obj maybe a function
 * @return {Boolean}
 */
var getNewOrApply = helpers.makeGetFirstSymbolValue(["can.new","can.apply"]);
function isFunctionLike(obj){
	var result,
		symbolValue = !!obj && obj[canSymbol.for("can.isFunctionLike")];

	if (symbolValue !== undefined) {
		return symbolValue;
	}

	result = getNewOrApply(obj);
	if(result !== undefined) {
		return !!result;
	}

	return typeof obj === "function";
}

/**
 * @function can-reflect.isPrimitive isPrimitive
 * @parent can-reflect/type
 * @description Test if a value is a JavaScript primitive.
 * @signature `isPrimitive(obj)`
 *
 * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.
 *
 * ```js
 * canReflect.isPrimitive(null); // -> true
 * canReflect.isPrimitive({}); // -> false
 * canReflect.isPrimitive(undefined); // -> true
 * canReflect.isPrimitive(1); // -> true
 * canReflect.isPrimitive([]); // -> false
 * canReflect.isPrimitive(function() {}); // -> false
 * canReflect.isPrimitive("foo"); // -> true
 *
 * ```
 *
 * @param  {*}  obj maybe a primitive value
 * @return {Boolean}
 */
function isPrimitive(obj){
	var type = typeof obj;
	if(obj == null || (type !== "function" && type !== "object") ) {
		return true;
	}
	else {
		return false;
	}
}

var coreHasOwn = Object.prototype.hasOwnProperty;
var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(obj) {
	// Must be an Object.
	// Because of IE, we also have to check the presence of the constructor property.
	// Make sure that DOM nodes and window objects don't pass through, as well
	if (!obj || typeof obj !== 'object' ) {
		return false;
	}
	var proto = Object.getPrototypeOf(obj);
	if(proto === Object.prototype || proto === null) {
		return true;
	}
	// partially inspired by lodash: https://github.com/lodash/lodash
	var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
	return typeof Constructor === 'function' && Constructor instanceof Constructor &&
    	funcToString.call(Constructor) === objectCtorString;
}

/**
 * @function can-reflect.isBuiltIn isBuiltIn
 * @parent can-reflect/type
 * @description Test if a value is a JavaScript built-in type.
 * @signature `isBuiltIn(obj)`
 *
 * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.
 *
 * ```js
 * canReflect.isBuiltIn(null); // -> true
 * canReflect.isBuiltIn({}); // -> true
 * canReflect.isBuiltIn(1); // -> true
 * canReflect.isBuiltIn([]); // -> true
 * canReflect.isBuiltIn(function() {}); // -> true
 * canReflect.isBuiltIn("foo"); // -> true
 * canReflect.isBuiltIn(new Date()); // -> true
 * canReflect.isBuiltIn(/[foo].[bar]/); // -> true
 * canReflect.isBuiltIn(new DefineMap); // -> false
 *
 * ```
 *
 * Not supported in browsers that have implementations of Map/Set where
 * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.
 *
 * @param  {*}  obj maybe a built-in value
 * @return {Boolean}
 */
function isBuiltIn(obj) {

	// If primitive, array, or POJO return true. Also check if
	// it is not a POJO but is some type like [object Date] or
	// [object Regex] and return true.
	if (isPrimitive(obj) ||
		Array.isArray(obj) ||
		isPlainObject(obj) ||
		(Object.prototype.toString.call(obj) !== '[object Object]' &&
			Object.prototype.toString.call(obj).indexOf('[object ') !== -1)) {
		return true;
	}
	else {
		return false;
	}
}

/**
 * @function can-reflect.isValueLike isValueLike
 * @parent can-reflect/type
 * @description Test if a value represents a single value (as opposed to several values).
 *
 * @signature `isValueLike(obj)`
 *
 * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],
 * `false` otherwise.
 *
 * ```js
 * canReflect.isValueLike(null); // -> true
 * canReflect.isValueLike({}); // -> false
 * canReflect.isValueLike(function() {}); // -> false
 * canReflect.isValueLike({ [canSymbol.for("can.isValueLike")]: true}); // -> true
 * canReflect.isValueLike({ [canSymbol.for("can.getValue")]: function() {} }); // -> true
 * canReflect.isValueLike(canCompute()); // -> true
 * canReflect.isValueLike(new DefineMap()); // -> false
 *
 * ```
 *
 * @param  {*}  obj maybe a primitive or an object that yields a value
 * @return {Boolean}
 */
function isValueLike(obj) {
	var symbolValue;
	if(isPrimitive(obj)) {
		return true;
	}
	symbolValue = obj[canSymbol.for("can.isValueLike")];
	if( typeof symbolValue !== "undefined") {
		return symbolValue;
	}
	var value = obj[canSymbol.for("can.getValue")];
	if(value !== undefined) {
		return !!value;
	}
}

/**
 * @function can-reflect.isMapLike isMapLike
 * @parent can-reflect/type
 *
 * @description Test if a value represents multiple values.
 *
 * @signature `isMapLike(obj)`
 *
 * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for
 * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements
 * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.
 *
 * ```js
 * canReflect.isMapLike(null); // -> false
 * canReflect.isMapLike(1); // -> false
 * canReflect.isMapLike("foo"); // -> false
 * canReflect.isMapLike({}); // -> true
 * canReflect.isMapLike(function() {}); // -> true
 * canReflect.isMapLike([]); // -> false
 * canReflect.isMapLike({ [canSymbol.for("can.isMapLike")]: false }); // -> false
 * canReflect.isMapLike({ [canSymbol.for("can.getKeyValue")]: null }); // -> false
 * canReflect.isMapLike(canCompute()); // -> false
 * canReflect.isMapLike(new DefineMap()); // -> true
 *
 * ```
 *
 * @param  {*}  obj maybe a Map-like
 * @return {Boolean}
 */
function isMapLike(obj) {
	if(isPrimitive(obj)) {
		return false;
	}
	var isMapLike = obj[canSymbol.for("can.isMapLike")];
	if(typeof isMapLike !== "undefined") {
		return !!isMapLike;
	}
	var value = obj[canSymbol.for("can.getKeyValue")];
	if(value !== undefined) {
		return !!value;
	}
	// everything else in JS is MapLike
	return true;
}

/**
 * @function can-reflect.isObservableLike isObservableLike
 * @parent can-reflect/type
 * @description Test if a value (or its keys) can be observed for changes.
 *
 * @signature `isObservableLike(obj)`
 *
 * Return  `true` if `obj` is _not_ a primitive and implements any of
 * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or
 * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.
 *
 * ```js
 * canReflect.isObservableLike(null); // -> false
 * canReflect.isObservableLike({}); // -> false
 * canReflect.isObservableLike([]); // -> false
 * canReflect.isObservableLike(function() {}); // -> false
 * canReflect.isObservableLike({ [canSymbol.for("can.onValue")]: function() {} }); // -> true
 * canReflect.isObservableLike({ [canSymbol.for("can.onKeyValue")]: function() {} }); // -> true
 * canReflect.isObservableLike(canCompute())); // -> true
 * canReflect.isObservableLike(new DefineMap())); // -> true
 * ```
 *
 * @param  {*}  obj maybe an observable
 * @return {Boolean}
 */

// Specially optimized
var onValueSymbol = canSymbol.for("can.onValue"),
	onKeyValueSymbol = canSymbol.for("can.onKeyValue"),
	onPatchesSymbol = canSymbol.for("can.onPatches");
function isObservableLike( obj ) {
	if(isPrimitive(obj)) {
		return false;
	}
	return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
}

/**
 * @function can-reflect.isListLike isListLike
 * @parent can-reflect/type
 *
 * @description Test if a value looks like a constructor function.
 *
 * @signature `isListLike(list)`
 *
 * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,
 * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a
 * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise
 *
 * ```js
 * canReflect.isListLike(null); // -> false
 * canReflect.isListLike({}); // -> false
 * canReflect.isListLike([]); // -> true
 * canReflect.isListLike("foo"); // -> true
 * canReflect.isListLike(1); // -> false
 * canReflect.isListLike({ [canSymbol.for("can.isListLike")]: true }); // -> true
 * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true
 * canReflect.isListLike({ length: 0 }); // -> true
 * canReflect.isListLike({ length: 3 }); // -> false
 * canReflect.isListLike({ length: 3, "2": true }); // -> true
 * canReflect.isListLike(new DefineMap()); // -> false
 * canReflect.isListLike(new DefineList()); // -> true
 * ```
 *
 * @param  {*}  list maybe a List-like
 * @return {Boolean}
 */
function isListLike( list ) {
	var symbolValue,
		type = typeof list;
	if(type === "string") {
		return true;
	}
	if( isPrimitive(list) ) {
		return false;
	}
	symbolValue = list[canSymbol.for("can.isListLike")];
	if( typeof symbolValue !== "undefined") {
		return symbolValue;
	}
	var value = list[canSymbol.iterator];
	if(value !== undefined) {
		return !!value;
	}
	if(Array.isArray(list)) {
		return true;
	}
	return helpers.hasLength(list);
}

/**
 * @function can-reflect.isSymbolLike isSymbolLike
 * @parent can-reflect/type
 *
 * @description Test if a value is a symbol or a [can-symbol].
 *
 * @signature `isSymbolLike(symbol)`
 *
 * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix
 * equal to that of CanJS's symbol polyfill; `false` otherwise.
 *
 * ```js
 * /* ES6 *\/ canReflect.isSymbolLike(Symbol.iterator); // -> true
 * canReflect.isSymbolLike(canSymbol.for("foo")); // -> true
 * canReflect.isSymbolLike("@@symbol.can.isSymbol"); // -> true (due to polyfill for non-ES6)
 * canReflect.isSymbolLike("foo"); // -> false
 * canReflect.isSymbolLike(null); // -> false
 * canReflect.isSymbolLike(1); // -> false
 * canReflect.isSymbolLike({}); // -> false
 * canReflect.isSymbolLike({ toString: function() { return "@@symbol.can.isSymbol"; } }); // -> true
 * ```
 *
 * @param  {*}  symbol maybe a symbol
 * @return {Boolean}
 */

var supportsNativeSymbols = (function() {
	var symbolExists = typeof Symbol !== "undefined" && typeof Symbol.for === "function";

	if (!symbolExists) {
		return false;
	}

	var symbol = Symbol("a symbol for testing symbols");
	return typeof symbol === "symbol";
}());

var isSymbolLike;
if(supportsNativeSymbols) {
	isSymbolLike = function(symbol) {
		return typeof symbol === "symbol";
	};
} else {
	var symbolStart = "@@symbol";
	isSymbolLike = function(symbol) {
		if(typeof symbol === "object" && !Array.isArray(symbol)){
			return symbol.toString().substr(0, symbolStart.length) === symbolStart;
		} else {
			return false;
		}
	};
}

module.exports = {
	isConstructorLike: isConstructorLike,
	isFunctionLike: isFunctionLike,
	isListLike: isListLike,
	isMapLike: isMapLike,
	isObservableLike: isObservableLike,
	isPrimitive: isPrimitive,
	isBuiltIn: isBuiltIn,
	isValueLike: isValueLike,
	isSymbolLike: isSymbolLike,
	/**
	 * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike
	 * @parent can-reflect/type
	 *
	 * @description Test if a value should be treated as a list instead of a map.
	 *
	 * @signature `isMoreListLikeThanMapLike(obj)`
	 *
	 * Return  `true` if `obj` is an Array, declares itself to be more ListLike with
	 * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.
	 *
	 * ```js
	 * canReflect.isMoreListLikeThanMapLike([]); // -> true
	 * canReflect.isMoreListLikeThanMapLike(null); // -> false
	 * canReflect.isMoreListLikeThanMapLike({}); // -> false
	 * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true
	 * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false
	 * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false
	 * ```
	 *
	 * @param  {Object}  obj the object to test for ListLike against MapLike traits.
	 * @return {Boolean}
	 */
	isMoreListLikeThanMapLike: function(obj){
		if(Array.isArray(obj)) {
			return true;
		}
		if(obj instanceof Array) {
			return true;
		}
		if( obj == null ) {
			return false;
		}
		var value = obj[canSymbol.for("can.isMoreListLikeThanMapLike")];
		if(value !== undefined) {
			return value;
		}
		var isListLike = this.isListLike(obj),
			isMapLike = this.isMapLike(obj);
		if(isListLike && !isMapLike) {
			return true;
		} else if(!isListLike && isMapLike) {
			return false;
		}
	},
	/**
	 * @function can-reflect.isIteratorLike isIteratorLike
	 * @parent can-reflect/type
	 * @description Test if a value looks like an iterator.
	 * @signature `isIteratorLike(obj)`
	 *
	 * Return `true` if `obj` has a key `"next"` pointing to a zero-argument function; `false` otherwise
	 *
	 * ```js
	 * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(null); // -> false
	 * canReflect.isIteratorLike({ next: function() {} }); // -> true
	 * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)
	 * ```
	 *
	 * @param  {Object}  obj the object to test for Iterator traits
	 * @return {Boolean}
	 */
	isIteratorLike: function(obj){
		return obj &&
			typeof obj === "object" &&
			typeof obj.next === "function" &&
			obj.next.length === 0;
	},
	/**
	 * @function can-reflect.isPromise isPromise
	 * @parent can-reflect/type
	 * @description Test if a value is a promise.
	 *
	 * @signature `isPromise(obj)`
	 *
	 * Return `true` if `obj` is an instance of promise or `.toString` returns `"[object Promise]"`.
	 *
	 * ```js
	 * canReflect.isPromise(Promise.resolve()); // -> true
	 * ```
	 *
	 * @param  {*}  obj the object to test for Promise traits.
	 * @return {Boolean}
	 */
	isPromise: function(obj){
		return (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));
	},
	/**
	 * @function can-reflect.isPlainObject isPlainObject
	 * @parent can-reflect/type
	 * @description Test if a value is an object created with `{}` or `new Object()`.
	 *
	 * @signature `isPlainObject(obj)`
	 *
	 * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:
	 *
	 * 1. Objects with prototypes (created using the `new` keyword).
	 * 2. Booleans.
	 * 3. Numbers.
	 * 4. NaN.
	 *
	 * ```js
	 * var isPlainObject = require("can-reflect").isPlainObject;
	 *
	 * // Created with {}
	 * console.log(isPlainObject({})); // -> true
	 *
	 * // new Object
	 * console.log(isPlainObject(new Object())); // -> true
	 *
	 * // Custom object
	 * var Ctr = function(){};
	 * var obj = new Ctr();
	 *
	 * console.log(isPlainObject(obj)); // -> false
	 * ```
	 *
	 * @param  {Object}  obj the object to test.
	 * @return {Boolean}
	 */
	isPlainObject: isPlainObject
};


/***/ }),

/***/ "./node_modules/can-reflect/types/map.js":
/*!***********************************************!*\
  !*** ./node_modules/can-reflect/types/map.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shape = __webpack_require__(/*! ../reflections/shape/shape */ "./node_modules/can-reflect/reflections/shape/shape.js");
var CanSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

function keysPolyfill() {
  var keys = [];
  var currentIndex = 0;

  this.forEach(function(val, key) { // jshint ignore:line
    keys.push(key);
  });

  return {
    next: function() {
      return {
        value: keys[currentIndex],
        done: (currentIndex++ === keys.length)
      };
    }
  };
}

if (typeof Map !== "undefined") {
  shape.assignSymbols(Map.prototype, {
    "can.getOwnEnumerableKeys": Map.prototype.keys,
    "can.setKeyValue": Map.prototype.set,
    "can.getKeyValue": Map.prototype.get,
    "can.deleteKeyValue": Map.prototype["delete"],
    "can.hasOwnKey": Map.prototype.has
  });

  if (typeof Map.prototype.keys !== "function") {
    Map.prototype.keys = Map.prototype[CanSymbol.for("can.getOwnEnumerableKeys")] = keysPolyfill;
  }
}

if (typeof WeakMap !== "undefined") {
  shape.assignSymbols(WeakMap.prototype, {
    "can.getOwnEnumerableKeys": function() {
      throw new Error("can-reflect: WeakMaps do not have enumerable keys.");
    },
    "can.setKeyValue": WeakMap.prototype.set,
    "can.getKeyValue": WeakMap.prototype.get,
    "can.deleteKeyValue": WeakMap.prototype["delete"],
    "can.hasOwnKey": WeakMap.prototype.has
  });
}


/***/ }),

/***/ "./node_modules/can-reflect/types/set.js":
/*!***********************************************!*\
  !*** ./node_modules/can-reflect/types/set.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shape = __webpack_require__(/*! ../reflections/shape/shape */ "./node_modules/can-reflect/reflections/shape/shape.js");
var CanSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

if (typeof Set !== "undefined") {
  shape.assignSymbols(Set.prototype, {
    "can.isMoreListLikeThanMapLike": true,
    "can.updateValues": function(index, removing, adding) {
      if (removing !== adding) {
        shape.each(
          removing,
          function(value) {
            this.delete(value);
          },
          this
        );
      }
      shape.each(
        adding,
        function(value) {
          this.add(value);
        },
        this
      );
    },
    "can.size": function() {
      return this.size;
    }
  });

  // IE11 doesn't support Set.prototype[@@iterator]
  if (typeof Set.prototype[CanSymbol.iterator] !== "function") {
	  Set.prototype[CanSymbol.iterator] = function() {
		  var arr = [];
		  var currentIndex = 0;

		  this.forEach(function(val) {
			  arr.push(val);
		  });

		  return {
			  next: function() {
				  return {
					  value: arr[currentIndex],
					  done: (currentIndex++ === arr.length)
				  };
			  }
		  };
	  };
  }
}
if (typeof WeakSet !== "undefined") {
  shape.assignSymbols(WeakSet.prototype, {
    "can.isListLike": true,
    "can.isMoreListLikeThanMapLike": true,
    "can.updateValues": function(index, removing, adding) {
      if (removing !== adding) {
        shape.each(
          removing,
          function(value) {
            this.delete(value);
          },
          this
        );
      }
      shape.each(
        adding,
        function(value) {
          this.add(value);
        },
        this
      );
    },
    "can.size": function() {
      throw new Error("can-reflect: WeakSets do not have enumerable keys.");
    }
  });
}


/***/ }),

/***/ "./node_modules/can-rest-model/can-rest-model.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-rest-model/can-rest-model.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! can-connect/can/map/map */ "./node_modules/can-connect/can/map/map.js");
var dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! can-connect/data/url/url */ "./node_modules/can-connect/data/url/url.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var ObservableArray = __webpack_require__(/*! can-observable-array */ "./node_modules/can-observable-array/dist/can-observable-array.js");
var ObservableObject = __webpack_require__(/*! can-observable-object */ "./node_modules/can-observable-object/dist/can-observable-object.js");
var base = __webpack_require__(/*! can-connect/base/base */ "./node_modules/can-connect/base/base.js");
var type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

function restModel(optionsOrUrl) {

	// If optionsOrUrl is a string, make options = {url: optionsOrUrl}
	var options = (typeof optionsOrUrl === "string") ? {url: optionsOrUrl} : optionsOrUrl;

	// If options.ObjectType or .ArrayType aren’t provided, define them
	if (typeof options.ObjectType === "undefined") {
		options.ObjectType = class DefaultObjectType extends ObservableObject {};
	}
	if (typeof options.ArrayType === "undefined") {
		options.ArrayType = class DefaultArrayType extends ObservableArray {
			static get items() {
				return type.convert(options.ObjectType);
			}
		};
	}

	var connection = [base,dataUrl, dataParse, constructor, canMap].reduce(function(prev, behavior){
		return behavior(prev);
	}, options);
	connection.init();
	return connection;
}

module.exports = namespace.restModel = restModel;


/***/ }),

/***/ "./node_modules/can-route-hash/can-route-hash.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route-hash/can-route-hash.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Regular expression for identifying &amp;key=value lists.
var paramsMatcher = /^(?:&[^=]+=[^&]*)+/;

var LOCATION = __webpack_require__(/*! can-globals/location/location */ "./node_modules/can-globals/location/location.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var KeyTree = __webpack_require__(/*! can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");

var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");

function getHash(){
    var loc = LOCATION();
    return loc.href.split(/#!?/)[1] || "";
}

function HashchangeObservable() {
    var dispatchHandlers =  this.dispatchHandlers.bind(this);
    var self = this;
		this._value = "";
    this.handlers = new KeyTree([Object,Array],{
        onFirst: function(){
            self._value = getHash();
            domEvents.addEventListener(window, 'hashchange', dispatchHandlers);
        },
        onEmpty: function(){
            domEvents.removeEventListener(window, 'hashchange', dispatchHandlers);
        }
    });
}
HashchangeObservable.prototype = Object.create(SimpleObservable.prototype);
HashchangeObservable.constructor = HashchangeObservable;
canReflect.assign(HashchangeObservable.prototype,{
    // STUFF NEEDED FOR can-route integration
    paramsMatcher: paramsMatcher,
    querySeparator: "&",
    // don't greedily match slashes in routing rules
    matchSlashes: false,
    root: "#!",
    dispatchHandlers: function() {
        var old = this._value;
        this._value = getHash();
        if(old !== this._value) {
            queues.enqueueByQueue(this.handlers.getNode([]), this, [this._value, old]
                //!steal-remove-start
                /* jshint laxcomma: true */
                , null
                , [ canReflect.getName(this), "changed to", this._value, "from", old ]
                /* jshint laxcomma: false */
                //!steal-remove-end
            );
        }
    },
    get: function(){
        ObservationRecorder.add(this);
        return getHash();
    },
    set: function(path){
        var loc = LOCATION();
        if(!path && !loc.hash) {

        } else if(loc.hash !== "#" + path) {
            loc.hash = "!" + path;
        }
        return path;
    }
});

Object.defineProperty(HashchangeObservable.prototype, "value", {
	get: function(){
		return canReflect.getValue(this);
	},
	set: function(value){
		canReflect.setValue(this, value);
	}
});

canReflect.assignSymbols(HashchangeObservable.prototype,{
	"can.getValue": HashchangeObservable.prototype.get,
	"can.setValue": HashchangeObservable.prototype.set,
	"can.onValue": HashchangeObservable.prototype.on,
	"can.offValue": HashchangeObservable.prototype.off,
	"can.isMapLike": false,
	"can.valueHasDependencies": function(){
		return true;
	},
	//!steal-remove-start
	"can.getName": function() {
		return "HashchangeObservable<" + this._value + ">";
	},
	//!steal-remove-end
});

module.exports = HashchangeObservable;


/***/ }),

/***/ "./node_modules/can-route-mock/can-route-mock.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route-mock/can-route-mock.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function MockRoute(){
    this.routeValue = new SimpleObservable("");
}
canReflect.assignMap(MockRoute.prototype,{
    paramsMatcher: /^(?:&[^=]+=[^&]*)+/,
    querySeparator: "&",
    // don't greedily match slashes in routing rules
    matchSlashes: false,
    root: "#!",
    get: function(){
        return this.value;
    },
    set: function(newVal){
        return this.value = newVal;
    },
    on: function(handler){
        canReflect.onValue(this, handler);
    },
    off: function(handler){
        canReflect.offValue(this, handler);
    }
});

Object.defineProperty(MockRoute.prototype,"value",{
    get: function(){
        return this.routeValue.get().split(/#!?/)[1] || "";
    },
    set: function(path){
        if(path[0] !== "#") {
			this.routeValue.set("#"+(path || ""));
		} else {
			this.routeValue.set(path || "");
		}
		return path;
    }
});

canReflect.assignSymbols(MockRoute.prototype,{
    "can.onValue": function(handler){
        this.routeValue.on(handler);
    },
    "can.offValue": function(handler) {
        this.routeValue.off(handler);
    },
    // Gets the part of the url we are determinging the route from.
    // For hashbased routing, it's everything after the #, for
    // pushState it's configurable
    "can.getValue": function() {
        return this.value;
    },
    // gets called with the serializedcanRoute data after a route has changed
    // returns what the url has been updated to (for matching purposes)
    "can.setValue": function(path){
		this.value = path;
    }
});


module.exports = MockRoute;


/***/ }),

/***/ "./node_modules/can-route-pushstate/can-route-pushstate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-route-pushstate/can-route-pushstate.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// # can-route-pushstate.js

// Plugin for `route` which uses browser `history.pushState` support
// to update window's pathname in addition to `hash`.

// On a high-level, `can-route-pushstate` creates an observable type, 
// `PushstateObservable`, that changes when `history.pushState` is called.
// It does this by:
//  - Intercepting `click` events on anchor elements ('<a>') when the
//    `.href` matches a routing rule.
//  - Decorating `replaceState` and `pushState` to dispatch observable
//    event handlers when called.
//  - Listen to `popstate` events and dispatch obserevable event handlers.

// `PushstateObservable` inherits from `SimpleObservable`, most of
// `PushstateObservable`'s "observable" logic comes from `SimpleObservable`.

/*jshint maxdepth:6, scripturl:true*/

var route = __webpack_require__(/*! can-route */ "./node_modules/can-route/can-route.js");
var bindingProxy = __webpack_require__(/*! can-route/src/binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var isNode = __webpack_require__(/*! can-globals/is-node/is-node */ "./node_modules/can-globals/is-node/is-node.js");
var LOCATION = __webpack_require__(/*! can-globals/location/location */ "./node_modules/can-globals/location/location.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var getGlobal = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");

var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");

var diffObject = __webpack_require__(/*! can-diff/map/map */ "./node_modules/can-diff/map/map.js");

// ## methodsToOverwrite
// Method names on `history` that will be overwritten
// during teardown these are reset to their original functions.
var methodsToOverwrite = ["pushState", "replaceState"],
	// This symbol is used in dispatchHandlers.
	dispatchSymbol = canSymbol.for("can.dispatch");

// ## Helpers
// The following are helper functions useful to `can-route-pushstate`'s main methods.

// ### cleanRoot
// Start of `location.pathname` is the root. 
// Returns the root minus the domain.
function cleanRoot() {
	var location = LOCATION(),
		domain = location.protocol + "//" + location.host,
		// pulls root from route.urlData
		root = bindingProxy.call("root"),
		index = root.indexOf(domain);

	if (index === 0) {
		return root.substr(domain.length);
	}
	return root;
}

// ### getCurrentUrl
// Gets the current url after the root.
// `root` is defined in the PushstateObservable constructor.
function getCurrentUrl() {
	var root = cleanRoot(),
		location = LOCATION(),
		loc = (location.pathname + location.search),
		index = loc.indexOf(root);

	return loc.substr(index + root.length);
}

// ## PushstateObservable
function PushstateObservable() {
	// Keys passed into `replaceStateOnce` will be stored in `replaceStateOnceKeys`.
	this.replaceStateOnceKeys = [];
	// Keys passed into `replaceStateOn` will be stored in `replaceStateKeys`.
	this.replaceStateKeys = [];
	this.dispatchHandlers = this.dispatchHandlers.bind(this);
	this.anchorClickHandler = function(event) {
		var shouldCallPushState = PushstateObservable.prototype.shouldCallPushState.call(this, this, event);
		if (shouldCallPushState) {
			PushstateObservable.prototype.anchorClickHandler.call(this, this, event);
		}
	};

	// ### `keepHash`
	// Currently is neither a feature that's documented,
	// nor is it toggled. [Issue #133](https://github.com/canjs/can-route-pushstate/issues/133)
	// is the discourse on it's removal.
	this.keepHash = true;
}

PushstateObservable.prototype = Object.create(SimpleObservable.prototype);
PushstateObservable.constructor = PushstateObservable;
canReflect.assign(PushstateObservable.prototype, {

	// ### root
	// Start of `location.pathname` is the root.
	// (Can be configured via `route.urlData.root`)
	// The default is `"#!"` set in can-route-hash.
	root: "/",

	// ### matchSlashes
	// The default is `false` set in can-route-hash.
	// Don't greedily match slashes in routing rules.
	matchSlashes: false,

	// ### paramsMatcher
	// Matches things like:
	//  - ?foo=bar
	//  - ?foo=bar&framework=canjs
	//  - ?foo=&bar=
	paramsMatcher: /^\?(?:[^=]+=[^&]*&)*[^=]+=[^&]*/,

	// ### querySeparator
	// Used in `can-route` for building regular expressions to match routes, or
	// return url substrings of routes.
	querySeparator: "?",

	// ### dispatchHandlers
	// Updates `this._value` to the current url and 
	// dispatches event handlers that are on the object.
	// `dispatchHandlers` is called if `pushState` or `replaceState`
	// are called, it is also an event handler on `'popstate'`.
	dispatchHandlers: function() {
		var old = this._value;
		this._value = getCurrentUrl();

		if (old !== this._value) {
			// PushstateObservable inherits from `SimpleObservable` which
			// is using the `can-event-queue/value/value` mixin, and is called
			// using the `can.dispatch` symbol.
			this[dispatchSymbol](this._value, old);
		}
	},

	// ### shouldCallPushState
	// Checks if a route is matched, if one is, returns true
	shouldCallPushState: function(node, event) {
		if (!(event.isDefaultPrevented ? event.isDefaultPrevented() : event.defaultPrevented === true)) {
			// If href has some JavaScript in it, let it run.
			if (node.href === "javascript://") {
				return;
			}

			// Do not pushstate if target is for blank window.
			if (node.target === "_blank") {
				return;
			}

			// Do not pushstate if meta key was pressed, mimicking standard browser behavior.
			if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
				return;
			}

			// linksHost is a Fix for IE showing blank host, but blank host means current host.
			var linksHost = node.host || window.location.host;

			// If link is within the same domain and descendant of `root`.
			if (window.location.host === linksHost) {
				var root = cleanRoot(),
					pathname,
					href,
					nodePathWithSearch;

				if (node instanceof HTMLAnchorElement) {
					pathname = node.pathname;
					href = node.href;
					nodePathWithSearch = pathname + node.search;
				} else if (node.namespaceURI === "http://www.w3.org/1999/xlink") {
					pathname = href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href");
					nodePathWithSearch = href;
				}

				// If the link is within the `root`.
				if (pathname !== undefined && pathname.indexOf(root) === 0) {
					var url = nodePathWithSearch.substr(root.length);

					// If a matching route exists.
					if (route.rule(url) !== undefined) {
						// Makes it possible to have a link with a hash.
						// Calling .pushState will dispatch events, causing
						// `can-route` to update its data, and then try to set back
						// the url without the hash.  We need to retain that.
						if (href.indexOf("#") >= 0) {
							this.keepHash = true;
						}

						// We do not want to call preventDefault() if the link is to the
						// same page and just a different hash; see can-route-pushstate#75.
						var windowPathWithSearch = window.location.pathname + window.location.search;
						var shouldCallPreventDefault = nodePathWithSearch !== windowPathWithSearch || node.hash === window.location.hash;

						// Test if you can preventDefault.
						if (shouldCallPreventDefault && event.preventDefault) {
							event.preventDefault();
						}
						return true;
					}
					return false;
				}
			}
		}
	},

	// ### anchorClickHandler
	// Handler function for `click` events.
	anchorClickHandler: function(node, event) {
		var href = node.href ? node.href : node.getAttributeNS("http://www.w3.org/1999/xlink", "href");
		// Update `window.location`.
		window.history.pushState(null, null, href);
	},

	// ### onBound
	// Initalizes this._value.
	// Sets up event listeners to capture `click` events on `<a>` elements.
	// Overwrites the history api methods `.pushState` and `.replaceState`.
	onBound: function() {
		// if running in Node.js, don't setup.
		if (isNode()) {
			return;
		}

		var document = getDocument(),
			window = getGlobal();

		this._value = getCurrentUrl();

		// Intercept routable links.
		domEvents.addDelegateListener(document.documentElement, "click", "a", this.anchorClickHandler);
		var originalMethods = this.originalMethods = {};
		var dispatchHandlers = this.dispatchHandlers;

		// Rewrites original `pushState`/`replaceState` methods on `history`
		// and keeps pointer to original methods.
		canReflect.eachKey(methodsToOverwrite, function(method) {
			this.originalMethods[method] = window.history[method];
			window.history[method] = function(state, title, url) {

				// Avoid doubled history states (with pushState).
				var absolute = url.indexOf("http") === 0;
				var location = LOCATION();
				var searchHash = location.search + location.hash;

				// If url differs from current call original history method and update `route` state.
				if ((!absolute && url !== location.pathname + searchHash) ||
					(absolute && url !== location.href + searchHash)) {
					originalMethods[method].apply(window.history, arguments);
					dispatchHandlers();
				}
			};
		}, this);

		// Bind dispatchHandlers to the `popstate` event, so they will fire
		// when `history.back()` or `history.forward()` methods are called.
		domEvents.addEventListener(window, "popstate", this.dispatchHandlers);
	},

	// ### onUnbound
	// removes the event listerns for capturing routable links.
	// Sets `.pushState` and `.replacState` to their original methods.
	onUnbound: function() {
		// If running in Node.js, don't teardown.
		if(isNode()) {
			return;
		}

		var document = getDocument(),
			window = getGlobal();

		domEvents.removeDelegateListener(document.documentElement, "click", "a", this.anchorClickHandler);

		// Reset the changed `window.history` methods to their original values.
		canReflect.eachKey(methodsToOverwrite, function(method) {
			window.history[method] = this.originalMethods[method];
		}, this);

		domEvents.removeEventListener(window, "popstate", this.dispatchHandlers);
	},

	// ### get
	// Allows `PushstateObservable` to be observable by can-observations,
	// and returns the current url.
	get: function get() {
		ObservationRecorder.add(this);
		return getCurrentUrl();
	},

	// ### set
	// Calls either pushState or replaceState on the difference
	// in properties between `oldProps` and `newProps`.
	set: function(path) {
		var newProps = route.deparam(path),
			oldProps = route.deparam(getCurrentUrl()),
			method = "pushState",
			changed = {};

		// Adds window.location.hash to path if it's not already in path.
		if (this.keepHash && path.indexOf("#") === -1 && window.location.hash) {
			path += window.location.hash;
		}

		// The old state and new state are diffed 
		// to figure out which keys are changing.
		diffObject(oldProps, newProps)
			.forEach(function(patch) {
				// `patch.key` refers to the mutated property name on `newProps`.
				return changed[patch.key] = true;
			});

		// If any of the changed properties are in `replaceStateKeys` or 
		// `replaceStateOnceKeys` change the method to `'replaceState'`.
		if (this.replaceStateKeys.length) {
			this.replaceStateKeys.forEach(function(replaceKey) {
				if (changed[replaceKey]) {
					method = "replaceState";
				}
			});
		}
		
		if (this.replaceStateOnceKeys.length) {
			this.replaceStateOnceKeys
				.forEach(function(replaceOnceKey, index, thisArray) {
					if (changed[replaceOnceKey]) {
						method = "replaceState";
						// Remove so we don't attempt to replace 
						// the state on this key again.
						thisArray.splice(index, 1);
					}
				});
		}
		window.history[method](null, null, bindingProxy.call("root") + path);
	},

	// ### replaceStateOn
	// Adds given arguments to `this.replaceStateKeys`.
	replaceStateOn: function() {
		canReflect.addValues(this.replaceStateKeys, canReflect.toArray(arguments));
	},

	// ### replaceStateOnce
	// Adds given arguments to `this.replaceStateOnceKeys`.
	// Keys in `this.replaceStateOnceKeys` will be removed
	// from the array the first time a changed route contains that key.
	replaceStateOnce: function() {
		canReflect.addValues(this.replaceStateOnceKeys, canReflect.toArray(arguments));
	},

	// ### replaceStateOff
	// Removes given arguments from both `this.replaceStateKeys` and
	// `this.replaceOnceKeys`.
	replaceStateOff: function() {
		canReflect.removeValues(this.replaceStateKeys, canReflect.toArray(arguments));
		canReflect.removeValues(this.replaceStateOnceKeys, canReflect.toArray(arguments));
	}
});

canReflect.assignSymbols(PushstateObservable.prototype, {
	"can.getValue": PushstateObservable.prototype.get,
	"can.setValue": PushstateObservable.prototype.set,
});

module.exports = PushstateObservable;


/***/ }),

/***/ "./node_modules/can-route/can-route.js":
/*!*********************************************!*\
  !*** ./node_modules/can-route/can-route.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// # can-route.js
// Manage browser history and client state by synchronizing
// the window.location.hash with an observable.


var Bind = __webpack_require__(/*! can-bind */ "./node_modules/can-bind/can-bind.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var type = __webpack_require__(/*! can-type */ "./node_modules/can-type/can-type.js");

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var devLog = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var makeCompute = __webpack_require__(/*! can-simple-observable/make-compute/make-compute */ "./node_modules/can-simple-observable/make-compute/make-compute.js");
var RouteData = __webpack_require__(/*! ./src/routedata */ "./node_modules/can-route/src/routedata.js");
var stringCoercingMapDecorator = __webpack_require__(/*! ./src/string-coercion */ "./node_modules/can-route/src/string-coercion.js").stringCoercingMapDecorator;

var registerRoute = __webpack_require__(/*! ./src/register */ "./node_modules/can-route/src/register.js");
var urlHelpers = __webpack_require__(/*! ./src/url-helpers */ "./node_modules/can-route/src/url-helpers.js");
var routeParam = __webpack_require__(/*! ./src/param */ "./node_modules/can-route/src/param.js");
var routeDeparam = __webpack_require__(/*! ./src/deparam */ "./node_modules/can-route/src/deparam.js");
var bindingProxy = __webpack_require__(/*! ./src/binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");
var Hashchange = __webpack_require__(/*! can-route-hash */ "./node_modules/can-route-hash/can-route-hash.js");

var isWebWorker =  __webpack_require__(/*! can-globals/is-web-worker/is-web-worker */ "./node_modules/can-globals/is-web-worker/is-web-worker.js");
var isBrowserWindow =  __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ "./node_modules/can-globals/is-browser-window/is-browser-window.js");

// ## hashchangeObservable
// `hashchangeObservable` is an instance of `Hashchange`, instances of
// `Hashchange` are two-way bound to `window.location.hash` once the
// instances have a listener.
var hashchangeObservable = new Hashchange();
bindingProxy.bindings.hashchange = hashchangeObservable;
bindingProxy.defaultBinding = "hashchange";
bindingProxy.urlDataObservable.value = hashchangeObservable;


// ## canRoute
function canRoute(url, defaults) {
	//!steal-remove-start
	if (typeof process !== "undefined" && "development" !== "production") {
		devLog.warn("Call route.register(url,defaults) instead of calling route(url, defaults)");
	}
	//!steal-remove-end
	registerRoute.register(url, defaults);
	return canRoute;
}


// ## Helper Functions
// A ~~throttled~~ debounced function called multiple times will only fire once the
// timer runs down. Each call resets the timer.
var timer;
// A dummy events object used to dispatch url change events on.
var currentRuleObservable = new Observation(function canRoute_matchedRoute() {
	var url = bindingProxy.call("can.getValue");
	return canRoute.rule(url);
});

// ### updateUrl
// If the `route.data` changes, update the hash.
// Using `.serialize()` retrieves the raw data contained in the `observable`.
// This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.
// This might be able to use batchNum and avoid this.
function updateUrl(serializedData) {
	// collect attributes that are changing
	clearTimeout(timer);
	timer = setTimeout(function () {
		// indicate that the hash is set to look like the data
		var serialized = canReflect.serialize( canRoute.data ),
			currentRouteName = currentRuleObservable.get(),
			route = routeParam.getMatchedRoute(serialized, currentRouteName),
			path = routeParam.paramFromRoute(route, serialized);

		bindingProxy.call("can.setValue", path);
		var onStartComplete = canRoute._onStartComplete;
		if (onStartComplete) {
			canRoute._onStartComplete = undefined;
			onStartComplete();
		}
	}, 10);
}

// ### updateRouteData
// Deparameterizes the portion of the hash of interest and assign the
// values to the `route.data` removing existing values no longer in the hash.
// updateRouteData is called typically by hashchange which fires asynchronously
// So it’s possible that someone started changing the data before the
// hashchange event fired.  For this reason, it will not set the route data
// if the data is changing or the hash already matches the hash that was set.
function updateRouteData() {
	var hash = bindingProxy.call("can.getValue");
	// if the hash data is currently changing, or
	// the hash is what we set it to anyway, do NOT change the hash

	queues.batch.start();

	var state = canRoute.deparam(hash);
	delete state.route;
	canReflect.update(canRoute.data,state);
	queues.batch.stop();

}


/**
 * @static
 */
Object.defineProperty(canRoute, "routes", {
	/**
	 * @property {Object} routes
	 * @hide
	 *
	 * A list of routes recognized by the router indixed by the url used to add it.
	 * Each route is an object with these members:
	 *
	 *  - test - A regular expression that will match the route when variable values
	 *    are present; i.e. for {page}/{type} the `RegExp` is /([\w\.]*)/([\w\.]*)/ which
	 *    will match for any value of {page} and {type} (word chars or period).
	 *
	 *  - route - The original URL, same as the index for this entry in routes.
	 *
	 *  - names - An array of all the variable names in this route
	 *
	 *  - defaults - Default values provided for the variables or an empty object.
	 *
	 *  - length - The number of parts in the URL separated by '/'.
	 */
 	get: function() {
 		return registerRoute.routes;
 	},
	set: function(newVal) {
		return registerRoute.routes = newVal;
	}
});

// ## canRoute.defaultBinding
Object.defineProperty(canRoute, "defaultBinding", {
 	get: function() {
		return bindingProxy.defaultBinding;
	},
	set: function(newVal) {
		bindingProxy.defaultBinding = newVal;
		var observable = bindingProxy.bindings[bindingProxy.defaultBinding];
		if (observable) {
			bindingProxy.urlDataObservable.value = observable;
		}
	}
});

// ## canRoute.urlData
Object.defineProperty(canRoute, "urlData", {
 	get: function() {
		return bindingProxy.urlDataObservable.value;
	},
	set: function(newVal) {
		canRoute._teardown();
		bindingProxy.urlDataObservable.value = newVal;
	}
});

canReflect.assignMap(canRoute, {
	// ## canRoute.param
	param: routeParam,
	// ## canRoute.deparam
	deparam: routeDeparam,
	// ## canRoute.map
	map: function(data) {
		//!steal-remove-start
		if (typeof process !== "undefined" && "development" !== "production") {
			devLog.warn("Set route.data directly instead of calling route.map");
		}
		//!steal-remove-end
		canRoute.data = data;
	},

	// ## canRoute.start
	start: function (val) {
		if (canRoute.data instanceof RouteData) {
			var routeData = canRoute.data;
			var definePropertyWithDefault = function(defaults, name) {
				var defaultValue = defaults[name];
				var propertyType = defaultValue != null ? type.maybeConvert(defaultValue.constructor) : type.maybeConvert(String);
				canReflect.defineInstanceKey(routeData.constructor, name, {
					type: propertyType
				});
			};

			canReflect.eachKey(canRoute.routes, function(route) {
				canReflect.eachIndex(route.names, function (name) {
					definePropertyWithDefault(route.defaults, name);
				});

				canReflect.eachKey(route.defaults, function(value, key) {
					definePropertyWithDefault(route.defaults, key);
				});
			});
		}

		if (val !== true) {
			canRoute._setup();
			if (isBrowserWindow() || isWebWorker()) {
				// We can't use updateRouteData because we want to merge the route data
				// into .data
				var hash = bindingProxy.call("can.getValue");
				queues.batch.start();
				// get teh data
				var state = canRoute.deparam(hash);
				delete state.route;

				canReflect.assign(canRoute.data,state);
				queues.batch.stop();
				updateUrl();
			}
		}
		
		return canRoute;
	},
	// ## canRoute.url
	url: urlHelpers.url,
	link: urlHelpers.link,
	isCurrent: urlHelpers.isCurrent,
	bindings: bindingProxy.bindings,

	// ready calls setup
	// setup binds and listens to data changes
	// bind listens to whatever you should be listening to
	// data changes tries to set the path

	// we need to be able to
	// easily kick off calling updateRouteData
	// 	teardown whatever is there
	//  turn on a particular binding

	// called when the route is ready
	_setup: function () {
		if (!canRoute._canBinding) {

			var bindingOptions = {

				// The parent is the hashchange observable
				parent: bindingProxy.urlDataObservable.value,
				setParent: updateUrl,

				// The child is route.data
				child: canRoute.serializedObservation,
				setChild: updateRouteData,

				// On init, we do not want the child set to the parent’s value; this is
				// handled by start() for reasons mentioned there.
				onInitDoNotUpdateChild: true,

				// Cycles are allowed because updateUrl is async; if another change
				// happens during its setTimeout, then without cycles the change would
				// be ignored :( TODO: Can this be removed if updateUrl stops using
				// setTimeout in a major version?
				cycles: 1,

				// Listen for changes in the notify queue
				queue: "notify"

			};

			// For debugging: the names that will be assigned to the updateChild and
			// updateParent functions within can-bind
			//!steal-remove-start
			if (typeof process !== "undefined" && "development" !== "production") {
				bindingOptions.updateChildName = "can-route.updateRouteData";
				bindingOptions.updateParentName = "can-route.updateUrl";
			}
			//!steal-remove-end

			// Create a new binding with can-bind
			canRoute._canBinding = new Bind(bindingOptions);

			// …and turn it on!
			canRoute._canBinding.start();

		}
	},
	_teardown: function () {
		if (canRoute._canBinding) {
			canRoute._canBinding.stop();
			canRoute._canBinding = null;
		}
		clearTimeout(timer);
	},

	stop: function() {
		this._teardown();
		return canRoute;
	},

	currentRule: makeCompute( currentRuleObservable ),
	register: registerRoute.register,
	rule: function(url) {
		var rule = routeDeparam.getRule(url);
		if (rule) {
			return rule.route;
		}
	}
});

// The functions in the following list applied to `canRoute` (e.g. `canRoute.attr('...')`) will
// instead act on the `canRoute.data` observe.

var bindToCanRouteData = function (name, args) {
	if (!canRoute.data[name]) {
		return canRoute.data.addEventListener.apply(canRoute.data, args);
	}
	return canRoute.data[name].apply(canRoute.data, args);
};

["addEventListener","removeEventListener","bind", "unbind", "on", "off"].forEach(function(name) {
	// exposing all internal eventQueue evt’s to canRoute
	canRoute[name] = function(eventName, handler) {
		if (eventName === "__url") {
			return bindingProxy.call("can.onValue", handler );
		}
		return bindToCanRouteData(name, arguments);
	};
});

["delegate", "undelegate", "removeAttr", "compute", "_get", "___get", "each"].forEach(function (name) {
	canRoute[name] = function () {
		// `delegate` and `undelegate` require
		// the `can/map/delegate` plugin
		return bindToCanRouteData(name, arguments);
	};
});


var routeData,
	serializedObservation,
	serializedCompute;

function setRouteData(data) {
	routeData = data;
	return routeData;
}

Object.defineProperty(canRoute, "serializedObservation", {
	get: function() {
		if (!serializedObservation) {
			serializedObservation = new Observation(function canRoute_data_serialized() {
				return canReflect.serialize( canRoute.data );
			});
		}
		return serializedObservation;
	}
});
Object.defineProperty(canRoute, "serializedCompute", {
	get: function() {
		if (!serializedCompute) {
			serializedCompute = makeCompute(canRoute.serializedObservation);
		}
		return serializedCompute;
	}
});

var viewModelSymbol = canSymbol.for("can.viewModel");
Object.defineProperty(canRoute, "data", {
	get: function() {
		if (routeData) {
			return routeData;
		} else {
			return setRouteData(new RouteData());
		}
	},
	set: function(data) {
		if ( canReflect.isConstructorLike(data) ) {
			data = new data();
		}
		if (data && data[viewModelSymbol] !== undefined) {
			data = data[viewModelSymbol];
		}
		// if it’s a map, we make it always set strings for backwards compat
		if ( "attr" in data ) {
			setRouteData( stringCoercingMapDecorator(data) );
		} else {
			setRouteData(data);
		}
	}
});

canRoute.attr = function(prop, value) {
	console.warn("can-route: can-route.attr is deprecated. Use methods on can-route.data instead.");
	if ("attr" in canRoute.data) {
		return canRoute.data.attr.apply(canRoute.data, arguments);
	} else {
		if (arguments.length > 1) {
			canReflect.setKeyValue(canRoute.data, prop, value);
			return canRoute.data;
		} else if (typeof prop === "object") {
			canReflect.assignDeep(canRoute.data,prop);
			return canRoute.data;
		} else if (arguments.length === 1) {
			return canReflect.getKeyValue(canRoute.data, prop);
		} else {
			return canReflect.unwrap(canRoute.data);
		}
	}
};


canReflect.setKeyValue(canRoute, canSymbol.for("can.isFunctionLike"), false);

// LEGACY
canRoute.matched = canRoute.currentRule;
canRoute.current = canRoute.isCurrent;

module.exports = namespace.route = canRoute;


/***/ }),

/***/ "./node_modules/can-route/src/binding-proxy.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-route/src/binding-proxy.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");

var urlDataObservable = new SimpleObservable(null);

canReflect.setName(urlDataObservable, "route.urlData");

var bindingProxy = {
	defaultBinding: null,
	urlDataObservable: urlDataObservable,
	bindings: {},
	call: function() {
		var args = canReflect.toArray(arguments),
			prop = args.shift(),
			binding = urlDataObservable.value;
		if (binding === null) {
			throw new Error("there is no current binding!!!");
		}
		var method = binding[prop.indexOf("can.") === 0 ? canSymbol.for(prop) : prop];
		if (method.apply) {
			return method.apply(binding, args);
		} else {
			return method;
		}
	}
};
module.exports = bindingProxy;


/***/ }),

/***/ "./node_modules/can-route/src/deparam.js":
/*!***********************************************!*\
  !*** ./node_modules/can-route/src/deparam.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var deparam = __webpack_require__(/*! can-deparam */ "./node_modules/can-deparam/can-deparam.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var bindingProxy = __webpack_require__(/*! ./binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");
var register = __webpack_require__(/*! ./register */ "./node_modules/can-route/src/register.js");

// ## Helper Functions

// ### decode
// Restore escaped HTML from its URI value.
// It isn't compatable with named character references (`&copy;`, etc).
function decode(str) {
	try {
		return decodeURIComponent(str);
	} catch(ex) {
		return unescape(str);
	}
}

// ### toURLFragment
// If the `root` ends with `/` and the url starts with it, remove `/`.
// TODO: I'm not totally sure this belongs here. This might be shifted to can-route-pushstate.
function toURLFragment(url) {
	var root = bindingProxy.call("root");
	if (root.lastIndexOf("/") === root.length - 1 && url.indexOf("/") === 0) {
		url = url.substr(1);
	}
	return url;
}

// ### canRoute_getRule
function canRoute_getRule(url) {
	url = toURLFragment(url);
	// See if the url matches any routes by testing it against the `route.test` `RegExp`.
	// By comparing the URL length the most specialized route that matches is used.
	var route = {
		length: -1
	};
	canReflect.eachKey(register.routes, function(temp, name) {
		if (temp.test.test(url) && temp.length > route.length) {
			route = temp;
		}
	});
	// If a route was matched.
	if (route.length > -1) {
		return route;
	}
}

function canRoute_deparam(url) {

	var route = canRoute_getRule(url),
		querySeparator = bindingProxy.call("querySeparator"),
		paramsMatcher = bindingProxy.call("paramsMatcher");

	url = toURLFragment(url);

	// If a route was matched.
	if (route) {
		// Since `RegExp` backreferences are used in `route.test` (parens)
		// the parts will contain the full matched string and each variable (back-referenced) value.
		var parts = url.match(route.test),
			// Start will contain the full matched string; parts contain the variable values.
			start = parts.shift(),
			// The remainder will be the `&amp;key=value` list at the end of the URL.
			remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)),
			// If there is a remainder and it contains a `&amp;key=value` list deparam it.
			obj = (remainder && paramsMatcher.test(remainder)) ? deparam(remainder.slice(1)) : {};

		// Add the default values for this route.
		obj = canReflect.assignDeep(canReflect.assignDeep({}, route.defaults), obj);
		// Overwrite each of the default values in `obj` with those in
		// parts if that part is not empty.
		parts.forEach(function (part, i) {
			if (part && part !== querySeparator) {
				obj[route.names[i]] = decode(part);
			}
		});
		return obj;
	}
	// If no route was matched, it is parsed as a `&amp;key=value` list.
	if (url.charAt(0) !== querySeparator) {
		url = querySeparator + url;
	}
	return paramsMatcher.test(url) ? deparam(url.slice(1)) : {};
}

canRoute_deparam.getRule = canRoute_getRule;

module.exports = canRoute_deparam;


/***/ }),

/***/ "./node_modules/can-route/src/param.js":
/*!*********************************************!*\
  !*** ./node_modules/can-route/src/param.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var param = __webpack_require__(/*! can-param */ "./node_modules/can-param/can-param.js");

var register = __webpack_require__(/*! ./register */ "./node_modules/can-route/src/register.js");
var regexps = __webpack_require__(/*! ./regexps */ "./node_modules/can-route/src/regexps.js");
var bindingProxy = __webpack_require__(/*! ./binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");

// ## matchesData
// Checks if a route matches the data provided. If any route variable
// is not present in the data, the route does not match. If all route
// variables are present in the data, the number of matches is returned
// to allow discerning between general and more specific routes.
function matchesData(route, data) {
	var count = 0,
		defaults = {};

	// Look at default route values, if they match increment count
	for (var name in route.defaults) {
		if (route.defaults[name] === data[name]) {
			defaults[name] = 1;
			count++;
		}
	}

	for (var i = 0; i < route.names.length; i++) {
		// If a route name isn't present in data, the route doesn't match.
		if (!data.hasOwnProperty(route.names[i])) {
			return -1;
		}
		if (!defaults[route.names[i]]) {
			count++;
		}
	}

	return count;
}

// ## getMatchedRoute

function getMatchedRoute(data, routeName) {
	// Check if the provided data keys match the names in any routes;
	// Get the one with the most matches.
	var route,
		// Need to have at least 1 match.
		matches = 0,
		matchCount,
		propCount = 0;

	delete data.route;

	canReflect.eachKey(data, function () {
		propCount++;
	});
	// Otherwise find route.
	canReflect.eachKey(register.routes, function (temp, name) {
		// best route is the first with all defaults matching

		matchCount = matchesData(temp, data);
		if (matchCount > matches) {
			route = temp;
			matches = matchCount;
		}
		if (matchCount >= propCount) {
			return false;
		}
	});
	// If we have a route name in our `register` data, and it's
	// just as good as what currently matches, use that
	if (register.routes[routeName] && matchesData(register.routes[routeName], data) === matches) {
		route = register.routes[routeName];
	}
	// If this is match...
	return route;
}
function paramFromRoute(route, data) {
	var cpy,
		res,
		after,
		matcher;
	if (route) {

		cpy = canReflect.assignMap({}, data);
		// fall back to legacy :foo RegExp if necessary
		matcher = regexps.colon.test(route.route) ? regexps.colon : regexps.curlies;
		// Create the url by replacing the var names with the provided data.
		// If the default value is found an empty string is inserted.
		res = route.route.replace(matcher, function (whole, name) {
			delete cpy[name];
			return data[name] === route.defaults[name] ? "" : encodeURIComponent(data[name]);
		})
		.replace("\\", "");
		// Remove matching default values
		canReflect.eachKey(route.defaults, function (val, name) {
			if (cpy[name] === val) {
				delete cpy[name];
			}
		});
		// The remaining elements of data are added as
		// `&amp;` separated parameters to the url.
		after = param(cpy);
		// if we are paraming for setting the hash
		// we also want to make sure the route value is updated
		//if (_setRoute) {
		//    register.matched(route.route);
		//}
		return res + (after ? bindingProxy.call("querySeparator") + after : "");
	}
	// If no route was found, there is no hash URL, only paramters.
	return canReflect.size(data) === 0 ? "" :bindingProxy.call("querySeparator") + param(data);
}

function canRoute_param(data, currentRouteName) {
 	return paramFromRoute(getMatchedRoute(data, currentRouteName), data);
}
module.exports = canRoute_param;
canRoute_param.paramFromRoute = paramFromRoute;
canRoute_param.getMatchedRoute = getMatchedRoute;


/***/ }),

/***/ "./node_modules/can-route/src/regexps.js":
/*!***********************************************!*\
  !*** ./node_modules/can-route/src/regexps.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";

module.exports = {
	curlies: /\{\s*([\w.]+)\s*\}/g,
	colon: /\:([\w.]+)/g
};


/***/ }),

/***/ "./node_modules/can-route/src/register.js":
/*!************************************************!*\
  !*** ./node_modules/can-route/src/register.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// This file contains the function that allows the registration of routes
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var bindingProxy = __webpack_require__(/*! ./binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");
var regexps = __webpack_require__(/*! ./regexps */ "./node_modules/can-route/src/regexps.js");

var diff = __webpack_require__(/*! can-diff/list/list */ "./node_modules/can-diff/list/list.js");
var diffObject = __webpack_require__(/*! can-diff/map/map */ "./node_modules/can-diff/map/map.js");

// `RegExp` used to match route variables of the type '{name}'.
// Any word character or a period is matched.

// ### removeBackslash
// Removes all backslashes (`\`) from a string.
function removeBackslash(string) {
	return string.replace(/\\/g, "");
}

// ### wrapQuote
// Converts input to a string and readies string for regex
// input by escaping the following special characters: `[ ] ( ) { } \ ^ $ . | ? * +`.
function wrapQuote(string) {
	return (string + "")
		.replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
}

var RouteRegistry = {
	routes:  {},
	register: function(url, defaults) {
		// If the root ends with a forward slash (`/`)
		// and url starts with a forward slash (`/`), remove the leading
		// forward slash (`/`) of the url.
		var root = bindingProxy.call("root");

		if ( root.lastIndexOf("/") === root.length - 1 && url.indexOf("/") === 0 ) {
			url = url.substr(1);
		}

		// `matcher` will be a regex
		// fall back to legacy `:foo` RegExp if necessary
		var matcher;
		if (regexps.colon.test(url)) {
			//!steal-remove-start
			if (true) {
				dev.warn("update route \"" + url + "\" to \"" + url.replace(regexps.colon, function(name, key) {
					return "{" + key + "}";
				}) + "\"");
			}
			//!steal-remove-end

			matcher = regexps.colon;
		} else {
			matcher = regexps.curlies;
		}

		defaults = defaults || {};

		// Extract the variable names and replace with `RegExp` that will match
		// an actual URL with values.
		var lastIndex = matcher.lastIndex = 0,
			names = [],
			res,
			test = "",
			next,
			querySeparator = bindingProxy.call("querySeparator"),
			matchSlashes = bindingProxy.call("matchSlashes");

		// res will be something like ["{foo}","foo"]
		while (res = matcher.exec(url)) {
			names.push(res[1]);
			test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
			// If matchSlashes is false (the default) don't greedily match any slash in the string, assume its part of the URL
			next = "\\" + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator+(matchSlashes? "": "|/"));
			// A name without a default value HAS to have a value.
			// A name that has a default value can be empty.
			// The `\\` is for string-escaping giving single `\` for `RegExp` escaping.
			test += "([^" + next + "]" + (defaults[res[1]] ? "*" : "+") + ")";
			lastIndex = matcher.lastIndex;
		}
		test += removeBackslash(url.substr(lastIndex));

		//!steal-remove-start
		if (true) {
			// warn if new route uses same map properties as an existing route
			canReflect.eachKey(RouteRegistry.routes, function(r) {
				var existingKeys = r.names.concat(Object.keys(r.defaults)).sort(),
					keys = names.concat(Object.keys(defaults)).sort(),
					sameMapKeys = !diff(existingKeys, keys).length,
					sameDefaultValues = !diffObject(r.defaults, defaults).length,
					//the regex removes the trailing slash
					matchingRoutesWithoutTrailingSlash = r.route.replace(/\/$/, "") === url.replace(/\/$/, "");

				if (sameMapKeys && sameDefaultValues && !matchingRoutesWithoutTrailingSlash) {
					dev.warn("two routes were registered with matching keys:\n" +
						"\t(1) route.register(\"" + r.route + "\", " + JSON.stringify(r.defaults) + ")\n" +
						"\t(2) route.register(\"" + url + "\", " + JSON.stringify(defaults) + ")\n" +
						"(1) will always be chosen since it was registered first");
				}
			});
		}
		//!steal-remove-end

		// Add route in a form that can be easily figured out.
		return RouteRegistry.routes[url] = {
			// A regular expression that will match the route when variable values
			// are present; i.e. for (`{page}/{type}`) the `RegExp` is `/([\w\.]*)/([\w\.]*)/` which
			// will match for any value of `{page}` and `{type}` (word chars or period).
			test: new RegExp("^" + test + "($|" + wrapQuote(querySeparator) + ")"),
			// The original URL, same as the index for this entry in routes.
			route: url,
			// An `array` of all the variable names in this route.
			names: names,
			// Default values provided for the variables.
			defaults: defaults,
			// The number of parts in the URL separated by `/`.
			length: url.split("/").length
		};
	}
};

module.exports = RouteRegistry;


/***/ }),

/***/ "./node_modules/can-route/src/routedata.js":
/*!*************************************************!*\
  !*** ./node_modules/can-route/src/routedata.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var ObservableObject = __webpack_require__(/*! can-observable-object */ "./node_modules/can-observable-object/dist/can-observable-object.js");
var stringify = __webpack_require__(/*! ./string-coercion */ "./node_modules/can-route/src/string-coercion.js").stringify;

var Stringify = {};
Stringify[canSymbol.for("can.new")] = function(value) {
	return stringify(value);
};
Stringify[canSymbol.for("can.isMember")] = function(value) {
	return typeof value === "string";
};

class RouteData extends ObservableObject {
	static get propertyDefaults() {
		return {
			type: Stringify
		};
	}
}

module.exports = RouteData;


/***/ }),

/***/ "./node_modules/can-route/src/string-coercion.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route/src/string-coercion.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

// # String Coercion Helper Functions

// ## stringify
// Converts an object, array, Map or List to a string.
// It attempts the following flow to convert to a string:
// if `obj` is an object:
//   - call `.serialize` on `obj`, if available
//   - shallow copy `obj` using `.slice` or `can-reflect.assign`
//   - convert each proprety to a string recursively
// else
//   - call `.toString` on `obj`, if available.
function stringify(obj) {
	if (obj && typeof obj === "object") {
		if ("serialize" in obj) {
			obj = obj.serialize();

		// Get array from array-like or shallow-copy object.
		} else if (typeof obj.slice === "function") {
			obj = obj.slice();
		} else {
			canReflect.assign({}, obj);
		}

		// Convert each object property or array item into a string.
		canReflect.eachKey(obj, function(val, prop) {
			obj[prop] = stringify(val);
		});

	// If `obj` supports `.toString` call it.
	} else if (obj !== undefined && obj !== null && (typeof obj.toString === "function" )) {
		obj = obj.toString();
	}

	return obj;
}

// ## stringCoercingMapDecorator
// Coercies the arguments of `can-map.attr` to strings.
// everything in the backing Map is a string
// add type coercion during Map setter to coerce all values to strings so unexpected conflicts don't happen.
// https://github.com/canjs/canjs/issues/2206
// A proposal to change this behavior is currently open:
// https://github.com/canjs/can-route/issues/125
function stringCoercingMapDecorator(map) {
	var decoratorSymbol = canSymbol.for("can.route.stringCoercingMapDecorator");

	if (!map.attr[decoratorSymbol]) {
		var attrUndecoratedFunction = map.attr;

		map.attr = function(key) {

			var serializable = typeof key === "string" &&
				(this.define === undefined || this.define[key] === undefined || !!this.define[key].serialize),
				args;

			if (serializable) { // if setting non-str non-num attr
				args = stringify(Array.apply(null, arguments));
			} else {
				args = arguments;
			}

			return attrUndecoratedFunction.apply(this, args);
		};

		canReflect.setKeyValue(map.attr, decoratorSymbol, true);
	}

	return map;
}

exports.stringCoercingMapDecorator = stringCoercingMapDecorator;
exports.stringify = stringify;


/***/ }),

/***/ "./node_modules/can-route/src/url-helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/can-route/src/url-helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bindingProxy = __webpack_require__(/*! ./binding-proxy */ "./node_modules/can-route/src/binding-proxy.js");
var routeDeparam = __webpack_require__(/*! ./deparam */ "./node_modules/can-route/src/deparam.js");
var routeParam = __webpack_require__(/*! ./param */ "./node_modules/can-route/src/param.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var string = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");

// ### formatAttributes
// Creates HTML-like attributes from an object.
// It escapes hyperlink references.
function formatAttributes(props) {
	var tags = [];
	canReflect.eachKey(props, function(value, name) {
		// Converts `"className"` to `"class"`.
		var attributeName = name === "className" ? "class" : name,

			// Escapes `value` if `name` is `"href"`.
			attributeValue = name === "href" ? value : string.esc(value);

		tags.push(attributeName + "=\"" + attributeValue + "\"");
	});
	return tags.join(" ");
}

// ### matchCheck
// It recursively compares property values in `matcher` to those in `source`.
// It returns `false` if there's a property in `source` that's not in `matcher`,
// or if the two values aren't loosely equal.
function matchCheck(source, matcher) {
	/*jshint eqeqeq:false*/
	for(var property in source) {
		var sourceProperty = source[property],
			matcherProperty = matcher[property];

		if (sourceProperty && matcherProperty &&
			typeof sourceProperty === "object" && typeof matcher === "object"
		) {
			return matchCheck(sourceProperty, matcherProperty);
		}

		if (sourceProperty != matcherProperty) {
			return false;
		}
	}
	return true;
}

// ### canRoute_url
function canRoute_url(options, merge) {
	if (merge) {
		var baseOptions = routeDeparam( bindingProxy.call("can.getValue") );
		options = canReflect.assignMap(canReflect.assignMap({}, baseOptions), options);
	}
	return bindingProxy.call("root") + routeParam(options);
}

module.exports = {
	url: canRoute_url,

	link: function canRoute_link(name, options, props, merge) {
		return "<a " + formatAttributes(
			canReflect.assignMap({
				href: canRoute_url(options, merge)
			}, props)) + ">" + name + "</a>";
	},

	isCurrent: function canRoute_isCurrent(options, subsetMatch) {
		var getValueSymbol = bindingProxy.call("can.getValue");

		if (subsetMatch) {
			// Everything in `options` shouhld be in `baseOptions`.
			var baseOptions = routeDeparam( getValueSymbol );
			return matchCheck(options, baseOptions);
		} else {
			return getValueSymbol === routeParam(options);
		}
	}
};


/***/ }),

/***/ "./node_modules/can-set-legacy/can-set-legacy.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-set-legacy/can-set-legacy.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// for can-set compat
var Query = __webpack_require__(/*! can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var transform = __webpack_require__(/*! can-key/transform/transform */ "./node_modules/can-key/transform/transform.js");
var deleteKey = __webpack_require__(/*! can-key/delete/delete */ "./node_modules/can-key/delete/delete.js");
var getKey = __webpack_require__(/*! can-key/get/get */ "./node_modules/can-key/get/get.js");
var helpers = __webpack_require__(/*! can-query-logic/src/helpers */ "./node_modules/can-query-logic/src/helpers.js");
var makeEnum = __webpack_require__(/*! can-query-logic/src/types/make-enum */ "./node_modules/can-query-logic/src/types/make-enum.js");
var SET = __webpack_require__(/*! can-query-logic/src/set */ "./node_modules/can-query-logic/src/set.js");

var IsBoolean = function(){

};
makeEnum(IsBoolean,[true, false], function(value) {

    if(value === "true") {
        return true;
    } else if(value === "false") {
        return false;
    } else {
        return value;
    }

});

function hasKey(obj, keys, parent, parentKey) {
    if(obj && typeof obj === "object") {
        for(var key in obj) {
            if(keys[key]) {
                if(typeof keys[key] === "function") {
                    parent[parentKey] = keys[key](obj);
                } else {
                    return true;
                }

            } else {
                if( hasKey(obj[key], keys, obj, key) ) {
                    return true;
                }
            }
        }
    }
    return false;
}

function convertToJSONAPISort(sortPropValue){
    var parts = sortPropValue.split(' ');
    var isDesc = (parts[1] || '').toLowerCase()	=== 'desc';

    return isDesc ? "-"+parts[0] : parts[0];
}
function convertToLegacySort(value) {
    var result = helpers.sortData(value);
    return result.desc ? "-"+result.prop : result.prop;
}

var defaultAlgebra;

var set = {
    UNIVERSAL: SET.UNIVERSAL,
    // Nothing
    EMPTY: SET.EMPTY,
    // The set exists, but we lack the language to represent it.
    UNDEFINABLE: SET.UNDEFINABLE,

    // We don't know if this exists. Intersection between two paginated sets.
    UNKNOWABLE: SET.UNKNOWABLE,
    Algebra: function(){
        var mutators = {
            schema: [],
            hydrate: [],
            serialize: []
        };
        canReflect.eachIndex(arguments, function(value){
            for(var prop in value) {
                if(mutators[prop]) {
                    mutators[prop].push(value[prop]);
                } else {
                    throw new Error("can-query-logic: This type of configuration is not supported. Please use can-query-logic directly.");
                }

            }
        });

        var obj = canReflect.assignSymbols({},{
            "can.getSchema": function(){
                var schema = {
                    kind: "record",
                    identity: [],
                    keys: {}
                };
                mutators.schema.forEach(function(updateSchema){
                    updateSchema(schema);
                });
                if(!schema.identity.length) {
                    schema.identity.push("id");
                }

                return schema;
            }
        });
        return new Query(obj, {
            toQuery: function(data){
                return mutators.hydrate.reduce(function(last, hydrator){
                    return hydrator(last);
                }, {filter: data});
            },
            toParams: function(data){
                if(SET.isSpecial(data)) {
                    return data;
                }
                /*if(data === SET.EMPTY) {
                    return false;
                }
                if(data === SET.UNDEFINABLE) {
                    return true;
                }*/
                if(Array.isArray(data.filter)){
                    // OR is not supported ...
                    return SET.UNDEFINABLE;
                }

                var filter = data.filter || {};
                if(hasKey(filter, {
                    "$ne": true,
                    "$in": function(val){ return val.$in; }
                })) {
                    return SET.UNDEFINABLE;
                }

                var out = mutators.serialize.reduce(function(last, serializer){
                    return serializer(last);
                }, data);

                filter = out.filter || {};
                delete out.filter;
                return canReflect.assign(out, filter);
            }
        });
    },
    Translate: function(clause, prop){
        if(clause !== "where") {
            throw new Error("can-query-logic/compat.Translate is only able to translate the where clause");
        }
        return {
            // {filter: {$where: {a:b}}} -> {filter: {a:b}}
            hydrate: function(raw){
                var clone = canReflect.serialize(raw);
                var value = clone.filter[prop];
                delete clone.filter[prop];
                if(value) {
                    canReflect.assign(clone.filter, value);
                }

                return clone;
            },
            // {filter: {foo:bar}} -> {filter: {where: {foo: bar}}}
            serialize: function(query){

                if(query.filter) {
                    var clone = canReflect.serialize(query);
                    var filter = query.filter;
                    clone.filter = {};
                    clone.filter[prop] = filter;
                    return clone;
                } else {
                    return query;
                }
            }
        };
    },
    props: {

        boolean: function(prop){
            // create boolean or enum
            return {
                schema: function(schema) {
                    schema.keys[prop] = IsBoolean;
                }
            };
        },
        dotNotation: function(){
            // This will be supported by default
            return {};
        },
        enum: function(property, propertyValues) {
            function Enum(){}
            makeEnum(Enum, propertyValues);
            return {
                schema: function(schema) {
                    schema.keys[property] = Enum;
                }
            };
        },
        id: function(id){
            return {
                "schema": function(schema){
                    schema.identity.push(id);
                }
            };
        },
        offsetLimit: function(offset, limit){
            offset = offset || "offset";
            limit = limit || "limit";

            return {
                // taking what was given and making it a raw query look
                // start -> page.start
                // end -> page.end
                hydrate: function(raw){
                    var clone = canReflect.serialize(raw);
                    if((offset in clone.filter) || (limit in clone.filter)) {
                        clone.page = {};
                    }
                    if(offset in clone.filter) {
                        clone.page.start = parseInt(clone.filter[offset], 10);
                        delete clone.filter[offset];
                    }
                    if(limit in clone.filter) {
                        clone.page.end = (clone.page.start || 0 ) + parseInt(clone.filter[limit], 10) - 1;
                        delete clone.filter[limit];
                    }
                    return clone;
                },
                // taking the normal format and putting it back
                // page.start -> start
                // page.end -> end
                serialize: function(raw){
                    var clone = canReflect.serialize(raw);
                    if(clone.page) {
                        clone[offset] = clone.page.start;
                        clone[limit] = (clone.page.end - clone.page.start) + 1;
                        delete clone.page;
                    }
                    return clone;
                }
            };
        },
        rangeInclusive: function(start, end){
            var hydrateTransfomer = {};
            hydrateTransfomer["filter."+start] = "page.start";
            hydrateTransfomer["filter."+end] = "page.end";

            var serializeTransformer = {
                "page.start": start,
                "page.end": end
            };
            return {
                // taking what was given and making it a raw query look
                // start -> page.start
                // end -> page.end
                hydrate: function(raw){
                    var res = transform(raw, hydrateTransfomer);
                    if(res.page) {
                        if(res.page.start) {
                            res.page.start = parseInt(res.page.start, 10);
                        }
                        if(res.page.end) {
                            res.page.end = parseInt(res.page.end, 10);
                        }
                    }
                    return res;
                },
                // taking the normal format and putting it back
                // page.start -> start
                // page.end -> end
                serialize: function(raw){
                    return transform(raw, serializeTransformer);
                }
            };
        },
        ignore: function(prop){
            return {
                hydrate: function(raw){
                    var clone = canReflect.serialize(raw);
                    delete clone.filter[prop];
                    return clone;
                }
            };
        },
        sort: function(prop, sortFunc){
            /**
             * var parts = sortPropValue.split(' ');
                 return {
                     prop: parts[0],
                     desc: (parts[1] || '').toLowerCase()	=== 'desc'
                 };
             */
            if(!prop) {
                prop = "sort";
            }
            if(sortFunc) {
                throw new Error("can-query-logic/compat.sort - sortFunc is not supported");
            }

            return {
                hydrate: function(raw){
                    var clone = canReflect.serialize(raw);
                    var sort = getKey(clone,"filter."+prop);
                    if(sort !== undefined) {
                        deleteKey(clone,"filter."+prop);
                        clone.sort = convertToJSONAPISort(sort);
                    }

                    return clone;
                },
                serialize: function(raw){
                    var clone = canReflect.serialize(raw);
                    var sort = clone.sort;
                    if(sort !== undefined) {
                        delete clone.sort;
                        clone[prop] = convertToLegacySort(sort);
                    }
                    return clone;
                }
            };
        }
    }
};

function makeAlgebra(algebra) {
    if(!algebra) {
        return defaultAlgebra;
    }
    else if(!(algebra instanceof Query) ) {
        return new set.Algebra(algebra);
    }
    return algebra;
}

function makeFromTwoQueries(prop) {
    set[prop] = function( a, b, algebra ){
        return makeAlgebra(algebra)[prop](a, b);
    };
}
makeFromTwoQueries("difference");
makeFromTwoQueries("union");
makeFromTwoQueries("intersection");
makeFromTwoQueries("isSubset");
makeFromTwoQueries("isEqual");
makeFromTwoQueries("isProperSubset");

set.count = function(query, algebra) {
    return makeAlgebra(algebra).count(query);
};

set.comparators = set.props;

defaultAlgebra = new set.Algebra();

module.exports = set;


/***/ }),

/***/ "./node_modules/can-simple-map/can-simple-map.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-simple-map/can-simple-map.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Construct = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
var eventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

// Ensure the "obj" passed as an argument has an object on @@can.meta
var ensureMeta = function ensureMeta(obj) {
	var metaSymbol = canSymbol.for("can.meta");
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect.setKeyValue(obj, metaSymbol, meta);
	}

	return meta;
};

// this is a very simple can-map like object
var SimpleMap = Construct.extend("SimpleMap",
	{
		// ### setup
		// A setup function for the instantiation of a simple-map.
		setup: function(initialData){
			this._data = {};
			if(initialData && typeof initialData === "object") {
				this.attr(initialData);
			}
		},
		// ### attr
		// The main get/set interface simple-map.
		// Either sets or gets one or more properties depending on how it is called.
		attr: function(prop, value) {
			var self = this;

			if(arguments.length === 0 ) {
				ObservationRecorder.add(this,"can.keys");
				var data = {};
				canReflect.eachKey(this._data, function(value, prop){
					ObservationRecorder.add(this, prop);
					data[prop] = value;
				}, this);
				return data;
			}
			else if(arguments.length > 1) {
				var had = this._data.hasOwnProperty(prop);
				var old = this._data[prop];
				this._data[prop] = value;
				if(old !== value) {


					//!steal-remove-start
					if (true) {
						if (typeof this._log === "function") {
							this._log(prop, value, old);
						}
					}
					//!steal-remove-end

					var dispatched = {
						keyChanged: !had ? prop : undefined,
						type: prop
					};
					//!steal-remove-start
					if (true) {
						dispatched = {
							keyChanged: !had ? prop : undefined,
							type: prop,
							reasonLog: [ canReflect.getName(this) + "'s", prop, "changed to", value, "from", old ],
						};
					}
					//!steal-remove-end

					this.dispatch(dispatched, [value, old]);
				}

			}
			// 1 argument
			else if(typeof prop === 'object') {
				queues.batch.start();
				canReflect.eachKey(prop, function(value, key) {
					self.attr(key, value);
				});
				queues.batch.stop();
			}
			else {
				if(prop !== "constructor") {
					ObservationRecorder.add(this, prop);
					return this._data[prop];
				}

				return this.constructor;
			}
		},
		serialize: function(){
			return canReflect.serialize(this, Map);
		},
		get: function(){
			return this.attr.apply(this, arguments);
		},
		set: function(){
			return this.attr.apply(this, arguments);
		},
		// call `.log()` to log all property changes
		// pass a single property to only get logs for said property, e.g: `.log("foo")`
		log: function(key) {
			//!steal-remove-start
			if (true) {
				var quoteString = function quoteString(x) {
					return typeof x === "string" ? JSON.stringify(x) : x;
				};
				var meta = ensureMeta(this);
				meta.allowedLogKeysSet = meta.allowedLogKeysSet || new Set();

				if (key) {
					meta.allowedLogKeysSet.add(key);
				}

				this._log = function(prop, current, previous, log) {
					if (key && !meta.allowedLogKeysSet.has(prop)) {
						return;
					}
					dev.log(
						canReflect.getName(this),
						"\n key ", quoteString(prop),
						"\n is  ", quoteString(current),
						"\n was ", quoteString(previous)
					);
				};
			}
			//!steal-remove-end
		}
	}
);

eventQueue(SimpleMap.prototype);

var simpleMapProto = {
	// -type-
	"can.isMapLike": true,
	"can.isListLike": false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": SimpleMap.prototype.get,
	"can.setKeyValue": SimpleMap.prototype.set,
	"can.deleteKeyValue": function(prop) {
		var dispatched;
		if( this._data.hasOwnProperty(prop) ) {
			var old = this._data[prop];
			delete this._data[prop];

			//!steal-remove-start
			if (true) {
				if (typeof this._log === "function") {
					this._log(prop, undefined, old);
				}
			}
			//!steal-remove-end
			dispatched = {
				keyChanged: prop,
				type: prop
			};
			//!steal-remove-start
			if (true) {
				dispatched = {
					keyChanged: prop,
					type: prop,
					reasonLog: [ canReflect.getName(this) + "'s", prop, "deleted", old ]
				};
			}
			//!steal-remove-end
			this.dispatch(dispatched, [undefined, old]);
		}
	},


	// -shape
	"can.getOwnEnumerableKeys": function(){
		ObservationRecorder.add(this, 'can.keys');
		return Object.keys(this._data);
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		queues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.assignMap(this, source);
		queues.batch.stop();
	},
	"can.updateDeep": function(source){
		queues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect.updateMap(this, source);
		queues.batch.stop();
	},
	"can.keyHasDependencies": function(key) {
		return false;
	},
	"can.getKeyDependencies": function(key) {
		return undefined;
	},
	"can.hasOwnKey": function(key){
		return this._data.hasOwnProperty(key);
	}
};

//!steal-remove-start
if (true) {
	simpleMapProto["can.getName"] = function() {
		return canReflect.getName(this.constructor) + "{}";
	};
}
//!steal-remove-end
canReflect.assignSymbols(SimpleMap.prototype,simpleMapProto);

// Setup other symbols


module.exports = SimpleMap;


/***/ }),

/***/ "./node_modules/can-simple-observable/async/async.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-simple-observable/async/async.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var SettableObservable = __webpack_require__(/*! ../settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");

// This is an observable that is like `settable`, but passed a `resolve`
// function that can resolve the value of this observable late.
function AsyncObservable(fn, context, initialValue) {
	this.resolve = this.resolve.bind(this);
	this.lastSetValue = new SimpleObservable(initialValue);
	this.handler = this.handler.bind(this);

	function observe() {
		this.resolveCalled = false;

		// set inGetter flag to avoid calling `resolve` redundantly if it is called
		// synchronously in the getter
		this.inGetter = true;
		var newVal = fn.call(
			context,
			this.lastSetValue.get(),
			this.bound === true ? this.resolve : undefined
		);
		this.inGetter = false;

		// if the getter returned a value, resolve with the value
		if (newVal !== undefined) {
			this.resolve(newVal);
		}
		// otherwise, if `resolve` was called synchronously in the getter,
		// resolve with the value passed to `resolve`
		else if (this.resolveCalled) {
			this.resolve(this._value);
		}

		// if bound, the handlers will be called by `resolve`
		// returning here would cause a duplicate event
		if (this.bound !== true) {
			return newVal;
		}
	}

	//!steal-remove-start
	if (true) {
		canReflect.assignSymbols(this, {
			"can.getName": function() {
				return (
					canReflect.getName(this.constructor) +
					"<" +
					canReflect.getName(fn) +
					">"
				);
			}
		});
		Object.defineProperty(this.handler, "name", {
			value: canReflect.getName(this) + ".handler"
		});
		Object.defineProperty(observe, "name", {
			value: canReflect.getName(fn) + "::" + canReflect.getName(this.constructor)
		});
	}
	//!steal-remove-end

	this.observation = new Observation(observe, this);
}
AsyncObservable.prototype = Object.create(SettableObservable.prototype);
AsyncObservable.prototype.constructor = AsyncObservable;

AsyncObservable.prototype.handler = function(newVal) {
	if (newVal !== undefined) {
		SettableObservable.prototype.handler.apply(this, arguments);
	}
};

var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
AsyncObservable.prototype.activate = function() {
	canReflect.onValue(this.observation, this.handler, "notify");
	if (!this.resolveCalled) {
		this._value = peek(this.observation);
	}
};

AsyncObservable.prototype.resolve = function resolve(newVal) {
	this.resolveCalled = true;
	var old = this._value;
	this._value = newVal;

	//!steal-remove-start
	if (true) {
		if (typeof this._log === "function") {
			this._log(old, newVal);
		}
	}
	//!steal-remove-end

	// if resolve was called synchronously from the getter, do not enqueue changes
	// the observation will handle calling resolve again if required
	if (!this.inGetter) {
		var queuesArgs = [
		this.handlers.getNode([]),
			this,
			[newVal, old],
			null
		];
		//!steal-remove-start
		if (true) {
			queuesArgs = [
				this.handlers.getNode([]),
				this,
				[newVal, old],
				null
				/* jshint laxcomma: true */
				, [canReflect.getName(this), "resolved with", newVal]
				/* jshint laxcomma: false */
			];
		}
		//!steal-remove-end
		// adds callback handlers to be called w/i their respective queue.
		queues.enqueueByQueue.apply(queues, queuesArgs);
	}
};

module.exports = AsyncObservable;


/***/ }),

/***/ "./node_modules/can-simple-observable/can-simple-observable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-simple-observable/can-simple-observable.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var log = __webpack_require__(/*! ./log */ "./node_modules/can-simple-observable/log.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");

var dispatchSymbol = canSymbol.for("can.dispatch");

/**
 * @module {function} can-simple-observable
 * @parent can-observables
 * @collection can-infrastructure
 * @package ./package.json
 * @description Create an observable value.
 *
 * @signature `new SimpleObservable(initialValue)`
 *
 * Creates an observable value that can be read, written, and observed using [can-reflect].
 *
 * @param {*} initialValue The initial value of the observable.
 *
 * @return {can-simple-observable} An observable instance
 *
 * @body
 *
 * ## Use
 *
 * ```js
 *  var obs = new SimpleObservable('one');
 *
 *  canReflect.getValue(obs); // -> "one"
 *
 *  canReflect.setValue(obs, 'two');
 *  canReflect.getValue(obs); // -> "two"
 *
 *  function handler(newValue) {
 *    // -> "three"
 *  };
 *  canReflect.onValue(obs, handler);
 *  canReflect.setValue(obs, 'three');
 *
 *  canReflect.offValue(obs, handler);
 * ```
 */
function SimpleObservable(initialValue) {
	this._value = initialValue;
}

// mix in the value-like object event bindings
valueEventBindings(SimpleObservable.prototype);

canReflect.assignMap(SimpleObservable.prototype, {
	log: log,
	get: function(){
		ObservationRecorder.add(this);
		return this._value;
	},
	set: function(value){
		var old = this._value;
		this._value = value;

		this[dispatchSymbol](value, old);
	}
});
Object.defineProperty(SimpleObservable.prototype,"value",{
	set: function(value){
		return this.set(value);
	},
	get: function(){
		return this.get();
	}
});

var simpleObservableProto = {
	"can.getValue": SimpleObservable.prototype.get,
	"can.setValue": SimpleObservable.prototype.set,
	"can.isMapLike": false,
	"can.valueHasDependencies": function(){
		return true;
	}
};

//!steal-remove-start
if (true) {
	simpleObservableProto["can.getName"] = function() {
		var value = this._value;
		if (typeof value !== 'object' || value === null) {
			value = JSON.stringify(value);
		}
		else {
			value = '';
		}

		return canReflect.getName(this.constructor) + "<" + value + ">";
	};
}
//!steal-remove-end

canReflect.assignSymbols(SimpleObservable.prototype, simpleObservableProto);

module.exports = ns.SimpleObservable = SimpleObservable;


/***/ }),

/***/ "./node_modules/can-simple-observable/key/key.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-simple-observable/key/key.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canKey = __webpack_require__(/*! can-key */ "./node_modules/can-key/can-key.js");
var canKeyUtils = __webpack_require__(/*! can-key/utils */ "./node_modules/can-key/utils.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");

//!steal-remove-start
if (true) {
	var canReflectDependencies = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
}
//!steal-remove-end

module.exports = function keyObservable(root, keyPath) {
	var keyPathParts = canKeyUtils.parts(keyPath);
	var lastIndex = keyPathParts.length - 1;

	// Some variables used to build the dependency/mutation graph
	//!steal-remove-start
	if (true) {
		var lastKey;// This stores the last part of the keyPath, e.g. “key” in “outer.inner.key”
		var lastParent;// This stores the object that the last key is on, e.g. “outer.inner” in outer: {inner: {"key": "value"}}
	}
	//!steal-remove-end

	var observation = new Observation(function() {
		var value;

		// This needs to be walked every time because the objects along the key path might change
		canKey.walk(root, keyPathParts, function(keyData, i) {
			if (i === lastIndex) {
				//!steal-remove-start
				if (true) {
					// observation is mutating keyData.parent
					if (lastParent && (keyData.key !== lastKey || keyData.parent !== lastParent)) {
						canReflectDependencies.deleteMutatedBy(lastParent, lastKey, observation);
					}
					lastKey = keyData.key;
					lastParent = keyData.parent;
					canReflectDependencies.addMutatedBy(lastParent, lastKey, observation);
				}
				//!steal-remove-end

				value = keyData.value;
			}
		});

		return value;
	});

	// Function for setting the value
	var valueSetter = function(newVal) {
		canKey.set(root, keyPathParts, newVal);
	};

	// The `value` property getter & setter
	Object.defineProperty(observation, "value", {
		get: observation.get,
		set: valueSetter
	});

	var symbolsToAssign = {
		"can.setValue": valueSetter
	};

	//!steal-remove-start
	if (true) {

		// Debug name
		symbolsToAssign["can.getName"] = function getName() {
			var objectName = canReflect.getName(root);
			return "keyObservable<" + objectName + "." + keyPath + ">";
		};

		// Register what this observable changes
		symbolsToAssign["can.getWhatIChange"] = function getWhatIChange() {
			var m = new Map();
			var s = new Set();
			s.add(lastKey);
			m.set(lastParent, s);
			return {
				mutate: {
					keyDependencies: m
				}
			};
		};
	}
	//!steal-remove-end

	return canReflect.assignSymbols(observation, symbolsToAssign);
}


/***/ }),

/***/ "./node_modules/can-simple-observable/log.js":
/*!***************************************************!*\
  !*** ./node_modules/can-simple-observable/log.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

// when printing out strings to the console, quotes are not included which
// makes it confusing to tell the actual output from static string messages
function quoteString(x) {
	return typeof x === "string" ? JSON.stringify(x) : x;
}

// To add the `.log` function to a observable
// a.- Add the log function to the propotype:
//	   `Observable.propotype.log = log`
// b.- Make sure `._log` is called by the observable when mutation happens
//     `_.log` should be passed the current value and the value before the mutation
module.exports = function log() {
	//!steal-remove-start
	if (true) {
		this._log = function(previous, current) {
			dev.log(
				canReflect.getName(this),
				"\n is  ", quoteString(current),
				"\n was ", quoteString(previous)
			);
		};
	}
	//!steal-remove-end
};


/***/ }),

/***/ "./node_modules/can-simple-observable/make-compute/make-compute.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-simple-observable/make-compute/make-compute.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Compute = function(newVal) {
	if (arguments.length) {
		return canReflect.setValue(this, newVal);
	} else {
		return canReflect.getValue(this);
	}
};

var translationHelpers = new WeakMap();

module.exports = function(observable) {
	var compute = Compute.bind(observable);
	compute.on = compute.bind = compute.addEventListener = function(
		event,
		handler
	) {
		var translationHandler = translationHelpers.get(handler);
		if (!translationHandler) {
			translationHandler = function(newVal, oldVal) {
				handler.call(compute, { type: "change" }, newVal, oldVal);
			};
			//!steal-remove-start
			if (true) {
				Object.defineProperty(translationHandler, "name", {
					value:
						"translationHandler(" +
						event +
						")::" +
						canReflect.getName(observable) +
						".onValue(" +
						canReflect.getName(handler) +
						")"
				});
			}
			//!steal-remove-end
			translationHelpers.set(handler, translationHandler);
		}
		canReflect.onValue(observable, translationHandler);
	};
	compute.off = compute.unbind = compute.removeEventListener = function(
		event,
		handler
	) {
		canReflect.offValue(observable, translationHelpers.get(handler));
	};

	canReflect.assignSymbols(compute, {
		"can.getValue": function() {
			return canReflect.getValue(observable);
		},
		"can.setValue": function(newVal) {
			return canReflect.setValue(observable, newVal);
		},
		"can.onValue": function(handler, queue) {
			return canReflect.onValue(observable, handler, queue);
		},
		"can.offValue": function(handler, queue) {
			return canReflect.offValue(observable, handler, queue);
		},
		"can.valueHasDependencies": function() {
			return canReflect.valueHasDependencies(observable);
		},
		"can.getPriority": function() {
			return canReflect.getPriority(observable);
		},
		"can.setPriority": function(newPriority) {
			canReflect.setPriority(observable, newPriority);
		},
		"can.isValueLike": true,
		"can.isFunctionLike": false
	});
	compute.isComputed = true;
	return compute;
};


/***/ }),

/***/ "./node_modules/can-simple-observable/resolver/resolver.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-simple-observable/resolver/resolver.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var mapEventBindings = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");
var SettableObservable = __webpack_require__(/*! ../settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");

var getChangesSymbol = canSymbol.for("can.getChangesDependencyRecord");
var metaSymbol = canSymbol.for("can.meta");

function ResolverObservable(resolver, context, initialValue, options) {
	// we don't want reads leaking out.  We should be binding to all of this ourselves.
	this.resolver = ObservationRecorder.ignore(resolver);
	this.context = context;
	this._valueOptions = {
		resolve: this.resolve.bind(this),
		listenTo: this.listenTo.bind(this),
		stopListening: this.stopListening.bind(this),
		lastSet: new SimpleObservable(initialValue)
	};

	this.update = this.update.bind(this);

	this.contextHandlers = new WeakMap();
	this.teardown = null;
	// a place holder for remembering where we bind
	this.binder = {};
	//!steal-remove-start
	if (true) {
		canReflect.assignSymbols(this, {
			"can.getName": function() {
				return (
					canReflect.getName(this.constructor) +
					"<" +
					canReflect.getName(resolver) +
					">"
				);
			}
		});
		Object.defineProperty(this.update, "name", {
			value: canReflect.getName(this) + ".update"
		});

		canReflect.assignSymbols(this._valueOptions.lastSet, {
			"can.getName": function() {
				return (
					canReflect.getName(this.constructor)  +"::lastSet"+
					"<" +
					canReflect.getName(resolver) +
					">"
				);
			}
		});
	}
	//!steal-remove-end

	this[metaSymbol] = canReflect.assignMap({}, options);
}
ResolverObservable.prototype = Object.create(SettableObservable.prototype);

function deleteHandler(bindTarget, event, queue, handler){
	mapEventBindings.off.call(bindTarget, event, handler, queue);
}

canReflect.assignMap(ResolverObservable.prototype, {
	constructor: ResolverObservable,
	listenTo: function(bindTarget, event, handler, queueName) {
		//Object.defineProperty(this.handler, "name", {
		//	value: canReflect.getName(this) + ".handler"
		//});
		if(canReflect.isPrimitive(bindTarget)) {
			handler = event;
			event = bindTarget;
			bindTarget = this.context;
		}
		if(typeof event === "function") {
			handler = event;
			event = undefined;
		}

		var resolverInstance = this;

		//!steal-remove-start
		if (true) {
			if(!handler.name) {
				Object.defineProperty(handler, "name", {
					value:
						(bindTarget ?
							 canReflect.getName(bindTarget) : "")+
						 (event ? ".on('"+event+"',handler)" : ".on(handler)")+
						 "::"+canReflect.getName(this)
				});
			}
		}
		//!steal-remove-end

		var contextHandler = handler.bind(this.context);
		contextHandler[getChangesSymbol] = function getChangesDependencyRecord() {
			var s = new Set();
			s.add(resolverInstance);
			return {
				valueDependencies: s
			};
		};

		this.contextHandlers.set(handler, contextHandler);
		mapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || "notify");
	},
	stopListening: function(){

		var meta = this.binder[canSymbol.for("can.meta")];
		var listenHandlers = meta && meta.listenHandlers;
		if(listenHandlers) {
			var keys = mapEventBindings.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: "notify"});

			listenHandlers.delete(keys, deleteHandler);
		}
		return this;
	},
	resolve: function(newVal) {
		this._value = newVal;
		// if we are setting up the initial binding and we get a resolved value
		// do not emit events for it.

		if(this.isBinding) {
			this.lastValue = this._value;
			return newVal;
		}

		if(this._value !== this.lastValue) {
			var enqueueMeta  = {};

			//!steal-remove-start
			if (true) {
				/* jshint laxcomma: true */
				enqueueMeta = {
					log: [canReflect.getName(this.update)],
					reasonLog: [canReflect.getName(this), "resolved with", newVal]
				};
				/* jshint laxcomma: false */
			}
			//!steal-remove-end

			queues.batch.start();
			queues.deriveQueue.enqueue(
				this.update,
				this,
				[],
				enqueueMeta
			);
			queues.batch.stop();
		}
		return newVal;
	},
	update: function(){

		if(this.lastValue !== this._value) {

			var old = this.lastValue;
			this.lastValue = this._value;
			//!steal-remove-start
			if (true) {
				if (typeof this._log === "function") {
					this._log(old, this._value);
				}
			}
			//!steal-remove-end

			// adds callback handlers to be called w/i their respective queue.
			queues.enqueueByQueue(
				this.handlers.getNode([]),
				this,
				[this._value, old]
			);
		}
	},
	activate: function() {
		this.isBinding = true;
		this.teardown = this.resolver.call(this.context, this._valueOptions);
		this.isBinding = false;
	},
	onUnbound: function() {
		this.bound = false;
		mapEventBindings.stopListening.call(this.binder);
		if(this.teardown != null) {
			this.teardown();
			this.teardown = null;
		}
	},
	set: function(value) {
		this._valueOptions.lastSet.set(value);

		/*if (newVal !== this.lastSetValue.get()) {
			this.lastSetValue.set(newVal);
		}*/
	},
	get: function() {
		if (ObservationRecorder.isRecording()) {
			ObservationRecorder.add(this);
			if (!this.bound) {
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this._value;
		} else {
			if (this[metaSymbol].resetUnboundValueInGet) {
				this._value = undefined;
			}

			var handler = function(){};
			this.on(handler);
			var val = this._value;
			this.off(handler);
			return val;
		}
	},
	hasDependencies: function hasDependencies() {
		var hasDependencies = false;

		if (this.bound) {
			var meta = this.binder[metaSymbol];
			var listenHandlers = meta && meta.listenHandlers;
			hasDependencies = !!listenHandlers.size();
		}

		return hasDependencies;
	},
	getValueDependencies: function getValueDependencies() {
		if (this.bound) {
			var meta = this.binder[canSymbol.for("can.meta")];
			var listenHandlers = meta && meta.listenHandlers;

			var keyDeps = new Map();
			var valueDeps = new Set();

			if (listenHandlers) {
				canReflect.each(listenHandlers.root, function(events, obj) {
					canReflect.each(events, function(queues, eventName) {
						if (eventName === undefined) {
							valueDeps.add(obj);
						} else {
							var entry = keyDeps.get(obj);
							if (!entry) {
								entry = new Set();
								keyDeps.set(obj, entry);
							}
							entry.add(eventName);
						}
					});
				});

				if (valueDeps.size || keyDeps.size) {
					var result = {};

					if (keyDeps.size) {
						result.keyDependencies = keyDeps;
					}
					if (valueDeps.size) {
						result.valueDependencies = valueDeps;
					}

					return result;
				}
			}
		}
	}
});

canReflect.assignSymbols(ResolverObservable.prototype, {
	"can.getValue": ResolverObservable.prototype.get,
	"can.setValue": ResolverObservable.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		// TODO: the priority should come from any underlying values
		return this.priority || 0;
	},
	"can.setPriority": function(newPriority) {
		this.priority = newPriority;
	},
	"can.valueHasDependencies": ResolverObservable.prototype.hasDependencies,
	"can.getValueDependencies": ResolverObservable.prototype.getValueDependencies
});


module.exports = ResolverObservable;


/***/ }),

/***/ "./node_modules/can-simple-observable/settable/settable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-simple-observable/settable/settable.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var log = __webpack_require__(/*! ../log */ "./node_modules/can-simple-observable/log.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");

var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));

// This supports an "internal" settable value that the `fn` can derive its value from.
// It's useful to `can-define`.
// ```
// new SettableObservable(function(lastSet){
//   return lastSet * 5;
// }, null, 5)
// ```
function SettableObservable(fn, context, initialValue) {

	this.lastSetValue = new SimpleObservable(initialValue);
	function observe() {
		return fn.call(context, this.lastSetValue.get());
	}
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	if (true) {
		canReflect.assignSymbols(this, {
			"can.getName": function() {
				return (
					canReflect.getName(this.constructor) +
					"<" +
					canReflect.getName(fn) +
					">"
				);
			}
		});
		Object.defineProperty(this.handler, "name", {
			value: canReflect.getName(this) + ".handler"
		});
		Object.defineProperty(observe, "name", {
			value: canReflect.getName(fn) + "::" + canReflect.getName(this.constructor)
		});
	}
	//!steal-remove-end

	this.observation = new Observation(observe, this);
}

valueEventBindings(SettableObservable.prototype);

canReflect.assignMap(SettableObservable.prototype, {
	// call `obs.log()` to log observable changes to the browser console
	// The observable has to be bound for `.log` to be called
	log: log,
	constructor: SettableObservable,
	handler: function(newVal) {
		var old = this._value, reasonLog;
		this._value = newVal;

		//!steal-remove-start
		if (true) {
			if (typeof this._log === "function") {
				this._log(old, newVal);
			}
			reasonLog = [canReflect.getName(this),"set to", newVal, "from", old];
		}
		//!steal-remove-end

		// adds callback handlers to be called w/i their respective queue.
		queues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[newVal, old],
			null,
			reasonLog
		);
	},
	onBound: function() {
		// onBound can be called by `.get` and then later called through
		// a keyTree binding.
		if(!this.bound) {
			this.bound = true;
			this.activate();
		}
	},
	activate: function(){
		canReflect.onValue(this.observation, this.handler, "notify");
		this._value = peek(this.observation);
	},
	onUnbound: function() {
		this.bound = false;
		canReflect.offValue(this.observation, this.handler, "notify");
	},
	set: function(newVal) {
		var oldVal =  this.lastSetValue.get();

		if (
			canReflect.isObservableLike(oldVal) &&
			canReflect.isValueLike(oldVal) &&
			!canReflect.isObservableLike(newVal)
		) {
			canReflect.setValue(oldVal, newVal);
		} else {
			if (newVal !== oldVal) {
				this.lastSetValue.set(newVal);
			}
		}
	},
	get: function() {
		if (ObservationRecorder.isRecording()) {
			ObservationRecorder.add(this);
			if (!this.bound) {
				// proactively setup bindings
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this._value;
		} else {
			return this.observation.get();
		}
	},
	hasDependencies: function() {
		return canReflect.valueHasDependencies(this.observation);
	},
	getValueDependencies: function() {
		return canReflect.getValueDependencies(this.observation);
	}
});

Object.defineProperty(SettableObservable.prototype,"value",{
	set: function(value){
		return this.set(value);
	},
	get: function(){
		return this.get();
	}
});

canReflect.assignSymbols(SettableObservable.prototype, {
	"can.getValue": SettableObservable.prototype.get,
	"can.setValue": SettableObservable.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		return canReflect.getPriority(this.observation);
	},
	"can.setPriority": function(newPriority) {
		canReflect.setPriority(this.observation, newPriority);
	},
	"can.valueHasDependencies": SettableObservable.prototype.hasDependencies,
	"can.getValueDependencies": SettableObservable.prototype.getValueDependencies
});

module.exports = SettableObservable;


/***/ }),

/***/ "./node_modules/can-simple-observable/setter/setter.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-simple-observable/setter/setter.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var SettableObservable = __webpack_require__(/*! ../settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var setElementSymbol = canSymbol.for("can.setElement");

// SetterObservable's call a function when set. Their getter is backed up by an
// observation.
function SetterObservable(getter, setter) {
	this.setter = setter;
	this.observation = new Observation(getter);
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	if (true) {
		canReflect.assignSymbols(this, {
			"can.getName": function() {
				return (
					canReflect.getName(this.constructor) +
					"<" +
					canReflect.getName(getter) +
					">"
				);
			}
		});
		Object.defineProperty(this.handler, "name", {
			value: canReflect.getName(this) + ".handler"
		});
	}
	//!steal-remove-end
}

SetterObservable.prototype = Object.create(SettableObservable.prototype);
SetterObservable.prototype.constructor = SetterObservable;
SetterObservable.prototype.set = function(newVal) {
	this.setter(newVal);
};
SetterObservable.prototype.hasDependencies = function() {
	return canReflect.valueHasDependencies(this.observation);
};
canReflect.assignSymbols(SetterObservable.prototype, {
	"can.setValue": SetterObservable.prototype.set,
	"can.valueHasDependencies": SetterObservable.prototype.hasDependencies,
	"can.setElement": function(el) {
		this.observation[setElementSymbol](el);
	}
});

module.exports = SetterObservable;


/***/ }),

/***/ "./node_modules/can-single-reference/can-single-reference.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-single-reference/can-single-reference.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var CID = __webpack_require__(/*! can-cid */ "./node_modules/can-cid/can-cid.js");

var singleReference;

function getKeyName(key, extraKey) {
	var keyName = extraKey ? CID(key) + ":" + extraKey : CID(key);
	return keyName || key;
}

// weak maps are slow
/* if(typeof WeakMap !== "undefined") {
	var globalMap = new WeakMap();
	singleReference = {
		set: function(obj, key, value){
			var localMap = globalMap.get(obj);
			if( !localMap ) {
				globalMap.set(obj, localMap = new WeakMap());
			}
			localMap.set(key, value);
		},
		getAndDelete: function(obj, key){
			return globalMap.get(obj).get(key);
		},
		references: globalMap
	};
} else {*/
singleReference = {
	// obj is a function ... we need to place `value` on it so we can retreive it
	// we can't use a global map
	set: function(obj, key, value, extraKey){
		// check if it has a single reference map
		obj[getKeyName(key, extraKey)] = value;
	},

	getAndDelete: function(obj, key, extraKey){
		var keyName = getKeyName(key, extraKey);
		var value = obj[keyName];
		delete obj[keyName];
		return value;
	}
};
/*}*/

module.exports = singleReference;


/***/ }),

/***/ "./node_modules/can-stache-ast/can-stache-ast.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache-ast/can-stache-ast.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var controls = __webpack_require__(/*! ./controls */ "./node_modules/can-stache-ast/controls.js");
var parser = __webpack_require__(/*! can-view-parser */ "./node_modules/can-view-parser/can-view-parser.js");

exports.parse = function(filename, source){
	if (arguments.length === 1) {
		source = arguments[0];
		filename = undefined;
	}

	var template = source;
	template = controls.cleanWhitespaceControl(template);
	template = controls.cleanLineEndings(template);

	var imports = [],
		dynamicImports = [],
		importDeclarations = [],
		ases = {},
		attributes = new Map(),
		inImport = false,
		inFrom = false,
		inAs = false,
		isUnary = false,
		importIsDynamic = false,
		currentAs = "",
		currentFrom = "",
		currentAttrName = null;

	function processImport(line) {
		if(currentAs) {
			ases[currentAs] = currentFrom;
			currentAs = "";
		}
		if(importIsDynamic) {
			dynamicImports.push(currentFrom);
		} else {
			imports.push(currentFrom);
		}
		importDeclarations.push({
			specifier: currentFrom,
			loc: {
				line: line
			},
			attributes: attributes
		});

		// Reset this scope value so that the next import gets new attributes.
		attributes = new Map();
	}

	var program = parser(template, {
		filename: filename,
		start: function( tagName, unary ){
			if(tagName === "can-import") {
				isUnary = unary;
				importIsDynamic = false; // assume static import unless there is content (chars/tags/special).
				inImport = true;
			} else if(tagName === "can-dynamic-import") {
				isUnary = unary;
				importIsDynamic = true;
				inImport = true;
			} else if(inImport) {
				importIsDynamic = true;  // found content inside can-import tag.
				inImport = false;
			}
		},
		attrStart: function( attrName ){
			currentAttrName = attrName;
			// Default to a boolean attribute, the attrValue hook will replace that.
			attributes.set(currentAttrName, true);

			if(attrName === "from") {
				inFrom = true;
			} else if(attrName === "as" || attrName === "export-as") {
				inAs = true;
			}
		},
		attrEnd: function( attrName ){
			if(attrName === "from") {
				inFrom = false;
			} else if(attrName === "as" || attrName === "export-as") {
				inAs = false;
			}
		},
		attrValue: function( value ){
			if(inImport) {
				attributes.set(currentAttrName, value);
			}
			if(inFrom && inImport) {
				currentFrom = value;
			} else if(inAs && inImport) {
				currentAs = value;
			}
		},
		end: function(tagName, unary, line){
			if((tagName === "can-import" || tagName === "can-dynamic-import") && isUnary) {
				processImport(line);
			}
		},
		close: function(tagName, unary, line){
			if((tagName === "can-import" || tagName === "can-dynamic-import")) {
				processImport(line);
			}
		},
		chars: function(text) {
			if(text.trim().length > 0) {
				importIsDynamic = true;
			}
		},
		special: function() {
			importIsDynamic = true;
		}
	}, true);

	return {
		intermediate: program,
		program: program,
		imports: imports,
		dynamicImports: dynamicImports,
		importDeclarations: importDeclarations,
		ases: ases,
		exports: ases
	};
};


/***/ }),

/***/ "./node_modules/can-stache-ast/controls.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache-ast/controls.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g,
	mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g;

function splitModeFromExpression(expression, state){
	expression = expression.trim();
	var mode = expression.charAt(0);

	if( "#/{&^>!<".indexOf(mode) >= 0 ) {
		expression =  expression.substr(1).trim();
	} else {
		mode = null;
	}
	// Triple braces do nothing within a tag.
	if(mode === "{" && state.node) {
		mode = null;
	}
	return {
		mode: mode,
		expression: expression
	};
}

function cleanLineEndings(template) {
		// Finds mustache tags with space around them or no space around them.
		return template.replace( mustacheLineBreakRegExp,
			function(whole,
				returnBefore,
				spaceBefore,
				special,
				expression,
				spaceAfter,
				returnAfter,
				// A mustache magic tag that has no space around it.
				spaceLessSpecial,
				spaceLessExpression,
				matchIndex){

			// IE 8 will provide undefined
			spaceAfter = (spaceAfter || "");
			returnBefore = (returnBefore || "");
			spaceBefore = (spaceBefore || "");

			var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});

			// If it's a partial or tripple stache, leave in place.
			if(spaceLessSpecial || ">{".indexOf( modeAndExpression.mode) >= 0) {
				return whole;
			}  else if( "^#!/".indexOf(  modeAndExpression.mode ) >= 0 ) {
				// Return the magic tag and a trailing linebreak if this did not
				// start a new line and there was an end line.
				// Add a normalized leading space, if there was any leading space, in case this abuts a tag name
				spaceBefore = (returnBefore + spaceBefore) && " ";
				return spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+"\n" :"");


			} else {
				// There is no mode, return special with spaces around it.
				return spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+"\n" : "");
			}
		});
}

function whiteSpaceReplacement(
	whole,
	spaceBefore,
	bracketBefore,
	controlBefore,
	expression,
	controlAfter,
	bracketAfter,
	spaceAfter
) {

	if (controlBefore === '-') {
		spaceBefore = '';
	}

	if (controlAfter === '-') {
		spaceAfter = '';
	}

	return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
}

function cleanWhitespaceControl(template) {
	return template.replace(mustacheWhitespaceRegExp, whiteSpaceReplacement);
}

exports.cleanLineEndings = cleanLineEndings;
exports.cleanWhitespaceControl = cleanWhitespaceControl;


/***/ }),

/***/ "./node_modules/can-stache-bindings/can-stache-bindings.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-stache-bindings/can-stache-bindings.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # can-stache-bindings.js
//
// This module provides CanJS's default data and event bindings.
// It's broken up into several parts:
//
// - Behaviors - Binding behaviors that run given an attribute or element.
// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.
// - getObservableFrom - Methods that return a observable cross bound to the scope, viewModel, or element.
// - bind - Methods for setting up cross binding
// - getBindingInfo - A helper that returns the details of a data binding given an attribute.
// - makeDataBinding - A helper method for setting up a data binding.
// - initializeValues - A helper that initializes a data binding.
var Bind = __webpack_require__(/*! can-bind */ "./node_modules/can-bind/can-bind.js");
var expression = __webpack_require__(/*! can-stache/src/expression */ "./node_modules/can-stache/src/expression.js");
var canViewModel = __webpack_require__(/*! can-view-model */ "./node_modules/can-view-model/can-view-model.js");
var stacheKey = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domData = __webpack_require__(/*! can-dom-data */ "./node_modules/can-dom-data/can-dom-data.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
var encoder = __webpack_require__(/*! can-attribute-encoder */ "./node_modules/can-attribute-encoder/can-attribute-encoder.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");
var SettableObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ "./node_modules/can-simple-observable/setter/setter.js");
var AttributeObservable = __webpack_require__(/*! can-attribute-observable */ "./node_modules/can-attribute-observable/can-attribute-observable.js");
var makeCompute = __webpack_require__(/*! can-view-scope/make-compute-like */ "./node_modules/can-view-scope/make-compute-like.js");

var canEventQueue = __webpack_require__(/*! can-event-queue/map/map */ "./node_modules/can-event-queue/map/map.js");

// Contains all of the stache bindings that will be exported.
var bindings = new Map();

var onMatchStr = "on:",
	vmMatchStr = "vm:",
	elMatchStr = "el:",
	byMatchStr = ":by:",
	toMatchStr = ":to",
	fromMatchStr = ":from",
	bindMatchStr = ":bind",
	viewModelBindingStr = "viewModel",
	attributeBindingStr = "attribute",
	scopeBindingStr = "scope",
	viewModelOrAttributeBindingStr = "viewModelOrAttribute",
	viewModelSymbol = canSymbol.for("can.viewModel"),
	preventDataBindingsSymbol = canSymbol.for("can.preventDataBindings");

var throwOnlyOneTypeOfBindingError = function() {
	throw new Error("can-stache-bindings - you can not have contextual bindings ( this:from='value' ) and key bindings ( prop:from='value' ) on one element.");
};

// This function checks if there bindings that are trying
// to set a property ON the viewModel _conflicting_ with bindings trying to
// set THE viewModel ITSELF.
// If there is a conflict, an error is thrown.
var checkBindingState = function(bindingState, siblingBindingData) {
	var isSettingOnViewModel = siblingBindingData.parent.exports && siblingBindingData.child.source === viewModelBindingStr;
	if (isSettingOnViewModel) {
		var bindingName = siblingBindingData.child.name;
		var isSettingViewModel = isSettingOnViewModel && ( bindingName === 'this' || bindingName === '.' );

		if (isSettingViewModel) {
			if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
				throwOnlyOneTypeOfBindingError();
			} else {
				return {
					isSettingViewModel: true,
					initialViewModelData: undefined
				};
			}
		} else {
			// just setting on viewModel
			if (bindingState.isSettingViewModel) {
				throwOnlyOneTypeOfBindingError();
			} else {
				return {
					isSettingOnViewModel: true,
					initialViewModelData: bindingState.initialViewModelData
				};
			}
		}
	} else {
		return bindingState;
	}
};

var getEventBindingData = function (attributeName, el, scope) {
	var bindingCode = attributeName.substr(onMatchStr.length);
	var viewModel = el && el[viewModelSymbol];
	var elUsed = startsWith.call(bindingCode, elMatchStr);
	var vmUsed = startsWith.call(bindingCode, vmMatchStr);
	var byUsed = bindingCode.indexOf(byMatchStr) > -1;
	var scopeUsed;

	// The values being returned
	var bindingContext;
	var eventName;
	var bindingContextObservable;
	var shortBindingCode = "";

	// if explicit context is specified, trim the string down
	// else, determine value of which scope being used elUsed, vmUsed, scopeUsed
	if (vmUsed) {
		shortBindingCode = "vm";
		bindingCode = bindingCode.substr(vmMatchStr.length);
	} else if (elUsed) {
		shortBindingCode = "el";
		bindingCode = bindingCode.substr(elMatchStr.length);
	} else if (!vmUsed && !elUsed) {
		if (byUsed) {
			scopeUsed = true;
		} else if (viewModel)  {
			vmUsed = true;
		} else {
			elUsed = true;
		}
	}

	// if by is used, take the appropriate path to determine the bindingContext
	// and create the bindingKeyValue
	var bindingContextKey;
	if (byUsed) {
		var byIndex = bindingCode.indexOf(byMatchStr);
		bindingContextKey = bindingCode.substr(byIndex + byMatchStr.length);
		bindingCode = bindingCode.substr(0, byIndex);
	}
	eventName = bindingCode;
	if (elUsed) {
		if (byUsed) {
			throw new Error('binding with :by in element scope is not currently supported');
		} else {
			bindingContext = el;
		}
	} else if (vmUsed) {
		bindingContext = viewModel;
		if (byUsed) {
			bindingContext = viewModel.get(bindingContextKey);
			bindingContextObservable = new Scope(viewModel).computeData(bindingContextKey);
		}
	} else if (scopeUsed) {
		bindingContext = scope;
		if (byUsed) {
			bindingContext = bindingContext.get(bindingContextKey);
			bindingContextObservable = scope.computeData(bindingContextKey);
		}
	}

	return {
		// single observable object to listen to eventName directly on one observable object
		bindingContext: bindingContext,
		// this observable emits the bindingContext
		bindingContextObservable: bindingContextObservable,
		// the eventName string
		eventName: eventName,
		// which binding code was explicitly set by the user
		bindingCode: shortBindingCode,
	};
};

var onKeyValueSymbol = canSymbol.for("can.onKeyValue");
var makeScopeFromEvent = function(element, event, viewModel, args, data, bindingContext){
	// TODO: Remove in 6.0.  In 4 and 5 arguments were wrong.
	var shiftArgumentsForLegacyArguments = bindingContext && bindingContext[onKeyValueSymbol] !== undefined;

	var specialValues = {
		element: element,
		event: event,
		viewModel: viewModel,
		arguments: shiftArgumentsForLegacyArguments ? Array.prototype.slice.call(args, 1) : args,
		args: args
	};

	// make a scope with these things just under
	return data.scope.add(specialValues, { special: true });
};

var runEventCallback = function (el, ev, data, scope, expr, attributeName, attrVal) {
	// create "special" values that can be looked up using
	// {{scope.element}}, etc

	var updateFn = function() {
		var value = expr.value(scope, {
			doNotWrapInObservation: true
		});

		value = canReflect.isValueLike(value) ?
			canReflect.getValue(value) :
			value;

		return typeof value === 'function' ?
			value(el) :
			value;
	};
	//!steal-remove-start
	if (true) {
		Object.defineProperty(updateFn, "name", {
			value: attributeName + '="' + attrVal + '"'
		});
	}
	//!steal-remove-end

	queues.batch.start();
	var mutateQueueArgs = [];
	mutateQueueArgs = [
		updateFn,
		null,
		null,
		{}
	];
	//!steal-remove-start
	if (true) {
		mutateQueueArgs = [
			updateFn,
			null,
			null, {
				reasonLog: [el, ev, attributeName+"="+attrVal]
			}
		];
	}
	//!steal-remove-end
	queues.mutateQueue.enqueue.apply(queues.mutateQueue, mutateQueueArgs);
	queues.batch.stop();
};

// ## Behaviors
var behaviors = {
	// ## completeBindings
	// Given a list of bindings, initializes the bindings, then the viewModel then completes the bindings.
	// Arguments:
	// - bindings  - An array of `{binding, siblingBindingData}`
	// - initialViewModelData - Extra initial viewModel values
	// - makeViewModel - `makeViewModel(props, hasBindings, bindingsState)`
	// - bindingContext - optional, `{scope}`
	// Returns:
	// `{viewModel, onTeardowns, bindingsState}`
	initializeViewModel: function(bindings, initialViewModelData, makeViewModel, bindingContext) {

		var onCompleteBindings = [],
			onTeardowns = {};

		var bindingsState = {
			// if we have a binding like {something}="foo"
			isSettingOnViewModel: false,
			// if we have binding like {this}="bar"
			isSettingViewModel: false,
			initialViewModelData: initialViewModelData || {}
		};

		bindings.forEach(function(dataBinding){
			// Immediately bind to the parent so we can read its value
			dataBinding.binding.startParent();

			var siblingBindingData = dataBinding.siblingBindingData;
			bindingsState = checkBindingState(bindingsState, siblingBindingData);

			// For bindings that change the viewModel,
			// save the initial value on the viewModel.
			if (siblingBindingData.parent.exports) {

				var parentValue = siblingBindingData.child.setCompute ? makeCompute(dataBinding.binding.parent) : dataBinding.binding.parentValue;

				if (parentValue !== undefined) {

					if (bindingsState.isSettingViewModel) {
						// the initial data is the context
						// TODO: this is covered by can-component’s tests but not can-stache-bindings’ tests
						bindingsState.initialViewModelData = parentValue;
					} else {
						bindingsState.initialViewModelData[cleanVMName(siblingBindingData.child.name, bindingContext.scope)] = parentValue;
					}

				}
			}

			// Save what needs to happen after the `viewModel` is created.
			onCompleteBindings.push(dataBinding.binding.start.bind(dataBinding.binding));

			onTeardowns[siblingBindingData.bindingAttributeName] = dataBinding.binding.stop.bind(dataBinding.binding);
		});

		var viewModel = makeViewModel(bindingsState.initialViewModelData, bindings.length > 0, bindingsState);

		// bind on the viewModel so we can updat ethe parent
		for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
			onCompleteBindings[i]();
		}
		return {viewModel: viewModel, onTeardowns: onTeardowns, bindingsState: bindingsState};
	},
	// ### bindings.behaviors.viewModel
	// Sets up all of an element's data binding attributes to a "soon-to-be-created"
	// `viewModel`.
	// This is primarily used by `Component` to ensure that its
	// `viewModel` is initialized with values from the data bindings as quickly as possible.
	// Component could look up the data binding values itself.  However, that lookup
	// would have to be duplicated when the bindings are established.
	// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`
	// after scope values have been looked up.
	//
	// Arguments:
	// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.
	// - `initialViewModelData` any initial data that should already be added to the `viewModel`.
	//
	// Returns:
	// - `function` - a function that tears all the bindings down. Component
	// wants all the bindings active so cleanup can be done during a component being removed.
	viewModel: function(el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {

		var attributeViewModelBindings = assign({}, initialViewModelData),

			// The data around the binding.
			bindingContext = assign({
				element: el,
				// this gets defined later
				viewModel: undefined
			}, tagData),

			// global settings for the bindings
			bindingSettings = {
				attributeViewModelBindings: attributeViewModelBindings,
				alreadyUpdatedChild: true,
				// force viewModel bindings in cases when it is ambiguous whether you are binding
				// on viewModel or an attribute (:to, :from, :bind)
				favorViewModel: true
			},
			dataBindings = [];

		// For each attribute, we create a dataBinding object.
		// These look like: `{binding, siblingBindingData}`
		canReflect.eachListLike(el.attributes || [], function(node) {
			var dataBinding = makeDataBinding(node, bindingContext, bindingSettings);

			if (dataBinding) {
				dataBindings.push(dataBinding);
			}
		});

		// If there are no binding, exit.
		if (staticDataBindingsOnly && dataBindings.length === 0) {
			return;
		}

		// Initialize the viewModel
		var completedData = behaviors.initializeViewModel(dataBindings, initialViewModelData, function(){
			// we need to make sure we have the viewModel available
			bindingContext.viewModel = makeViewModel.apply(this, arguments);
		}, bindingContext),
			onTeardowns = completedData.onTeardowns,
			bindingsState = completedData.bindingsState,
			siblingBindingDatas = {};


		// Listen to attribute changes and re-initialize
		// the bindings.
		var attributeDisposal;
		if (!bindingsState.isSettingViewModel) {
			// We need to update the child on any new bindings.
			bindingSettings.alreadyUpdatedChild = false;
			attributeDisposal = domMutate.onNodeAttributeChange(el, function(ev) {
				var attrName = ev.attributeName,
					value = el.getAttribute(attrName);

				if (onTeardowns[attrName]) {
					onTeardowns[attrName]();
				}
				// Parent attribute bindings we always re-setup.
				var parentBindingWasAttribute = siblingBindingDatas[attrName] && siblingBindingDatas[attrName].parent.source === attributeBindingStr;

				if (value !== null || parentBindingWasAttribute) {
					var dataBinding = makeDataBinding({
						name: attrName,
						value: value
					}, bindingContext, bindingSettings);
					if (dataBinding) {
						// The viewModel is created, so call callback immediately.
						dataBinding.binding.start();
						siblingBindingDatas[attrName] = dataBinding.siblingBindingData;
						onTeardowns[attrName] = dataBinding.binding.stop.bind(dataBinding.binding);
					}
				}
			});
		}

		return function() {
			if (attributeDisposal) {
				attributeDisposal();
				attributeDisposal = undefined;
			}
			for (var attrName in onTeardowns) {
				onTeardowns[attrName]();
			}
		};
	},
	// ### bindings.behaviors.data
	// This is called when an individual data binding attribute is placed on an element.
	// For example `{^value}="name"`.
	data: function(el, attrData) {
		if (el[preventDataBindingsSymbol] === true || domData.get(el, "preventDataBindings")) {
			return;
		}
		var viewModel,
			getViewModel = ObservationRecorder.ignore(function() {
				return viewModel || (viewModel = canViewModel(el));
			}),
			teardown,
			attributeDisposal,
			removedDisposal,
			bindingContext = {
				element: el,
				templateType: attrData.templateType,
				scope: attrData.scope,
				parentNodeList: attrData.nodeList,
				get viewModel(){
					return getViewModel();
				}
			};

		// Setup binding
		var dataBinding = makeDataBinding({
			name: attrData.attributeName,
			value: el.getAttribute(attrData.attributeName),
		}, bindingContext, {
			syncChildWithParent: false
		});

		//!steal-remove-start
		if (true) {
			if (dataBinding.siblingBindingData.child.source === "viewModel" && !domData.get(el, "viewModel")) {
				dev.warn('This element does not have a viewModel. (Attempting to bind `' + dataBinding.siblingBindingData.bindingAttributeName + '="' + dataBinding.siblingBindingData.parent.name + '"`)');
			}
		}
		//!steal-remove-end

		// Flag to prevent start binding twice in dev mode
		var started = false;

		//!steal-remove-start
		if (true) {
			if (el.nodeName === 'INPUT') {
				try {
					dataBinding.binding.start();
					started = true;
				} catch (error) {
					throw new Error(error.message + ' <input> elements always set properties to Strings.');
				}
			}
		}
		//!steal-remove-end

		if (!started) {
			dataBinding.binding.start();
			started = true;
		}

		var attributeListener = function(ev) {
			var attrName = ev.attributeName,
				value = el.getAttribute(attrName);

			if (attrName === attrData.attributeName) {
				if (teardown) {
					teardown();
				}

				if(value !== null  ) {
					var dataBinding = makeDataBinding({name: attrName, value: value}, bindingContext, {
						syncChildWithParent: false
					});
					if(dataBinding) {
						// The viewModel is created, so call callback immediately.
						dataBinding.binding.start();
						teardown = dataBinding.binding.stop.bind(dataBinding.binding);
					}
					teardown = dataBinding.onTeardown;
				}
			}
		};


		var tearItAllDown = function() {
			if (teardown) {
				teardown();
				teardown = undefined;
			}

			if (removedDisposal) {
				removedDisposal();
				removedDisposal = undefined;
			}
			if (attributeDisposal) {
				attributeDisposal();
				attributeDisposal = undefined;
			}
		};



		// Listen for changes
		teardown = dataBinding.binding.stop.bind(dataBinding.binding);

		attributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);
		removedDisposal = domMutate.onNodeDisconnected(el, function() {
			var doc = el.ownerDocument;
			var ownerNode = doc.contains ? doc : doc.documentElement;
			if (!ownerNode || ownerNode.contains(el) === false) {
				tearItAllDown();
			}
		});
	},
	// ### bindings.behaviors.event
	// The following section contains code for implementing the can-EVENT attribute.
	// This binds on a wildcard attribute name. Whenever a view is being processed
	// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler
	// that calls a method identified by the value of this attribute.
	event: function(el, data) {
		var eventBindingData;
		// Get the `event` name and if we are listening to the element or viewModel.
		// The attribute name is the name of the event.
		var attributeName = encoder.decode(data.attributeName),
			// the name of the event we are binding
			event,
			// the context to which we bind the event listener
			bindingContext,
			// if the bindingContext is null, then use this observable to watch for changes
			bindingContextObservable;

		// check for `on:event:value:to` type things and call data bindings
		if (attributeName.indexOf(toMatchStr + ":") !== -1 ||
			attributeName.indexOf(fromMatchStr + ":") !== -1 ||
			attributeName.indexOf(bindMatchStr + ":") !== -1
		) {
			return this.data(el, data);
		}

		if (startsWith.call(attributeName, onMatchStr)) {
			eventBindingData = getEventBindingData(attributeName, el, data.scope);
			event = eventBindingData.eventName;
			bindingContext = eventBindingData.bindingContext;
			bindingContextObservable = eventBindingData.bindingContextObservable;

			//!steal-remove-start
			if(true) {
				if(
					!eventBindingData.bindingCode &&
					el[viewModelSymbol] &&
					("on" + event) in el
				) {
					dev.warn(
						"The " + event + " event is bound the view model for <" + el.tagName.toLowerCase() +
							">. Use " + attributeName.replace(onMatchStr, "on:el:") +  " to bind to the element instead."
					);
				}
			}
			//!steal-remove-end
		} else {
			throw new Error("can-stache-bindings - unsupported event bindings " + attributeName);
		}

		// This is the method that the event will initially trigger. It will look up the method by the string name
		// passed in the attribute and call it.
		var handler = function(ev) {
			var attrVal = el.getAttribute(encoder.encode(attributeName));
			if (!attrVal) {
				return;
			}

			var viewModel = el[viewModelSymbol];

			// expression.parse will read the attribute
			// value and parse it identically to how mustache helpers
			// get parsed.
			var expr = expression.parse(attrVal, {
				lookupRule: function() {
					return expression.Lookup;
				},
				methodRule: "call"
			});

			var runScope = makeScopeFromEvent(el, ev, viewModel, arguments, data, bindingContext);

			if (expr instanceof expression.Hashes) {
				var hashExprs = expr.hashExprs;
				var key = Object.keys(hashExprs)[0];
				var value = expr.hashExprs[key].value(runScope);
				var isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);
				runScope.set(key, isObservableValue ? canReflect.getValue(value) : value);
			} else if (expr instanceof expression.Call) {
				runEventCallback(el, ev, data, runScope, expr, attributeName, attrVal);
			} else {
				throw new Error("can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in " + data.attributeName + "=" + JSON.stringify(attrVal));
			}
		};

		var attributesDisposal,
			removalDisposal,
			removeObservation,
			currentContext;

		// Unbind the event when the attribute is removed from the DOM
		var attributesHandler = function(ev) {
			var isEventAttribute = ev.attributeName === attributeName;
			var isRemoved = !el.getAttribute(attributeName);
			var isEventAttributeRemoved = isEventAttribute && isRemoved;
			if (isEventAttributeRemoved) {
				unbindEvent();
			}
		};
		var removalHandler = function() {
			var doc = el.ownerDocument;
			var ownerNode = doc.contains ? doc : doc.documentElement;
			if (!ownerNode || !ownerNode.contains(el)) {
				unbindEvent();
			}
		};
		var unbindEvent = function() {
			if (bindingContext) {
				canEventQueue.off.call(bindingContext, event, handler);
			}
			if (attributesDisposal) {
				attributesDisposal();
				attributesDisposal = undefined;
			}
			if (removalDisposal) {
				removalDisposal();
				removalDisposal = undefined;
			}
			if (removeObservation) {
				removeObservation();
				removeObservation = undefined;
			}
		};

		function updateListener(newVal, oldVal) {
			if (oldVal) {
				canEventQueue.off.call(oldVal, event, handler);
			}
			if (newVal) {
				canEventQueue.on.call(newVal, event, handler);
				currentContext = newVal;
			}
		}

		// Bind the handler defined above to the element we're currently processing and the event name provided in this
		// attribute name (can-click="foo")
		attributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);
		removalDisposal = domMutate.onNodeDisconnected(el, removalHandler);
		if (!bindingContext && bindingContextObservable) {
			// on value changes of the observation, rebind the listener to the new context
			removeObservation = function () {
				if (currentContext) {
					canEventQueue.off.call(currentContext, event, handler);
				}
				canReflect.offValue(bindingContextObservable, updateListener);
			};
			canReflect.onValue(bindingContextObservable, updateListener);
		} else {
			try {
				canEventQueue.on.call(bindingContext, event, handler);
			} catch (error) {
				if (/Unable to bind/.test(error.message)) {
					var msg = 'can-stache-bindings - Unable to bind "' + event + '"';
					msg += ': "' + event  + '" is a property on a plain object "';
					msg += JSON.stringify(bindingContext);
					msg += '". Binding is available with observable objects only.';
					msg += ' For more details check https://canjs.com/doc/can-stache-bindings.html#Callafunctionwhenaneventhappensonavalueinthescope_animation_';
					throw new Error(msg);
				} else {
					throw error;
				}
			}
		}
	}
};


// ## Attribute Syntaxes
// The following sets up the bindings functions to be called
// when called in a template.


// value:to="bar" data bindings
// these are separate so that they only capture at the end
// to avoid (toggle)="bar" which is encoded as :lp:toggle:rp:="bar"
bindings.set(/[\w\.:]+:to$/, behaviors.data);
bindings.set(/[\w\.:]+:from$/, behaviors.data);
bindings.set(/[\w\.:]+:bind$/, behaviors.data);
bindings.set(/[\w\.:]+:raw$/, behaviors.data);
// value:to:on:input="bar" data bindings
bindings.set(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
bindings.set(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
bindings.set(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);


// `(EVENT)` event bindings.
bindings.set(/on:[\w\.:]+/, behaviors.event);

// ## getObservableFrom
// An object of helper functions that make a getter/setter observable
// on different types of objects.
var getObservableFrom = {
	// ### getObservableFrom.viewModelOrAttribute
	viewModelOrAttribute: function(bindingData, bindingContext) {
		var viewModel = bindingContext.element[viewModelSymbol];

		// if we have a viewModel, use it; otherwise, setup attribute binding
		if (viewModel) {
			return this.viewModel.apply(this, arguments);
		} else {
			return this.attribute.apply(this, arguments);
		}
	},
	// ### getObservableFrom.scope
	// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.
	scope: function(bindingData, bindingContext) {
		var scope = bindingContext.scope,
			scopeProp = bindingData.name,
			mustBeGettable = bindingData.exports;

		if (!scopeProp) {
			return new SimpleObservable();
		} else {
			// Check if we need to spend time building a scope-key-data
			// If we have a '(', it likely means a call expression.
			if (mustBeGettable || scopeProp.indexOf("(") >= 0 || scopeProp.indexOf("=") >= 0) {
				var parentExpression = expression.parse(scopeProp,{baseMethodType: "Call"});

				if (parentExpression instanceof expression.Hashes) {
					return new SimpleObservable(function () {
						var hashExprs = parentExpression.hashExprs;
						var key = Object.keys(hashExprs)[0];
						var value = parentExpression.hashExprs[key].value(scope);
						var isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);
						scope.set(key, isObservableValue ? canReflect.getValue(value) : value);
					});
				} else {
					return parentExpression.value(scope);
				}
			} else {
				var observation = {};
				canReflect.assignSymbols(observation, {
					"can.getValue": function getValue() {},

					"can.valueHasDependencies": function hasValueDependencies() {
						return false;
					},

					"can.setValue": function setValue(newVal) {
						var expr = expression.parse(cleanVMName(scopeProp, scope),{baseMethodType: "Call"});
						var value = expr.value(scope);
						canReflect.setValue(value, newVal);
					},

					// Register what the custom observation changes
					"can.getWhatIChange": function getWhatIChange() {
						var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
						var m = new Map();
						var s = new Set();
						s.add(data.key);
						m.set(data.parent, s);

						return {
							mutate: {
								keyDependencies: m
							}
						};
					},

					"can.getName": function getName() {
						//!steal-remove-start
						if (true) {
							var result = "ObservableFromScope<>";
							var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));

							if (data.parent && data.key) {
								result = "ObservableFromScope<" +
									canReflect.getName(data.parent) +
									"." +
									data.key +
									">";
							}

							return result;
						}
						//!steal-remove-end
					},
				});

				var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
				if (data.parent && data.key) {
					// Register what changes the Scope's parent key
					canReflectDeps.addMutatedBy(data.parent, data.key, observation);
				}

				return observation;
			}
		}
	},
	// ### getObservableFrom.viewModel
	// Returns a compute that's two-way bound to the `viewModel` returned by
	// `options.bindingSettings()`.
	// Arguments:
	// - bindingData - {source, name, setCompute}
	// - bindingContext - {scope, element}
	// - bindingSettings - {getViewModel}
	viewModel: function(bindingData, bindingContext) {
		var scope = bindingContext.scope,
			vmName = bindingData.name,
			setCompute = bindingData.setCompute;

		var setName = cleanVMName(vmName, scope);
		var isBoundToContext = vmName === "." || vmName === "this";
		var keysToRead = isBoundToContext ? [] : stacheKey.reads(vmName);

		function getViewModelProperty() {
			var viewModel = bindingContext.viewModel;
			return stacheKey.read(viewModel, keysToRead, {}).value;
		}
		//!steal-remove-start
		if (true) {

			Object.defineProperty(getViewModelProperty, "name", {
				value: "<"+bindingContext.element.tagName.toLowerCase()+">." + vmName
			});
		}
		//!steal-remove-end

		var observation = new SettableObservable(
			getViewModelProperty,

			function setViewModelProperty(newVal) {
				var viewModel = bindingContext.viewModel;

				if (setCompute) {
					// If there is a binding like `foo:from="~bar"`, we need
					// to set the observable itself.
					var oldValue = canReflect.getKeyValue(viewModel, setName);
					if (canReflect.isObservableLike(oldValue)) {
						canReflect.setValue(oldValue, newVal);
					} else {
						canReflect.setKeyValue(
							viewModel,
							setName,
							new SimpleObservable(canReflect.getValue(newVal))
						);
					}
				} else {
					if (isBoundToContext) {
						canReflect.setValue(viewModel, newVal);
					} else {
						stacheKey.write(viewModel, keysToRead, newVal);
					}
				}
			}
		);

		//!steal-remove-start
		if (true) {
			var viewModel = bindingContext.viewModel;
			if (viewModel && setName) {
				canReflectDeps.addMutatedBy(viewModel, setName, observation);
			}
		}
		//!steal-remove-end

		return observation;
	},
	// ### getObservableFrom.attribute
	// Returns a compute that is two-way bound to an attribute or property on the element.
	attribute: function(bindingData, bindingContext ) {

		if(bindingData.name === "this") {
			return canReflect.assignSymbols({}, {
				"can.getValue": function() {
					return bindingContext.element;
				},

				"can.valueHasDependencies": function() {
					return false;
				},
				"can.getName": function getName() {
					//!steal-remove-start
					return "<"+bindingContext.element.nodeName+">";
					//!steal-remove-end
				}
			});
		} else {
			return new AttributeObservable(bindingContext.element, bindingData.name, {}, bindingData.event);
		}

	}
};

var startsWith = String.prototype.startsWith || function(text){
	return this.indexOf(text) === 0;
};

// Gets an event name in the after part.
function getEventName(result) {
	if (result.special.on !== undefined) {
		return result.tokens[result.special.on + 1];
	}
}

var siblingBindingRules = {
	to: {
		child: {
			exports: true,
			syncSibling: false
		},
		parent: {
			exports: false,
			syncSibling: false
		}
	},
	from: {
		child: {
			exports: false,
			syncSibling: false
		},
		parent: {
			exports: true,
			syncSibling: false
		}
	},
	bind: {
		child: {
			exports: true,
			syncSibling: false
		},
		parent: {
			exports: true,
			syncSibling: true
		}
	},
	raw: {
		child: {
			exports: false,
			syncSibling: false
		},
		parent: {
			exports: true,
			syncSibling: false
		}
	}
};
var bindingNames = [];
var special = {
	vm: true,
	on: true
};
canReflect.eachKey(siblingBindingRules, function(value, key) {
	bindingNames.push(key);
	special[key] = true;
});

// "on:click:value:to" //-> {tokens: [...], special: {on: 0, to: 3}}
function tokenize(source) {
	var splitByColon = source.split(":");
	// combine tokens that are not to, from, vm,
	var result = {
		tokens: [],
		special: {}
	};
	splitByColon.forEach(function(token) {
		if (special[token]) {
			result.special[token] = result.tokens.push(token) - 1;
		} else {
			result.tokens.push(token);
		}
	});

	return result;
}

// ## getChildBindingStr
var getChildBindingStr = function(tokens, favorViewModel) {
	if (tokens.indexOf('vm') >= 0) {
		return viewModelBindingStr;
	} else if (tokens.indexOf('el') >= 0) {
		return attributeBindingStr;
	} else {
		return favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;
	}
};

// ## getSiblingBindingData
// Returns information about the binding read from an attribute node.
// Arguments:
// - node - An attribute node like: `{name, value}`
// - bindingSettings - Optional.  Has {favorViewModel: Boolean}
// Returns an object with:
// - `parent` - {source, name, event, exports, syncSibling}
// - `child` - {source, name, event, exports, syncSibling, setCompute}
// - `bindingAttributeName` - debugging name.
// - `initializeValues` - should parent and child be initialized to their counterpart.
//
// `parent` and `child` properties:
//
// - `source` - where is the value read from: "scope", "attribute", "viewModel".
// - `name` - the name of the property that should be read
// - `event` - an optional event name to listen to
// - `exports` - if the value is exported to its sibling
// - `syncSibling` - if the value is sticky. When this value is updated, should the value be checked after
//   and its sibling be updated immediately.
// - `setCompute` - set the value to a compute.
function getSiblingBindingData(node, bindingSettings) {

	var siblingBindingData,
		attributeName = encoder.decode(node.name),
		attributeValue = node.value || "";

	var result = tokenize(attributeName),
		dataBindingName,
		specialIndex;

	// check if there's a match of a binding name with at least a value before it
	bindingNames.forEach(function(name) {
		if (result.special[name] !== undefined && result.special[name] > 0) {
			dataBindingName = name;
			specialIndex = result.special[name];
			return false;
		}
	});

	if (dataBindingName) {
		var childEventName = getEventName(result);

		var initializeValues = childEventName && dataBindingName !== "bind" ? false : true;
		siblingBindingData = {
			parent: assign({
				source: scopeBindingStr,
				name: result.special.raw ? ('"' + attributeValue + '"') : attributeValue
			}, siblingBindingRules[dataBindingName].parent),
			child: assign({
				source: getChildBindingStr(result.tokens, bindingSettings && bindingSettings.favorViewModel),
				name: result.tokens[specialIndex - 1],
				event: childEventName
			}, siblingBindingRules[dataBindingName].child),
			bindingAttributeName: attributeName,
			initializeValues: initializeValues
		};
		if (attributeValue.trim().charAt(0) === "~") {
			siblingBindingData.child.setCompute = true;
		}
		return siblingBindingData;
	}
}



// ## makeDataBinding
// Makes a data binding for an attribute `node`.  Returns an object with information
// about the binding, including an `onTeardown` method that undoes the binding.
// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on
// the object.  This method must be called after the element has a `viewModel` with the
// `viewModel` to complete the binding.
//
// Arguments:
// - `node` - an attribute node or an object with a `name` and `value` property.
// - `bindingContext` - The stache context  `{scope, element, parentNodeList}`
// - `bindingSettings` - Settings to control the behavior.
//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the
//      `viewModel` doesn't exist yet.
//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.
//   - `favorViewModel`
//   - `alreadyUpdatedChild`
// Returns:
// - `undefined` - If this isn't a data binding.
// - `object` - An object with information about the binding:
//   - siblingBindingData: the binding behavior
//   - binding: canBinding
var makeDataBinding = function(node, bindingContext, bindingSettings) {
	// Get information about the binding.
	var siblingBindingData = getSiblingBindingData( node, bindingSettings );
	if (!siblingBindingData) {
		return;
	}

	// Get computes for the parent and child binding
	var parentObservable = getObservableFrom[siblingBindingData.parent.source](
		siblingBindingData.parent,
		bindingContext, bindingSettings
	),
	childObservable = getObservableFrom[siblingBindingData.child.source](
		siblingBindingData.child,
		bindingContext, bindingSettings,
		parentObservable
	);

	var childToParent = !!siblingBindingData.child.exports;
	var parentToChild = !!siblingBindingData.parent.exports;

	// Check for child:bind="~parent" (it’s not supported because it’s unclear
	// what the “right” behavior should be)

	//!steal-remove-start
	if (true) {
		if (siblingBindingData.child.setCompute && childToParent && parentToChild) {
			dev.warn("Two-way binding computes is not supported.");
		}
	}
	//!steal-remove-end

	var bindingOptions = {
		child: childObservable,
		childToParent: childToParent,
		// allow cycles if one directional
		cycles: childToParent === true && parentToChild === true ? 0 : 100,
		onInitDoNotUpdateChild: bindingSettings.alreadyUpdatedChild || siblingBindingData.initializeValues === false,
		onInitDoNotUpdateParent: siblingBindingData.initializeValues === false,
		onInitSetUndefinedParentIfChildIsDefined: true,
		parent: parentObservable,
		parentToChild: parentToChild,
		priority: bindingContext.parentNodeList ? bindingContext.parentNodeList.nesting + 1 : undefined,
		queue: "dom",
		sticky: siblingBindingData.parent.syncSibling ? "childSticksToParent" : undefined,
		element: bindingContext.element
	};

	//!steal-remove-start
	if (true) {
		var nodeHTML = encoder.decode(node.name)+"="+JSON.stringify(node.value);
		var tagStart = "<"+bindingContext.element.nodeName.toLowerCase(),
			tag = tagStart+">";

		var makeUpdateName = function(child, childName) {

			if(child === "viewModel") {
				return tag+"."+childName;
			}
			else if(child === "scope") {
				return "{{"+childName+"}}";
			}
			else {
				return ""+child+"."+childName;
			}
		};
		bindingOptions.debugName = tagStart+" "+nodeHTML+">";
		bindingOptions.updateChildName = bindingOptions.debugName+" updates "+
			makeUpdateName(siblingBindingData.child.source, siblingBindingData.child.name)+
			" from "+makeUpdateName(siblingBindingData.parent.source, siblingBindingData.parent.name);

		bindingOptions.updateParentName = bindingOptions.debugName+" updates "+
			makeUpdateName(siblingBindingData.parent.source, siblingBindingData.parent.name)+
			" from "+makeUpdateName(siblingBindingData.child.source, siblingBindingData.child.name);
	}
	//!steal-remove-end

	// Create the binding
	var canBinding = new Bind(bindingOptions);

	return {
		siblingBindingData: siblingBindingData,
		binding: canBinding
	};
};

var cleanVMName = function(name, scope) {
	//!steal-remove-start
	if (true) {
		if (name.indexOf("@") >= 0 && scope) {
			var filename = scope.peek('scope.filename');
			var lineNumber = scope.peek('scope.lineNumber');

			dev.warn(
				(filename ? filename + ':' : '') +
				(lineNumber ? lineNumber + ': ' : '') +
				'functions are no longer called by default so @ is unnecessary in \'' + name + '\'.');
		}
	}
	//!steal-remove-end
	return name.replace(/@/g, "");
};

var canStacheBindings = {
	behaviors: behaviors,
	getSiblingBindingData: getSiblingBindingData,
	bindings: bindings,
	getObservableFrom: getObservableFrom,
	makeDataBinding: makeDataBinding
};

canStacheBindings[canSymbol.for("can.callbackMap")] = bindings;

module.exports = canStacheBindings;


/***/ }),

/***/ "./node_modules/can-stache-converters/can-stache-converters.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-stache-converters/can-stache-converters.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var stache = __webpack_require__(/*! can-stache */ "./node_modules/can-stache/can-stache.js");
var stringToAny = __webpack_require__(/*! can-string-to-any */ "./node_modules/can-string-to-any/can-string-to-any.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var stacheBindings = __webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");
var stacheHelpers = __webpack_require__(/*! can-stache-helpers */ "./node_modules/can-stache-helpers/can-stache-helpers.js");


stache.addBindings(stacheBindings);

// feature detect if multiple arguments are going to be passed
// to an nested function call
var shouldPop = false;
stache("{{echo(args(1))}}")({
	echo: function(){},
	args: function(){
		shouldPop = ( arguments.length > 1 );
	}
});

stache.registerConverter("boolean-to-inList", {
	get: function(item, list){
		if(!list) {
			return false;
		} else {
			return list.indexOf(item) !== -1;
		}
	},
	set: function(newVal, item, list){
		if(!list) {
			return;
		}
		if(!newVal) {
			var idx = list.indexOf(item);
			if(idx !== -1) {
				list.splice(idx, 1);
			}
		} else {
			list.push(item);
		}
	}
});

var converters = {
	"string-to-any": {
		get: function(obs){
			return "" + canReflect.getValue(obs);
		},
		set: function(newVal, obs){
			var converted = stringToAny(newVal);
			canReflect.setValue(obs, converted);
		}
	},
	"index-to-selected": {
		get: function(item, list){
			var val = canReflect.getValue(item);
			var idx = canReflect.getValue(list).indexOf(val);
			return idx;
		},
		set: function(idx, item, list){
			var newVal = canReflect.getValue(list)[idx];
			canReflect.setValue(item, newVal);
		}
	},
	"selected-to-index": {
		get: function(idx, list){
			var val = canReflect.getValue(idx),
				listValue = canReflect.getValue(list);
			var item = listValue[val];
			return item;
		},
		set: function(item, idx, list){
			var newVal = canReflect.getValue(list).indexOf(item);
			canReflect.setValue(idx, newVal);
		}
	},
	"either-or": {
		get: function(chosen, a, b){
			var chosenVal = canReflect.getValue(chosen),
				aValue = canReflect.getValue(a),
				bValue = canReflect.getValue(b);
			var matchA = (aValue === chosenVal);
			var matchB = (bValue === chosenVal);

			if (!matchA && !matchB) {
				//!steal-remove-start
				if (true) {
					dev.warn(
						"can-stache-converter.either-or:",
						"`" + chosenVal + "`",
						"does not match `" + aValue + "`",
						"or `" + bValue + "`"
					);
				}
				//!steal-remove-end

				return;
			}
			else {
				return matchA;
			}
		},
		set: function(newVal, chosen, a, b){
			var setVal = newVal ? canReflect.getValue(a) : canReflect.getValue(b);
			canReflect.setValue(chosen, setVal);
		}
	},
	"equal": {
		get: function(){
			var args = canReflect.toArray(arguments);
			// We don't need the helperOptions
			if(shouldPop) {
				args.pop();
			}
			if (args.length > 1) {
				var comparer = canReflect.getValue( args.pop() );

				return args.every(function(obs) {
					var value = canReflect.getValue(obs);
					return value === comparer;
				});
			}
		},
		set: function(){
			var args = canReflect.toArray(arguments);
			// Ignore the helperOptions
			if(shouldPop) {
				args.pop();
			}
			if (args.length > 2) {
				var b = args.shift();
				var comparer = canReflect.getValue( args.pop() );
				if(b) {
					for(var i = 0; i < args.length; i++) {
						canReflect.setValue(args[i], comparer);
					}
				}
			}
		}
	}
};

// Register itself right away
stache.addConverter(converters);

if(!stacheHelpers.not) {
	stache.addConverter("not",{
		get: function(obs){
			return !canReflect.getValue(obs);
		},
		set: function(newVal, obs){
			canReflect.setValue(obs, !newVal);
		}
	});
}

module.exports = converters;


/***/ }),

/***/ "./node_modules/can-stache-element/dist/can-stache-element.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/can-stache-element.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var mixinLifecycleMethods = __webpack_require__(/*! ./mixin-lifecycle-methods */ "./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js");

var mixinProps = __webpack_require__(/*! ./mixin-props */ "./node_modules/can-stache-element/dist/mixin-props.js");

var mixinStacheView = __webpack_require__(/*! ./mixin-stache-view */ "./node_modules/can-stache-element/dist/mixin-stache-view.js");

var mixinViewModelSymbol = __webpack_require__(/*! ./mixin-viewmodel-symbol */ "./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js");

var mixinBindings = __webpack_require__(/*! ./mixin-bindings */ "./node_modules/can-stache-element/dist/mixin-bindings.js");

var mixinInitializeBindings = __webpack_require__(/*! ./mixin-initialize-bindings */ "./node_modules/can-stache-element/dist/mixin-initialize-bindings.js");

var mixinBindBehaviour = __webpack_require__(/*! ./mixin-bind-behaviour */ "./node_modules/can-stache-element/dist/mixin-bind-behaviour.js");

var _require = __webpack_require__(/*! ./mixin-bind-behaviour */ "./node_modules/can-stache-element/dist/mixin-bind-behaviour.js"),
    initializeObservedAttributes = _require.initializeObservedAttributes;

var canStacheBindings = __webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");

var _require2 = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    createConstructorFunction = _require2.createConstructorFunction;

var initializeSymbol = Symbol.for("can.initialize");
var teardownHandlersSymbol = Symbol.for("can.teardownHandlers");
var isViewSymbol = Symbol.for("can.isView");

var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js"); // Calling a renderer like {{foo()}} gets the template scope
// added no matter what. This checks for that condition.
// https://github.com/canjs/can-stache/issues/719


function rendererWasCalledWithData(scope) {
  return scope instanceof Scope && scope._parent && scope._parent._context instanceof Scope.TemplateContext;
}

function addContext(rawRenderer, tagData) {
  function renderer(data) {
    if (rendererWasCalledWithData(data)) {
      return rawRenderer(tagData.scope.addLetContext(data._context));
    } else {
      // if it was called programmatically (not in stache), just add the data
      return rawRenderer(tagData.scope.addLetContext(data));
    }
  } // Marking as a view will add the template scope ... but it should
  // already be present in `tagData.scope`.
  // However, I mark this as a renderer because that is what it is.


  renderer[isViewSymbol] = true;
  return renderer;
}

function DeriveElement() {
  var BaseElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;

  var StacheElement = /*#__PURE__*/function (_mixinLifecycleMethod) {
    _inherits(StacheElement, _mixinLifecycleMethod);

    var _super = _createSuper(StacheElement);

    function StacheElement() {
      _classCallCheck(this, StacheElement);

      return _super.apply(this, arguments);
    }

    _createClass(StacheElement, [{
      key: initializeSymbol,
      value: function value(el, tagData) {
        var teardownBindings = canStacheBindings.behaviors.viewModel(el, tagData, function makeViewModel(initialViewmodelData) {
          for (var prop in tagData.templates) {
            // It's ok to modify the argument. The argument is created
            // just for what gets passed into creating the VM.
            initialViewmodelData[prop] = addContext(tagData.templates[prop], tagData);
          }

          el.render(initialViewmodelData);
          return el;
        });

        if (el[teardownHandlersSymbol]) {
          el[teardownHandlersSymbol].push(teardownBindings);
        }
      }
    }]);

    return StacheElement;
  }( // add lifecycle methods
  // this needs to happen after other mixins that implement these methods
  // so that this.<lifecycleMethod> is the actual lifecycle method which
  // controls whether the methods farther "down" the chain are called
  mixinLifecycleMethods( // mixin .bindings() method and behavior
  mixinBindings( // Find all prop definitions and extract `{ bind: () => {} }` for binding initialization
  mixinBindBehaviour( // Initialize the bindings
  mixinInitializeBindings( // mix in viewModel symbol used by can-stache-bindings
  mixinViewModelSymbol( // mix in stache renderer from `static view` property
  mixinStacheView( // add getters/setters from `static props` property
  mixinProps(BaseElement))))))));

  var StacheElementConstructorFunction = createConstructorFunction(StacheElement); // Initialize the `observedAttributes`

  initializeObservedAttributes(StacheElementConstructorFunction);
  return StacheElementConstructorFunction;
}

module.exports = namespace.StacheElement = DeriveElement();

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-bind-behaviour.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-bind-behaviour.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    mixins = _require.mixins;

var metaSymbol = Symbol.for("can.meta"); // `attributeChangedCallback` cannot be overwritten so we need to create a named
// function to check if we have had a `attributeChangedCallback` set.

function baseAttributeChangedCallback() {
  /* jshint validthis: true */
  if (this.attributeChangedCallback !== baseAttributeChangedCallback) {
    // `this.attributeChangedCallback` is being set up within `can-observable-bindings`
    this.attributeChangedCallback.apply(this, arguments);
  }
}

module.exports = function mixinBindBehaviour() {
  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;

  var BindingPropsClass = /*#__PURE__*/function (_Base) {
    _inherits(BindingPropsClass, _Base);

    var _super = _createSuper(BindingPropsClass);

    function BindingPropsClass() {
      _classCallCheck(this, BindingPropsClass);

      return _super.apply(this, arguments);
    }

    _createClass(BindingPropsClass, [{
      key: "initialize",
      value: function initialize(props) {
        var _this = this;

        if (this[metaSymbol] === undefined) {
          this[metaSymbol] = {};
        }

        if (this[metaSymbol]._bindings === undefined) {
          this[metaSymbol]._bindings = [];
        } // `_uninitializedBindings` are being set within `observedAttributes` which creates the bindings


        Object.keys(this.constructor[metaSymbol]._uninitializedBindings).forEach(function (propName) {
          var binding = _this.constructor[metaSymbol]._uninitializedBindings[propName](_this); // Add bindings to the instance `metaSymbol` to be set up during `mixin-initialize-bindings`


          _this[metaSymbol]._bindings.push({
            binding: binding,
            siblingBindingData: {
              parent: {
                source: "scope",
                exports: true
              },
              child: {
                source: "viewModel",
                exports: true,
                name: propName
              },
              bindingAttributeName: propName
            }
          });
        });

        if (_get(_getPrototypeOf(BindingPropsClass.prototype), "initialize", this)) {
          _get(_getPrototypeOf(BindingPropsClass.prototype), "initialize", this).call(this, props);
        }
      }
    }]);

    return BindingPropsClass;
  }(Base); // To prevent inifinite loop, use a named function so we can differentiate
  // make it writable so it can be set elsewhere  


  Object.defineProperty(BindingPropsClass.prototype, 'attributeChangedCallback', {
    value: baseAttributeChangedCallback,
    writable: true
  });
  return BindingPropsClass;
}; // We can't set `observedAttributes` on the `StacheElement.prototype` as static properties are
// not copied over with `Object.create`


module.exports.initializeObservedAttributes = function initializeObservedAttributes(ctr) {
  Object.defineProperty(ctr, 'observedAttributes', {
    get: function get() {
      var _this2 = this;

      // We only want to return `observedAttributes` if we have a `bind` on the
      // property definition
      var hasBindDefinition = false; // Run finalizeClass to set up the property definitions

      mixins.finalizeClass(this);

      if (this[metaSymbol] === undefined) {
        this[metaSymbol] = {};
      }

      if (this[metaSymbol]._uninitializedBindings === undefined) {
        this[metaSymbol]._uninitializedBindings = {};
      } // Check that we have property definitions


      var definitions = this.prototype._define && this.prototype._define.definitions;

      if (definitions) {
        // Run through all defitions so we can check if they have a `bind` function
        Object.keys(definitions).forEach(function (propName) {
          var definition = definitions[propName];

          if (typeof definition.bind === 'function') {
            var bindFn = definition.bind(propName, _this2); // Set up the bindings so that they can be called during initialize
            // to setup binding starts

            _this2[metaSymbol]._uninitializedBindings[propName] = bindFn;
            hasBindDefinition = true;
          }
        });
      } // Only return `this.observedAttributes` if we have binds otherwise
      // we create an inifinite loop


      return hasBindDefinition ? this.observedAttributes : [];
    }
  });
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-bindings.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-bindings.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var keyObservable = __webpack_require__(/*! can-simple-observable/key/key */ "./node_modules/can-simple-observable/key/key.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Bind = __webpack_require__(/*! can-bind */ "./node_modules/can-bind/can-bind.js");

var getValueSymbol = Symbol.for("can.getValue");
var setValueSymbol = Symbol.for("can.setValue");
var metaSymbol = Symbol.for("can.meta");

module.exports = function mixinBindings() {
  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;
  return /*#__PURE__*/function (_Base) {
    _inherits(BindingsClass, _Base);

    var _super = _createSuper(BindingsClass);

    function BindingsClass() {
      _classCallCheck(this, BindingsClass);

      return _super.apply(this, arguments);
    }

    _createClass(BindingsClass, [{
      key: "bindings",
      value: function bindings(_bindings) {
        var _this = this;

        if (this[metaSymbol] === undefined) {
          this[metaSymbol] = {};
        }

        var bindingsObservables = {};
        canReflect.eachKey(_bindings, function (parent, propName) {
          // Create an observable for reading/writing the viewModel
          // even though it doesn't exist yet.
          var child = keyObservable(_this, propName);
          bindingsObservables[propName] = {
            parent: parent,
            child: child
          };
        });
        this[metaSymbol]._connectedBindings = bindingsObservables;
        return this;
      }
    }, {
      key: "initialize",
      value: function initialize(props) {
        var _this2 = this;

        var savedBindings = this[metaSymbol] && this[metaSymbol]._connectedBindings;

        if (savedBindings) {
          props = props || {};

          if (this[metaSymbol]._bindings === undefined) {
            this[metaSymbol]._bindings = [];
          }

          canReflect.eachKey(savedBindings, function (binding, propName) {
            var child = binding.child,
                parent = binding.parent;
            var canGetParentValue = parent != null && !!parent[getValueSymbol];
            var canSetParentValue = parent != null && !!parent[setValueSymbol]; // If we can get or set the value, then we’ll create a binding

            if (canGetParentValue || canSetParentValue) {
              // Create the binding similar to what’s in can-stache-bindings
              var canBinding = new Bind({
                child: child,
                parent: parent,
                queue: "dom",
                element: _this2,
                //!steal-remove-start
                // For debugging: the names that will be assigned to the updateChild
                // and updateParent functions within can-bind
                updateChildName: "update <" + _this2.nodeName.toLowerCase() + ">." + propName,
                updateParentName: "update " + canReflect.getName(parent) + " from <" + _this2.nodeName.toLowerCase() + ">." + propName //!steal-remove-end

              });

              _this2[metaSymbol]._bindings.push({
                binding: canBinding,
                siblingBindingData: {
                  parent: {
                    source: "scope",
                    exports: canGetParentValue
                  },
                  child: {
                    source: "viewModel",
                    exports: canSetParentValue,
                    name: propName
                  },
                  bindingAttributeName: propName
                }
              });
            } else {
              // Can’t get or set the value, so assume it’s not an observable
              props[propName] = parent;
            }
          });
          this[metaSymbol].other = true;
        }

        if (_get(_getPrototypeOf(BindingsClass.prototype), "initialize", this)) {
          _get(_getPrototypeOf(BindingsClass.prototype), "initialize", this).call(this, props);
        }
      }
    }, {
      key: "render",
      value: function render(props, renderOptions) {
        var viewRoot = this.viewRoot || this;
        viewRoot.innerHTML = "";

        if (_get(_getPrototypeOf(BindingsClass.prototype), "render", this)) {
          _get(_getPrototypeOf(BindingsClass.prototype), "render", this).call(this, props, renderOptions);
        }
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        delete this[metaSymbol]._bindings;

        if (_get(_getPrototypeOf(BindingsClass.prototype), "disconnect", this)) {
          _get(_getPrototypeOf(BindingsClass.prototype), "disconnect", this).call(this);
        }
      }
    }]);

    return BindingsClass;
  }(Base);
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-initialize-bindings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-initialize-bindings.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var stacheBindings = __webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");

var metaSymbol = Symbol.for("can.meta");
var inSetupSymbol = Symbol.for("can.initializing");

module.exports = function mixinBindings() {
  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;
  return /*#__PURE__*/function (_Base) {
    _inherits(InitializeBindingsClass, _Base);

    var _super = _createSuper(InitializeBindingsClass);

    function InitializeBindingsClass() {
      _classCallCheck(this, InitializeBindingsClass);

      return _super.apply(this, arguments);
    }

    _createClass(InitializeBindingsClass, [{
      key: "initialize",
      value: function initialize(props) {
        var _this = this;

        var bindings = this[metaSymbol] && this[metaSymbol]._bindings;

        if (bindings && bindings.length) {
          // set inSetup to false so that observations read in `initializeViewModel`
          // correctly set up bindings
          var origInSetup = this[inSetupSymbol];
          this[inSetupSymbol] = false;
          var bindingContext = {
            element: this
          }; // Initialize the viewModel.  Make sure you
          // save it so the observables can access it.

          var initializeData = stacheBindings.behaviors.initializeViewModel(bindings, props, function (properties) {
            _get(_getPrototypeOf(InitializeBindingsClass.prototype), "initialize", _this).call(_this, properties);

            return _this;
          }, bindingContext);

          this[metaSymbol]._connectedBindingsTeardown = function () {
            for (var attrName in initializeData.onTeardowns) {
              initializeData.onTeardowns[attrName]();
            }
          }; // restore inSetup to the original value


          this[inSetupSymbol] = origInSetup;
        } else {
          if (_get(_getPrototypeOf(InitializeBindingsClass.prototype), "initialize", this)) {
            _get(_getPrototypeOf(InitializeBindingsClass.prototype), "initialize", this).call(this, props);
          }
        }
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this[metaSymbol] && this[metaSymbol]._connectedBindingsTeardown) {
          this[metaSymbol]._connectedBindingsTeardown();

          this[metaSymbol]._connectedBindingsTeardown = null;
        }

        if (_get(_getPrototypeOf(InitializeBindingsClass.prototype), "disconnect", this)) {
          _get(_getPrototypeOf(InitializeBindingsClass.prototype), "disconnect", this).call(this);
        }
      }
    }]);

    return InitializeBindingsClass;
  }(Base);
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var lifecycleStatusSymbol = Symbol.for("can.lifecycleStatus");
var inSetupSymbol = Symbol.for("can.initializing");
var teardownHandlersSymbol = Symbol.for("can.teardownHandlers");

function defineConfigurableNonEnumerable(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: value
  });
}

module.exports = function mixinLifecycleMethods() {
  var BaseElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;
  return /*#__PURE__*/function (_BaseElement) {
    _inherits(LifecycleElement, _BaseElement);

    var _super = _createSuper(LifecycleElement);

    function LifecycleElement() {
      var _this;

      _classCallCheck(this, LifecycleElement);

      _this = _super.call(this);

      if (arguments.length) {
        throw new Error("can-stache-element: Do not pass arguments to the constructor. Initial property values should be passed to the `initialize` hook.");
      } // add inSetup symbol to prevent events being dispatched


      defineConfigurableNonEnumerable(_assertThisInitialized(_this), inSetupSymbol, true); // add lifecycle status symbol

      defineConfigurableNonEnumerable(_assertThisInitialized(_this), lifecycleStatusSymbol, {
        initialized: false,
        rendered: false,
        connected: false,
        disconnected: false
      }); // add a place to store additional teardownHandlers

      defineConfigurableNonEnumerable(_assertThisInitialized(_this), teardownHandlersSymbol, []);
      return _this;
    } // custom element lifecycle methods


    _createClass(LifecycleElement, [{
      key: "connectedCallback",
      value: function connectedCallback(props) {
        this.initialize(props);
        this.render();
        this.connect();
        return this;
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.disconnect();
        return this;
      } // custom lifecycle methods

    }, {
      key: "initialize",
      value: function initialize(props) {
        var lifecycleStatus = this[lifecycleStatusSymbol];

        if (lifecycleStatus.initialized) {
          return this;
        } // Overwrite ... this means that this initialize
        // can't be inherited (super.initialize).


        this[inSetupSymbol] = true;

        if (_get(_getPrototypeOf(LifecycleElement.prototype), "initialize", this)) {
          _get(_getPrototypeOf(LifecycleElement.prototype), "initialize", this).call(this, props);
        }

        this[inSetupSymbol] = false;
        lifecycleStatus.initialized = true;
        return this;
      }
    }, {
      key: "render",
      value: function render(props) {
        var lifecycleStatus = this[lifecycleStatusSymbol];

        if (lifecycleStatus.rendered) {
          return this;
        }

        if (!lifecycleStatus.initialized) {
          this.initialize(props);
        }

        if (_get(_getPrototypeOf(LifecycleElement.prototype), "render", this)) {
          _get(_getPrototypeOf(LifecycleElement.prototype), "render", this).call(this, props);
        }

        lifecycleStatus.rendered = true;
        return this;
      }
    }, {
      key: "connect",
      value: function connect(props) {
        var lifecycleStatus = this[lifecycleStatusSymbol];

        if (lifecycleStatus.connected) {
          return this;
        }

        if (!lifecycleStatus.initialized) {
          this.initialize(props);
        }

        if (!lifecycleStatus.rendered) {
          this.render(props);
        }

        if (_get(_getPrototypeOf(LifecycleElement.prototype), "connect", this)) {
          _get(_getPrototypeOf(LifecycleElement.prototype), "connect", this).call(this, props);
        }

        if (this.connected) {
          var connectedTeardown = this.connected();

          if (typeof connectedTeardown === "function") {
            this[teardownHandlersSymbol].push(connectedTeardown);
          }
        }

        lifecycleStatus.connected = true;
        lifecycleStatus.disconnected = false;
        return this;
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        var lifecycleStatus = this[lifecycleStatusSymbol];

        if (lifecycleStatus.disconnected) {
          return this;
        }

        if (_get(_getPrototypeOf(LifecycleElement.prototype), "disconnect", this)) {
          _get(_getPrototypeOf(LifecycleElement.prototype), "disconnect", this).call(this);
        }

        if (this.stopListening) {
          this.stopListening();
        }

        var _iterator = _createForOfIteratorHelper(this[teardownHandlersSymbol]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var handler = _step.value;
            handler.call(this);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (this.disconnected) {
          this.disconnected();
        }

        this[lifecycleStatusSymbol] = {
          initialized: false,
          rendered: false,
          connected: false,
          disconnected: true
        };
        return this;
      }
    }]);

    return LifecycleElement;
  }(BaseElement);
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-props.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-props.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js"),
    mixinElement = _require.mixinElement,
    mixins = _require.mixins;

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var canLogDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var eventTargetInstalledSymbol = Symbol.for("can.eventTargetInstalled");

module.exports = function mixinDefine() {
  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;
  var realAddEventListener = Base.prototype.addEventListener;
  var realRemoveEventListener = Base.prototype.removeEventListener;

  function installEventTarget(Type) {
    if (Type[eventTargetInstalledSymbol]) {
      return;
    }

    var eventQueueAddEventListener = Type.prototype.addEventListener;
    var eventQueueRemoveEventListener = Type.prototype.removeEventListener;

    Type.prototype.addEventListener = function () {
      eventQueueAddEventListener.apply(this, arguments);
      return realAddEventListener.apply(this, arguments);
    };

    Type.prototype.removeEventListener = function () {
      eventQueueRemoveEventListener.apply(this, arguments);
      return realRemoveEventListener.apply(this, arguments);
    };

    Type[eventTargetInstalledSymbol] = true;
  } // Warn on special properties
  //!steal-remove-start


  function raisePropWarnings(Type, Base) {
    if (true) {
      // look for `static props`and fall back to `static define` if `props` doesn't exist
      var props = _typeof(Type.props) === "object" ? Type.props : _typeof(Type.define) === "object" ? Type.define : {};
      Object.keys(props).forEach(function (key) {
        if ("on" + key in Type.prototype) {
          canLogDev.warn("".concat(canReflect.getName(Type), ": The defined property [").concat(key, "] matches the name of a DOM event. This property could update unexpectedly. Consider renaming."));
        } else if (key in Base.prototype) {
          canLogDev.warn("".concat(canReflect.getName(Type), ": The defined property [").concat(key, "] matches the name of a property on the type being extended, ").concat(canReflect.getName(Base), ". This could lead to errors by changing the expected behaviour of that property. Consider renaming."));
        }
      });
    }
  } //!steal-remove-end


  var DefinedClass = /*#__PURE__*/function (_mixinElement) {
    _inherits(DefinedClass, _mixinElement);

    var _super = _createSuper(DefinedClass);

    function DefinedClass() {
      var _this;

      _classCallCheck(this, DefinedClass);

      _this = _super.call(this); //!steal-remove-start

      raisePropWarnings(_this.constructor, Base); //!steal-remove-end

      installEventTarget(_this.constructor);
      return _this;
    }

    _createClass(DefinedClass, [{
      key: "initialize",
      value: function initialize(props) {
        _get(_getPrototypeOf(DefinedClass.prototype), "initialize", this).call(this, props);

        var prop, staticProps;

        if (this.constructor.props) {
          staticProps = Object.keys(this.constructor.props);
        }

        for (prop in this) {
          if (this.hasOwnProperty(prop)) {
            if (staticProps && staticProps.includes(prop)) {
              var val = this[prop];
              delete this[prop];
              this[prop] = val;
            } else {
              mixins.expando(this, prop, this[prop]);
            }
          }
        }
      }
    }]);

    return DefinedClass;
  }(mixinElement(Base));

  return DefinedClass;
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-stache-view.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-stache-view.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var stache = __webpack_require__(/*! can-stache */ "./node_modules/can-stache/can-stache.js");

var stacheBindings = __webpack_require__(/*! can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");

var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");

var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");

var rendererSymbol = Symbol.for("can.stacheRenderer");
var viewInsertSymbol = Symbol.for("can.viewInsert"); // make bindings work

stache.addBindings(stacheBindings);

module.exports = function mixinStacheView() {
  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;

  var StacheClass = /*#__PURE__*/function (_Base) {
    _inherits(StacheClass, _Base);

    var _super = _createSuper(StacheClass);

    function StacheClass() {
      _classCallCheck(this, StacheClass);

      return _super.apply(this, arguments);
    }

    _createClass(StacheClass, [{
      key: "render",
      value: function render(props, renderOptions) {
        if (_get(_getPrototypeOf(StacheClass.prototype), "render", this)) {
          _get(_getPrototypeOf(StacheClass.prototype), "render", this).call(this, props);
        } // cache renderer function so `stache(...)` is only called
        // for the first instance of each StacheElement constructor


        var renderer = this.constructor[rendererSymbol];

        if (!renderer) {
          var view = this.constructor.view;
          var viewName = canReflect.getName(this.constructor) + "View";
          renderer = typeof view === "function" ? view : stache(viewName, view || "");
          this.constructor[rendererSymbol] = renderer;
        }

        var frag = renderer(new Scope(this, null, {
          viewModel: true
        }), renderOptions);
        var viewRoot = this.viewRoot || this;
        domMutateNode.appendChild.call(viewRoot, frag);
      }
    }, {
      key: "connect",
      value: function connect() {
        var _this = this;

        if (_get(_getPrototypeOf(StacheClass.prototype), "connect", this)) {
          _get(_getPrototypeOf(StacheClass.prototype), "connect", this).call(this);
        }

        var removedDisposal = domMutate.onNodeRemoved(this, function () {
          var doc = _this.ownerDocument;
          var rootNode = doc.contains ? doc : doc.documentElement;

          if (!rootNode || !rootNode.contains(_this)) {
            removedDisposal();

            _this.disconnect();
          }
        });
      }
    }, {
      key: viewInsertSymbol,
      value: function value() {
        return this;
      }
    }]);

    return StacheClass;
  }(Base);

  StacheClass.prototype[Symbol.for("can.preventDataBindings")] = true;
  return StacheClass;
};

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");

var viewModelSymbol = Symbol.for("can.viewModel");

module.exports = function mixinViewModelSymbol() {
  var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;

  var ViewModelClass = /*#__PURE__*/function (_BaseClass) {
    _inherits(ViewModelClass, _BaseClass);

    var _super = _createSuper(ViewModelClass);

    function ViewModelClass() {
      _classCallCheck(this, ViewModelClass);

      return _super.apply(this, arguments);
    }

    return ViewModelClass;
  }(BaseClass); // can-stache-bindings uses viewModel symbol


  defineLazyValue(ViewModelClass.prototype, viewModelSymbol, function () {
    return this;
  });
  return ViewModelClass;
};

/***/ }),

/***/ "./node_modules/can-stache-helpers/can-stache-helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-stache-helpers/can-stache-helpers.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

if (namespace.stacheHelpers) {
	throw new Error("You can't have two versions of can-stache-helpers, check your dependencies");
} else {
	module.exports = namespace.stacheHelpers = {};
}


/***/ }),

/***/ "./node_modules/can-stache-key/can-stache-key.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache-key/can-stache-key.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canReflectPromise = __webpack_require__(/*! can-reflect-promise */ "./node_modules/can-reflect-promise/can-reflect-promise.js");

var getValueSymbol = canSymbol.for("can.getValue");
var setValueSymbol = canSymbol.for("can.setValue");

var isValueLikeSymbol = canSymbol.for("can.isValueLike");
var peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));
var observeReader;
var isPromiseLike = ObservationRecorder.ignore(function isPromiseLike(value){
	return typeof value === "object" && value && typeof value.then === "function";
});

var bindName = Function.prototype.bind;
//!steal-remove-start
if (true) {
	bindName = function(source){
		var fn = Function.prototype.bind.call(this, source);
		Object.defineProperty(fn, "name", {
			value: canReflect.getName(source) + "."+canReflect.getName(this)
		});
		return fn;
	};
}
//!steal-remove-end

var isAt = function(index, reads) {
	var prevRead = reads[index-1];
	return prevRead && prevRead.at;
};

var readValue = function(value, index, reads, options, state, prev){
	// if the previous read is AT false ... we shouldn't be doing this;
	var usedValueReader;
	do {

		usedValueReader = false;
		for(var i =0, len = observeReader.valueReaders.length; i < len; i++){
			if( observeReader.valueReaders[i].test(value, index, reads, options) ) {
				value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
				//usedValueReader = true;
			}
		}
	} while(usedValueReader);

	return value;
};

var specialRead = {index: true, key: true, event: true, element: true, viewModel: true};

var checkForObservableAndNotify = function(options, state, getObserves, value, index){
	if(options.foundObservable && !state.foundObservable) {
		if(ObservationRecorder.trapsCount()) {
			ObservationRecorder.addMany( getObserves() );
			options.foundObservable(value, index);
			state.foundObservable = true;
		}
	}
};

var objHasKeyAtIndex = function(obj, reads, index) {
	return !!(
		reads && reads.length &&
		canReflect.hasKey(obj, reads[index].key)
	);
};

observeReader = {
	// there are things that you need to evaluate when you get them back as a property read
	// for example a compute or a function you might need to call to get the next value to
	// actually check
	// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a
	//   compute as a delegate.  In 3.0, this should be removed and force people to write "{@prop} change"
	// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.
	// - executeAnonymousFunctions - call a function if it's found, defaults to true
	// - proxyMethods - if the last read is a method, return a function so `this` will be correct.
	// - args - arguments to call functions with.
	//
	// Callbacks
	// - earlyExit - called if a value could not be found
	// - foundObservable - called when an observable value is found
	read: function (parent, reads, options) {
		options = options || {};
		var state = {
			foundObservable: false
		};
		var getObserves;
		if(options.foundObservable) {
			getObserves = ObservationRecorder.trap();
		}

		// `cur` is the current value.
		var cur = readValue(parent, 0, reads, options, state),
			type,
			// `prev` is the object we are reading from.
			prev,
			// `foundObs` did we find an observable.
			readLength = reads.length,
			i = 0,
			last,
			parentHasKey;

		checkForObservableAndNotify(options, state, getObserves, parent, 0);

		while( i < readLength ) {
			prev = cur;
			// try to read the property
			for(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
				var reader = observeReader.propertyReaders[r];
				if(reader.test(cur)) {
					cur = reader.read(cur, reads[i], i, options, state);
					break; // there can be only one reading of a property
				}
			}
			checkForObservableAndNotify(options, state, getObserves, prev, i);
			last = cur;
			i = i+1;
			// read the value if it is a compute or function
			cur = readValue(cur, i, reads, options, state, prev);

			checkForObservableAndNotify(options, state, getObserves, prev, i-1);

			type = typeof cur;
			// early exit if need be
			if (i < reads.length && (cur === null || cur === undefined )) {
				parentHasKey = objHasKeyAtIndex(prev, reads, i - 1);
				if (options.earlyExit && !parentHasKey) {
					options.earlyExit(prev, i - 1, cur);
				}
				// return undefined so we know this isn't the right value
				return {
					value: undefined,
					parent: prev,
					parentHasKey: parentHasKey,
					foundLastParent: false
				};
			}

		}

		parentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);
		// if we don't have a value, exit early.
		if (cur === undefined && !parentHasKey) {
			if (options.earlyExit) {
				options.earlyExit(prev, i - 1);
			}
		}
		return {
			value: cur,
			parent: prev,
			parentHasKey: parentHasKey,
			foundLastParent: true
		};
	},
	get: function(parent, reads, options){
		return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
	},
	valueReadersMap: {},
	// an array of types that might have a value inside them like functions
	// value readers check the current value
	// and get a new value from it
	// ideally they would keep calling until
	// none of these passed
	valueReaders: [
		{
			name: "function",
			// if this is a function before the last read and its not a constructor function
			test: function(value){
				return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
			},
			read: function(value, i, reads, options, state, prev){
				if(options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
					dev.warn("can-stache-key: read() called with `callMethodsOnObservables: true`.");

					return value.apply(prev, options.args || []);
				}

				return options.proxyMethods !== false ? bindName.call(value, prev) : value;
			}
		},
		{
			name: "isValueLike",
			// compute value reader
			test: function(value, i, reads, options) {
				return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );
			},
			read: function(value, i, reads, options){
				if(options.readCompute === false && i === reads.length ) {
					return value;
				}
				return canReflect.getValue(value);
			},
			write: function(base, newVal){
				if(base[setValueSymbol]) {
					base[setValueSymbol](newVal);
				} else if(base.set) {
					base.set(newVal);
				} else {
					base(newVal);
				}
			}
		}],
	propertyReadersMap: {},
	// an array of things that might have a property
	propertyReaders: [
		{
			name: "map",
			test: function(value){
				// the first time we try reading from a promise, set it up for
				//  special reflections.
				if(canReflect.isPromise(value) ||
					isPromiseLike(value)) {
					canReflectPromise(value);
				}

				return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
			},
			read: function(value, prop){
				var res = canReflect.getKeyValue(value, prop.key);
				if(res !== undefined) {
					return res;
				} else {
					return value[prop.key];
				}
			},
			write: canReflect.setKeyValue
		},

		// read a normal object
		{
			name: "object",
			// this is the default
			test: function(){return true;},
			read: function(value, prop, i, options){
				if(value == null) {
					return undefined;
				} else {
					if(typeof value === "object") {
						if(prop.key in value) {
							return value[prop.key];
						}
						// TODO: remove in 5.0.
						//!steal-remove-start
						if (true) {
							if( prop.at && specialRead[prop.key] && ( ("@"+prop.key) in value)) {
								options.foundAt = true;
								dev.warn("Use %"+prop.key+" in place of @"+prop.key+".");
								return undefined;
							}
						}
						//!steal-remove-end
					} else {
						return value[prop.key];
					}
				}
			},
			write: function(base, prop, newVal){
				var propValue = base[prop];
				// if newVal is observable object, lets try to update
				if(newVal != null && typeof newVal === "object" && canReflect.isMapLike(propValue) ) {
					dev.warn("can-stache-key: Merging data into \"" + prop + "\" because its parent is non-observable");
					canReflect.update(propValue, newVal);
				} else if(propValue != null && propValue[setValueSymbol] !== undefined){
					canReflect.setValue(propValue, newVal);
				} else {
					base[prop] = newVal;
				}
			}
		}
	],
	reads: function(keyArg) {
		var key = ""+keyArg;
		var keys = [];
		var last = 0;
		var at = false;
		if( key.charAt(0) === "@" ) {
			last = 1;
			at = true;
		}
		var keyToAdd = "";
		for(var i = last; i < key.length; i++) {
			var character = key.charAt(i);
			if(character === "." || character === "@") {
				if( key.charAt(i -1) !== "\\" ) {
					keys.push({
						key: keyToAdd,
						at: at
					});
					at = character === "@";
					keyToAdd = "";
				} else {
					keyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + ".";
				}
			} else {
				keyToAdd += character;
			}
		}
		keys.push({
			key: keyToAdd,
			at: at
		});

		return keys;
	},
	// This should be able to set a property similar to how read works.
	write: function(parent, key, value, options) {
		var keys = typeof key === "string" ? observeReader.reads(key) : key;
		var last;

		options = options || {};
		if(keys.length > 1) {
			last = keys.pop();
			parent = observeReader.read(parent, keys, options).value;
			keys.push(last);
		} else {
			last = keys[0];
		}
		if(!parent) {
			return;
		}
		var keyValue = peek(parent, last.key);
		// here's where we need to figure out the best way to write

		// if property being set points at a compute, set the compute
		if( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {
			observeReader.valueReadersMap.isValueLike.write(keyValue, value, options);
		} else {
			if(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {
				parent = parent[getValueSymbol]();
			}
			if(observeReader.propertyReadersMap.map.test(parent)) {
				observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
			}
			else if(observeReader.propertyReadersMap.object.test(parent)) {
				observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
				if(options.observation) {
					options.observation.update();
				}
			}
		}
	}
};
observeReader.propertyReaders.forEach(function(reader){
	observeReader.propertyReadersMap[reader.name] = reader;
});
observeReader.valueReaders.forEach(function(reader){
	observeReader.valueReadersMap[reader.name] = reader;
});
observeReader.set = observeReader.write;

module.exports = observeReader;


/***/ }),

/***/ "./node_modules/can-stache-route-helpers/can-stache-route-helpers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-stache-route-helpers/can-stache-route-helpers.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var helpers = __webpack_require__(/*! can-stache/helpers/core */ "./node_modules/can-stache/helpers/core.js");
var route = __webpack_require__(/*! can-route */ "./node_modules/can-route/can-route.js");

var stacheExpression = __webpack_require__(/*! can-stache/src/expression */ "./node_modules/can-stache/src/expression.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var looksLikeOptions = helpers.looksLikeOptions;

var calculateArgs = function(){
	var finalParams,
		finalMerge,
		optionsArg;

	canReflect.eachIndex(arguments, function(arg){
		if(typeof arg === "boolean") {
			finalMerge = arg;
		} else if( arg && typeof arg === "object"  ) {
			if(!looksLikeOptions(arg) ) {
				finalParams = helpers.resolveHash(arg);
			} else {
				optionsArg = arg;
			}
		}
	});

	if(!finalParams && optionsArg) {
		finalParams = helpers.resolveHash(optionsArg.hash);
	}
	return {
		finalParams: finalParams || {},
		finalMerge: finalMerge,
		optionsArg: optionsArg
	};
};


// go through arguments ... if there's a boolean ... if there's a plain object
var routeUrl = function(){
	var args = calculateArgs.apply(this, arguments);

	return route.url(args.finalParams, typeof args.finalMerge === "boolean" ? args.finalMerge : undefined);
};
helpers.registerHelper('routeUrl', routeUrl);

var routeCurrent = function(){

	var args = calculateArgs.apply(this, arguments);
	var result = route.isCurrent( args.finalParams, typeof args.finalMerge === "boolean" ? args.finalMerge : undefined );

	if( args.optionsArg && !(args.optionsArg instanceof stacheExpression.Call) ) {
		if( result ) {
			return args.optionsArg.fn();
		} else {
			return args.optionsArg.inverse();
		}
	} else {
		return result;
	}
};
routeCurrent.callAsMethod = true;

helpers.registerHelper('routeCurrent', routeCurrent);

module.exports = {
	routeUrl: routeUrl,
	routeCurrent: routeCurrent
};


/***/ }),

/***/ "./node_modules/can-stache/can-stache.js":
/*!***********************************************!*\
  !*** ./node_modules/can-stache/can-stache.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint undef: false */

var parser = __webpack_require__(/*! can-view-parser */ "./node_modules/can-view-parser/can-view-parser.js");
var viewCallbacks = __webpack_require__(/*! can-view-callbacks */ "./node_modules/can-view-callbacks/can-view-callbacks.js");

var HTMLSectionBuilder = __webpack_require__(/*! ./src/html_section */ "./node_modules/can-stache/src/html_section.js");
var TextSectionBuilder = __webpack_require__(/*! ./src/text_section */ "./node_modules/can-stache/src/text_section.js");
var mustacheCore = __webpack_require__(/*! ./src/mustache_core */ "./node_modules/can-stache/src/mustache_core.js");
var mustacheHelpers = __webpack_require__(/*! ./helpers/core */ "./node_modules/can-stache/helpers/core.js");
var getIntermediateAndImports = __webpack_require__(/*! can-stache-ast */ "./node_modules/can-stache-ast/can-stache-ast.js").parse;
var utils = __webpack_require__(/*! ./src/utils */ "./node_modules/can-stache/src/utils.js");
var makeRendererConvertScopes = utils.makeRendererConvertScopes;
var last = utils.last;

var attributeEncoder = __webpack_require__(/*! can-attribute-encoder */ "./node_modules/can-attribute-encoder/can-attribute-encoder.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var DOCUMENT = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var importer = __webpack_require__(/*! can-import-module */ "./node_modules/can-import-module/can-import-module.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");
var TemplateContext = __webpack_require__(/*! can-view-scope/template-context */ "./node_modules/can-view-scope/template-context.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
// Make sure that we can also use our modules with Stache as a plugin

__webpack_require__(/*! can-view-target */ "./node_modules/can-view-target/can-view-target.js");


if(!viewCallbacks.tag("content")) {
	// This was moved from the legacy view/scanner.js to here.
	// This makes sure content elements will be able to have a callback.
	viewCallbacks.tag("content", function(el, tagData) {
		return tagData.scope;
	});
}

var isViewSymbol = canSymbol.for("can.isView");

var wrappedAttrPattern = /[{(].*[)}]/;
var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
var svgNamespace = "http://www.w3.org/2000/svg",
xmlnsAttrNamespaceURI = "http://www.w3.org/2000/xmlns/",
xlinkHrefAttrNamespaceURI =  "http://www.w3.org/1999/xlink";
var namespaces = {
	"svg": svgNamespace,
	// this allows a partial to start with g.
	"g": svgNamespace,
	"defs": svgNamespace,
	"path": svgNamespace,
	"filter": svgNamespace,
	"feMorphology": svgNamespace,
	"feGaussianBlur": svgNamespace,
	"feOffset": svgNamespace,
	"feComposite": svgNamespace,
	"feColorMatrix": svgNamespace,
	"use": svgNamespace
},
	attrsNamespacesURI = {
		'xmlns': xmlnsAttrNamespaceURI,
		'xlink:href': xlinkHrefAttrNamespaceURI
	},
	textContentOnlyTag = {style: true, script: true};

function stache (filename, template) {
	if (arguments.length === 1) {
		template = arguments[0];
		filename = undefined;
	}

	var inlinePartials = {};

	// Remove line breaks according to mustache's specs.
	if(typeof template === "string") {
		template = mustacheCore.cleanWhitespaceControl(template);
		template = mustacheCore.cleanLineEndings(template);
	}

	// The HTML section that is the root section for the entire template.
	var section = new HTMLSectionBuilder(filename),
		// Tracks the state of the parser.
		state = {
			node: null,
			attr: null,
			// A stack of which node / section we are in.
			// There is probably a better way of doing this.
			sectionElementStack: [],
			// If text should be inserted and HTML escaped
			text: false,
			// which namespace we are in
			namespaceStack: [],
			// for style and script tags
			// we create a special TextSectionBuilder and add things to that
			// when the element is done, we compile the text section and
			// add it as a callback to `section`.
			textContentOnly: null

		},

		// This function is a catch all for taking a section and figuring out
		// how to create a "renderer" that handles the functionality for a
		// given section and modify the section to use that renderer.
		// For example, if an HTMLSection is passed with mode `#` it knows to
		// create a liveBindingBranchRenderer and pass that to section.add.
		// jshint maxdepth:5
		makeRendererAndUpdateSection = function(section, mode, stache, lineNo){

			if(mode === ">") {
				// Partials use liveBindingPartialRenderers
				section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ filename: section.filename, lineNo: lineNo })));

			} else if(mode === "/") {

				var createdSection = section.last();
				if ( createdSection.startedWith === "<" ) {
					inlinePartials[ stache ] = section.endSubSectionAndReturnRenderer();
					// Remove *TWO* nodes because we now have a start and an end comment for the section....
					section.removeCurrentNode();
					section.removeCurrentNode();
				} else {
					section.endSection();
				}

				// to avoid "Blocks are nested too deeply" when linting
				//!steal-remove-start
				if (true) {
					if(section instanceof HTMLSectionBuilder) {
						var last = state.sectionElementStack[state.sectionElementStack.length - 1];
						if (last.tag && last.type === "section" && stache !== "" && stache !== last.tag) {
							if (filename) {
								dev.warn(filename + ":" + lineNo + ": unexpected closing tag {{/" + stache + "}} expected {{/" + last.tag + "}}");
							}
							else {
								dev.warn(lineNo + ": unexpected closing tag {{/" + stache + "}} expected {{/" + last.tag + "}}");
							}
						}
					}
				}
				//!steal-remove-end

				if(section instanceof HTMLSectionBuilder) {
					state.sectionElementStack.pop();
				}
			} else if(mode === "else") {

				section.inverse();

			} else {

				// If we are an HTMLSection, we will generate a
				// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.
				// A LiveBindingBranchRenderer function processes
				// the mustache text, and sets up live binding if an observable is read.
				// A StringBranchRenderer function processes the mustache text and returns a
				// text value.
				var makeRenderer = section instanceof HTMLSectionBuilder ?
					mustacheCore.makeLiveBindingBranchRenderer:
					mustacheCore.makeStringBranchRenderer;

				if(mode === "{" || mode === "&") {

					// Adds a renderer function that just reads a value or calls a helper.
					section.add(makeRenderer(null,stache, copyState({ filename: section.filename, lineNo: lineNo })));

				} else if(mode === "#" || mode === "^" || mode === "<") {
					// Adds a renderer function and starts a section.
					var renderer = makeRenderer(mode, stache, copyState({ filename: section.filename, lineNo: lineNo }));
					var sectionItem = {
						type: "section"
					};
					section.startSection(renderer, stache);
					section.last().startedWith = mode;

					// If we are a directly nested section, count how many we are within
					if(section instanceof HTMLSectionBuilder) {
						//!steal-remove-start
						if (true) {
							var tag = typeof renderer.exprData.closingTag === 'function' ?
								renderer.exprData.closingTag() : stache;
							sectionItem.tag = tag;
						}
						//!steal-remove-end

						state.sectionElementStack.push(sectionItem);
					}
				} else {
					// Adds a renderer function that only updates text.
					section.add(makeRenderer(null, stache, copyState({text: true, filename: section.filename, lineNo: lineNo })));
				}

			}
		},
		isDirectlyNested = function() {
			var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
			return state.sectionElementStack.length ?
				lastElement.type === "section" || lastElement.type === "custom": true;
		},
		// Copys the state object for use in renderers.
		copyState = function(overwrites){

			var cur = {
				tag: state.node && state.node.tag,
				attr: state.attr && state.attr.name,
				// <content> elements should be considered direclty nested
				directlyNested: isDirectlyNested(),
				textContentOnly: !!state.textContentOnly
			};
			return overwrites ? assign(cur, overwrites) : cur;
		},
		addAttributesCallback = function(node, callback){
			if( !node.attributes ) {
				node.attributes = [];
			}
			node.attributes.unshift(callback);
		};

	parser(template, {
		filename: filename,
		start: function(tagName, unary, lineNo){
			var matchedNamespace = namespaces[tagName];

			if (matchedNamespace && !unary ) {
				state.namespaceStack.push(matchedNamespace);
			}

			// either add templates: {} here or check below and decorate
			// walk up the stack/targetStack until you find the first node
			// with a templates property, and add the popped renderer
			state.node = {
				tag: tagName,
				children: [],
				namespace: matchedNamespace || last(state.namespaceStack)
			};
		},
		end: function(tagName, unary, lineNo){
			var isCustomTag =  viewCallbacks.tag(tagName);
			var directlyNested = isDirectlyNested();
			if(unary){
				// If it's a custom tag with content, we need a section renderer.
				section.add(state.node);
				if(isCustomTag) {
					// Call directlyNested now as it's stateful.
					addAttributesCallback(state.node, function(scope){
						//!steal-remove-start
						if (true) {
							scope.set('scope.lineNumber', lineNo);
						}
						//!steal-remove-end
						viewCallbacks.tagHandler(this,tagName, {
							scope: scope,
							subtemplate: null,
							templateType: "stache",
							directlyNested: directlyNested
						});
					});
				}
			} else {
				section.push(state.node);

				state.sectionElementStack.push({
					type: isCustomTag ? "custom" : null,
					tag: isCustomTag ? null : tagName,
					templates: {},
					directlyNested: directlyNested
				});

				// If it's a custom tag with content, we need a section renderer.
				if( isCustomTag ) {
					section.startSubSection();
				} else if(textContentOnlyTag[tagName]) {
					state.textContentOnly = new TextSectionBuilder(filename);
				}
			}


			state.node =null;

		},
		close: function(tagName, lineNo) {
			var matchedNamespace = namespaces[tagName];

			if (matchedNamespace  ) {
				state.namespaceStack.pop();
			}

			var isCustomTag = viewCallbacks.tag(tagName),
				renderer;

			if( isCustomTag ) {
				renderer = section.endSubSectionAndReturnRenderer();
			}

			if(textContentOnlyTag[tagName]) {
				section.last().add(state.textContentOnly.compile(copyState()));
				state.textContentOnly = null;
			}

			var oldNode = section.pop();
			if( isCustomTag ) {
				if (tagName === "can-template") {
					// If we find a can-template we want to go back 2 in the stack to get it's inner content
					// rather than the <can-template> element itself
					var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
					if (renderer) {// Only add the renderer if the template has content
						parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
					}
					section.removeCurrentNode();
				} else {
					// Get the last element in the stack
					var current = state.sectionElementStack[state.sectionElementStack.length - 1];
					addAttributesCallback(oldNode, function(scope){
						//!steal-remove-start
						if (true) {
							scope.set('scope.lineNumber', lineNo);
						}
						//!steal-remove-end
						viewCallbacks.tagHandler(this,tagName, {
							scope: scope,
							subtemplate: renderer  ? makeRendererConvertScopes(renderer) : renderer,
							templateType: "stache",
							templates: current.templates,
							directlyNested: current.directlyNested
						});
					});
				}
			}
			state.sectionElementStack.pop();
		},
		attrStart: function(attrName, lineNo){
			if(state.node.section) {
				state.node.section.add(attrName+"=\"");
			} else {
				state.attr = {
					name: attrName,
					value: ""
				};
			}

		},
		attrEnd: function(attrName, lineNo){
			var matchedAttrNamespacesURI = attrsNamespacesURI[attrName];
			if(state.node.section) {
				state.node.section.add("\" ");
			} else {
				if(!state.node.attrs) {
					state.node.attrs = {};
				}

				if (state.attr.section) {
					state.node.attrs[state.attr.name] = state.attr.section.compile(copyState());
				} else if (matchedAttrNamespacesURI) {
					state.node.attrs[state.attr.name] = {
						value: state.attr.value,
						namespaceURI: attrsNamespacesURI[attrName]
					};
				} else {
					state.node.attrs[state.attr.name] = state.attr.value;
				}

				var attrCallback = viewCallbacks.attr(attrName);

				//!steal-remove-start
				if (true) {
					var decodedAttrName = attributeEncoder.decode(attrName);
					var weirdAttribute = !!wrappedAttrPattern.test(decodedAttrName) || !!colonWrappedAttrPattern.test(decodedAttrName);
					if (weirdAttribute && !attrCallback) {
						dev.warn("unknown attribute binding " + decodedAttrName + ". Is can-stache-bindings imported?");
					}
				}
				//!steal-remove-end

				if(attrCallback) {
					if( !state.node.attributes ) {
						state.node.attributes = [];
					}
					state.node.attributes.push(function(scope){
						//!steal-remove-start
						if (true) {
							scope.set('scope.lineNumber', lineNo);
						}
						//!steal-remove-end
						attrCallback(this,{
							attributeName: attrName,
							scope: scope
						});
					});
				}

				state.attr = null;
			}
		},
		attrValue: function(value, lineNo){
			var section = state.node.section || state.attr.section;
			if(section){
				section.add(value);
			} else {
				state.attr.value += value;
			}
		},
		chars: function(text, lineNo) {
			(state.textContentOnly || section).add(text);
		},
		special: function(text, lineNo){
			var firstAndText = mustacheCore.splitModeFromExpression(text, state),
				mode = firstAndText.mode,
				expression = firstAndText.expression;


			if(expression === "else") {
				var inverseSection;
				if(state.attr && state.attr.section) {
					inverseSection = state.attr.section;
				} else if(state.node && state.node.section ) {
					inverseSection = state.node.section;
				} else {
					inverseSection = state.textContentOnly || section;
				}
				inverseSection.inverse();
				return;
			}

			if(mode === "!") {
				return;
			}

			if(state.node && state.node.section) {

				makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);

				if(state.node.section.subSectionDepth() === 0){
					state.node.attributes.push( state.node.section.compile(copyState()) );
					delete state.node.section;
				}

			}
			// `{{}}` in an attribute like `class="{{}}"`
			else if(state.attr) {

				if(!state.attr.section) {
					state.attr.section = new TextSectionBuilder(filename);
					if(state.attr.value) {
						state.attr.section.add(state.attr.value);
					}
				}
				makeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);

			}
			// `{{}}` in a tag like `<div {{}}>`
			else if(state.node) {

				if(!state.node.attributes) {
					state.node.attributes = [];
				}
				if(!mode) {
					state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ filename: section.filename, lineNo: lineNo })));
				} else if( mode === "#" || mode === "^" ) {
					if(!state.node.section) {
						state.node.section = new TextSectionBuilder(filename);
					}
					makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
				} else {
					throw new Error(mode+" is currently not supported within a tag.");
				}
			}
			else {
				makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);
			}
		},
		comment: function(text) {
			// create comment node
			section.add({
				comment: text
			});
		},
		done: function(lineNo){
			//!steal-remove-start
			// warn if closing magic tag is missed #675
			if (true) {
				var last = state.sectionElementStack[state.sectionElementStack.length - 1];
				if (last && last.tag && last.type === "section") {
					if (filename) {
						dev.warn(filename + ":" + lineNo + ": closing tag {{/" + last.tag + "}} was expected");
					}
					else {
						dev.warn(lineNo + ": closing tag {{/" + last.tag + "}} was expected");
					}
				}
			}
			//!steal-remove-end
		}
	});

	var renderer = section.compile();

	var scopifiedRenderer = ObservationRecorder.ignore(function(scope, options){
		// if an object is passed to options, assume it is the helpers object
		if (options && !options.helpers && !options.partials && !options.tags) {
			options = {
				helpers: options
			};
		}
		// mark passed in helper so they will be automatically passed
		// helperOptions (.fn, .inverse, etc) when called as Call Expressions
		canReflect.eachKey(options && options.helpers, function(helperValue) {
			helperValue.requiresOptionsArgument = true;
		});

		// helpers, partials, tags, vars
		var templateContext = new TemplateContext(options);

		// copy inline partials over
		canReflect.eachKey(inlinePartials, function(partial, partialName) {
			canReflect.setKeyValue(templateContext.partials, partialName, partial);
		});

		// allow the current renderer to be called with {{>scope.view}}
		canReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);
		//!steal-remove-start
		if (true) {
			canReflect.setKeyValue(templateContext, 'filename', section.filename);
		}
		//!steal-remove-end


		// now figure out the final structure ...
		if ( !(scope instanceof Scope) ) {
			scope = new Scope(templateContext).add(scope);
		} else {
			// we are going to split ...
			var templateContextScope = new Scope(templateContext);
			templateContextScope._parent = scope._parent;
			scope._parent = templateContextScope;
		}

		return renderer(scope.addLetContext());
	});

	// Identify is a view type
	scopifiedRenderer[isViewSymbol] = true;

	return scopifiedRenderer;
}

// At this point, can.stache has been created
assign(stache, mustacheHelpers);

stache.safeString = function(text){

	return canReflect.assignSymbols({},{
		"can.toDOM": function(){
			return text;
		}
	});
};
stache.async = function(source){
	var iAi = getIntermediateAndImports(source);
	var importPromises = iAi.imports.map(function(moduleName){
		return importer(moduleName);
	});
	return Promise.all(importPromises).then(function(){
		return stache(iAi.intermediate);
	});
};
var templates = {};
stache.from = mustacheCore.getTemplateById = function(id){
	if(!templates[id]) {
		var el = DOCUMENT().getElementById(id);
		if(el) {
			templates[id] = stache("#" + id, el.innerHTML);
		}
	}
	return templates[id];
};

stache.registerPartial = function(id, partial) {
	templates[id] = (typeof partial === "string" ? stache(partial) : partial);
};

stache.addBindings = viewCallbacks.attrs;

module.exports = namespace.stache = stache;


/***/ }),

/***/ "./node_modules/can-stache/expressions/arg.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/expressions/arg.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";

// ### Arg
// `new Arg(Expression [,modifierOptions] )`
// Used to identify an expression that should return a value.
var Arg = function(expression, modifiers){
	this.expr = expression;
	this.modifiers = modifiers || {};
	this.isCompute = false;
};
Arg.prototype.value = function(){
	return this.expr.value.apply(this.expr, arguments);
};
//!steal-remove-start
if (true) {
	Arg.prototype.sourceText = function(){
		return (this.modifiers.compute ? "~" : "")+ this.expr.sourceText();
	};
}
//!steal-remove-end

module.exports = Arg;


/***/ }),

/***/ "./node_modules/can-stache/expressions/bracket.js":
/*!********************************************************!*\
  !*** ./node_modules/can-stache/expressions/bracket.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//!steal-remove-start
if (true) {
	var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
}
//!steal-remove-end
var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");

// ### Bracket
// For accessing properties using bracket notation like `foo[bar]`
var Bracket = function (key, root, originalKey) {
	this.root = root;
	this.key = key;
	//!steal-remove-start
	if (true) {
		this[canSymbol.for("can-stache.originalKey")] = originalKey;
	}
	//!steal-remove-end
};
Bracket.prototype.value = function (scope, helpers) {
	var root = this.root ? this.root.value(scope, helpers) : scope.peek("this");
	return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
};
//!steal-remove-start
if (true) {
	Bracket.prototype.sourceText = function(){
		if(this.rootExpr) {
			return this.rootExpr.sourceText()+"["+this.key+"]";
		} else {
			return "["+this.key+"]";
		}
	};
}
//!steal-remove-end

Bracket.prototype.closingTag = function() {
	//!steal-remove-start
	if (true) {
		return this[canSymbol.for('can-stache.originalKey')] || '';
	}
	//!steal-remove-end
};

module.exports = Bracket;


/***/ }),

/***/ "./node_modules/can-stache/expressions/call.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/expressions/call.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Hashes = __webpack_require__(/*! ./hashes */ "./node_modules/can-stache/expressions/hashes.js");
var SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ "./node_modules/can-stache/src/set-identifier.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ "./node_modules/can-simple-observable/setter/setter.js");
var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

var sourceTextSymbol = canSymbol.for("can-stache.sourceText");
var isViewSymbol = canSymbol.for("can.isView");
var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");

// ### Call
// `new Call( new Lookup("method"), [new ScopeExpr("name")], {})`
// A call expression like `method(arg1, arg2)` that, by default,
// calls `method` with non compute values.
var Call = function(methodExpression, argExpressions){
	this.methodExpr = methodExpression;
	this.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);
};
Call.prototype.args = function(scope, ignoreArgLookup) {
	var hashExprs = {};
	var args = [];
	var gotIgnoreFunction = typeof ignoreArgLookup === "function";

	for (var i = 0, len = this.argExprs.length; i < len; i++) {
		var arg = this.argExprs[i];
		if(arg.expr instanceof Hashes){
			assign(hashExprs, arg.expr.hashExprs);
		}
		if (!gotIgnoreFunction || !ignoreArgLookup(i)) {
			var value = arg.value.apply(arg, arguments);
			args.push({
				// always do getValue unless compute is false
				call: !arg.modifiers || !arg.modifiers.compute,
				value: value
			});
		}
	}
	return function(doNotWrapArguments){
		var finalArgs = [];
		if(canReflect.size(hashExprs) > 0){
			finalArgs.hashExprs = hashExprs;
		}
		for(var i = 0, len = args.length; i < len; i++) {
			if (doNotWrapArguments) {
				finalArgs[i] = args[i].value;
			} else {
				finalArgs[i] = args[i].call ?
					canReflect.getValue( args[i].value ) :
					expressionHelpers.toCompute( args[i].value );
			}
		}
		return finalArgs;
	};
};

Call.prototype.value = function(scope, helperOptions){
	var callExpression = this;

	// proxyMethods must be false so that the `requiresOptionsArgument` and any
	// other flags stored on the function are preserved
	var method = this.methodExpr.value(scope, { proxyMethods: false });
	Observation.temporarilyBind(method);
	var func = canReflect.getValue( method );

	var getArgs = callExpression.args(scope , func && func.ignoreArgLookup);

	var computeFn = function(newVal){
		var func = canReflect.getValue( method );
		if(typeof func === "function") {
			if (canReflect.isObservableLike(func)) {
				func = canReflect.getValue(func);
			}
			var args = getArgs(
				func.isLiveBound
			);

			if (func.requiresOptionsArgument) {
				if(args.hashExprs && helperOptions && helperOptions.exprData){
					helperOptions.exprData.hashExprs = args.hashExprs;
				}
				// For #581
				if(helperOptions !== undefined) {
					args.push(helperOptions);
				}
			}
			// we are calling a view!
			if(func[isViewSymbol] === true) {
				// if not a scope, we should create a scope that
				// includes the template scope
				if(!(args[0] instanceof Scope)){
					args[0] = scope.getTemplateContext().add(args[0]);
				}
			}
			if(arguments.length) {
				args.unshift(new SetIdentifier(newVal));
			}

			// if this is a call like `foo.bar()` the method.thisArg will be set to `foo`
			// for a call like `foo()`, method.thisArg will not be set and we will default
			// to setting the scope as the context of the function
			return func.apply(method.thisArg || scope.peek("this"), args);
		}
	};
	//!steal-remove-start
	if (true) {
		Object.defineProperty(computeFn, "name", {
			value: "{{" + this.sourceText() + "}}"
		});
	}
	//!steal-remove-end

	if (helperOptions && helperOptions.doNotWrapInObservation) {
		return computeFn();
	} else {
		var computeValue = new SetterObservable(computeFn, computeFn);

		return computeValue;
	}
};
//!steal-remove-start
if (true) {
	Call.prototype.sourceText = function(){
		var args = this.argExprs.map(function(arg){
			return arg.sourceText();
		});
		return this.methodExpr.sourceText()+"("+args.join(",")+")";
	};
}
//!steal-remove-end
Call.prototype.closingTag = function() {
	//!steal-remove-start
	if (true) {
		if(this.methodExpr[sourceTextSymbol]) {
			return this.methodExpr[sourceTextSymbol];
		}
	}
	//!steal-remove-end
	return this.methodExpr.key;
};

module.exports = Call;


/***/ }),

/***/ "./node_modules/can-stache/expressions/hashes.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/hashes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");

var Hashes = function(hashes){
	this.hashExprs = hashes;
};
Hashes.prototype.value = function(scope, helperOptions){
	var hash = {};
	for(var prop in this.hashExprs) {
		var val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]),
			value = val.value.apply(val, arguments);

		hash[prop] = {
			call: !val.modifiers || !val.modifiers.compute,
			value: value
		};
	}
	return new Observation(function(){
		var finalHash = {};
		for(var prop in hash) {
			finalHash[prop] = hash[prop].call ? canReflect.getValue( hash[prop].value ) : expressionHelpers.toComputeOrValue( hash[prop].value );
		}
		return finalHash;
	});
};
//!steal-remove-start
if (true) {
	Hashes.prototype.sourceText = function(){
		var hashes = [];
		canReflect.eachKey(this.hashExprs, function(expr, prop){
			hashes.push( prop+"="+expr.sourceText() );
		});
		return hashes.join(" ");
	};
}
//!steal-remove-end

module.exports = Hashes;


/***/ }),

/***/ "./node_modules/can-stache/expressions/helper.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/helper.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Literal = __webpack_require__(/*! ./literal */ "./node_modules/can-stache/expressions/literal.js");
var Hashes = __webpack_require__(/*! ./hashes */ "./node_modules/can-stache/expressions/hashes.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Helper = function(methodExpression, argExpressions, hashExpressions){
	this.methodExpr = methodExpression;
	this.argExprs = argExpressions;
	this.hashExprs = hashExpressions;
	this.mode = null;
};
Helper.prototype.args = function(scope){
	var args = [];
	for(var i = 0, len = this.argExprs.length; i < len; i++) {
		var arg = this.argExprs[i];
		// TODO: once we know the helper, we should be able to avoid compute conversion
		args.push( expressionHelpers.toComputeOrValue( arg.value.apply(arg, arguments) ) );
	}
	return args;
};
Helper.prototype.hash = function(scope){
	var hash = {};
	for(var prop in this.hashExprs) {
		var val = this.hashExprs[prop];
		// TODO: once we know the helper, we should be able to avoid compute conversion
		hash[prop] = expressionHelpers.toComputeOrValue( val.value.apply(val, arguments) );
	}
	return hash;
};

Helper.prototype.value = function(scope, helperOptions){
	// If a literal, this means it should be treated as a key. But helpers work this way for some reason.
	// TODO: fix parsing so numbers will also be assumed to be keys.
	var methodKey = this.methodExpr instanceof Literal ?
		"" + this.methodExpr._value :
		this.methodExpr.key,
		helperInstance = this,
		// proxyMethods must be false so that the `requiresOptionsArgument` and any
		// other flags stored on the function are preserved
		helperFn = scope.computeData(methodKey,  { proxyMethods: false }),
		initialValue = helperFn && helperFn.initialValue,
		thisArg = helperFn && helperFn.thisArg;

	if (typeof initialValue === "function") {
		helperFn = function helperFn() {
			var args = helperInstance.args(scope),
				helperOptionArg = assign(assign({}, helperOptions), {
					hash: helperInstance.hash(scope),
					exprData: helperInstance
				});

			args.push(helperOptionArg);

			return initialValue.apply(thisArg || scope.peek("this"), args);
		};
		//!steal-remove-start
		if (true) {
			Object.defineProperty(helperFn, "name", {
				configurable: true,
				value: canReflect.getName(this)
			});
		}
		//!steal-remove-end
	}
	//!steal-remove-start
	else if (true) {
		var filename = scope.peek('scope.filename');
			var lineNumber = scope.peek('scope.lineNumber');
			dev.warn(
				(filename ? filename + ':' : '') +
				(lineNumber ? lineNumber + ': ' : '') +
				'Unable to find helper "' + methodKey + '".');
	}
	//!steal-remove-end

	return  helperFn;
};

Helper.prototype.closingTag = function() {
	return this.methodExpr.key;
};

//!steal-remove-start
if (true) {
	Helper.prototype.sourceText = function(){
		var text = [this.methodExpr.sourceText()];
		if(this.argExprs.length) {
			text.push( this.argExprs.map(function(arg){
				return arg.sourceText();
			}).join(" ") );
		}
		if(canReflect.size(this.hashExprs) > 0){
			text.push( Hashes.prototype.sourceText.call(this) );
		}
		return text.join(" ");
	};

	canReflect.assignSymbols(Helper.prototype,{
		"can.getName": function() {
			return canReflect.getName(this.constructor) + "{{" + (this.sourceText()) + "}}";
		}
	});
}
//!steal-remove-end

module.exports = Helper;


/***/ }),

/***/ "./node_modules/can-stache/expressions/literal.js":
/*!********************************************************!*\
  !*** ./node_modules/can-stache/expressions/literal.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

// ### Literal
// For inline static values like `{{"Hello World"}}`
var Literal = function(value){
	this._value = value;
};
Literal.prototype.value = function(){
	return this._value;
};
//!steal-remove-start
if (true) {
	Literal.prototype.sourceText = function(){
		return JSON.stringify(this._value);
	};
}
//!steal-remove-end

module.exports = Literal;


/***/ }),

/***/ "./node_modules/can-stache/expressions/lookup.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/lookup.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var sourceTextSymbol = canSymbol.for("can-stache.sourceText");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

// ### Lookup
// `new Lookup(String, [Expression])`
// Finds a value in the scope or a helper.
var Lookup = function(key, root, sourceText) {
	this.key = key;
	this.rootExpr = root;
	canReflect.setKeyValue(this, sourceTextSymbol, sourceText);
};
Lookup.prototype.value = function(scope, readOptions){
	if (this.rootExpr) {
		return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});
	} else {
		return scope.computeData(this.key, assign({
			warnOnMissingKey: true
		},readOptions));
	}
};
//!steal-remove-start
if (true) {
	Lookup.prototype.sourceText = function(){
		if(this[sourceTextSymbol]) {
			return this[sourceTextSymbol];
		} else if(this.rootExpr) {
			return this.rootExpr.sourceText()+"."+this.key;
		} else {
			return this.key;
		}
	};
}
//!steal-remove-end

module.exports = Lookup;


/***/ }),

/***/ "./node_modules/can-stache/helpers/-debugger.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/helpers/-debugger.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canLog = __webpack_require__(/*! can-log */ "./node_modules/can-log/can-log.js");
function noop () {}
var resolveValue = noop;
var evaluateArgs = noop;
var __testing = {};

//!steal-remove-start
if (true) {
	var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

	var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

	__testing = {
		allowDebugger: true
	};

	resolveValue = function (value) {
		if (value && value[canSymbol.for("can.getValue")]) {
			return canReflect.getValue(value);
		}
		return value;
	};

	evaluateArgs = function (left, right) {
		switch (arguments.length) {
			case 0: return true;
			case 1: return !!resolveValue(left);
			case 2: return resolveValue(left) === resolveValue(right);
			default:
				canLog.log([
					'Usage:',
					'  {{debugger}}: break any time this helper is evaluated',
					'  {{debugger condition}}: break when `condition` is truthy',
					'  {{debugger left right}}: break when `left` === `right`'
				].join('\n'));
				throw new Error('{{debugger}} must have less than three arguments');
		}
	};
}
//!steal-remove-end

function debuggerHelper (left, right) {
	//!steal-remove-start
	if (true) {
		var shouldBreak = evaluateArgs.apply(null, Array.prototype.slice.call(arguments, 0, -1));
		if (!shouldBreak) {
			return;
		}

		var options = arguments[arguments.length - 1],
			scope = options && options.scope;
		var get = function (path) {
			return scope.get(path);
		};
		// This makes sure `get`, `options` and `scope` are available
		debuggerHelper._lastGet = get;

		canLog.log('Use `get(<path>)` to debug this template');

		var allowDebugger = __testing.allowDebugger;
		// forgotten debugger
		// jshint -W087
		if (allowDebugger) {
			debugger;
			return;
		}
		// jshint +W087
	}
	//!steal-remove-end

	canLog.warn('Forgotten {{debugger}} helper');
}
debuggerHelper.requiresOptionsArgument = true;

module.exports = {
	helper: debuggerHelper,
	evaluateArgs: evaluateArgs,
	resolveValue: resolveValue,

	// used only for testing purposes
	__testing: __testing
};


/***/ }),

/***/ "./node_modules/can-stache/helpers/-for-of.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/helpers/-for-of.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var live = __webpack_require__(/*! can-view-live */ "./node_modules/can-view-live/can-view-live.js");
var expression = __webpack_require__(/*! ../src/expression */ "./node_modules/can-stache/src/expression.js");
var KeyObservable = __webpack_require__(/*! ../src/key-observable */ "./node_modules/can-stache/src/key-observable.js");

var bindAndRead = function (value) {
	if ( value && canReflect.isValueLike(value) ) {
		Observation.temporarilyBind(value);
		return canReflect.getValue(value);
	} else {
		return value;
	}
};

function forOfInteger(integer, variableName, options) {
	var result = [];
	for (var i = 0; i < integer; i++) {
		var variableScope = {};
		if(variableName !== undefined){
			variableScope[variableName] = i;
		}
		result.push(
			options.fn( options.scope
				.add({ index: i }, { special: true })
				.addLetContext(variableScope) )
		);
	}

	return options.stringOnly ? result.join('') : result;
}

function forOfObject(object, variableName, options){
	var result = [];
	canReflect.each(object, function(val, key){
		// Allow key to contain a dot, for example: "My.key.has.dot"
		var value = new KeyObservable(object, key.replace(/\./g, "\\."));
		var variableScope = {};
		if(variableName !== undefined){
			variableScope[variableName] = value;
		}
		result.push(
			options.fn( options.scope
				.add({ key: key }, { special: true })
				.addLetContext(variableScope) )
		);
	});

	return options.stringOnly ? result.join('') : result;
}

// this is called with the ast ... we are going to use that to our advantage.
var forHelper = function(helperOptions) {
	// lookup

	// TODO: remove in prod
	// make sure we got called with the right stuff
	if(helperOptions.exprData.argExprs.length !== 1) {
		throw new Error("for(of) broken syntax");
	}

	// TODO: check if an instance of helper;

	var helperExpr = helperOptions.exprData.argExprs[0].expr;
	var variableName, valueLookup, valueObservable;
	if(helperExpr instanceof expression.Lookup) {

		valueObservable = helperExpr.value(helperOptions.scope);

	} else if(helperExpr instanceof expression.Helper) {
		// TODO: remove in prod
		var inLookup = helperExpr.argExprs[0];
		if(inLookup.key !== "of") {
			throw new Error("for(of) broken syntax");
		}
		variableName = helperExpr.methodExpr.key;
		valueLookup = helperExpr.argExprs[1];
		valueObservable = valueLookup.value(helperOptions.scope);
	}

	var items =  valueObservable;

	var args = [].slice.call(arguments),
		options = args.pop(),
		resolved = bindAndRead(items);

	if(resolved && resolved === Math.floor(resolved)) {
		return forOfInteger(resolved, variableName, helperOptions);
	}
	if(resolved && !canReflect.isListLike(resolved)) {
		return forOfObject(resolved,variableName, helperOptions);
	}
	if(options.stringOnly) {
		var parts = [];
		canReflect.eachIndex(resolved, function(value, index){
			var variableScope = {};
			if(variableName !== undefined){
				variableScope[variableName] = value;
			}
			parts.push(
				helperOptions.fn( options.scope
					.add({ index: index }, { special: true })
					.addLetContext(variableScope) )
			);
		});
		return parts.join("");
	} else {
		// Tells that a helper has been called, this function should be returned through
		// checking its value.
		options.metadata.rendered = true;
		return function(el){

			var cb = function (item, index) {
				var variableScope = {};
				if(variableName !== undefined){
					variableScope[variableName] = item;
				}
				return options.fn(
					options.scope
					.add({ index: index }, { special: true })
					.addLetContext(variableScope),
					options.options
				);
			};

			live.list(el, items, cb, options.context, function(list){
				return options.inverse(options.scope, options.options);
			});
		};
	}
};
forHelper.isLiveBound = true;
forHelper.requiresOptionsArgument = true;
forHelper.ignoreArgLookup = function ignoreArgLookup(index) {
	return index === 0;
};

module.exports = forHelper;


/***/ }),

/***/ "./node_modules/can-stache/helpers/-let.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache/helpers/-let.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

function isVariable(scope) {
	return scope._meta.variable === true;
}

// This sets variables so it needs to not causes changes.
var letHelper = ObservationRecorder.ignore(function(options){
	if(options.isSection){
		return options.fn( options.scope.addLetContext( options.hash ) );
	}
	var variableScope = options.scope.getScope(isVariable);
	if(!variableScope) {
		throw new Error("There is no variable scope!");
	}

	canReflect.assignMap(variableScope._context, options.hash);
	return document.createTextNode("");
});

module.exports = letHelper;


/***/ }),

/***/ "./node_modules/can-stache/helpers/-portal.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/helpers/-portal.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var live = __webpack_require__(/*! can-view-live */ "./node_modules/can-view-live/can-view-live.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var liveHelpers = __webpack_require__(/*! can-view-live/lib/helpers */ "./node_modules/can-view-live/lib/helpers.js");

var keepNodeSymbol = canSymbol.for("done.keepNode");

function portalHelper(elementObservable, options){
	var debugName = "portal(" + canReflect.getName(elementObservable) + ")";

	function portalContents() {
		var frag = options.fn(
			options.scope
			.addLetContext({}),
			options.options
		);

		var child = frag.firstChild;
		while(child) {
			// makes sure DoneJS does not remove these nodes
			child[keepNodeSymbol] = true;
			child = child.nextSibling;
		}


		return frag;
	}

	//!steal-remove-start
	if(true) {
		Object.defineProperty(portalContents,"name",{
			value: debugName+" contents"
		});
	}
	//!steal-remove-end


	// Where we are portalling
	var portalElement,
		startPortalledPlaceholder,
		endPortalledPlaceholder,
		commentPlaceholderDispose;
	function teardownPortalledContent() {

		if(portalElement) {
			canReflect.offValue(elementObservable, getElementAndRender);
			portalElement = null;
		}

		if(startPortalledPlaceholder && endPortalledPlaceholder) {
			var parentNode = startPortalledPlaceholder.parentNode;
			if(parentNode) {
				liveHelpers.range.remove({start: startPortalledPlaceholder, end: endPortalledPlaceholder});
				domMutateNode.removeChild.call(parentNode, startPortalledPlaceholder );
				domMutateNode.removeChild.call(parentNode, endPortalledPlaceholder );
				startPortalledPlaceholder = endPortalledPlaceholder = null;
			}
		}
	}
	function teardownEverything(){
		if(commentPlaceholderDispose) {
			commentPlaceholderDispose();
		}
		teardownPortalledContent();
	}
	// The element has changed
	function getElementAndRender() {
		// remove the old rendered content and unbind if we've bound before
		teardownPortalledContent();

		canReflect.onValue(elementObservable, getElementAndRender);

		portalElement = canReflect.getValue(elementObservable);

		if(portalElement) {
			startPortalledPlaceholder = portalElement.ownerDocument.createComment(debugName+" contents");
			endPortalledPlaceholder = portalElement.ownerDocument.createComment("can-end-placeholder");
			startPortalledPlaceholder[keepNodeSymbol] = true;
			endPortalledPlaceholder[keepNodeSymbol] = true;
			portalElement.appendChild(startPortalledPlaceholder);
			portalElement.appendChild(endPortalledPlaceholder);

			var observable = new Observation(portalContents, null, {isObservable: false});

			live.html(startPortalledPlaceholder, observable);
		} else {
			options.metadata.rendered = true;
		}

	}

	getElementAndRender();

	return function(placeholderElement) {
		var commentPlaceholder = placeholderElement.ownerDocument.createComment(debugName);

		placeholderElement.parentNode.replaceChild(commentPlaceholder, placeholderElement);
		commentPlaceholderDispose = domMutate.onNodeRemoved(commentPlaceholder, teardownEverything);
		return commentPlaceholder;
	};
}

portalHelper.isLiveBound = true;
portalHelper.requiresOptionsArgument = true;

module.exports = portalHelper;


/***/ }),

/***/ "./node_modules/can-stache/helpers/converter.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/helpers/converter.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ "./node_modules/can-stache/src/set-identifier.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function makeConverter(getterSetter){
	getterSetter = getterSetter || {};
	return function(newVal, source) {
		var args = canReflect.toArray(arguments);
		if(newVal instanceof SetIdentifier) {
			return typeof getterSetter.set === "function" ?
				getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) :
				source(newVal.value);
		} else {
			return typeof getterSetter.get === "function" ?
				getterSetter.get.apply(this, args) :
				args[0];
		}
	};
}

module.exports = makeConverter;


/***/ }),

/***/ "./node_modules/can-stache/helpers/core.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache/helpers/core.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var live = __webpack_require__(/*! can-view-live */ "./node_modules/can-view-live/can-view-live.js");
var utils = __webpack_require__(/*! ../src/utils */ "./node_modules/can-stache/src/utils.js");
var getBaseURL = __webpack_require__(/*! can-globals/base-url/base-url */ "./node_modules/can-globals/base-url/base-url.js");
var joinURIs = __webpack_require__(/*! can-join-uris */ "./node_modules/can-join-uris/can-join-uris.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var debuggerHelper = __webpack_require__(/*! ./-debugger */ "./node_modules/can-stache/helpers/-debugger.js").helper;
var KeyObservable = __webpack_require__(/*! ../src/key-observable */ "./node_modules/can-stache/src/key-observable.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var TruthyObservable = __webpack_require__(/*! ../src/truthy-observable */ "./node_modules/can-stache/src/truthy-observable.js");
var helpers = __webpack_require__(/*! can-stache-helpers */ "./node_modules/can-stache-helpers/can-stache-helpers.js");
var makeConverter = __webpack_require__(/*! ./converter */ "./node_modules/can-stache/helpers/converter.js");

var domData = __webpack_require__(/*! can-dom-data */ "./node_modules/can-dom-data/can-dom-data.js");

var forHelper = __webpack_require__(/*! ./-for-of */ "./node_modules/can-stache/helpers/-for-of.js");
var letHelper = __webpack_require__(/*! ./-let */ "./node_modules/can-stache/helpers/-let.js");
var portalHelper = __webpack_require__(/*! ./-portal */ "./node_modules/can-stache/helpers/-portal.js");

var builtInHelpers = {};
var builtInConverters = {};
var converterPackages = new WeakMap();

// ## Helpers
var helpersCore = {
	looksLikeOptions: function(options){
		return options && typeof options.fn === "function" && typeof options.inverse === "function";
	},
	resolve: function(value) {
		if (value && canReflect.isValueLike(value)) {
			return canReflect.getValue(value);
		} else {
			return value;
		}
	},
	resolveHash: function(hash){
		var params = {};
		for(var prop in hash) {
			params[prop] = helpersCore.resolve(hash[prop]);
		}
		return params;
	},
	bindAndRead: function (value) {
		if ( value && canReflect.isValueLike(value) ) {
			Observation.temporarilyBind(value);
			return canReflect.getValue(value);
		} else {
			return value;
		}
	},
	registerHelper: function(name, callback){
		//!steal-remove-start
		if (true) {
			if (helpers[name]) {
				dev.warn('The helper ' + name + ' has already been registered.');
			}
		}
		//!steal-remove-end

		// mark passed in helper so it will be automatically passed
		// helperOptions (.fn, .inverse, etc) when called as Call Expressions
		callback.requiresOptionsArgument = true;

		// store on global helpers list
		helpers[name] = callback;
	},
	registerHelpers: function(helpers) {
		var name, callback;
		for(name in helpers) {
			callback = helpers[name];
			helpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));
		}
	},
	registerConverter: function(name, getterSetter) {
		helpersCore.registerHelper(name, makeConverter(getterSetter));
	},
	makeSimpleHelper: function(fn) {
		return function() {
			var realArgs = [];
			canReflect.eachIndex(arguments, function(val) {
				realArgs.push(helpersCore.resolve(val));
			});
			return fn.apply(this, realArgs);
		};
	},
	addHelper: function(name, callback) {
		if(typeof name === "object") {
			return helpersCore.registerHelpers(name);
		}
		return helpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));
	},
	addConverter: function(name, getterSetter) {
		if(typeof name === "object") {
			if(!converterPackages.has(name)) {
				converterPackages.set(name, true);
				canReflect.eachKey(name, function(getterSetter, name) {
					helpersCore.addConverter(name, getterSetter);
				});
			}
			return;
		}

		var helper = makeConverter(getterSetter);
		helper.isLiveBound = true;
		helpersCore.registerHelper(name, helper);
	},

	// add helpers that set up their own internal live-binding
	// these helpers will not be wrapped in computes and will
	// receive observable arguments when called with Call Expressions
	addLiveHelper: function(name, callback) {
		callback.isLiveBound = true;
		return helpersCore.registerHelper(name, callback);
	},

	getHelper: function(name, scope) {
		var helper = scope && scope.getHelper(name);

		if (!helper) {
			helper = helpers[name];
		}

		return helper;
	},
	__resetHelpers: function() {
		// remove all helpers from can-stache-helpers object
		for (var helper in helpers) {
			delete helpers[helper];
		}
		// Clear converterPackages map before re-adding converters
		converterPackages.delete(builtInConverters);

		helpersCore.addBuiltInHelpers();
		helpersCore.addBuiltInConverters();
	},
	addBuiltInHelpers: function() {
		canReflect.each(builtInHelpers, function(helper, helperName) {
			helpers[helperName] = helper;
		});
	},
	addBuiltInConverters: function () {
		helpersCore.addConverter(builtInConverters);
	},
	_makeLogicHelper: function(name, logic){
		var logicHelper =  assign(function() {
			var args = Array.prototype.slice.call(arguments, 0),
				options;

			if( helpersCore.looksLikeOptions(args[args.length - 1]) ){
				options = args.pop();
			}

			function callLogic(){
				// if there are options, we want to prevent re-rendering if values are still truthy
				if(options) {
					return logic(args) ? true: false;
				} else {
					return logic(args);
				}

			}

			//!steal-remove-start
			if (true) {
				Object.defineProperty(callLogic, "name", {
					value: name+"("+args.map(function(arg){
						return canReflect.getName(arg);
					}).join(",")+")",
					configurable: true
				});
			}
			//!steal-remove-end
			var callFn = new Observation(callLogic);

			if(options) {
				return callFn.get() ? options.fn() : options.inverse();
			} else {
				return callFn.get();
			}

		},{requiresOptionsArgument: true, isLiveBound: true});

		//!steal-remove-start
		if (true) {
			Object.defineProperty(logicHelper, "name", {
				value: name,
				configurable: true
			});
		}
		//!steal-remove-end

		return logicHelper;
	}
};



// ## IF HELPER
var ifHelper = assign(function ifHelper(expr, options) {
	var value;
	// if it's a function, wrap its value in a compute
	// that will only change values from true to false
	if (expr && canReflect.isValueLike(expr)) {
		value = canReflect.getValue(new TruthyObservable(expr));
	} else {
		value = !! helpersCore.resolve(expr);
	}

	if (options) {
		return value ? options.fn(options.scope || this) : options.inverse(options.scope || this);
	}

	return !!value;
}, {requiresOptionsArgument: true, isLiveBound: true});




//## EQ/IS HELPER
var isHelper = helpersCore._makeLogicHelper("eq", function eqHelper(args){
	var curValue, lastValue;
	for (var i = 0; i < args.length; i++) {
		curValue = helpersCore.resolve(args[i]);
		curValue = typeof curValue === "function" ? curValue() : curValue;

		if (i > 0) {
			if (curValue !== lastValue) {
				return false;
			}
		}
		lastValue = curValue;
	}
	return true;
});

var andHelper = helpersCore._makeLogicHelper("and", function andHelper(args){
	if(args.length === 0 ) {
		return false;
	}
	var last;
	for (var i = 0, len = args.length; i < len; i++) {
		last = helpersCore.resolve(args[i]);
		if( !last  ) {
			return last;
		}
	}
	return last;
});

var orHelper = helpersCore._makeLogicHelper("or", function orHelper(args){
	if(args.length === 0 ) {
		return false;
	}
	var last;
	for (var i = 0, len = args.length; i < len; i++) {
		last = helpersCore.resolve(args[i]);
		if( last  ) {
			return last;
		}
	}
	return last;
});


var switchHelper = function(expression, options){
	helpersCore.resolve(expression);
	var found = false;

	var caseHelper = function(value, options) {
		if(!found && helpersCore.resolve(expression) === helpersCore.resolve(value)) {
			found = true;
			return options.fn(options.scope);
		}
	};
	caseHelper.requiresOptionsArgument = true;

	// create default helper as a value-like function
	// so that either {{#default}} or {{#default()}} will work
	var defaultHelper = function(options) {
		if (!found) {
			return options ? options.scope.peek('this') : true;
		}
	};
	defaultHelper.requiresOptionsArgument = true;
	canReflect.assignSymbols(defaultHelper, {
		"can.isValueLike": true,
		"can.isFunctionLike": false,
		"can.getValue": function() {
			// pass the helperOptions passed to {{#switch}}
			return this(options);
		}
	});

	var newScope = options.scope.add({
		case: caseHelper,
		default: defaultHelper
	}, { notContext: true });

	return options.fn(newScope, options);
};
switchHelper.requiresOptionsArgument = true;


// ## ODD HELPERS

var domDataHelper = function(attr, value) {
	var data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;
	return function setDomData(el) {
		domData.set( el, attr, data );
	};
};

var joinBaseHelper = function(firstExpr/* , expr... */){
	var args = [].slice.call(arguments);
	var options = args.pop();

	var moduleReference = args.map( function(expr){
		var value = helpersCore.resolve(expr);
		return typeof value === "function" ? value() : value;
	}).join("");

	var templateModule = canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');
	var parentAddress = templateModule ? templateModule.uri: undefined;

	var isRelative = moduleReference[0] === ".";

	if(isRelative && parentAddress) {
		return joinURIs(parentAddress, moduleReference);
	} else {
		var baseURL = (typeof System !== "undefined" &&
			(System.renderingBaseURL || System.baseURL)) ||	getBaseURL();

		// Make sure one of them has a needed /
		if(moduleReference[0] !== "/" && baseURL[baseURL.length - 1] !== "/") {
			baseURL += "/";
		}

		return joinURIs(baseURL, moduleReference);
	}
};
joinBaseHelper.requiresOptionsArgument = true;

// ## LEGACY HELPERS

// ### each
var eachHelper = function(items) {
	var args = [].slice.call(arguments),
		options = args.pop(),
		hashExprs = options.exprData.hashExprs,
		resolved = helpersCore.bindAndRead(items),
		hashOptions,
		aliases;

	// Check if using hash
	if (canReflect.size(hashExprs) > 0) {
		hashOptions = {};
		canReflect.eachKey(hashExprs, function (exprs, key) {
			hashOptions[exprs.key] = key;
		});
	}

	if ((
		canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) ||
			( canReflect.isListLike(resolved) && canReflect.isValueLike(items) )
	) && !options.stringOnly) {
		// Tells that a helper has been called, this function should be returned through
		// checking its value.
		options.metadata.rendered = true;
		return function(el){
			var cb = function (item, index) {
				var aliases = {};

				if (canReflect.size(hashOptions) > 0) {
					if (hashOptions.value) {
						aliases[hashOptions.value] = item;
					}
					if (hashOptions.index) {
						aliases[hashOptions.index] = index;
					}
				}

				return options.fn(
					options.scope
					.add(aliases, { notContext: true })
					.add({ index: index }, { special: true })
					.add(item),
				options.options
				);
			};

			live.list(el, items, cb, options.context , function(list){
				return options.inverse(options.scope.add(list), options.options);
			});
		};
	}

	var expr = helpersCore.resolve(items),
		result;

	if (!!expr && canReflect.isListLike(expr)) {
		result = utils.getItemsFragContent(expr, options, options.scope);
		return options.stringOnly ? result.join('') : result;
	} else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {
		result = [];
		canReflect.each(expr, function(val, key){
			var value = new KeyObservable(expr, key);
			aliases = {};

			if (canReflect.size(hashOptions) > 0) {
				if (hashOptions.value) {
					aliases[hashOptions.value] = value;
				}
				if (hashOptions.key) {
					aliases[hashOptions.key] = key;
				}
			}
			result.push(options.fn(
				options.scope
				.add(aliases, { notContext: true })
				.add({ key: key }, { special: true })
				.add(value)
			));
		});

		return options.stringOnly ? result.join('') : result;
	}
};
eachHelper.isLiveBound = true;
eachHelper.requiresOptionsArgument = true;
eachHelper.ignoreArgLookup = function ignoreArgLookup(index) {
	return index === 1;
};

// ### index
// This is legacy for `{{index(5)}}`
var indexHelper = assign(function indexHelper(offset, options) {
	if (!options) {
		options = offset;
		offset = 0;
	}
	var index = options.scope.peek("scope.index");
	return ""+((typeof(index) === "function" ? index() : index) + offset);
}, {requiresOptionsArgument: true});

// ### WITH HELPER
var withHelper = function (expr, options) {
	var ctx = expr;
	if(!options) {
		// hash-only case if no current context expression
		options = expr;
		expr = true;
		ctx = options.hash;
	} else {
		expr = helpersCore.resolve(expr);
		if(options.hash && canReflect.size(options.hash) > 0) {
			// presumably rare case of both a context object AND hash keys
			// Leaving it undocumented for now, but no reason not to support it.
			ctx = options.scope.add(options.hash, { notContext: true }).add(ctx);
		}
	}
	return options.fn(ctx || {});
};
withHelper.requiresOptionsArgument = true;

// ### data helper
var dataHelper = function(attr, value) {
	var data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;
	return function setData(el) {
		//!steal-remove-start
		if (true) {
			dev.warn('The {{data}} helper has been deprecated; use {{domData}} instead: https://canjs.com/doc/can-stache.helpers.domData.html');
		}
		//!steal-remove-end
		domData.set( el, attr, data );
	};
};

// ## UNLESS HELPER
var unlessHelper = function (expr, options) {
	if(!options) {
		return !ifHelper.apply(this, [expr]);
	}
	return ifHelper.apply(this, [expr, assign(assign({}, options), {
		fn: options.inverse,
		inverse: options.fn
	})]);
};
unlessHelper.requiresOptionsArgument = true;
unlessHelper.isLiveBound = true;


// ## Converters
// ## NOT converter
var notConverter = {
	get: function(obs, options){
		if(helpersCore.looksLikeOptions(options)) {
			return canReflect.getValue(obs) ? options.inverse() : options.fn();
		} else {
			return !canReflect.getValue(obs);
		}
	},
	set: function(newVal, obs){
		canReflect.setValue(obs, !newVal);
	}
};

// ## Register as defaults

assign(builtInHelpers, {
	'debugger': debuggerHelper,
	each: eachHelper,
	eachOf: eachHelper,
	index: indexHelper,
	'if': ifHelper,
	is: isHelper,
	eq: isHelper,
	unless: unlessHelper,
	'with': withHelper,
	console: console,
	data: dataHelper,
	domData: domDataHelper,
	'switch': switchHelper,
	joinBase: joinBaseHelper,
	and: andHelper,
	or: orHelper,
	'let': letHelper,
	'for': forHelper,
	portal: portalHelper
});

assign(builtInConverters, {
	'not': notConverter
});

// add all the built-in helpers when stache is loaded
helpersCore.addBuiltInHelpers();
helpersCore.addBuiltInConverters();

module.exports = helpersCore;


/***/ }),

/***/ "./node_modules/can-stache/src/expression-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-stache/src/expression-helpers.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Arg = __webpack_require__(/*! ../expressions/arg */ "./node_modules/can-stache/expressions/arg.js");
var Literal = __webpack_require__(/*! ../expressions/literal */ "./node_modules/can-stache/expressions/literal.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var stacheKey = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var makeComputeLike = __webpack_require__(/*! can-view-scope/make-compute-like */ "./node_modules/can-view-scope/make-compute-like.js");
var SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ "./node_modules/can-simple-observable/setter/setter.js");

// ## Helpers

function getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {
	// This needs to return something similar to a ScopeKeyData with intialValue and parentHasKey
	var getKeys = function(){
		return stacheKey.reads(("" + canReflect.getValue(key)).replace(/\./g, "\\."));
	};
	var parentHasKey;
	var computeValue = new SetterObservable(function getDynamicKey() {
		var readData = stacheKey.read( canReflect.getValue(root) , getKeys());
		parentHasKey = readData.parentHasKey;
		return readData.value;
	}, function setDynamicKey(newVal){
		stacheKey.write(canReflect.getValue(root), getKeys(), newVal);
	});
	// This prevents lazy evalutaion
	Observation.temporarilyBind(computeValue);

	// peek so no observable that might call getObservableValue_fromDynamicKey_fromObservable will re-evaluate if computeValue changes.
	computeValue.initialValue = ObservationRecorder.peekValue(computeValue);
	computeValue.parentHasKey = parentHasKey;
	// Todo:
	// 1. We should warn here if `initialValue` is undefined.  We can expose the warning function
	//    in can-view-scope and call it here.
	// 2. We should make this lazy if possible.  We can do that by making getter/setters for
	//    initialValue and parentHasKey (and possibly @@can.valueHasDependencies)
	return computeValue;
}

// If not a Literal or an Arg, convert to an arg for caching.
function convertToArgExpression(expr) {
	if(!(expr instanceof Arg) && !(expr instanceof Literal)) {
		return new Arg(expr);
	} else {
		return expr;
	}
}

function toComputeOrValue(value) {
	// convert to non observable value
	if(canReflect.isObservableLike(value)) {
		// we only want to do this for things that `should` have dependencies, but dont.
		if(canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {
			return canReflect.getValue(value);
		}
		// if compute data
		if(value.compute) {
			return value.compute;
		} else {
			return makeComputeLike(value);
		}
	}
	return value;
}

// try to make it a compute no matter what.  This is useful for
// ~ operator.
function toCompute(value) {
	if(value) {

		if(value.isComputed) {
			return value;
		}
		if(value.compute) {
			return value.compute;
		} else {
			return makeComputeLike(value);
		}
	}
	return value;
}

module.exports = {
	getObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,
	convertToArgExpression: convertToArgExpression,
	toComputeOrValue: toComputeOrValue,
	toCompute: toCompute
};


/***/ }),

/***/ "./node_modules/can-stache/src/expression.js":
/*!***************************************************!*\
  !*** ./node_modules/can-stache/src/expression.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// ## Expression Types
//
// These expression types return a value. They are assembled by `expression.parse`.
var Arg = __webpack_require__(/*! ../expressions/arg */ "./node_modules/can-stache/expressions/arg.js");
var Literal = __webpack_require__(/*! ../expressions/literal */ "./node_modules/can-stache/expressions/literal.js");
var Hashes = __webpack_require__(/*! ../expressions/hashes */ "./node_modules/can-stache/expressions/hashes.js");
var Bracket = __webpack_require__(/*! ../expressions/bracket */ "./node_modules/can-stache/expressions/bracket.js");
var Call = __webpack_require__(/*! ../expressions/call */ "./node_modules/can-stache/expressions/call.js");
var Helper = __webpack_require__(/*! ../expressions/helper */ "./node_modules/can-stache/expressions/helper.js");
var Lookup = __webpack_require__(/*! ../expressions/lookup */ "./node_modules/can-stache/expressions/lookup.js");

var SetIdentifier = __webpack_require__(/*! ./set-identifier */ "./node_modules/can-stache/src/set-identifier.js");
var expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ "./node_modules/can-stache/src/expression-helpers.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/can-stache/src/utils.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var last = utils.last;
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var sourceTextSymbol = canSymbol.for("can-stache.sourceText");

// ### Hash
// A placeholder. This isn't actually used.
var Hash = function(){ }; // jshint ignore:line

// NAME - \w
// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo
// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE
// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)
// HELPEREXPRESSION = KEY ARG ARG NAME=ARG
// DOT .NAME
// AT @NAME
//
var keyRegExp = /[\w\.\\\-_@\/\&%]+/,
	tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g,
	bracketSpaceRegExp = /\]\s+/,
	literalRegExp = /^('.*?'|".*?"|-?[0-9]+\.?[0-9]*|true|false|null|undefined)$/;

var isTokenKey = function(token){
	return keyRegExp.test(token);
};

var testDot = /^[\.@]\w/;
var isAddingToExpression = function(token) {

	return isTokenKey(token) && testDot.test(token);
};

var ensureChildren = function(type) {
	if(!type.children) {
		type.children = [];
	}
	return type;
};

var Stack = function(){

	this.root = {children: [], type: "Root"};
	this.current = this.root;
	this.stack = [this.root];
};
assign(Stack.prototype,{
	top: function(){
		return last(this.stack);
	},
	isRootTop: function(){
		return this.top() === this.root;
	},
	popTo: function(types){
		this.popUntil(types);
		this.pop();
	},
	pop: function() {
		if(!this.isRootTop()) {
			this.stack.pop();
		}
	},
	first: function(types){
		var curIndex = this.stack.length - 1;
		while( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {
			curIndex--;
		}
		return this.stack[curIndex];
	},
	firstParent: function(types){
		var curIndex = this.stack.length - 2;
		while( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {
			curIndex--;
		}
		return this.stack[curIndex];
	},
	popUntil: function(types){
		while( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {
			this.stack.pop();
		}
		return this.top();
	},
	addTo: function(types, type){
		var cur = this.popUntil(types);
		ensureChildren(cur).children.push(type);
	},
	addToAndPush: function(types, type){
		this.addTo(types, type);
		this.stack.push(type);
	},
	push: function(type) {
		this.stack.push(type);
	},
	topLastChild: function(){
		return last(this.top().children);
	},
	replaceTopLastChild: function(type){
		var children = ensureChildren(this.top()).children;
		children.pop();
		children.push(type);
		return type;
	},
	replaceTopLastChildAndPush: function(type) {
		this.replaceTopLastChild(type);
		this.stack.push(type);
	},
	replaceTopAndPush: function(type){
		var children;
		if(this.top() === this.root) {
			children = ensureChildren(this.top()).children;
		} else {
			this.stack.pop();
			// get parent and clean
			children = ensureChildren(this.top()).children;
		}

		children.pop();
		children.push(type);
		this.stack.push(type);
		return type;
	}
});

// converts
// - "../foo" -> "../@foo",
// - "foo" -> "@foo",
// - ".foo" -> "@foo",
// - "./foo" -> "./@foo"
// - "foo.bar" -> "foo@bar"
var convertKeyToLookup = function(key){
	var lastPath = key.lastIndexOf("./");
	var lastDot = key.lastIndexOf(".");
	if(lastDot > lastPath) {
		return key.substr(0, lastDot)+"@"+key.substr(lastDot+1);
	}
	var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;
	var firstNonPathChar = key.charAt(firstNonPathCharIndex);
	if(firstNonPathChar === "." || firstNonPathChar === "@" ) {
		return key.substr(0, firstNonPathCharIndex)+"@"+key.substr(firstNonPathCharIndex+1);
	} else {
		return key.substr(0, firstNonPathCharIndex)+"@"+key.substr(firstNonPathCharIndex);
	}
};
var convertToAtLookup = function(ast){
	if(ast.type === "Lookup") {
		canReflect.setKeyValue(ast, sourceTextSymbol, ast.key);
		ast.key = convertKeyToLookup(ast.key);
	}
	return ast;
};

var convertToHelperIfTopIsLookup = function(stack){
	var top = stack.top();
	// if two scopes, that means a helper
	if(top && top.type === "Lookup") {

		var base = stack.stack[stack.stack.length - 2];
		// That lookup shouldn't be part of a Helper already or
		if(base.type !== "Helper" && base) {
			stack.replaceTopAndPush({
				type: "Helper",
				method: top
			});
		}
	}
};

var expression = {
	toComputeOrValue: expressionHelpers.toComputeOrValue,
	convertKeyToLookup: convertKeyToLookup,

	Literal: Literal,
	Lookup: Lookup,
	Arg: Arg,
	Hash: Hash,
	Hashes: Hashes,
	Call: Call,
	Helper: Helper,
	Bracket: Bracket,

	SetIdentifier: SetIdentifier,
	tokenize: function(expression){
		var tokens = [];
		(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
			if (bracketSpaceRegExp.test(arg)) {
				tokens.push(arg[0]);
				tokens.push(arg.slice(1));
			} else {
				tokens.push(arg);
			}
		});
		return tokens;
	},
	lookupRules: {
		"default": function(ast, methodType, isArg){
			return ast.type === "Helper" ? Helper : Lookup;
		},
		"method": function(ast, methodType, isArg){
			return Lookup;
		}
	},
	methodRules: {
		"default": function(ast){
			return ast.type === "Call" ? Call : Helper;
		},
		"call": function(ast){
			return Call;
		}
	},
	// ## expression.parse
	//
	// - {String} expressionString - A stache expression like "abc foo()"
	// - {Object} options
	//   - baseMethodType - Treat this like a Helper or Call.  Default to "Helper"
	//   - lookupRule - "default" or "method"
	//   - methodRule - "default" or "call"
	parse: function(expressionString, options){
		options =  options || {};
		var ast = this.ast(expressionString);

		if(!options.lookupRule) {
			options.lookupRule = "default";
		}
		if(typeof options.lookupRule === "string") {
			options.lookupRule = expression.lookupRules[options.lookupRule];
		}
		if(!options.methodRule) {
			options.methodRule = "default";
		}
		if(typeof options.methodRule === "string") {
			options.methodRule = expression.methodRules[options.methodRule];
		}

		var expr = this.hydrateAst(ast, options, options.baseMethodType || "Helper");

		return expr;
	},
	hydrateAst: function(ast, options, methodType, isArg){
		var hashes;
		if(ast.type === "Lookup") {
			var LookupRule = options.lookupRule(ast, methodType, isArg);
			var lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol] );
			return lookup;
		}
		else if(ast.type === "Literal") {
			return new Literal(ast.value);
		}
		else if(ast.type === "Arg") {
			return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});
		}
		else if(ast.type === "Hash") {
			throw new Error("");
		}
		else if(ast.type === "Hashes") {
			hashes = {};
			ast.children.forEach(function(hash){
				hashes[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );
			}, this);
			return new Hashes(hashes);
		}
		else if(ast.type === "Call" || ast.type === "Helper") {
			//get all arguments and hashes
			hashes = {};
			var args = [],
				children = ast.children,
				ExpressionType = options.methodRule(ast);
			if(children) {
				for(var i = 0 ; i <children.length; i++) {
					var child = children[i];
					if(child.type === "Hashes" && ast.type === "Helper" &&
						(ExpressionType !== Call)) {

						child.children.forEach(function(hash){
							hashes[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );
						}, this);

					} else {
						args.push( this.hydrateAst(child, options, ast.type, true) );
					}
				}
			}


			return new ExpressionType(this.hydrateAst(ast.method, options, ast.type),
																args, hashes);
		} else if (ast.type === "Bracket") {
			var originalKey;
			//!steal-remove-start
			if (true) {
				originalKey = ast[canSymbol.for("can-stache.originalKey")];
			}
			//!steal-remove-end
			return new Bracket(
				this.hydrateAst(ast.children[0], options),
				ast.root ? this.hydrateAst(ast.root, options) : undefined,
				originalKey
			);
		}
	},
	ast: function(expression){
		var tokens = this.tokenize(expression);
		return this.parseAst(tokens, {
			index: 0
		});
	},
	parseAst: function(tokens, cursor) {
		// jshint maxdepth: 6
		var stack = new Stack(),
			top,
			firstParent,
			lastToken;

		while(cursor.index < tokens.length) {
			var token = tokens[cursor.index],
				nextToken = tokens[cursor.index+1];

			cursor.index++;

			// Hash
			if(nextToken === "=") {
				//convertToHelperIfTopIsLookup(stack);
				top = stack.top();

				// If top is a Lookup, we might need to convert to a helper.
				if(top && top.type === "Lookup") {
					// Check if current Lookup is part of a Call, Helper, or Hash
					// If it happens to be first within a Call or Root, that means
					// this is helper syntax.
					firstParent = stack.firstParent(["Call","Helper","Hash"]);
					if(firstParent.type === "Call" || firstParent.type === "Root") {

						stack.popUntil(["Call"]);
						top = stack.top();
						stack.replaceTopAndPush({
							type: "Helper",
							method: top.type === "Root" ? last(top.children) : top
						});

					}
				}

				firstParent = stack.first(["Call","Helper","Hashes","Root"]);
				// makes sure we are adding to Hashes if there already is one
				// otherwise we create one.
				var hash = {type: "Hash", prop: token};
				if(firstParent.type === "Hashes") {
					stack.addToAndPush(["Hashes"], hash);
				} else {
					stack.addToAndPush(["Helper", "Call","Root"], {
						type: "Hashes",
						children: [hash]
					});
					stack.push(hash);
				}
				cursor.index++;

			}
			// Literal
			else if(literalRegExp.test( token )) {
				convertToHelperIfTopIsLookup(stack);
				// only add to hash if there's not already a child.
				firstParent = stack.first(["Helper", "Call", "Hash", "Bracket"]);
				if(firstParent.type === "Hash" && (firstParent.children && firstParent.children.length > 0)) {
					stack.addTo(["Helper", "Call", "Bracket"], {type: "Literal", value: utils.jsonParse( token )});
				} else if(firstParent.type === "Bracket" && (firstParent.children && firstParent.children.length > 0)) {
					stack.addTo(["Helper", "Call", "Hash"], {type: "Literal", value: utils.jsonParse( token )});
				} else {
					stack.addTo(["Helper", "Call", "Hash", "Bracket"], {type: "Literal", value: utils.jsonParse( token )});
				}

			}
			// Lookup
			else if(keyRegExp.test(token)) {
				lastToken = stack.topLastChild();
				firstParent = stack.first(["Helper", "Call", "Hash", "Bracket"]);

				// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.
				if(lastToken && (lastToken.type === "Call" || lastToken.type === "Bracket" ) && isAddingToExpression(token)) {
					stack.replaceTopLastChildAndPush({
						type: "Lookup",
						root: lastToken,
						key: token.slice(1) // remove leading `.`
					});
				}
				else if(firstParent.type === 'Bracket') {
					// a Bracket expression without children means we have
					// parsed `foo[` of an expression like `foo[bar]`
					// so we know to add the Lookup as a child of the Bracket expression
					if (!(firstParent.children && firstParent.children.length > 0)) {
						stack.addToAndPush(["Bracket"], {type: "Lookup", key: token});
					} else {
						// check if we are adding to a helper like `eq foo[bar] baz`
						// but not at the `.baz` of `eq foo[bar].baz xyz`
						if(stack.first(["Helper", "Call", "Hash", "Arg"]).type === 'Helper' && token[0] !== '.') {
							stack.addToAndPush(["Helper"], {type: "Lookup", key: token});
						} else {
							// otherwise, handle the `.baz` in expressions like `foo[bar].baz`
							stack.replaceTopAndPush({
								type: "Lookup",
								key: token.slice(1),
								root: firstParent
							});
						}
					}
				}
				else {
					// if two scopes, that means a helper
					convertToHelperIfTopIsLookup(stack);

					stack.addToAndPush(["Helper", "Call", "Hash", "Arg", "Bracket"], {type: "Lookup", key: token});
				}

			}
			// Arg
			else if(token === "~") {
				convertToHelperIfTopIsLookup(stack);
				stack.addToAndPush(["Helper", "Call", "Hash"], {type: "Arg", key: token});
			}
			// Call
			// foo[bar()]
			else if(token === "(") {
				top = stack.top();
				lastToken = stack.topLastChild();
				if(top.type === "Lookup") {
					stack.replaceTopAndPush({
						type: "Call",
						method: convertToAtLookup(top)
					});

				// Nested Call
				// foo()()
				} else if (lastToken && lastToken.type === "Call") {
					stack.replaceTopAndPush({
						type: "Call",
						method: lastToken
					});
				} else {
					throw new Error("Unable to understand expression "+tokens.join(''));
				}
			}
			// End Call
			else if(token === ")") {
				stack.popTo(["Call"]);
			}
			// End Call argument
			else if(token === ",") {
				// The {{let foo=zed, bar=car}} helper is not in a call
				// expression.
				var call = stack.first(["Call"]);
				if(call.type !== "Call") {
					stack.popUntil(["Hash"]);
				} else {
					stack.popUntil(["Call"]);
				}

			}
			// Bracket
			else if(token === "[") {
				top = stack.top();
				lastToken = stack.topLastChild();

				// foo()[bar] => top -> root, lastToken -> {t: call, m: "@foo"}
				// foo()[bar()] => same as above last thing we see was a call expression "rotate"
				// test['foo'][0] => lastToken => {root: test, t: Bracket, c: 'foo' }
				// log(thing['prop'][0]) =>
				//
				//     top -> {Call, children|args: [Bracket(Lookup(thing), c: ['[prop]'])]}
				//     last-> Bracket(Lookup(thing), c: ['[prop]'])
				if (lastToken && (lastToken.type === "Call" || lastToken.type === "Bracket"  )  ) {
					// must be on top of the stack as it recieves new stuff ...
					// however, what we really want is to
					stack.replaceTopLastChildAndPush({type: "Bracket", root: lastToken});
				} else if (top.type === "Lookup" || top.type === "Bracket") {
					var bracket = {type: "Bracket", root: top};
					//!steal-remove-start
					if (true) {
						canReflect.setKeyValue(bracket, canSymbol.for("can-stache.originalKey"), top.key);
					}
					//!steal-remove-end
					stack.replaceTopAndPush(bracket);
				} else if (top.type === "Call") {
					stack.addToAndPush(["Call"], { type: "Bracket" });
				} else if (top === " ") {
					stack.popUntil(["Lookup", "Call"]);
					convertToHelperIfTopIsLookup(stack);
					stack.addToAndPush(["Helper", "Call", "Hash"], {type: "Bracket"});
				} else {
					stack.replaceTopAndPush({type: "Bracket"});
				}
			}
			// End Bracket
			else if(token === "]") {
				stack.pop();
			}
			else if(token === " ") {
				stack.push(token);
			}
		}
		return stack.root.children[0];
	}
};

module.exports = expression;


/***/ }),

/***/ "./node_modules/can-stache/src/html_section.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/src/html_section.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var target = __webpack_require__(/*! can-view-target */ "./node_modules/can-view-target/can-view-target.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/can-stache/src/utils.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");


var last = utils.last;

var decodeHTML = typeof document !== "undefined" && (function(){
	var el = getDocument().createElement('div');
	return function(html){
		if(html.indexOf("&") === -1) {
			return html.replace(/\r\n/g,"\n");
		}
		el.innerHTML = html;
		return el.childNodes.length === 0 ? "" : el.childNodes.item(0).nodeValue;
	};
})();
// ## HTMLSectionBuilder
//
// Contains a stack of HTMLSections.
// An HTMLSection is created everytime a subsection is found. For example:
//
//     {{#if(items)}} {{#items}} X
//
// At the point X was being processed, there would be 2 HTMLSections in the
// stack.  One for the content of `{{#if(items)}}` and the other for the
// content of `{{#items}}`
var HTMLSectionBuilder = function(filename){
	if (filename) {
		this.filename = filename;
	}
	this.stack = [new HTMLSection()];
};


assign(HTMLSectionBuilder.prototype,utils.mixins);

assign(HTMLSectionBuilder.prototype,{
	startSubSection: function(process){
		var newSection = new HTMLSection(process);
		this.stack.push(newSection);
		return newSection;
	},
	// Ends the current section and returns a renderer.
	// But only returns a renderer if there is a template.
	endSubSectionAndReturnRenderer: function(){
		if(this.last().isEmpty()) {
			this.stack.pop();
			return null;
		} else {
			var htmlSection = this.endSection();
			return utils.makeView(htmlSection.compiled.hydrate.bind(htmlSection.compiled));
		}
	},
	startSection: function( process, commentName ) {
		var newSection = new HTMLSection(process);
		this.last().add({
			comment: commentName || "#section",
			callbacks: [newSection.targetCallback]
		});
		this.last().add({
			comment: "can-end-placeholder"
		});
		// adding a section within a section ...
		// the stack has section ...
		this.stack.push(newSection);
	},
	endSection: function(){
		this.last().compile();
		return this.stack.pop();
	},
	inverse: function(){
		this.last().inverse();
	},
	compile: function(){
		var compiled = this.stack.pop().compile();
		// ignore observations here.  the render fn
		//  itself doesn't need to be observable.
		return utils.makeView( compiled.hydrate.bind(compiled) );
	},
	push: function(chars){
		this.last().push(chars);
	},
	pop: function(){
		return this.last().pop();
	},
	removeCurrentNode: function() {
		this.last().removeCurrentNode();
	}
});

var HTMLSection = function(process){
	this.data = "targetData";
	this.targetData = [];
	// A record of what targetData element we are within.
	this.targetStack = [];
	var self = this;
	this.targetCallback = function(scope){
		process.call(this,
			scope,
			self.compiled.hydrate.bind(self.compiled),
			self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;
	};
};
assign(HTMLSection.prototype,{
	inverse: function(){
		this.inverseData = [];
		this.data = "inverseData";
	},
	// Adds a DOM node.
	push: function(data){
		this.add(data);
		this.targetStack.push(data);
	},
	pop: function(){
		return this.targetStack.pop();
	},
	add: function(data){
		if(typeof data === "string"){
			data = decodeHTML(data);
		}
		if(this.targetStack.length) {
			last(this.targetStack).children.push(data);
		} else {
			this[this.data].push(data);
		}
	},
	compile: function(){
		this.compiled = target(this.targetData, getDocument());
		if(this.inverseData) {
			this.inverseCompiled = target(this.inverseData, getDocument());
			delete this.inverseData;
		}
		this.targetStack = this.targetData = null;
		return this.compiled;
	},
	removeCurrentNode: function() {
		var children = this.children();
		return children.pop();
	},
	children: function(){
		if(this.targetStack.length) {
			return last(this.targetStack).children;
		} else {
			return this[this.data];
		}
	},
	// Returns if a section is empty
	isEmpty: function(){
		return !this.targetData.length;
	}
});
HTMLSectionBuilder.HTMLSection = HTMLSection;

module.exports = HTMLSectionBuilder;


/***/ }),

/***/ "./node_modules/can-stache/src/key-observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/src/key-observable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");
var stacheKey = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");


function KeyObservable(root, key){
    key = ""+key;
    this.key = key;
    this.root = root;
    SettableObservable.call(this, function(){
        return stacheKey.get(this,key);
    }, root);
}

KeyObservable.prototype = Object.create(SettableObservable.prototype);

KeyObservable.prototype.set = function(newVal) {
    stacheKey.set(this.root,this.key, newVal);
};


module.exports = KeyObservable;


/***/ }),

/***/ "./node_modules/can-stache/src/mustache_core.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/src/mustache_core.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//
// This provides helper utilities for Mustache processing. Currently,
// only stache uses these helpers.  Ideally, these utilities could be used
// in other libraries implementing Mustache-like features.
var live = __webpack_require__(/*! can-view-live */ "./node_modules/can-view-live/can-view-live.js");
var liveHelpers = __webpack_require__(/*! can-view-live/lib/helpers */ "./node_modules/can-view-live/lib/helpers.js");

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/can-stache/src/utils.js");
var expression = __webpack_require__(/*! ./expression */ "./node_modules/can-stache/src/expression.js");
var frag = __webpack_require__(/*! can-fragment */ "./node_modules/can-fragment/can-fragment.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");

var toDOMSymbol = canSymbol.for("can.toDOM");

// Lazily lookup the context only if it's needed.
function HelperOptions(scope, exprData, stringOnly) {
	this.metadata = { rendered: false };
	this.stringOnly = stringOnly;
	this.scope = scope;
	this.exprData = exprData;
}
defineLazyValue(HelperOptions.prototype,"context", function(){
	return this.scope.peek("this");
});




// ## Helpers

var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g,
	mustacheWhitespaceRegExp = /\s*\{\{--\}\}\s*|\s*(\{\{\{?)-|-(\}\}\}?)\s*/g,
	k = function(){};
var viewInsertSymbol = canSymbol.for("can.viewInsert");


// DOM, safeString or the insertSymbol can opt-out of updating as text
function valueShouldBeInsertedAsHTML(value) {
	return value !== null && typeof value === "object" && (
		typeof value[toDOMSymbol] === "function" ||
		typeof value[viewInsertSymbol] === "function" ||
		typeof value.nodeType === "number" );
}




var core = {
	expression: expression,
	// ## mustacheCore.makeEvaluator
	// Given a scope and expression, returns a function that evaluates that expression in the scope.
	//
	// This function first reads lookup values in the args and hash.  Then it tries to figure out
	// if a helper is being called or a value is being read.  Finally, depending on
	// if it's a helper, or not, and which mode the expression is in, it returns
	// a function that can quickly evaluate the expression.
	/**
	 * @hide
	 * Given a mode and expression data, returns a function that evaluates that expression.
	 * @param {can-view-scope} The scope in which the expression is evaluated.
	 * @param {can.view.Options} The option helpers in which the expression is evaluated.
	 * @param {String} mode Either null, #, ^. > is handled elsewhere
	 * @param {Object} exprData Data about what was in the mustache expression
	 * @param {renderer} [truthyRenderer] Used to render a subsection
	 * @param {renderer} [falseyRenderer] Used to render the inverse subsection
	 * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.
	 * @return {Function} An 'evaluator' function that evaluates the expression.
	 */
	makeEvaluator: function (scope, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {

		if(mode === "^") {
			var temp = truthyRenderer;
			truthyRenderer = falseyRenderer;
			falseyRenderer = temp;
		}

		var value,
			helperOptions = new HelperOptions(scope , exprData, stringOnly);
			// set up renderers
			utils.createRenderers(helperOptions, scope ,truthyRenderer, falseyRenderer, stringOnly);

		if(exprData instanceof expression.Call) {
			value = exprData.value(scope, helperOptions);
		} else if (exprData instanceof expression.Bracket) {
			value = exprData.value(scope);
		} else if (exprData instanceof expression.Lookup) {
			value = exprData.value(scope);
		} else if (exprData instanceof expression.Literal) {
			value = exprData.value.bind(exprData);
		} else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
			// Brackets get wrapped in Helpers when used in attributes
			// like `<p class="{{ foo[bar] }}" />`
			value = exprData.methodExpr.value(scope, helperOptions);
		} else {
			value = exprData.value(scope, helperOptions);
			if (typeof value === "function") {
				return value;
			}
		}
		// {{#something()}}foo{{/something}}
		// return evaluator for no mode or rendered value if a renderer was called
		if(!mode || helperOptions.metadata.rendered) {
			return value;
		} else if( mode === "#" || mode === "^" ) {

			return function(){
				// Get the value
				var finalValue = canReflect.getValue(value);
				var result;

				// if options.fn or options.inverse was called, we take the observable's return value
				// as what should be put in the DOM.
				if(helperOptions.metadata.rendered) {
					result = finalValue;
				}
				// If it's an array, render.
				else if ( typeof finalValue !== "string" && canReflect.isListLike(finalValue) ) {
					var isObserveList = canReflect.isObservableLike(finalValue) &&
						canReflect.isListLike(finalValue);

					if(canReflect.getKeyValue(finalValue, "length")) {
						if (stringOnly) {
							result = utils.getItemsStringContent(finalValue, isObserveList, helperOptions);
						} else {
							result = frag(utils.getItemsFragContent(finalValue, helperOptions, scope));
						}
					} else {
						result = helperOptions.inverse(scope);
					}
				}
				else {
					result = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);
				}
				// We always set the rendered result back to false.
				// - Future calls might change from returning a value to calling `.fn`
				// - We are calling `.fn` and `.inverse` ourselves.
				helperOptions.metadata.rendered = false;
				return result;
			};
		} else {
			// not supported!
		}
	},
	// ## mustacheCore.makeLiveBindingPartialRenderer
	// Returns a renderer function that live binds a partial.
	/**
	 * @hide
	 * Returns a renderer function that live binds a partial.
	 * @param {String} expressionString
	 * @param {Object} state The html state of where the expression was found.
	 * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function
	 * live binds a partial.
	 */
	makeLiveBindingPartialRenderer: function(expressionString, state){
		expressionString = expressionString.trim();
		var exprData,
				partialName = expressionString.split(/\s+/).shift();

		if(partialName !== expressionString) {
			exprData = core.expression.parse(expressionString);
		}

		return function(scope){
			//!steal-remove-start
			if (true) {
				scope.set('scope.filename', state.filename);
				scope.set('scope.lineNumber', state.lineNo);
			}
			//!steal-remove-end

			var partialFrag = new Observation(function(){
				var localPartialName = partialName;
				var partialScope = scope;
				// If the second parameter of a partial is a custom context
				if(exprData && exprData.argExprs.length === 1) {
					var newContext = canReflect.getValue( exprData.argExprs[0].value(scope) );
					if(typeof newContext === "undefined") {
						//!steal-remove-start
						if (true) {
							dev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +
								'partial ('+ partialName +') is not defined in the scope!');
						}
						//!steal-remove-end
					}else{
						partialScope = scope.add(newContext);
					}
				}
				// Look up partials in templateContext first
				var partial = canReflect.getKeyValue(partialScope.templateContext.partials, localPartialName);
				var renderer;

				if (partial) {
					renderer = function() {
						return partial.render ? partial.render(partialScope)
							: partial(partialScope);
					};
				}
				// Use can.view to get and render the partial.
				else {
					var scopePartialName = partialScope.read(localPartialName, {
						isArgument: true
					}).value;

					if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
						return frag("");
					}
					if (scopePartialName) {
						localPartialName = scopePartialName;
					}

					renderer = function() {
						if(typeof localPartialName === "function"){
							return localPartialName(partialScope, {});
						} else {
							var domRenderer = core.getTemplateById(localPartialName);
							//!steal-remove-start
							if (true) {
								if (!domRenderer) {
									dev.warn(
										(state.filename ? state.filename + ':' : '') +
										(state.lineNo ? state.lineNo + ': ' : '') +
										'Unable to find partial "' + localPartialName + '".');
								}
							}
							//!steal-remove-end
							return domRenderer ? domRenderer(partialScope, {}) : getDocument().createDocumentFragment();
						}
					};
				}
				var res = ObservationRecorder.ignore(renderer)();
				return frag(res);
			});

			live.html(this, partialFrag);
		};
	},
	// ## mustacheCore.makeStringBranchRenderer
	// Return a renderer function that evalutes to a string and caches
	// the evaluator on the scope.
	/**
	 * @hide
	 * Return a renderer function that evaluates to a string.
	 * @param {String} mode
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The html state of where the expression was found.
	 * @return {function(can.view.Scope,can.view.Options, can-stache.view, can.view.renderer)}
	 */
	makeStringBranchRenderer: function(mode, expressionString, state){
		var exprData = core.expression.parse(expressionString),
			// Use the full mustache expression as the cache key.
			fullExpression = mode+expressionString;

		// A branching renderer takes truthy and falsey renderer.
		var branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){
			//!steal-remove-start
			if (true) {
				scope.set('scope.filename', state.filename);
				scope.set('scope.lineNumber', state.lineNo);
			}
			//!steal-remove-end
			// Check the scope's cache if the evaluator already exists for performance.
			var evaluator = scope.__cache[fullExpression];
			if(mode || !evaluator) {
				evaluator = makeEvaluator( scope, mode, exprData, truthyRenderer, falseyRenderer, true);
				if(!mode) {
					scope.__cache[fullExpression] = evaluator;
				}
			}
			var gotObservableValue = evaluator[canSymbol.for("can.onValue")],
				res;

			// Run the evaluator and return the result.
			if(gotObservableValue) {
				res = canReflect.getValue(evaluator);
			} else {
				res = evaluator();
			}

			if (res == null) {
				return "";
			}
			return res.nodeType === 11 ? res.textContent : ""+res;
		};

		branchRenderer.exprData = exprData;

		return branchRenderer;
	},
	// ## mustacheCore.makeLiveBindingBranchRenderer
	// Return a renderer function that evaluates the mustache expression and
	// sets up live binding if a compute with dependencies is found. Otherwise,
	// the element's value is set.
	//
	// This function works by creating a `can.compute` from the mustache expression.
	// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,
	// it updates the element's property based on the compute's value.
	/**
	 * @hide
	 * Returns a renderer function that evaluates the mustache expression.
	 * @param {String} mode
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The html state of where the expression was found.
	 */
	makeLiveBindingBranchRenderer: function(mode, expressionString, state){
		// Pre-process the expression.
		var exprData = core.expression.parse(expressionString);

		// A branching renderer takes truthy and falsey renderer.
		var branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){
			// If this is within a tag, make sure we only get string values.
			var stringOnly = state.tag;
			//!steal-remove-start
			if (true) {
				scope.set('scope.filename', state.filename);
				scope.set('scope.lineNumber', state.lineNo);
			}
			//!steal-remove-end

			// Get the evaluator. This does not need to be cached (probably) because if there
			// an observable value, it will be handled by `can.view.live`.
			var evaluator = makeEvaluator( scope, mode, exprData, truthyRenderer, falseyRenderer, stringOnly );

			// Create a compute that can not be observed by other
			// computes. This is important because this renderer is likely called by
			// parent expressions.  If this value changes, the parent expressions should
			// not re-evaluate. We prevent that by making sure this compute is ignored by
			// everyone else.
			//var compute = can.compute(evaluator, null, false);
			var gotObservableValue = evaluator[canSymbol.for("can.onValue")];
			var observable;
			if(gotObservableValue) {
				observable = evaluator;
			} else {
				//!steal-remove-start
				if (true) {
					Object.defineProperty(evaluator,"name",{
						value: "{{"+(mode || "")+expressionString+"}}"
					});
				}
				//!steal-remove-end
				observable = new Observation(evaluator,null,{isObservable: false});
			}

			// Bind on the computeValue to set the cached value. This helps performance
			// so live binding can read a cached value instead of re-calculating.
			canReflect.onValue(observable, k);

			var value = canReflect.getValue(observable);

			// If value is a function and not a Lookup ({{foo}}),
			// it's a helper that returned a function and should be called.
			if(typeof value === "function" && !(exprData instanceof expression.Lookup)) {

				// A helper function should do it's own binding.  Similar to how
				// we prevented this function's compute from being noticed by parent expressions,
				// we hide any observables read in the function by saving any observables that
				// have been read and then setting them back which overwrites any `can.__observe` calls
				// performed in value.
				ObservationRecorder.ignore(value)(this);

			}
			// If the computeValue has observable dependencies, setup live binding.
			else if( canReflect.valueHasDependencies(observable) ) {
				// Depending on where the template is, setup live-binding differently.
				if(state.attr) {
					live.attr(this, state.attr, observable);
				}
				else if( state.tag )  {
					live.attrs( this, observable );
				}
				else if(state.text && !valueShouldBeInsertedAsHTML(value)) {
					//!steal-remove-start
					if (true) {
						if(value !== null && typeof value === "object") {
							dev.warn("Previously, the result of "+
								expressionString+" in "+state.filename+":"+state.lineNo+
								", was being inserted as HTML instead of TEXT. Please use stache.safeString(obj) "+
								"if you would like the object to be treated as HTML.");
						}
					}
					//!steal-remove-end
					live.text(this, observable);
				} else {
					live.html(this, observable);
				}
			}
			// If the computeValue has no observable dependencies, just set the value on the element.
			else {

				if(state.attr) {
					domMutate.setAttribute(this, state.attr, value);
				}
				else if(state.tag) {
					live.attrs(this, value);
				}
				else if(state.text && !valueShouldBeInsertedAsHTML(value)) {
					this.nodeValue = liveHelpers.makeString(value);
				}
				else if( value != null ){
					if (typeof value[viewInsertSymbol] === "function") {
						var insert = value[viewInsertSymbol]({});
						this.parentNode.replaceChild( insert, this );
					} else {
						this.parentNode.replaceChild(frag(value, this.ownerDocument), this);
						//domMutateNode.replaceChild.call(this.parentNode, frag(value, this.ownerDocument), this);
					}
				}
			}
			// Unbind the compute.
			canReflect.offValue(observable, k);
		};

		branchRenderer.exprData = exprData;

		return branchRenderer;
	},
	// ## mustacheCore.splitModeFromExpression
	// Returns the mustache mode split from the rest of the expression.
	/**
	 * @hide
	 * Returns the mustache mode split from the rest of the expression.
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The state of HTML where the expression was found.
	 */
	splitModeFromExpression: function(expression, state){
		expression = expression.trim();
		var mode = expression.charAt(0);

		if( "#/{&^>!<".indexOf(mode) >= 0 ) {
			expression =  expression.substr(1).trim();
		} else {
			mode = null;
		}
		// Triple braces do nothing within a tag.
		if(mode === "{" && state.node) {
			mode = null;
		}
		return {
			mode: mode,
			expression: expression
		};
	},
	// ## mustacheCore.cleanLineEndings
	// Removes line breaks accoding to the mustache specification.
	/**
	 * @hide
	 * Prunes line breaks accoding to the mustache specification.
	 * @param {String} template
	 * @return {String}
	 */
	cleanLineEndings: function(template){

		// Finds mustache tags with space around them or no space around them.
		return template.replace( mustacheLineBreakRegExp,
			function(whole,
				returnBefore,
				spaceBefore,
				special,
				expression,
				spaceAfter,
				returnAfter,
				// A mustache magic tag that has no space around it.
				spaceLessSpecial,
				spaceLessExpression,
				matchIndex){

			// IE 8 will provide undefined
			spaceAfter = (spaceAfter || "");
			returnBefore = (returnBefore || "");
			spaceBefore = (spaceBefore || "");

			var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});

			// If it's a partial or tripple stache, leave in place.
			if(spaceLessSpecial || ">{".indexOf( modeAndExpression.mode) >= 0) {
				return whole;
			}  else if( "^#!/".indexOf(  modeAndExpression.mode ) >= 0 ) {
				// Return the magic tag and a trailing linebreak if this did not
				// start a new line and there was an end line.
				// Add a normalized leading space, if there was any leading space, in case this abuts a tag name
				spaceBefore = (returnBefore + spaceBefore) && " ";
				return spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+"\n" :"");


			} else {
				// There is no mode, return special with spaces around it.
				return spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+"\n" : "");
			}

		});
	},
	// ## mustacheCore.cleanWhitespaceControl
	// Removes whitespace according to the whitespace control.
	/**
	 * @hide
	 * Prunes whitespace according to the whitespace control.
	 * @param {String} template
	 * @return {String}
	 */
	cleanWhitespaceControl: function(template) {
		return template.replace(mustacheWhitespaceRegExp, "$1$2");
	},
	getTemplateById: function(){}
};

// ## Local Variable Cache
//
// The following creates slightly more quickly accessible references of the following
// core functions.
var makeEvaluator = core.makeEvaluator,
	splitModeFromExpression = core.splitModeFromExpression;

module.exports = core;


/***/ }),

/***/ "./node_modules/can-stache/src/set-identifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/src/set-identifier.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

module.exports = function SetIdentifier(value){
	this.value = value;
};


/***/ }),

/***/ "./node_modules/can-stache/src/text_section.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/src/text_section.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var live = __webpack_require__(/*! can-view-live */ "./node_modules/can-view-live/can-view-live.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/can-stache/src/utils.js");

var domMutate = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");

var noop = function(){};

var TextSectionBuilder = function(filename){
	if (filename) {
		this.filename = filename;
	}
	this.stack = [new TextSection()];
};

assign(TextSectionBuilder.prototype,utils.mixins);

assign(TextSectionBuilder.prototype,{
	// Adds a subsection.
	startSection: function(process){
		var subSection = new TextSection();
		this.last().add({process: process, truthy: subSection});
		this.stack.push(subSection);
	},
	endSection: function(){
		this.stack.pop();
	},
	inverse: function(){
		this.stack.pop();
		var falseySection = new TextSection();
		this.last().last().falsey = falseySection;
		this.stack.push(falseySection);
	},
	compile: function(state){

		var renderer = this.stack[0].compile();
		//!steal-remove-start
		if (true) {
			Object.defineProperty(renderer,"name",{
				value: "textSectionRenderer<"+state.tag+"."+state.attr+">"
			});
		}
		//!steal-remove-end

		return function(scope){
			function textSectionRender(){
				return renderer(scope);
			}
			//!steal-remove-start
			if (true) {
				Object.defineProperty(textSectionRender,"name",{
					value: "textSectionRender<"+state.tag+"."+state.attr+">"
				});
			}
			//!steal-remove-end
			var observation = new Observation(textSectionRender, null, {isObservable: false});

			canReflect.onValue(observation, noop);

			var value = canReflect.getValue(observation);
			if( canReflect.valueHasDependencies( observation ) ) {
				if(state.textContentOnly) {
					live.text(this, observation);
				}
				else if(state.attr) {
					live.attr(this, state.attr, observation);
				}
				else {
					live.attrs(this, observation, scope);
				}
				canReflect.offValue(observation, noop);
			} else {
				if(state.textContentOnly) {
					this.nodeValue = value;
				}
				else if(state.attr) {
					domMutate.setAttribute.call(this, state.attr, value);
				}
				else {
					live.attrs(this, value);
				}
			}
		};
	}
});

var passTruthyFalsey = function(process, truthy, falsey){
	return function(scope){
		return process.call(this, scope, truthy, falsey);
	};
};

var TextSection = function(){
	this.values = [];
};

assign( TextSection.prototype, {
	add: function(data){
		this.values.push(data);
	},
	last: function(){
		return this.values[this.values.length - 1];
	},
	compile: function(){
		var values = this.values,
			len = values.length;

		for(var i = 0 ; i < len; i++) {
			var value = this.values[i];
			if(typeof value === "object") {
				values[i] = passTruthyFalsey( value.process,
				    value.truthy && value.truthy.compile(),
				    value.falsey && value.falsey.compile());
			}
		}

		return function(scope){
			var txt = "",
				value;
			for(var i = 0; i < len; i++){
				value = values[i];
				txt += typeof value === "string" ? value : value.call(this, scope);
			}
			return txt;
		};
	}
});

module.exports = TextSectionBuilder;


/***/ }),

/***/ "./node_modules/can-stache/src/truthy-observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-stache/src/truthy-observable.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

module.exports = function(observable){
    return new Observation(function truthyObservation(){
        var val = canReflect.getValue(observable);

        return !!val;
    });
};


/***/ }),

/***/ "./node_modules/can-stache/src/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/can-stache/src/utils.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Scope = __webpack_require__(/*! can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var observationReader = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var KeyObservable = __webpack_require__(/*! ./key-observable */ "./node_modules/can-stache/src/key-observable.js");

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var isViewSymbol = canSymbol.for("can.isView");

// this creates a noop that marks that a renderer was called
// this is for situations where a helper function calls a renderer
// that was not provided such as
// {{#if false}} ... {{/if}}
// with no {{else}}
var createNoOpRenderer = function (metadata) {
	return function noop() {
		if (metadata) {
			metadata.rendered = true;
		}
	};
};

module.exports = {
	last: function(arr){
		return arr !=null && arr[arr.length-1];
	},
	// A generic empty function
	emptyHandler: function(){},
	// Converts a string like "1" into 1. "null" into null, etc.
	// This doesn't have to do full JSON, so removing eval would be good.
	jsonParse: function(str){
		// if it starts with a quote, assume a string.
		if(str[0] === "'") {
			return str.substr(1, str.length -2);
		} else if(str === "undefined") {
			return undefined;
		} else {
			return JSON.parse(str);
		}
	},
	mixins: {
		last: function(){
			return this.stack[this.stack.length - 1];
		},
		add: function(chars){
			this.last().add(chars);
		},
		subSectionDepth: function(){
			return this.stack.length - 1;
		}
	},
	// Sets .fn and .inverse on a helperOptions object and makes sure
	// they can reference the current scope and options.
	createRenderers: function(helperOptions, scope, truthyRenderer, falseyRenderer, isStringOnly){
		helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
		helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
		helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
	},
	// Returns a new renderer function that makes sure any data or helpers passed
	// to it are converted to a can.view.Scope and a can.view.Options.
	makeRendererConvertScopes: function (renderer, parentScope, observeObservables, metadata) {
		var convertedRenderer = function (newScope, newOptions) {
			// prevent binding on fn.
			// If a non-scope value is passed, add that to the parent scope.
			if (newScope !== undefined && !(newScope instanceof Scope)) {
				if (parentScope) {
					newScope = parentScope.add(newScope);
				}
				else {
					newScope = new Scope(newScope || {});
				}
			}
			if (metadata) {
				metadata.rendered = true;
			}

			var result = renderer(newScope || parentScope );
			return result;
		};
		return observeObservables ? convertedRenderer :
			ObservationRecorder.ignore(convertedRenderer);
	},
	makeView: function(renderer){
		var view = ObservationRecorder.ignore(function(scope){
			if(!(scope instanceof Scope)) {
				scope = new Scope(scope);
			}
			return renderer(scope);
		});
		view[isViewSymbol] = true;
		return view;
	},
	// Calls the truthy subsection for each item in a list and returning them in a string.
	getItemsStringContent: function(items, isObserveList, helperOptions){
		var txt = "",
			len = observationReader.get(items, 'length'),
			isObservable = canReflect.isObservableLike(items);

		for (var i = 0; i < len; i++) {
			var item = isObservable ? new KeyObservable(items, i) :items[i];
			txt += helperOptions.fn(item);
		}
		return txt;
	},
	// Calls the truthy subsection for each item in a list and returns them in a document Fragment.
	getItemsFragContent: function(items, helperOptions, scope) {
		var result = [],
			len = observationReader.get(items, 'length'),
			isObservable = canReflect.isObservableLike(items),
			hashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs,
			hashOptions;

		// Check if using hash
		if (canReflect.size(hashExprs) > 0) {
			hashOptions = {};
			canReflect.eachKey(hashExprs, function (exprs, key) {
				hashOptions[exprs.key] = key;
			});
		}

		for (var i = 0; i < len; i++) {
			var aliases = {};

			var item = isObservable ? new KeyObservable(items, i) :items[i];

			if (canReflect.size(hashOptions) > 0) {
				if (hashOptions.value) {
					aliases[hashOptions.value] = item;
				}
				if (hashOptions.index) {
					aliases[hashOptions.index] = i;
				}
			}

			result.push(helperOptions.fn(
				scope
				.add(aliases, { notContext: true })
				.add({ index: i }, { special: true })
				.add(item))
			);
		}
		return result;
	}
};


/***/ }),

/***/ "./node_modules/can-stream-kefir/can-stream-kefir.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-stream-kefir/can-stream-kefir.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Kefir = __webpack_require__(/*! can-kefir */ "./node_modules/can-kefir/can-kefir.js");
var compute = __webpack_require__(/*! can-compute */ "./node_modules/can-compute/can-compute.js");
var canStream = __webpack_require__(/*! can-stream */ "./node_modules/can-stream/can-stream.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
var getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');

var canStreamKefir = {};

/*
 * Converts all arguments passed into a single stream and resolves the resulting
 * streams into a single stream. Assumes all arguments are computes and last
 * argument is optionally a function.
 */
canStreamKefir.toStream = function (compute) {
	var stream = Kefir.stream(function (emitter) {
		var changeHandler = function (ev, newVal) {
			emitter.emit(newVal);
		};

		compute.on('change', changeHandler);

		var currentValue = compute();
		if(currentValue !== undefined) {
			emitter.emit(currentValue);
		}

		return function () {
			compute.off('change', changeHandler);
		};
	});

	stream[getValueDependenciesSymbol] = function getValueDependencies() {
		return {
			valueDependencies: new Set([compute])
		};
	};

	return stream;
};

canStreamKefir.toCompute = function(makeStream, context){
	var emitter,
		lastValue,
		streamHandler,
		lastSetValue;

	var setterStream = Kefir.stream(function (e) {
		emitter = e;
		if (lastSetValue !== undefined) {
			emitter.emit(lastSetValue);
		}
	});
	var valueStream = makeStream.call(context, setterStream);

	// Create a compute that will bind to the resolved stream when bound
	var streamCompute = compute(undefined, {
		// When the compute is read, use that last value
		get: function () {
			return lastValue;
		},
		set: function (val) {
			if(emitter) {
				emitter.emit(val);
			} else {
				lastSetValue = val;
			}
			return val;
		},

		// When the compute is bound, bind to the resolved stream
		on: function (updated) {

			// When the stream passes a new values, save a reference to it and call
			// the compute's internal `updated` method (which ultimately calls `get`)
			streamHandler = function (val) {
				lastValue = val;
				updated();
			};
			valueStream.onValue(streamHandler);
		},

		// When the compute is unbound, unbind from the resolved stream
		off: function () {
			valueStream.offValue(streamHandler);
		}
	});

	// the symbol should ideally be implemented in the compute wrapper instead of
	// the internal instance, this should be fixed once can-compute is removed
	var _compute = streamCompute.computeInstance;
	_compute[getKeyDependenciesSymbol] = function getKeyDependencies(key) {
		if (key === 'change') {
			return {
				valueDependencies: new Set([valueStream])
			};
		}
	};

	return streamCompute;
};

if (!namespace.streamKefir) {
	/*
	 * Exposes a simple toStream method that takes an observable and event or propname and returns a Kefir stream object
	 */
	module.exports = namespace.streamKefir = canStream(canStreamKefir);
}



/***/ }),

/***/ "./node_modules/can-stream/can-stream.js":
/*!***********************************************!*\
  !*** ./node_modules/can-stream/can-stream.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var compute = __webpack_require__(/*! can-compute */ "./node_modules/can-compute/can-compute.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var toComputeFromEvent = function(observable, eventName){
	var handler,
		lastSet;
	return compute(undefined, {
		on: function(updated) {
			handler = function(ev, val) {
				lastSet = assign({
					args: [].slice.call(arguments, 1)
				}, ev);
				updated();
			};
			observable.on(eventName, handler);
		},
		off: function(updated) {
			observable.off(eventName, handler);
			lastSet = undefined;
		},
		get: function(){
			return lastSet;
		}
	});
};


var STREAM = function(canStreamInterface) {

	var canStream;

	var toStreamFromProperty = function(obs, propName) {
		return canStreamInterface.toStream(compute(obs, propName));
	};

	var toStreamFromEvent = function() {
		var obs = arguments[0];
		var eventName, propName, lastValue, internalCompute;


		if(arguments.length === 2) {
			//.toStreamFromEvent(obs, event);

			internalCompute = toComputeFromEvent(obs,  arguments[1]);

			return canStreamInterface.toStream(internalCompute);
		} else {
			//.toStreamFromEvent(obs, propName, event);
			propName = arguments[1];
			eventName = arguments[2];
			lastValue = obs[propName];

			var valuePropCompute = compute(obs, propName);

			var eventHandler;
			var propChangeHandler;

			internalCompute = compute(undefined,{
				on: function(updater){
					eventHandler = function(ev, newVal, oldVal) {
						lastValue = newVal;
						updater(lastValue);
					};

					propChangeHandler = function(ev, newVal, oldVal) {
						oldVal.off(eventName, eventHandler);
						newVal.on(eventName, eventHandler);
					};

					valuePropCompute.on('change', propChangeHandler);

					valuePropCompute().on(eventName, eventHandler);
				},
				off: function(){
					valuePropCompute().off(eventName, eventHandler);
					valuePropCompute.off('change', propChangeHandler);
				},
				get: function(){
					return lastValue;
				},
				set: function(val){
					throw new Error("can-stream: you can't set this type of compute");
				}
			});

			var stream = canStreamInterface.toStream(internalCompute);

			return stream;
		}
	};

	//.toStream(observable, propAndOrEvent[,event])
	var toStream = function() {

		if(arguments.length === 1) {
			//we expect it to be a compute:
			return canStreamInterface.toStream(arguments[0]); //toStream(compute)
		}
		else if(arguments.length > 1) {
			var obs = arguments[0];
			var eventNameOrPropName = arguments[1].trim();

			if(eventNameOrPropName.indexOf(" ") === -1) {
				//no space found (so addressing the first three)
				if(eventNameOrPropName.indexOf(".") === 0) {
					//starts with a dot
					return canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1)); //toStream(obj, "tasks")
				}
				else {
					return canStream.toStreamFromEvent(obs, eventNameOrPropName); //toStream( obj, "close")
				}
			}
			else {
				var splitEventNameAndProperty = eventNameOrPropName.split(" ");
				return canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);  //toStream(obj, "tasks add")
			}
		}
		return undefined;
	};

	var toCompute = function(makeStream, context) {
		var args = canReflect.toArray(arguments);
		return canStreamInterface.toCompute.apply(this, args);
	};

	canStream = toStream;
	canStream.toStream = canStream;
	canStream.toStreamFromProperty = toStreamFromProperty;
	canStream.toStreamFromEvent = toStreamFromEvent;
	canStream.toCompute = toCompute;

	return canStream;
};
STREAM.toComputeFromEvent = toComputeFromEvent;

module.exports = namespace.stream = STREAM;


/***/ }),

/***/ "./node_modules/can-string-to-any/can-string-to-any.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-string-to-any/can-string-to-any.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function(str){
	switch(str) {
		case "NaN":
		case "Infinity":
			return +str;
		case "null":
			return null;
		case "undefined":
			return undefined;
		case "true":
		case "false":
			return str === "true";
		default:
			var val = +str;
			if(!isNaN(val)) {
				return val;
			} else {
				return str;
			}
	}
};


/***/ }),

/***/ "./node_modules/can-string/can-string.js":
/*!***********************************************!*\
  !*** ./node_modules/can-string/can-string.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";

// ##string.js
// _Miscellaneous string utility functions._
// Several of the methods in this plugin use code adapted from Prototype
// Prototype JavaScript framework, version 1.6.0.1.
// © 2005-2007 Sam Stephenson
var strUndHash = /_|-/,
	strColons = /\=\=/,
	strWords = /([A-Z]+)([A-Z][a-z])/g,
	strLowUp = /([a-z\d])([A-Z])/g,
	strDash = /([a-z\d])([A-Z])/g,
	strQuote = /"/g,
	strSingleQuote = /'/g,
	strHyphenMatch = /-+(.)?/g,
	strCamelMatch = /[a-z][A-Z]/g,
	convertBadValues = function (content) {
		// Convert bad values into empty strings
		var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
		return '' + (isInvalid ? '' : content);
	};

var string = {
	/**
	 * @function can-string.esc esc
	 * @signature `string.esc(content)`
	 * @param  {String} content a string
	 * @return {String}         the string safely HTML-escaped
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * string.esc("<div>&nbsp;</div>"); //-> "&lt;div&gt;&amp;nbsp;&lt;/div&gt;"
	 * ```
	 */
	esc: function (content) {
		return convertBadValues(content)
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(strQuote, '&#34;')
			.replace(strSingleQuote, '&#39;');
	},
	/**
	 * @function can-string.capitalize capitalize
	 * @signature `string.capitalize(s)`
	 * @param  {String} s     the string to capitalize
	 * @return {String}       the supplied string with the first character uppercased if it is a letter
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.capitalize("foo")); // -> "Foo"
	 * console.log(string.capitalize("123")); // -> "123"
	 * ```
	 */
	capitalize: function (s) {
		// Used to make newId.
		return s.charAt(0)
			.toUpperCase() + s.slice(1);
	},
	/**
	 * @function can-string.camelize camelize
	 * @signature `string.camelize(s)`
	 * @param  {String} str   the string to camelCase
	 * @return {String}       the supplied string with hyphens removed and following letters capitalized.
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.camelize("foo-bar")); // -> "fooBar"
	 * console.log(string.camelize("-webkit-flex-flow")); // -> "WebkitFlexFlow"
	 * ```
	 */
	camelize: function (str) {
		return convertBadValues(str)
			.replace(strHyphenMatch, function (match, chr) {
				return chr ? chr.toUpperCase() : '';
			});
	},
	/**
	 * @function can-string.hyphenate hyphenate
	 * @signature `string.hyphenate(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.hyphenate("fooBar")); // -> "foo-bar"
	 * console.log(string.hyphenate("WebkitFlexFlow")); // -> "Webkit-flex-flow"
	 * ```
	 */
	hyphenate: function (str) {
		return convertBadValues(str)
			.replace(strCamelMatch, function (str) {
				return str.charAt(0) + '-' + str.charAt(1)
					.toLowerCase();
			});
	},
	/**
	 * @function can-string.pascalize pascalize
	 * @signature `string.pascalize(s)`
	 * @param  {String} str   the string in hyphen case | camelCase
	 * @return {String}       the supplied string with hyphens | camelCase converted to PascalCase
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.pascalize("fooBar")); // -> "FooBar"
	 * console.log(string.pascalize("baz-bar")); // -> "BazBar"
	 * ```
	 */
	pascalize: function (str) {
		return string.capitalize(string.camelize(str));
	},
	/**
	 * @function can-string.underscore underscore
	 * @signature `string.underscore(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.underscore("fooBar")); // -> "foo_bar"
	 * console.log(string.underscore("HTMLElement")); // -> "html_element"
	 * ```
	 */
	underscore: function (s) {
		return s.replace(strColons, '/')
			.replace(strWords, '$1_$2')
			.replace(strLowUp, '$1_$2')
			.replace(strDash, '_')
			.toLowerCase();
	},
	/**
	 * @property {RegExp} can-string.strUndHash strUndHash
	 *
	 * A regex which matches an underscore or hyphen character
	 */
	undHash: strUndHash
};
module.exports = string;


/***/ }),

/***/ "./node_modules/can-super-model/can-super-model.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-super-model/can-super-model.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var connect = __webpack_require__(/*! can-connect */ "./node_modules/can-connect/can-connect.js");

var connectConstructor = __webpack_require__(/*! can-connect/constructor/constructor */ "./node_modules/can-connect/constructor/constructor.js");
var canMap = __webpack_require__(/*! can-connect/can/map/map */ "./node_modules/can-connect/can/map/map.js");
var canRef = __webpack_require__(/*! can-connect/can/ref/ref */ "./node_modules/can-connect/can/ref/ref.js");
var constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ "./node_modules/can-connect/constructor/store/store.js");
var dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ "./node_modules/can-connect/data/callbacks/callbacks.js");
var callbacksCache = __webpack_require__(/*! can-connect/data/callbacks-cache/callbacks-cache */ "./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js");
var combineRequests = __webpack_require__(/*! can-connect/data/combine-requests/combine-requests */ "./node_modules/can-connect/data/combine-requests/combine-requests.js");
var localCache = __webpack_require__(/*! can-connect/data/localstorage-cache/localstorage-cache */ "./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js");
var dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ "./node_modules/can-connect/data/parse/parse.js");
var dataUrl = __webpack_require__(/*! can-connect/data/url/url */ "./node_modules/can-connect/data/url/url.js");
var fallThroughCache = __webpack_require__(/*! can-connect/fall-through-cache/fall-through-cache */ "./node_modules/can-connect/fall-through-cache/fall-through-cache.js");
var realTime = __webpack_require__(/*! can-connect/real-time/real-time */ "./node_modules/can-connect/real-time/real-time.js");
var callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js");
var DefineList = __webpack_require__(/*! can-define/list/list */ "./node_modules/can-define/list/list.js");
var DefineMap = __webpack_require__(/*! can-define/map/map */ "./node_modules/can-define/map/map.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var QueryLogic = __webpack_require__(/*! can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");

function superModel(optionsOrUrl) {

	// If optionsOrUrl is a string, make options = {url: optionsOrUrl}
	var options = (typeof optionsOrUrl === "string") ? {url: optionsOrUrl} : optionsOrUrl;

	// If options.Map or .List aren’t provided, define them
	if (typeof options.Map === "undefined") {
		options.Map = DefineMap.extend({seal: false}, {});
	}
	if (typeof options.List === "undefined") {
		options.List = options.Map.List || DefineList.extend({"#": options.Map});
	}

    options = canReflect.assignDeep({},options);

    if(!options.name) {
        options.name = canReflect.getName(options.Map)+".connection";
    }
    if(!options.queryLogic) {
        options.queryLogic = new QueryLogic(options.Map);
    }

	var behaviors = [
		connectConstructor,
		canMap,
		canRef,
		constructorStore,
		dataCallbacks,
		combineRequests,
		dataParse,
		dataUrl,
		realTime,
		callbacksOnce];

	if(typeof localStorage !== "undefined") {
		if(!options.cacheConnection) {
			options.cacheConnection = connect([localCache],{
				name: options.name+".cacheConnection",
				idProp: options.idProp,
				queryLogic: options.queryLogic
			});
		}
		behaviors.push(callbacksCache,fallThroughCache);
	}
	return connect(behaviors,options);
}

module.exports = namespace.superModel = superModel;


/***/ }),

/***/ "./node_modules/can-symbol/can-symbol.js":
/*!***********************************************!*\
  !*** ./node_modules/can-symbol/can-symbol.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var supportsNativeSymbols = (function() {
	var symbolExists = typeof Symbol !== "undefined" && typeof Symbol.for === "function";

	if (!symbolExists) {
		return false;
	}

	var symbol = Symbol("a symbol for testing symbols");
	return typeof symbol === "symbol";
}());

var CanSymbol;
if(supportsNativeSymbols) {
	CanSymbol = Symbol;
} else {

	var symbolNum = 0;
	CanSymbol = function CanSymbolPolyfill(description){
		var symbolValue = "@@symbol"+(symbolNum++)+(description);

		var symbol = {}; // make it object type

		Object.defineProperties(symbol, {
			toString: {
				value: function(){
					return symbolValue;
				}
			}
		});

		return symbol;
	};

	var descriptionToSymbol = {};
	var symbolToDescription = {};

	/**
	 * @function can-symbol.for for
	 * @parent  can-symbol/methods
	 * @description  Get a symbol based on a known string identifier, or create it if it doesn't exist.
	 *
	 * @signature `canSymbol.for(String)`
	 *
	 * @param { String } description  The string value of the symbol
	 * @return { CanSymbol } The globally unique and consistent symbol with the given string value.
	 */
	CanSymbol.for = function(description){
		var symbol = descriptionToSymbol[description];
		if(!symbol) {
			symbol = descriptionToSymbol[description] = CanSymbol(description);
			symbolToDescription[symbol] = description;
		}
		return symbol;
	};
	/**
	 * @function can-symbol.keyFor keyFor
	 * @parent  can-symbol
	 * @description  Get the description for a symbol.
	 *
	 * @signature `canSymbol.keyFor(CanSymbol)`
	 *
	 * @param { String } description  The string value of the symbol
	 * @return { CanSymbol } The globally unique and consistent symbol with the given string value.
	 */
	CanSymbol.keyFor = function(symbol) {
		return symbolToDescription[symbol];
	};
	["hasInstance","isConcatSpreadable",
		"iterator","match","prototype","replace","search","species","split",
	"toPrimitive","toStringTag","unscopables"].forEach(function(name){
		CanSymbol[name] = CanSymbol("Symbol."+name);
	});
}

// Generate can. symbols.
[
	// ======= Type detection ==========
	"isMapLike",
	"isListLike",
	"isValueLike",
	"isFunctionLike",
	// ======= Shape detection =========
	"getOwnKeys",
	"getOwnKeyDescriptor",
	"proto",
	// optional
	"getOwnEnumerableKeys",
	"hasOwnKey",
	"hasKey",
	"size",
	"getName",
	"getIdentity",

	// shape manipulation
	"assignDeep",
	"updateDeep",

	// ======= GET / SET
	"getValue",
	"setValue",
	"getKeyValue",
	"setKeyValue",
	"updateValues",
	"addValue",
	"removeValues",
	// ======= Call =========
	"apply",
	"new",
	// ======= Observe =========
	"onValue",
	"offValue",
	"onKeyValue",
	"offKeyValue",
	"getKeyDependencies",
	"getValueDependencies",
	"keyHasDependencies",
	"valueHasDependencies",
	"onKeys",
	"onKeysAdded",
	"onKeysRemoved",
	"onPatches"
	].forEach(function(name){
	CanSymbol.for("can."+name);
});

module.exports = namespace.Symbol = CanSymbol;


/***/ }),

/***/ "./node_modules/can-type/can-type.js":
/*!*******************************************!*\
  !*** ./node_modules/can-type/can-type.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canString = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var isMemberSymbol = canSymbol.for("can.isMember");
var newSymbol = canSymbol.for("can.new");
var getSchemaSymbol = canSymbol.for("can.getSchema");
var baseTypeSymbol = canSymbol.for("can.baseType");
var strictTypeOfSymbol = canSymbol.for("can.strictTypeOf");

var type = exports;

function makeSchema(values) {
	return function(){
		return {
			type: "Or",
			values: values
		};
	};
}

// Default "can.new"
function canNew(value) {
	if(this[isMemberSymbol](value)) {
		return value;
	}

	return canReflect.convert(value, this[baseTypeSymbol]);
}

function strictNew(value) {
	var isMember = this[isMemberSymbol](value);
	if(!isMember) {
		return check(this[baseTypeSymbol], value);
	}
	return value;
}

// "can.new" for Booleans
function booleanNew(value) {
	if (value === "false" || value=== "0") {
		return false;
	}
	return Boolean(value);
}

var maybeValues = Object.freeze([null, undefined]);

function check(Type, val) {
	var valueType = canString.capitalize(typeof val);
	var error = new Error('Type value ' + typeof val === "string" ? '"' + val + '"' : val + ' (' + valueType + ') is not of type ' + canReflect.getName(Type) + '.'	);
	error.type = 'can-type-error';
	throw error;
}

function makeIsMember(Type) {
	if(isMemberSymbol in Type) {
		return Type[isMemberSymbol];
	}
	return function(value) {
		return value instanceof Type;
	};
}

function makeBaseType(Type) {
	var typeObject = {};
	typeObject[newSymbol] = canNew;
	typeObject[isMemberSymbol] = makeIsMember(Type);
	typeObject[baseTypeSymbol] = Type;
	typeObject[getSchemaSymbol] = makeSchema([Type]);
	Type[strictTypeOfSymbol] = typeObject[strictTypeOfSymbol] = typeObject;
	return typeObject;
}

function makePrimitiveType(Type, typeString) {
	var typeObject = makeBaseType(Type);
	if(Type === Boolean) {
		typeObject[newSymbol] = booleanNew;
		typeObject[getSchemaSymbol] = makeSchema([true, false]);
	}
	typeObject[isMemberSymbol] = function(value) {
		return typeof value === typeString;
	};
	return typeObject;
}

function getBaseType(Type) {
	if(typeof Type === "function") {
		if(canReflect.hasOwnKey(Type, strictTypeOfSymbol)) {
			return Type[strictTypeOfSymbol];
		}
	} else if(strictTypeOfSymbol in Type) {
		return Type[strictTypeOfSymbol];
	}
	return makeBaseType(Type);
}

function makeMaybe(Type) {
	var isMember = Type[isMemberSymbol];
	return function(value) {
		return value == null || isMember.call(this, value);
	};
}

function makeMaybeSchema(baseType) {
	var baseSchema = canReflect.getSchema(baseType);
	var allValues = baseSchema.values.concat(maybeValues);
	return makeSchema(allValues);
}

function inheritFrom(o, Type, property) {
	if(property in Type) {
		o[property] = Type[property];
	}
}

function wrapName(wrapper, Type) {
	var baseName = canReflect.getName(Type);
	return "type." + wrapper + "(" + baseName + ")";
}

canReflect.each({
	"boolean": Boolean,
	"number": Number,
	"string": String
}, function(Type, typeString) {
	makePrimitiveType(Type, typeString);
});

function isTypeObject(Type) {
	if(canReflect.isPrimitive(Type)) {
		return false;
	}

	return (newSymbol in Type) && (isMemberSymbol in Type);
}

function normalize(Type) {
	if(canReflect.isPrimitive(Type)) {
		throw new Error("can-type: Unable to normalize primitive values.");
	} else if(isTypeObject(Type)) {
		return Type;
	} else {
		return type.check(Type);
	}
}

function late(fn) {
	var lateType = {};
	var underlyingType;
	var unwrap = function() {
		underlyingType = type.normalize(fn());
		unwrap = function() { return underlyingType; };
		return underlyingType;
	};
	return canReflect.assignSymbols(lateType, {
		"can.new": function(val) {
			return canReflect.new(unwrap(), val);
		},
		"can.isMember": function(val) {
			return unwrap()[isMemberSymbol](val);
		}
	});
}

var Any = canReflect.assignSymbols({}, {
	"can.new": function(val) { return val; },
	"can.isMember": function() { return true; }
});

function all(typeFn, Type) {
	var typeObject = typeFn(Type);
	typeObject[getSchemaSymbol] = function() {
		var parentSchema = canReflect.getSchema(Type);
		var schema = canReflect.assignMap({}, parentSchema);
		schema.keys = {};
		canReflect.eachKey(parentSchema.keys, function(value, key) {
			schema.keys[key] = typeFn(value);
		});
		return schema;
	};

	function Constructor(values) {
		var schema = canReflect.getSchema(this);
		var keys = schema.keys;
		var convertedValues = {};
		canReflect.eachKey(values || {}, function(value, key) {
			convertedValues[key] = canReflect.convert(value, keys[key]);
		});
		return canReflect.new(Type, convertedValues);
	}

	canReflect.setName(Constructor, "Converted<" + canReflect.getName(Type) + ">");
	Constructor.prototype = typeObject;

	return Constructor;
}

var Integer = {};
Integer[newSymbol] = function(value) {
	// parseInt(notANumber) returns NaN
	// Since we always want an integer returned
	// using |0 instead.
	return value | 0;
};
Integer[isMemberSymbol] = function(value) {
	// “polyfill” for Number.isInteger because it’s not supported in IE11
	return typeof value === "number" && isFinite(value) &&
		Math.floor(value) === value;
};
Integer[getSchemaSymbol] = makeSchema([Number]);
canReflect.setName(Integer, "Integer");

function makeCache(fn) {
	var cache = new WeakMap();
	return function(Type) {
		if(cache.has(Type)) {
			return cache.get(Type);
		}
		var typeObject = fn.call(this, Type);
		cache.set(Type, typeObject);
		return typeObject;
	};
}

exports.check = makeCache(function(Type) {
	var o = Object.create(getBaseType(Type));
	o[newSymbol] = strictNew;
	inheritFrom(o, Type, isMemberSymbol);
	inheritFrom(o, Type, getSchemaSymbol);
	canReflect.setName(o, wrapName("check", Type));
	return o;
});

exports.convert = makeCache(function(Type) {
	var o = Object.create(getBaseType(Type));
	inheritFrom(o, Type, isMemberSymbol);
	inheritFrom(o, Type, getSchemaSymbol);
	canReflect.setName(o, wrapName("convert", Type));
	return o;
});

exports.maybe = makeCache(function(Type) {
	var baseType = getBaseType(Type);
	var desc = {};
	desc[newSymbol] = {
		value: strictNew
	};
	desc[isMemberSymbol] = {
		value: makeMaybe(baseType)
	};
	desc[getSchemaSymbol] = {
		value: makeMaybeSchema(baseType)
	};
	var o = Object.create(baseType, desc);
	canReflect.setName(o, wrapName("maybe", Type));
	return o;
});

exports.maybeConvert = makeCache(function(Type) {
	var baseType = getBaseType(Type);
	var desc = {};
	desc[isMemberSymbol] = {
		value: makeMaybe(baseType)
	};
	desc[getSchemaSymbol] = {
		value: makeMaybeSchema(baseType)
	};
	var o = Object.create(baseType, desc);
	canReflect.setName(o, wrapName("maybeConvert", Type));
	return o;
});

//!steal-remove-start
// type checking should not throw in production
if(false) {}
//!steal-remove-end

exports.Any = Any;
exports.Integer = Integer;

exports.late = late;
exports.isTypeObject = isTypeObject;
exports.normalize = normalize;
exports.all = all;
exports.convertAll = all.bind(null, exports.convert);
namespace.type = exports;


/***/ }),

/***/ "./node_modules/can-types/can-types.js":
/*!*********************************************!*\
  !*** ./node_modules/can-types/can-types.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

/**
 * @module {Object} can-types
 * @parent can-typed-data
 * @collection can-infrastructure
 * @package ./package.json
 * @description A stateful container for CanJS type information.
 *
 * @body
 *
 * ## Use
 *
 * `can-types` exports an object with placeholder functions that
 * can be used to provide default types or test if something is of a certain type.
 *
 * For example, `can-define/map/map` might overwrite `DefeaultMap` to return DefineMap
 *
 * ```js
 * types.DefaultMap = DefineMap;
 * ```
 */

var types = {
	isMapLike: function(obj){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isMapLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isMapLike(obj)` instead.');
		}
		//!steal-remove-end
		return canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);
	},

	isListLike: function(obj){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isListLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isListLike(obj)` instead.');
		}
		//!steal-remove-end
		return canReflect.isObservableLike(obj) && canReflect.isListLike(obj);
	},

	isPromise: function(obj){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isPromise is deprecated, please use canReflect.isPromise instead.');
		}
		//!steal-remove-end
		return canReflect.isPromise(obj);
	},

	isConstructor: function(func){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isConstructor is deprecated, please use canReflect.isConstructorLike instead.');
		}
		//!steal-remove-end
		return canReflect.isConstructorLike(func);
	},

	isCallableForValue: function(obj){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isCallableForValue(obj) is deprecated, please use `canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj)` instead.');
		}
		//!steal-remove-end
		return obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);
	},

	isCompute: function(obj){
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.isCompute is deprecated.');
		}
		//!steal-remove-end
		return obj && obj.isComputed;
	},

	get iterator() {
		//!steal-remove-start
		if (true) {
			dev.warn('can-types.iterator is deprecated, use `canSymbol.iterator || canSymbol.for("iterator")` instead.');
		}
		//!steal-remove-end
		return canSymbol.iterator || canSymbol.for("iterator");
	},
	/**
	 * @property {Map} can-types.DefaultMap DefaultMap
	 *
	 * @option {Map}
	 *
	 *   The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]
	 *   are imported, the default type will be [can-define/map/map].
	 */
	DefaultMap: null,
	/**
	 * @property {can-connect.List} can-types.DefaultList DefaultList
	 *
	 * @option {can-connect.List}
	 *
	 *   The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]
	 *   are imported, the default type will be [can-define/list/list].
	 */
	DefaultList: null,
	/**
	 * @function can-types.queueTask queueTask
	 * @signature `types.queueTask(task)`
	 *   Run code that will be queued at the end of the current batch.
	 *   @param {Array} task
	 */
	queueTask: function(task){
		var args = task[2] || [];
		task[0].apply(task[1], args);
	},
	/**
	 * @function can-types.wrapElement wrapElement
	 * @signature `types.wrapElement(element)`
	 *   Wraps an element into an object useful by DOM libraries ala jQuery.
	 *
	 *   @param {Node} element Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node).
	 *   @return {{}} A wrapped object.
	 */
	wrapElement: function(element){
		return element;
	},
	/**
	 * @function can-types.unwrapElement unwrapElement
	 * @signature `types.unwrapElement(object)`
	 *   Unwraps an object that contains an element within.
	 *
	 *   @param {{}} object Any object that can be unwrapped into a Node.
	 *   @return {Node} A Node.
	 */
	unwrapElement: function(element){
		return element;
	}
};

if (namespace.types) {
	throw new Error("You can't have two versions of can-types, check your dependencies");
} else {
	module.exports = namespace.types = types;
}


/***/ }),

/***/ "./node_modules/can-validate-interface/index.js":
/*!******************************************************!*\
  !*** ./node_modules/can-validate-interface/index.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


function flatten(arrays) {
	return arrays.reduce(function(ret, val) {
		return ret.concat(val);
	}, []);
}

// return a function that validates it's argument has all the properties in the interfacePropArrays
function makeInterfaceValidator(interfacePropArrays) {
	var props = flatten(interfacePropArrays);

	return function(base) {
			var missingProps = props.reduce(function(missing, prop) {
				return prop in base ? missing : missing.concat(prop);
			}, []);

		return missingProps.length ? {message:"missing expected properties", related: missingProps} : undefined;
	};
}

module.exports = makeInterfaceValidator;


/***/ }),

/***/ "./node_modules/can-validate-validatejs/can-validate-validatejs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-validate-validatejs/can-validate-validatejs.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var validatejs = __webpack_require__(/*! validate.js */ "./node_modules/validate.js/validate.js");

var makeValidator = function(constraints) {
	return function(value) {
		// Returns an array or undefined
		return validatejs.single(value, constraints);
	};
};

makeValidator.many = function(constraints) {
	return function(values) {
		var rawErrors = validatejs(values, constraints, {
			format: "detailed",
			fullMessages: false
		});
		var errors;

		if (rawErrors) {
			errors = [];
			canReflect.eachIndex(rawErrors, function(error) {
				errors.push({
					message: error.options.message || error.error,
					related: [error.attribute]
				});
			});
		}
		return errors;
	};
};

makeValidator.validatejs = validatejs;

module.exports = makeValidator;


/***/ }),

/***/ "./node_modules/can-validate/can-validate.js":
/*!***************************************************!*\
  !*** ./node_modules/can-validate/can-validate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var validate = {};

var helpers = {
	'object': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? {}: undefined;

		canReflect.eachIndex(normalizedErrors, function (error) {
			canReflect.eachIndex(error.related, function (related) {
				if (!errors[related]) {
					errors[related] = [];
				}
				errors[related].push(error.message);
			});
		});
		return errors;
	},
	'flat': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? []: undefined;
		canReflect.eachIndex(normalizedErrors, function (error) {
			errors.push(error.message);
		});
		return errors;
	},
	'errors': function (normalizedErrors) {
		return normalizedErrors.length > 0 ? normalizedErrors: undefined;
	},
	'errors-object': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? {}: undefined;
		canReflect.eachIndex(normalizedErrors, function (error) {
			canReflect.eachIndex(error.related, function (related) {
				if (!errors[related]) {
					errors[related] = [];
				}
				errors[related].push(error);
			});
		});
		return errors;
	}
};

var parseErrorItem = function (rawErrors) {
	var errors = [];
	if (typeof rawErrors === 'string') {
		errors.push({message: rawErrors, related: ['*']});
	}
	if (typeof rawErrors === 'object' && !Array.isArray(rawErrors)) {
		// Although related can be a string, internally, it is easier if it is
		// always an array
		if (rawErrors.related) {
			if (!Array.isArray(rawErrors.related)) {
				rawErrors.related = [rawErrors.related];
			}
		} else {
			rawErrors.related = '*';
		}
		errors.push(rawErrors);
	}
	if (Array.isArray(rawErrors)) {
		canReflect.eachIndex(rawErrors, function (error) {
			[].push.apply(errors, parseErrorItem(error));
		});
	}
	return errors;
};

// Takes errors and normalizes them
var normalizeErrors = function (rawErrors) {
	var normalizedErrors = [];
  if (
    typeof rawErrors === 'string' ||
    (typeof rawErrors === 'object' && !Array.isArray(rawErrors))
  ) {
		// Only one error set, which we can assume was for a single property
		rawErrors = [rawErrors];
	}

  if (rawErrors != null) {
    canReflect.eachIndex(rawErrors, function (error) {
      [].push.apply(normalizedErrors, parseErrorItem(error));
    });
  }

	return normalizedErrors;
};

validate.formatErrors = function (errors, format) {
	var normalized = normalizeErrors(errors);
	if (format) {
		if (helpers[format]) {
			return helpers[format](normalized);
		} else {
			return normalized;
		}
	} else {
		return normalized;
	}
};

module.exports = validate;


/***/ }),

/***/ "./node_modules/can-value/can-value.js":
/*!*********************************************!*\
  !*** ./node_modules/can-value/can-value.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canKey = __webpack_require__(/*! can-key */ "./node_modules/can-key/can-key.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var keyObservable = __webpack_require__(/*! can-simple-observable/key/key */ "./node_modules/can-simple-observable/key/key.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ "./node_modules/can-simple-observable/settable/settable.js");

module.exports = namespace.value = {
	bind: function(object, keyPath) {
		return keyObservable(object, keyPath);
	},

	from: function(object, keyPath) {
		var observationFunction = function() {
			return canKey.get(object, keyPath);
		};

		//!steal-remove-start
		if (true) {
			var objectName = canReflect.getName(object);
			Object.defineProperty(observationFunction, "name", {
				value: "ValueFrom<" + objectName + "." + keyPath + ">"
			});
		}
		//!steal-remove-end

		return new Observation(observationFunction);
	},

	returnedBy: function(getter, context, initialValue) {
		if(getter.length === 1) {
			return new SettableObservable(getter, context, initialValue);
		} else {
			return new Observation(getter, context);
		}
	},

	to: function(object, keyPath) {
		var observable = keyObservable(object, keyPath);

		//!steal-remove-start
		if (true) {
			canReflect.assignSymbols(observable.onDependencyChange, {
				"can.getChangesDependencyRecord": function getChangesDependencyRecord() {
					// can-simple-observable/key/ creates an observation that walks along
					// the keyPath. In doing so, it implicitly registers the objects and
					// keys along the path as mutators of the observation; this means
					// getDependencyDataOf(...an object and key along the path) returns
					// whatIChange.derive.valueDependencies = [observable], which is not
					// true! The observable does not derive its value from the objects
					// along the keyPath. By implementing getChangesDependencyRecord and
					// returning undefined, calls to can.getWhatIChange() for any objects
					// along the keyPath will not include the observable.
				}
			});
		}
		//!steal-remove-end

		var symbolsToAssign = {
			// Remove the getValue symbol so the observable is only a setter
			"can.getValue": null
		};

		//!steal-remove-start
		if (true) {
			symbolsToAssign["can.getValueDependencies"] = function getValueDependencies() {
				// Normally, getDependencyDataOf(observable) would include
				// whatChangesMe.derive.keyDependencies, and it would contain
				// the object and anything along keyPath. This symbol returns
				// undefined because this observable does not derive its value
				// from the object or anything along the keyPath, it only
				// mutates the last object in the keyPath.
			};
		}
		//!steal-remove-end

		return canReflect.assignSymbols(observable, symbolsToAssign);
	},

	with: function(initialValue) {
		return new SimpleObservable(initialValue);
	}
};


/***/ }),

/***/ "./node_modules/can-view-autorender/can-view-autorender.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-view-autorender/can-view-autorender.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canViewModel = __webpack_require__(/*! can-view-model */ "./node_modules/can-view-model/can-view-model.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var camelize = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js").camelize;
var load = __webpack_require__(/*! can-import-module */ "./node_modules/can-import-module/can-import-module.js");
var domEvents = __webpack_require__(/*! can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");

var ignoreAttributesRegExp = /^(dataViewId|class|id|type|src|style)$/i;

var typeMatch = /\s*text\/(stache)\s*/;
function isIn(element, type) {
	while(element.parentNode) {
		element = element.parentNode;
		if(element.nodeName.toLowerCase() === type.toLowerCase()) {
			return true;
		}
	}
}
function setAttr(el, attr, viewModel){
	var camelized = camelize(attr);
	if (!ignoreAttributesRegExp.test(camelized) ) {
		var value = el.getAttribute(attr);

		if(!canReflect.hasKey(viewModel, camelized)) {
			canReflect.defineInstanceKey(viewModel.constructor, camelized, typeof value);
		}
		canReflect.setKeyValue(viewModel, camelized, value);
	}
}
function insertAfter(ref, element) {
	if(ref.nextSibling){
		ref.parentNode.insertBefore(element, ref.nextSibling);
	} else {
		ref.parentNode.appendChild(element);
	}
}

function render(renderer, scope, el) {
	var frag = renderer(scope);
	if( isIn(el, "head") ) {
		document.body.appendChild(frag);
	} else if(el.nodeName.toLowerCase() === "script") {
		insertAfter(el, frag);
	} else {
		insertAfter(el, frag);
		el.parentNode.removeChild(el);
	}
}
function setupScope(el) {
	var scope = canViewModel(el);

	canReflect.each(el.attributes || [], function(attr) {
		setAttr(el, attr.name, scope);
	});

	domEvents.addEventListener(el, "attributes", function(ev) {
		setAttr(el, ev.attributeName, scope);
	});

	return scope;
}

var promise = new Promise(function(resolve, reject) {
	function autoload(){
		var promises = [];

		canReflect.each(document.querySelectorAll("[can-autorender]"), function( el, i){
			el.style.display = "none";

			var text = el.innerHTML || el.text,
				typeAttr = el.getAttribute("type"),
				typeInfo = typeAttr.match( typeMatch ),
				type = typeInfo && typeInfo[1],
				typeModule = "can-" + type;

			promises.push(load(typeModule).then(function(engine){
				if(engine.async) {
					return engine.async(text).then(function(renderer){
						render(renderer, setupScope(el), el);
					});
				} else {
					var renderer = engine(text);
					render(renderer, setupScope(el), el);
				}
			}));

		});

		Promise.all(promises).then(resolve, reject);
	}

	if (document.readyState === "complete") {
		autoload();
	} else {
		domEvents.addEventListener(window, "load", autoload);
	}
});

module.exports = namespace.autorender = function autorender(success, error){
	return promise.then(success, error);
};


/***/ }),

/***/ "./node_modules/can-view-callbacks/can-view-callbacks.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-view-callbacks/can-view-callbacks.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");

var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var getGlobal = __webpack_require__(/*! can-globals/global/global */ "./node_modules/can-globals/global/global.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var makeFrag = __webpack_require__(/*! can-fragment */ "./node_modules/can-fragment/can-fragment.js");
var globals = __webpack_require__(/*! can-globals */ "./node_modules/can-globals/can-globals.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var callbackMapSymbol = canSymbol.for('can.callbackMap');
var initializeSymbol = canSymbol.for('can.initialize');

//!steal-remove-start
if (true) {
	var requestedAttributes = {};
}
//!steal-remove-end

var tags = {};

// WeakSet containing elements that have been rendered already
// and therefore do not need to be rendered again

var automountEnabled = function(){
	var document = globals.getKeyValue("document");
	if(document == null || document.documentElement == null) {
		return false;
	}
	return document.documentElement.getAttribute("data-can-automount") !== "false";
};

var renderedElements = new WeakMap();

var mountElement = function (node) {
	var tagName = node.tagName && node.tagName.toLowerCase();
	var tagHandler = tags[tagName];

	// skip elements that already have a viewmodel or elements whose tags don't match a registered tag
	// or elements that have already been rendered
	if (tagHandler) {
		callbacks.tagHandler(node, tagName, {});
	}
};

var mutationObserverEnabled = false;
var disableMutationObserver;
var enableMutationObserver = function() {
	var docEl = getDocument().documentElement;

	if (mutationObserverEnabled) {
		if (mutationObserverEnabled === docEl) {
			return;
		}
		// if the document has changed, re-enable mutationObserver
		disableMutationObserver();
	}

	var undoOnInsertionHandler = domMutate.onConnected(docEl, function(mutation) {
		mountElement(mutation.target);
	});
	mutationObserverEnabled = true;

	disableMutationObserver = function() {
		undoOnInsertionHandler();
		mutationObserverEnabled = false;
	};
};

var renderTagsInDocument = function(tagName) {
	var nodes = getDocument().getElementsByTagName(tagName);

	for (var i=0, node; (node = nodes[i]) !== undefined; i++) {
		mountElement(node);
	}
};

var attr = function (attributeName, attrHandler) {
	if(attrHandler) {
		if (typeof attributeName === "string") {
			attributes[attributeName] = attrHandler;
			//!steal-remove-start
			if (true) {
				if(requestedAttributes[attributeName]) {
					dev.warn("can-view-callbacks: " + attributeName+ " custom attribute behavior requested before it was defined.  Make sure "+attributeName+" is defined before it is needed.");
				}
			}
			//!steal-remove-end
		} else {
			regExpAttributes.push({
				match: attributeName,
				handler: attrHandler
			});

			//!steal-remove-start
			if (true) {
				Object.keys(requestedAttributes).forEach(function(requested){
					if(attributeName.test(requested)) {
						dev.warn("can-view-callbacks: " + requested+ " custom attribute behavior requested before it was defined.  Make sure "+requested+" is defined before it is needed.");
					}
				});
			}
			//!steal-remove-end
		}
	} else {
		var cb = attributes[attributeName];
		if( !cb ) {

			for( var i = 0, len = regExpAttributes.length; i < len; i++) {
				var attrMatcher = regExpAttributes[i];
				if(attrMatcher.match.test(attributeName)) {
					return attrMatcher.handler;
				}
			}
		}
		//!steal-remove-start
		if (true) {
			requestedAttributes[attributeName] = true;
		}
		//!steal-remove-end

		return cb;
	}
};

var attrs = function(attrMap) {
	var map = canReflect.getKeyValue(attrMap, callbackMapSymbol) || attrMap;

	// Only add bindings once.
	if(attrMaps.has(map)) {
		return;
	} else {
		// Would prefer to use WeakSet but IE11 doesn't support it.
		attrMaps.set(map, true);
	}

	canReflect.eachKey(map, function(callback, exp){
		attr(exp, callback);
	});
};

var attributes = {},
	regExpAttributes = [],
	attrMaps = new WeakMap(),
	automaticCustomElementCharacters = /[-\:]/;
var defaultCallback = function () {};

var tag = function (tagName, tagHandler) {
	if(tagHandler) {
		var validCustomElementName = automaticCustomElementCharacters.test(tagName),
			tagExists = typeof tags[tagName.toLowerCase()] !== 'undefined',
			customElementExists;

		//!steal-remove-start
		if (true) {
			if (tagExists) {
				dev.warn("Custom tag: " + tagName.toLowerCase() + " is already defined");
			}

			if (!validCustomElementName && tagName !== "content") {
				dev.warn("Custom tag: " + tagName.toLowerCase() + " hyphen missed");
			}
		}
		//!steal-remove-end

		tags[tagName.toLowerCase()] = tagHandler;

		if(automountEnabled()) {
			var customElements = globals.getKeyValue("customElements");

			// automatically render elements that have tagHandlers
			// If browser supports customElements, register the tag as a custom element
			if (customElements) {
				customElementExists = customElements.get(tagName.toLowerCase());

				if (validCustomElementName && !customElementExists) {
					var CustomElement = function() {
						return Reflect.construct(HTMLElement, [], CustomElement);
					};

					CustomElement.prototype = Object.create(HTMLElement.prototype);
					CustomElement.prototype.constructor = CustomElement;

					CustomElement.prototype.connectedCallback = function() {
						callbacks.tagHandler(this, tagName.toLowerCase(), {});
					};

					customElements.define(tagName, CustomElement);
				}
			}
			// If browser doesn't support customElements, set up MutationObserver for
			// rendering elements when they are inserted in the page
			// and rendering elements that are already in the page
			else {
				enableMutationObserver();
				renderTagsInDocument(tagName);
			}
		} else if(mutationObserverEnabled) {
			disableMutationObserver();
		}
	} else {
		var cb;

		// if null is passed as tagHandler, remove tag
		if (tagHandler === null) {
			delete tags[tagName.toLowerCase()];
		} else {
			cb = tags[tagName.toLowerCase()];
		}

		if(!cb && automaticCustomElementCharacters.test(tagName)) {
			// empty callback for things that look like special tags
			cb = defaultCallback;
		}
		return cb;
	}

};

var callbacks = {
	_tags: tags,
	_attributes: attributes,
	_regExpAttributes: regExpAttributes,
	defaultCallback: defaultCallback,
	tag: tag,
	attr: attr,
	attrs: attrs,
	// handles calling back a tag callback
	tagHandler: function(el, tagName, tagData){
		// skip elements that have already been rendered
		if (renderedElements.has(el)) {
			return;
		}

		var scope = tagData.scope,
			helperTagCallback = scope && scope.templateContext.tags.get(tagName),
			tagCallback = helperTagCallback || tags[tagName] || el[initializeSymbol],
			res;

		// If this was an element like <foo-bar> that doesn't have a component, just render its content
		if(tagCallback) {
			res = ObservationRecorder.ignore(tagCallback)(el, tagData);

			// add the element to the Set of elements that have had their handlers called
			// this will prevent the handler from being called again when the element is inserted
			renderedElements.set(el, true);
		} else {
			res = scope;
		}

		//!steal-remove-start
		if (true) {
			if (!tagCallback) {
				var GLOBAL = getGlobal();
				var ceConstructor = getDocument().createElement(tagName).constructor;
				// If not registered as a custom element, the browser will use default constructors
				if (ceConstructor === GLOBAL.HTMLElement || ceConstructor === GLOBAL.HTMLUnknownElement) {
					dev.warn('can-view-callbacks: No custom element found for ' + tagName);
				}
			}
		}
		//!steal-remove-end

		// If the tagCallback gave us something to render with, and there is content within that element
		// render it!
		if (res && tagData.subtemplate) {
			if (scope !== res) {
				scope = scope.add(res);
			}

			//var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);
			//nodeList.expression = "<" + el.tagName + ">";

			var result = tagData.subtemplate(scope, tagData.options);
			var frag = typeof result === "string" ? makeFrag(result) : result;
			domMutateNode.appendChild.call(el, frag);
		}
	}
};

namespace.view = namespace.view || {};

if (namespace.view.callbacks) {
	throw new Error("You can't have two versions of can-view-callbacks, check your dependencies");
} else {
	module.exports = namespace.view.callbacks = callbacks;
}


/***/ }),

/***/ "./node_modules/can-view-live/can-view-live.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-view-live/can-view-live.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**	
 * @module {{}} can-view-live can-view-live	
 * @parent can-views	
 * @collection can-infrastructure	
 * @package ./package.json	
 *	
 * Setup live-binding between the DOM and a compute manually.	
 *	
 * @option {Object} An object with the live-binding methods:	
 * [can-view-live.html], [can-view-live.list], [can-view-live.text], and	
 * [can-view-live.attr].	
 *
 *	
 * @body	
 *	
 * ## Use	
 *	
 *  [can-view-live] is an object with utility methods for setting up	
 *  live-binding in relation to different parts of the DOM and DOM elements.  For	
 *  example, to make an `<h2>`'s text stay live with	
 *  a compute:	
 *	
 *  ```js	
 *  var live = require("can-view-live");	
 *  var text = canCompute("Hello World");	
 *  var textNode = $("h2").text(" ")[0].childNodes[0];	
 *  live.text(textNode, text);	
 *  ```	
 *	
 */
var live = {};
live.attr = __webpack_require__(/*! ./lib/attr */ "./node_modules/can-view-live/lib/attr.js");
live.attrs = __webpack_require__(/*! ./lib/attrs */ "./node_modules/can-view-live/lib/attrs.js");
live.html = __webpack_require__(/*! ./lib/html */ "./node_modules/can-view-live/lib/html.js");
live.list = __webpack_require__(/*! ./lib/list */ "./node_modules/can-view-live/lib/list.js");
live.text = __webpack_require__(/*! ./lib/text */ "./node_modules/can-view-live/lib/text.js");


module.exports = live;


/***/ }),

/***/ "./node_modules/can-view-live/lib/attr.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/attr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var attr = __webpack_require__(/*! can-attribute-observable/behaviors */ "./node_modules/can-attribute-observable/behaviors.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/can-view-live/lib/helpers.js");

/**
 * @function can-view-live.attr attr
 * @parent can-view-live
 *
 * @signature `live.attr(el, attributeName, observable)`
 *
 * Keep an attribute live to a [can-reflect]-ed observable.
 *
 * ```js
 * var div = document.createElement('div');
 * var value = new SimpleObservable("foo bar");
 * live.attr(div,"class", value);
 * ```
 *
 * @param {HTMLElement} el The element whos attribute will be kept live.
 * @param {String} attributeName The attribute name.
 * @param {Object} observable An observable value.
 *
 * @body
 *
 * ## How it works
 *
 * This listens for the changes in the observable and uses those changes to
 * set the specified attribute.
 */
module.exports = function(el, attributeName, compute) {
	var handlerName = "";
	//!steal-remove-start
	if(true) {
		// register that the handler changes the parent element
		handlerName = "live.attr update::"+canReflect.getName(compute);
	}
	//!steal-remove-end

	new helpers.ListenUntilRemovedAndInitialize(compute,
			function liveUpdateAttr(newVal) {
				attr.set(el,attributeName, newVal);
			},
			el,
			"dom",
			handlerName
		);
};


/***/ }),

/***/ "./node_modules/can-view-live/lib/attrs.js":
/*!*************************************************!*\
  !*** ./node_modules/can-view-live/lib/attrs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// This provides live binding for stache attributes.
var viewCallbacks = __webpack_require__(/*! can-view-callbacks */ "./node_modules/can-view-callbacks/can-view-callbacks.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/can-view-live/lib/helpers.js");

module.exports = function(el, compute, scope, options) {
	var handlerName = "";
	if (!canReflect.isObservableLike(compute)) {
		// Non-live case (`compute` was not a compute):
		//  set all attributes on the element and don't
		//  worry about setting up live binding since there
		//  is not compute to bind on.
		var attrs = helpers.getAttributeParts(compute);
		for (var name in attrs) {
			domMutateNode.setAttribute.call(el, name, attrs[name]);
		}
		return;
	}

	//!steal-remove-start
	if(true) {
		handlerName = "live.attrs update::"+canReflect.getName(compute);
	}
	//!steal-remove-end


	// last set of attributes
	var oldAttrs = {};


	new helpers.ListenUntilRemovedAndInitialize(compute,
		function canViewLive_updateAttributes(newVal) {
			var newAttrs = helpers.getAttributeParts(newVal),
				name;
			for (name in newAttrs) {
				var newValue = newAttrs[name],
					// `oldAttrs` was set on the last run of setAttrs in this context
					//  (for this element and compute)
					oldValue = oldAttrs[name];
				// Only fire a callback
				//  if the value of the attribute has changed
				if (newValue !== oldValue) {
					// set on DOM attributes (dispatches an "attributes" event as well)
					domMutateNode.setAttribute.call(el, name, newValue);
					// get registered callback for attribute name and fire
					var callback = viewCallbacks.attr(name);
					if (callback) {
						callback(el, {
							attributeName: name,
							scope: scope,
							options: options
						});
					}
				}
				// remove key found in new attrs from old attrs
				delete oldAttrs[name];
			}
			// any attrs left at this point are not set on the element now,
			// so remove them.
			for (name in oldAttrs) {
				domMutateNode.removeAttribute.call(el, name);
			}
			oldAttrs = newAttrs;
		},
		el,
		"dom",
		handlerName);

};


/***/ }),

/***/ "./node_modules/can-view-live/lib/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/can-view-live/lib/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
var parser = __webpack_require__(/*! can-view-parser */ "./node_modules/can-view-parser/can-view-parser.js");
var canDev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var isConnected = __webpack_require__(/*! can-dom-mutate/-is-connected */ "./node_modules/can-dom-mutate/-is-connected.js");

var setElementSymbol = canSymbol.for("can.setElement");
var elementSymbol = canSymbol.for("can.element");

function ListenUntilRemovedAndInitialize(
	observable,
	handler,
	placeholder,
	queueName,
	handlerName
) {
	this.observable = observable;
	this.handler = handler;
	this.placeholder = placeholder;
	this.queueName = queueName;
	this.handler[elementSymbol] = placeholder;

	if( observable[setElementSymbol] ) {
		observable[setElementSymbol](placeholder);
	} else {
		console.warn("no can.setElement symbol on observable", observable);
	}

	//!steal-remove-start
	if(true) {
		// register that the handler changes the parent element
		canReflect.assignSymbols(handler, {
			"can.getChangesDependencyRecord": function() {
				var s = new Set();
				s.add(placeholder);
				return {
					valueDependencies: s
				};
			}
		});

		Object.defineProperty(handler, "name", {
			value: handlerName,
		});

	}
	//!steal-remove-end

	this.setup();
}
ListenUntilRemovedAndInitialize.prototype.setup = function() {
	// reinsertion case, not applicable during initial setup
	if(this.setupNodeReinserted) {
		// do not set up again if disconnected
		if(!isConnected.isConnected(this.placeholder)) {
			return;
		}
		this.setupNodeReinserted();
	}
	this.teardownNodeRemoved = domMutate.onNodeRemoved(this.placeholder,
		this.teardown.bind(this));


	//!steal-remove-start
	if(true) {
		canReflectDeps.addMutatedBy(this.placeholder, this.observable);
	}
	//!steal-remove-end

	canReflect.onValue(this.observable, this.handler, this.queueName);
	this.handler(  canReflect.getValue(this.observable) );

};
ListenUntilRemovedAndInitialize.prototype.teardown = function(){
	// do not teardown if still connected.
	if(isConnected.isConnected(this.placeholder)) {
		return;
	}
	this.teardownNodeRemoved();
	this.setupNodeReinserted = domMutate.onNodeInserted(this.placeholder,
		this.setup.bind(this));

	//!steal-remove-start
	if(true) {
		canReflectDeps.deleteMutatedBy(this.placeholder, this.observable);
	}
	//!steal-remove-end
	canReflect.offValue(this.observable, this.handler, this.queueName);
};


module.exports = {
	range: {
		create: function(el, rangeName){
			var start, end, next;

			if(el.nodeType === Node.COMMENT_NODE) {
				start = el;
				next = el.nextSibling;
				if(next && next.nodeType === Node.COMMENT_NODE && next.nodeValue === "can-end-placeholder") {
					end = next;
					end.nodeValue = "/" + (start.nodeValue = rangeName);
				} else {
					canDev.warn("can-view-live: creating an end comment for ", rangeName, el);
				}
			} else {
				canDev.warn("can-view-live: forcing a comment range for ", rangeName, el);
				start = el.ownerDocument.createComment( rangeName );
				el.parentNode.replaceChild( start, el );
			}

			if(!end) {
				end = el.ownerDocument.createComment( "/" + rangeName );
				start.parentNode.insertBefore(end, start.nextSibling);
			}

			return {start: start, end: end};
		},
		remove: function ( range ) {
			// TODO: Ideally this would be able to remove from the end, but
			// dispatch in the right order.
			// For now, we might want to remove nodes in the right order.
			var parentNode = range.start.parentNode,
				cur = range.end.previousSibling,
				remove;
			while(cur && cur !== range.start) {
				remove = cur;
				cur = cur.previousSibling;
				domMutateNode.removeChild.call(parentNode, remove );
			}

			domMutate.flushRecords();
		},

		update: function ( range, frag ) {
			var parentNode = range.start.parentNode;
			if(parentNode) {
				domMutateNode.insertBefore.call(parentNode, frag, range.end);
				// this makes it so `connected` events will be called immediately
				domMutate.flushRecords();
			}
		}
	},
	ListenUntilRemovedAndInitialize: ListenUntilRemovedAndInitialize,
	getAttributeParts: function(newVal) {
		var attrs = {},
			attr;
		parser.parseAttrs(newVal, {
			attrStart: function(name) {
				attrs[name] = "";
				attr = name;
			},
			attrValue: function(value) {
				attrs[attr] += value;
			},
			attrEnd: function() {}
		});
		return attrs;
	},
	// #### addTextNodeIfNoChildren
	// Append an empty text node to a parent with no children;
	//  do nothing if the parent already has children.
	addTextNodeIfNoChildren: function(frag) {
		if (!frag.firstChild) {
			frag.appendChild(frag.ownerDocument.createTextNode(""));
		}
	},
	// #### makeString
	// any -> string converter (including nullish)
	makeString: function(txt) {
		return txt == null ? "" : "" + txt;
	}
};


/***/ }),

/***/ "./node_modules/can-view-live/lib/html.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var makeFragment = __webpack_require__(/*! can-fragment */ "./node_modules/can-fragment/can-fragment.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/can-view-live/lib/helpers.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");

var viewInsertSymbol = canSymbol.for("can.viewInsert");

function makeCommentFragment(comment) {
		var doc = getDocument();
		return makeFragment([
			doc.createComment(comment),
			doc.createComment("can-end-placeholder")
		]);
}

/**
 * @function can-view-live.html html
 * @parent can-view-live
 * @release 2.0.4
 *
 * Live binds a compute's value to a collection of elements.
 *
 * @signature `live.html(el, compute, [parentNode])`
 *
 * `live.html` is used to setup incremental live-binding on a block of html.
 *
 * ```js
 * // a compute that changes its list
 * var greeting = compute(function(){
 *   return "Welcome <i>"+me.attr("name")+"</i>"
 * });
 *
 * var placeholder = document.createTextNode(" ");
 * $("#greeting").append(placeholder);
 *
 * live.html(placeholder, greeting);
 * ```
 *
 * @param {HTMLElement} el An html element to replace with the live-section.
 *
 * @param {can.compute} compute A [can.compute] whose value is HTML.
 *
 * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is
 * a documentFragment.
 *
 *
 */
module.exports = function(el, compute, viewInsertSymbolOptions) {

	var observableName = "";
	var updateRange = helpers.range.update;

	//!steal-remove-start
	if(true) {
		// register that the handler changes the parent element
		updateRange = helpers.range.update.bind(null);
		observableName = canReflect.getName(compute);
		Object.defineProperty(updateRange, "name", {
			value: "live.html update::"+observableName,
		});
	}
	//!steal-remove-end

	if (el.nodeType !== Node.COMMENT_NODE) {
		var commentFrag = makeCommentFragment(observableName);
		var startCommentNode = commentFrag.firstChild;
		el.parentNode.replaceChild(commentFrag, el);
		el = startCommentNode;
	}

	// replace element with a comment node
	var range = helpers.range.create(el, observableName);

	var useQueue = false;
	new helpers.ListenUntilRemovedAndInitialize(compute,
		function canViewLive_updateHTML(val) {

			// If val has the can.viewInsert symbol, call it and get something usable for val back
			if (val && typeof val[viewInsertSymbol] === "function") {
				val = val[viewInsertSymbol](viewInsertSymbolOptions);
			}

			var isFunction = typeof val === "function";

			// translate val into a document fragment if it's DOM-like
			var frag = isFunction ?
				makeCommentFragment(observableName) :
				makeFragment(val);

			if(isFunction) {
				val(frag.firstChild);
			}

			if(useQueue === true) {
				helpers.range.remove(range);
				updateRange(range, frag);
			} else {
				helpers.range.update(range, frag);
				useQueue = true;
			}
		},
		range.start,
		"dom",
		"live.html replace::" + observableName);

};


/***/ }),

/***/ "./node_modules/can-view-live/lib/list.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/list.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var frag = __webpack_require__(/*! can-fragment */ "./node_modules/can-fragment/can-fragment.js");
var domMutate = __webpack_require__(/*! can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var queues = __webpack_require__(/*! can-queues */ "./node_modules/can-queues/can-queues.js");

var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");

var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");

var Patcher = __webpack_require__(/*! can-diff/patcher/patcher */ "./node_modules/can-diff/patcher/patcher.js");
var patchSort = __webpack_require__(/*! can-diff/patch-sort/patch-sort */ "./node_modules/can-diff/patch-sort/patch-sort.js");

var SetObservable = __webpack_require__(/*! ./set-observable */ "./node_modules/can-view-live/lib/set-observable.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/can-view-live/lib/helpers.js");

var splice = [].splice;

// #### renderAndAddRangeNode
// a helper function that renders something and adds its nodeLists to newNodeLists
// in the right way for stache.
var renderAndAddRangeNode = function(render, context, args, document) {
		// call the renderer, passing in the new nodeList as the last argument
		var itemHTML = render.apply(context, args.concat()),
			// and put the output into a document fragment
			itemFrag = frag(itemHTML);

		var rangeNode = document.createTextNode("");
		itemFrag.appendChild(rangeNode);
		return itemFrag;
	};


function getFrag(first, last){
	var frag = first.ownerDocument.createDocumentFragment();
	var current,
		lastInserted;
	// hopefully this doesn't dispatch removed?
	while(last !== first) {
		current = last;
		last = current.previousSibling;
		frag.insertBefore(current, lastInserted);
		lastInserted = current;
	}
	frag.insertBefore(last, lastInserted);
	return frag;
}

var onPatchesSymbol = canSymbol.for("can.onPatches");
var offPatchesSymbol = canSymbol.for("can.offPatches");

function ListDOMPatcher(el, compute, render, context, falseyRender) {
	this.patcher = new Patcher(compute);
	var observableName = canReflect.getName(compute);

	// argument cleanup

	// function callback binding

	// argument saving -----
	this.value = compute;
	this.render = render;
	this.context = context;
	this.falseyRender = falseyRender;
	this.range = helpers.range.create(el, observableName);

	// A mapping of indices to observables holding that index.
	this.indexMap = [];
	// A mapping of each item's end node
	this.itemEndNode = [];

	// A mapping of each item to its pending patches.
	this.domQueue = [];

	this.isValueLike = canReflect.isValueLike(this.value);
	this.isObservableLike = canReflect.isObservableLike(this.value);

	// Setup binding and teardown to add and remove events
	this.onPatches = this.onPatches.bind(this);
	this.processDomQueue = this.processDomQueue.bind(this);
	this.teardownValueBinding = this.teardownValueBinding.bind(this);

	this.meta = {reasonLog: "live.html add::"+observableName, element: this.range.start};

	//!steal-remove-start
	if(true) {
		Object.defineProperty(this.onPatches, "name", {
			value: "live.list update::"+canReflect.getName(compute),
		});
	}
	//!steal-remove-end

	this.setupValueBinding();
}

var onPatchesSymbol = canSymbol.for("can.onPatches");
var offPatchesSymbol = canSymbol.for("can.offPatches");

ListDOMPatcher.prototype = {
	setupValueBinding: function() {
		// Teardown when the placeholder element is removed.
		this.teardownNodeRemoved = domMutate.onNodeRemoved(this.range.start, this.teardownValueBinding);

		// Listen to when the patcher produces patches.
		this.patcher[onPatchesSymbol](this.onPatches, "notify");

		// Initialize with the patcher's value
		if (this.patcher.currentList && this.patcher.currentList.length) {
			this.add(this.patcher.currentList, 0);
		} else {
			this.addFalseyIfEmpty();
		}
		//!steal-remove-start
		if(true) {
			canReflectDeps.addMutatedBy(this.range.start, this.patcher.observableOrList);
		}
		//!steal-remove-end
	},
	teardownValueBinding: function() {

		this.exit = true;
		// Stop listening for teardowns
		this.teardownNodeRemoved();
		this.patcher[offPatchesSymbol](this.onPatches, "notify");
		// Todo: I bet this is no longer necessary?
		//this.remove({
		//	length: this.patcher.currentList ? this.patcher.currentList.length : 0
		//}, 0, true);
		//!steal-remove-start
		if(true) {
			canReflectDeps.deleteMutatedBy(this.range.start, this.patcher.observableOrList);
		}
		//!steal-remove-end
	},
	onPatches: function ListDOMPatcher_onPatches(patches) {
		if (this.exit) {
			return;
		}
		var sortedPatches = [];
		patches.forEach(function(patch) {
			sortedPatches.push.apply(sortedPatches, patchSort([patch]));
		});
		// adjust so things can happen
		for (var i = 0, patchLen = sortedPatches.length; i < patchLen; i++) {
			var patch = sortedPatches[i];
			if (patch.type === "move") {
				this.addToDomQueue(
					this.move,
					[patch.toIndex, patch.fromIndex]
				);
			} else {
				if (patch.deleteCount) {
					// Remove any items scheduled for deletion from the patch.
					this.addToDomQueue(this.remove, [{
						length: patch.deleteCount
					}, patch.index]);
				}
				if (patch.insert && patch.insert.length) {
					// Insert any new items at the index
					this.addToDomQueue(this.add, [patch.insert, patch.index]);
				}
			}

		}
	},
	addToDomQueue: function(fn, args) {
		this.domQueue.push({
			fn: fn,
			args: args
		});
		queues.domQueue.enqueue(this.processDomQueue, this, [this.domQueue], this.meta);
	},
	processDomQueue: function() {
		this.domQueue.forEach(function(queueItem) {
			var fn = queueItem.fn;
			var args = queueItem.args;
			fn.apply(this, args);
		}.bind(this));
		this.domQueue = [];
	},
	add: function(items, index) {
		//if (!afterPreviousEvents) {
		//	return;
		//}
		// Collect new html and mappings
		var ownerDocument = this.range.start.ownerDocument,
			frag = ownerDocument.createDocumentFragment(),
			newEndNodes = [],
			newIndicies = [],
			render = this.render,
			context = this.context;
		// For each new item,
		items.forEach( function(item, key) {

			var itemIndex = new SimpleObservable(key + index),
				itemCompute = new SetObservable(item, function(newVal) {
					canReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal );
				}.bind(this)),
				itemFrag = renderAndAddRangeNode(render, context, [itemCompute, itemIndex], ownerDocument);

			newEndNodes.push(itemFrag.lastChild);
			// Hookup the fragment (which sets up child live-bindings) and
			// add it to the collection of all added elements.
			frag.appendChild(itemFrag);
			// track indicies;
			newIndicies.push(itemIndex);
		}, this);
		// The position of elements is always after the initial text placeholder node

		// TODO: this should probably happen earlier.
		// remove falsey if there's something there
		if (!this.indexMap.length) {
			// remove all leftover things
			helpers.range.remove(this.range);
			this.itemEndNode = [];
		}
		// figure out where we are placing things.
		var placeholder,
			endNodesLength = this.itemEndNode.length;
		if(index === endNodesLength ) {
			placeholder = this.range.end;
		} else if(index === 0) {
			placeholder = this.range.start.nextSibling;
		} else if(index < endNodesLength) {
			placeholder = this.itemEndNode[index - 1].nextSibling;
		} else {
			throw new Error("Unable to place item");
		}

		domMutateNode.insertBefore.call(placeholder.parentNode,frag,placeholder);

		splice.apply(this.itemEndNode, [
			index,
			0
		].concat(newEndNodes));

		// update indices after insert point
		splice.apply(this.indexMap, [
			index,
			0
		].concat(newIndicies));

		for (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {
			this.indexMap[i].set(i);
		}
	},
	remove: function(items, index) {
		//if (!afterPreviousEvents) {
		//	return;
		//}

		// If this is because an element was removed, we should
		// check to make sure the live elements are still in the page.
		// If we did this during a teardown, it would cause an infinite loop.
		//if (!duringTeardown && this.data.teardownCheck(this.placeholder.parentNode)) {
		//	return;
		//}
		if (index < 0) {
			index = this.indexMap.length + index;
		}
		var removeStart;
		var removeEnd;
		var removeCount = items.length;
		var endIndex = index + removeCount - 1;
		if(index === 0) {
			removeStart = this.range.start;
		} else {
			removeStart = this.itemEndNode[index - 1];
		}
		removeEnd = this.itemEndNode[endIndex].nextSibling;

		this.itemEndNode.splice(index, items.length);

		if (removeStart && removeEnd) {
			helpers.range.remove({start: removeStart, end: removeEnd});
		}

		var indexMap = this.indexMap;

		// update indices after remove point
		indexMap.splice(index, items.length);
		for (var i = index, len = indexMap.length; i < len; i++) {
			indexMap[i].set(i);
		}

		// don't remove elements during teardown.  Something else will probably be doing that.
		if (!this.exit) {
			// adds the falsey section if the list is empty
			this.addFalseyIfEmpty();
		} else {
			// This probably isn't needed anymore as element removal will be propagated
			// nodeLists.unregister(this.masterNodeList);
		}
	},
	// #### addFalseyIfEmpty
	// Add the results of redering the "falsey" or inverse case render to the
	// master nodeList and the DOM if the live list is empty
	addFalseyIfEmpty: function() {
		if (this.falseyRender && this.indexMap.length === 0) {
			// If there are no items ... we should render the falsey template
			var falseyFrag = renderAndAddRangeNode(this.falseyRender, this.currentList, [this.currentList], this.range.start.ownerDocument);
			helpers.range.update(this.range, falseyFrag);
		}
	},
	move: function move(newIndex, currentIndex) {
		//if (!afterPreviousEvents) {
		//	return;
		//}
		// The position of elements is always after the initial text
		// placeholder node


		var currentFirstNode,
			currentEndNode = this.itemEndNode[currentIndex];
		if( currentIndex > 0 ) {
			currentFirstNode = this.itemEndNode[currentIndex - 1].nextSibling;
		} else {
			currentFirstNode = this.range.start.nextSibling;
		}
		var newIndexFirstNode;
		if (currentIndex < newIndex) {
			// we need to advance one spot, because removing at
			// current index will shift everything left
			newIndexFirstNode = this.itemEndNode[newIndex].nextSibling;
		} else {
			if( newIndex > 0 ) {
				newIndexFirstNode = this.itemEndNode[newIndex - 1].nextSibling;
			} else {
				newIndexFirstNode = this.range.start.nextSibling;
			}
		}
		// need to put this at the newIndex



		var frag = getFrag(currentFirstNode, currentEndNode);
		newIndexFirstNode.parentNode.insertBefore(frag, newIndexFirstNode);

		// update endNodes
		this.itemEndNode.splice(currentIndex, 1);
		this.itemEndNode.splice(newIndex, 0,currentEndNode);


		// Update indexMap
		newIndex = newIndex + 1;
		currentIndex = currentIndex + 1;

		var indexMap = this.indexMap;

		// Convert back to a zero-based array index
		newIndex = newIndex - 1;
		currentIndex = currentIndex - 1;

		// Grab the index compute from the `indexMap`
		var indexCompute = indexMap[currentIndex];

		// Remove the index compute from the `indexMap`
		[].splice.apply(indexMap, [currentIndex, 1]);

		// Move the index compute to the correct index in the `indexMap`
		[].splice.apply(indexMap, [newIndex, 0, indexCompute]);

		var i = Math.min(currentIndex, newIndex);
		var len = indexMap.length;

		for (i, len; i < len; i++) {
			// set each compute to have its current index in the map as its value
			indexMap[i].set(i);
		}
	}
};



/**
 * @function can-view-live.list list
 * @parent can-view-live
 * @release 2.0.4
 *
 * @signature `live.list(el, list, render, context)`
 *
 * Live binds a compute's list incrementally.
 *
 * ```js
 * // a compute that change's it's list
 * var todos = compute(function(){
 *   return new Todo.List({page: can.route.attr("page")})
 * })
 *
 * var placeholder = document.createTextNode(" ");
 * $("ul#todos").append(placeholder);
 *
 * can.view.live.list(
 *   placeholder,
 *   todos,
 *   function(todo, index){
 *     return "<li>"+todo.attr("name")+"</li>"
 *   });
 * ```
 *
 * @param {HTMLElement} el An html element to replace with the live-section.
 *
 * @param {Object} list An observable value or list type. If an observable value, it should contain
 * a falsey value or a list type.
 *
 * @param {function(this:*,*,index):String} render(index, index) A function that when called with
 * the incremental item to render and the index of the item in the list.
 *
 * @param {Object} context The `this` the `render` function will be called with.
 *
 * @body
 *
 * ## How it works
 *
 * If `list` is an observable value, `live.list` listens to changes in in that
 * observable value.  It will generally change from one list type (often a list type that implements `onPatches`)
 * to another.  When the value changes, a diff will be performed and the DOM updated.  Also, `live.list`
 * will listen to `.onPatches` on the new list and apply any patches emitted from it.
 *
 *
 */
module.exports = function(el, list, render, context, falseyRender) {
	new ListDOMPatcher(el, list, render, context, falseyRender);
};


/***/ }),

/***/ "./node_modules/can-view-live/lib/set-observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-view-live/lib/set-observable.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

function SetObservable(initialValue, setter) {
	this.setter = setter;

	SimpleObservable.call(this, initialValue);
}

SetObservable.prototype = Object.create(SimpleObservable.prototype);
SetObservable.prototype.constructor = SetObservable;
SetObservable.prototype.set = function(newVal) {
	this.setter(newVal);
};


canReflect.assignSymbols(SetObservable.prototype, {
	"can.setValue": SetObservable.prototype.set
});

module.exports = SetObservable;


/***/ }),

/***/ "./node_modules/can-view-live/lib/text.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/text.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/can-view-live/lib/helpers.js");

/**
 * @function can-view-live.text text
 * @parent can-view-live
 * @release 2.0.4
 *
 * @signature `live.text(el, compute)`
 *
 * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.
 */
module.exports = function(el, compute) {
	var handlerName = "";

	//!steal-remove-start
	if(true) {
		if(arguments.length > 2) {
			// TODO: remove
			throw new Error("too many arguments");

		}
		handlerName = "live.text update::"+canReflect.getName(compute);
	}
	//!steal-remove-end

	// TODO: we can remove this at some point
	if (el.nodeType !== Node.TEXT_NODE) {
		var textNode;

		textNode = document.createTextNode("");
		el.parentNode.replaceChild(textNode, el);
		el = textNode;

	}

	new helpers.ListenUntilRemovedAndInitialize(compute, function liveTextUpdateTextNode(newVal) {
		el.nodeValue = helpers.makeString(newVal);
	},
	el,
	"dom", // TODO: should this still be domUI?
	handlerName);
};


/***/ }),

/***/ "./node_modules/can-view-model/can-view-model.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-model/can-view-model.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var SimpleMap = __webpack_require__(/*! can-simple-map */ "./node_modules/can-simple-map/can-simple-map.js");
var ns = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");

var viewModelSymbol = canSymbol.for('can.viewModel');

module.exports = ns.viewModel = function (el, attr, val) {
	if (typeof el === "string") {
		el = getDocument().querySelector(el);
	} else if (canReflect.isListLike(el) && !el.nodeType) {
		el = el[0];
	}

	if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
		el[viewModelSymbol] = attr;
		return;
	}

	var scope = el[viewModelSymbol];
	if(!scope) {
		scope = new SimpleMap();
		el[viewModelSymbol] = scope;
	}
	switch (arguments.length) {
		case 0:
		case 1:
			return scope;
		case 2:
			return canReflect.getKeyValue(scope, attr);
		default:
			canReflect.setKeyValue(scope, attr, val);
			return el;
	}
};


/***/ }),

/***/ "./node_modules/can-view-parser/can-view-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-parser/can-view-parser.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint maxdepth:7,node:true, latedef:false */
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js"),
	dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js"),
	encoder = __webpack_require__(/*! can-attribute-encoder */ "./node_modules/can-attribute-encoder/can-attribute-encoder.js");

function each(items, callback){
	for ( var i = 0; i < items.length; i++ ) {
		callback(items[i], i);
	}
}

function makeMap(str){
	var obj = {}, items = str.split(",");
	each(items, function(name){
		obj[name] = true;
	});
	return obj;
}

function handleIntermediate(intermediate, handler){
	for(var i = 0, len = intermediate.length; i < len; i++) {
		var item = intermediate[i];
		handler[item.tokenType].apply(handler, item.args);
	}
	return intermediate;
}

//!steal-remove-start
if (true) {
	//assign the function to a var to avoid jshint
	//"Function declarations should not be placed in blocks"
	var countLines = function countLines(input) {
		// TODO: optimize?
		return input.split('\n').length - 1;
	};
}
//!steal-remove-end

var alphaNumeric = "A-Za-z0-9",
	alphaNumericHU = "-:_"+alphaNumeric,
	magicStart = "{{",
	endTag = new RegExp("^<\\/(["+alphaNumericHU+"]+)[^>]*>"),
	magicMatch = new RegExp("\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?","g"),
	space = /\s/,
	alphaRegex = new RegExp('['+ alphaNumeric + ']'),
	attributeRegexp = new RegExp("["+alphaNumericHU+"]+\s*=\s*(\"[^\"]*\"|'[^']*')");

// Empty Elements - HTML 5
var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");

// Elements for which tag case matters - shouldn't be lowercased.
var caseMattersElements = makeMap("altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath");

// Elements that you can, intentionally, leave open
// (and which close themselves)
var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

// Special Elements (can contain anything)
var special = makeMap("script");

// Callback names on `handler`.
var tokenTypes = "start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done".split(",");

//maps end characters to start characters
var startOppositesMap = {"{": "}", "(":")"};

var fn = function(){};

var HTMLParser = function (html, handler, returnIntermediate) {
	if(typeof html === "object") {
		return handleIntermediate(html, handler);
	}

	var intermediate = [];
	handler = handler || {};
	if(returnIntermediate) {
		// overwrite handlers so they add to intermediate
		each(tokenTypes, function(name){
			var callback = handler[name] || fn;
			handler[name] = function(){
				if( callback.apply(this, arguments) !== false ) {
					var end = arguments.length;

					// the intermediate is stringified in the compiled stache templates
					// so we want to trim the last item if it is the line number
					if (arguments[end - 1] === undefined) {
						end = arguments.length - 1;
					}

					//!steal-remove-start
					if (true) {
						// but restore line number in dev mode
						end = arguments.length;
					}
					//!steal-remove-end

					intermediate.push({
						tokenType: name,
						args: [].slice.call(arguments, 0, end),
					});
				}
			};
		});
	}

	function parseStartTag(tag, tagName, rest, unary) {
		tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();

		if (closeSelf[tagName] && stack.last() === tagName) {
			parseEndTag("", tagName);
		}

		unary = empty[tagName] || !!unary;
		handler.start(tagName, unary, lineNo);
		if (!unary) {
			stack.push(tagName);
		}

		// find attribute or special
		HTMLParser.parseAttrs(rest, handler, lineNo);

		//!steal-remove-start
		if (true) {
			lineNo += countLines(tag);
		}
		//!steal-remove-end


		handler.end(tagName, unary, lineNo);

		if(tagName === "html") {
			skipChars = true;
		}
	}

	function parseEndTag(tag, tagName) {
		// If no tag name is provided, clean shop
		var pos;
		if (!tagName) {
			pos = 0;
		}
		// Find the closest opened tag of the same type
		else {
			tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
			for (pos = stack.length - 1; pos >= 0; pos--) {
				if (stack[pos] === tagName) {
					break;
				}
			}
		}

		//!steal-remove-start
		if (true) {
			if (typeof tag === 'undefined') {
				if (stack.length > 0) {
					if (handler.filename) {
						dev.warn(handler.filename + ": expected closing tag </" + stack[pos] + ">");
					}
					else {
						dev.warn("expected closing tag </" + stack[pos] + ">");
					}
				}
			} else if (pos < 0 || pos !== stack.length - 1) {
				if (stack.length > 0) {
					if (handler.filename) {
						dev.warn(handler.filename + ":" + lineNo + ": unexpected closing tag " + tag + " expected </" + stack[stack.length - 1] + ">");
					}
					else {
						dev.warn(lineNo + ": unexpected closing tag " + tag + " expected </" + stack[stack.length - 1] + ">");
					}
				} else {
					if (handler.filename) {
						dev.warn(handler.filename + ":" + lineNo + ": unexpected closing tag " + tag);
					}
					else {
						dev.warn(lineNo + ": unexpected closing tag " + tag);
					}
				}
			}
		}
		//!steal-remove-end

		if (pos >= 0) {
			// Close all the open elements, up the stack
			for (var i = stack.length - 1; i >= pos; i--) {
				if (handler.close) {
					handler.close(stack[i], lineNo);
				}
			}

			// Remove the open elements from the stack
			stack.length = pos;

			// Don't add TextNodes after the <body> tag
			if(tagName === "body") {
				skipChars = true;
			}
		}
	}

	function parseMustache(mustache, inside){
		if(handler.special){
			handler.special(inside, lineNo);
		}
	}

	var callChars = function(){
		if(charsText && !skipChars) {
			if(handler.chars) {
				handler.chars(charsText, lineNo);
			}

			//!steal-remove-start
			if (true) {
				lineNo += countLines(charsText);
			}
			//!steal-remove-end
		}

		skipChars = false;
		charsText = "";
	};

	var index,
		chars,
		skipChars,
		match,
		lineNo,
		stack = [],
		last = html,
		// an accumulating text for the next .chars callback
		charsText = "";

	//!steal-remove-start
	if (true) {
		lineNo = 1;
	}
	//!steal-remove-end

	stack.last = function () {
		return this[this.length - 1];
	};

	while (html) {

		chars = true;

		// Make sure we're not in a script or style element
		if (!stack.last() || !special[stack.last()]) {

			// Comment
			if (html.indexOf("<!--") === 0) {
				index = html.indexOf("-->");

				if (index >= 0) {
					callChars();
					if (handler.comment) {
						handler.comment(html.substring(4, index), lineNo);
					}

					//!steal-remove-start
					if (true) {
						lineNo += countLines(html.substring(0, index + 3));
					}
					//!steal-remove-end

					html = html.substring(index + 3);
					chars = false;
				}

				// end tag
			} else if (html.indexOf("</") === 0) {
				match = html.match(endTag);

				if (match) {
					callChars();
					match[0].replace(endTag, parseEndTag);

					//!steal-remove-start
					if (true) {
						lineNo += countLines(html.substring(0, match[0].length));
					}
					//!steal-remove-end

					html = html.substring(match[0].length);
					chars = false;
				}

				// start tag
			} else if (html.indexOf("<") === 0) {
				var res = HTMLParser.searchStartTag(html);

				if(res) {
					callChars();
					parseStartTag.apply(null, res.match);

					html = res.html;
					chars = false;
				}

				// magic tag
			} else if (html.indexOf(magicStart) === 0 ) {
				match = html.match(magicMatch);

				if (match) {
					callChars();
					match[0].replace(magicMatch, parseMustache);

					//!steal-remove-start
					if (true) {
						lineNo += countLines(html.substring(0, match[0].length));
					}
					//!steal-remove-end

					html = html.substring(match[0].length);
				}
			}

			if (chars) {
				index = findBreak(html, magicStart);
				if(index === 0 && html === last) {
					charsText += html.charAt(0);
					html = html.substr(1);
					index = findBreak(html, magicStart);
				}

				var text = index < 0 ? html : html.substring(0, index);
				html = index < 0 ? "" : html.substring(index);

				if (text) {
					charsText += text;
				}
			}

		} else {
			html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
				text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
				if (handler.chars) {
					handler.chars(text, lineNo);
				}

				//!steal-remove-start
				if (true) {
					lineNo += countLines(text);
				}
				//!steal-remove-end

				return "";
			});

			parseEndTag("", stack.last());
		}

		if (html === last) {
			throw new Error("Parse Error: " + html);
		}

		last = html;
	}
	callChars();
	// Clean up any remaining tags
	parseEndTag();


	handler.done(lineNo);
	return intermediate;
};

var callAttrStart = function(state, curIndex, handler, rest, lineNo){
	var attrName = rest.substring(typeof state.nameStart === "number" ? state.nameStart : curIndex, curIndex),
		newAttrName = encoder.encode(attrName);

	state.attrStart = newAttrName;
	handler.attrStart(state.attrStart, lineNo);
	state.inName = false;
};

var callAttrEnd = function(state, curIndex, handler, rest, lineNo){
	if(state.valueStart !== undefined && state.valueStart < curIndex) {
		var val = rest.substring(state.valueStart, curIndex);
		//!steal-remove-start
		if (true) {
			var quotedVal, closedQuote;
			quotedVal = rest.substring(state.valueStart - 1, curIndex + 1);
			quotedVal = quotedVal.trim();
			closedQuote = quotedVal.charAt(quotedVal.length - 1);

			if (state.inQuote !== closedQuote) {
				if (handler.filename) {
					dev.warn(handler.filename + ":" + lineNo + ": End quote is missing for " + val);
				} else {
					dev.warn(lineNo + ": End quote is missing for " + val);
				}
			}
		}
		//!steal-remove-end
		handler.attrValue(val, lineNo);
	}
	// if this never got to be inValue, like `DISABLED` then send a attrValue
	// else if(!state.inValue){
	// 	handler.attrValue(state.attrStart, lineNo);
	// }

	handler.attrEnd(state.attrStart, lineNo);
	state.attrStart = undefined;
	state.valueStart = undefined;
	state.inValue = false;
	state.inName = false;
	state.lookingForEq = false;
	state.inQuote = false;
	state.lookingForName = true;
};

var findBreak = function(str, magicStart) {
	var magicLength = magicStart.length;
	for(var i = 0, len = str.length; i < len; i++) {
		if(str[i] === "<" || str.substr(i, magicLength) === magicStart) {
			return i;
		}
	}
	return -1;
};

HTMLParser.parseAttrs = function(rest, handler, lineNo){
	if(!rest) {
		return;
	}

	var i = 0;
	var curIndex;
	var state = {
		inName: false,
		nameStart: undefined,
		inValue: false,
		valueStart: undefined,
		inQuote: false,
		attrStart: undefined,
		lookingForName: true,
		lookingForValue: false,
		lookingForEq : false
	};

	while(i < rest.length) {
		curIndex = i;
		var cur = rest.charAt(i);
		i++;

		if(magicStart === rest.substr(curIndex, magicStart.length) ) {
			if(state.inValue && curIndex > state.valueStart) {
				handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
			}
			// `{{#foo}}DISABLED{{/foo}}`
			else if(state.inName && state.nameStart < curIndex) {
				callAttrStart(state, curIndex, handler, rest, lineNo);
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
			// foo={{bar}}
			else if(state.lookingForValue){
				state.inValue = true;
			}
			// a {{bar}}
			else if(state.lookingForEq && state.attrStart) {
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}

			magicMatch.lastIndex = curIndex;
			var match = magicMatch.exec(rest);
			if(match) {
				handler.special(match[1], lineNo);
				// i is already incremented
				i = curIndex + (match[0].length);
				if(state.inValue) {
					state.valueStart = curIndex+match[0].length;
				}
			}
		}
		else if(state.inValue) {
			if(state.inQuote) {
				if(cur === state.inQuote) {
					callAttrEnd(state, curIndex, handler, rest, lineNo);
				}
			}
			else if(space.test(cur)) {
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
		}
		// if we hit an = outside a value
		else if(cur === "=" && (state.lookingForEq || state.lookingForName || state.inName)) {
			// if we haven't yet started this attribute `{{}}=foo` case:
			if(!state.attrStart) {
				callAttrStart(state, curIndex, handler, rest, lineNo);
			}
			state.lookingForValue = true;
			state.lookingForEq = false;
			state.lookingForName = false;
		}
		// if we are currently in a name:
		//  when the name starts with `{` or `(`
		//  it isn't finished until the matching end character is found
		//  otherwise, a space finishes the name
		else if(state.inName) {
			var started = rest[ state.nameStart ],
					otherStart, otherOpposite;
			if(startOppositesMap[started] === cur) {
				//handle mismatched brackets: `{(})` or `({)}`
				otherStart = started === "{" ? "(" : "{";
				otherOpposite = startOppositesMap[otherStart];

				if(rest[curIndex+1] === otherOpposite){
					callAttrStart(state, curIndex+2, handler, rest, lineNo);
					i++;
				}else{
					callAttrStart(state, curIndex+1, handler, rest, lineNo);
				}

				state.lookingForEq = true;
			}
			else if(space.test(cur) && started !== "{" && started !== "(") {
					callAttrStart(state, curIndex, handler, rest, lineNo);
					state.lookingForEq = true;
			}
		}
		else if(state.lookingForName) {
			if(!space.test(cur)) {
				// might have just started a name, we need to close it
				if(state.attrStart) {
					callAttrEnd(state, curIndex, handler, rest, lineNo);
				}
				state.nameStart = curIndex;
				state.inName = true;
			}
		}
		else if(state.lookingForValue) {
			if(!space.test(cur)) {
				state.lookingForValue = false;
				state.inValue = true;
				if(cur === "'" || cur === '"') {
					state.inQuote = cur;
					state.valueStart = curIndex+1;
				} else {
					state.valueStart = curIndex;
				}
				// if we are looking for a value
				// at the end of the loop we need callAttrEnd
			} else if (i === rest.length){
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
		}
	}

	if(state.inName) {
		callAttrStart(state, curIndex+1, handler, rest, lineNo);
		callAttrEnd(state, curIndex+1, handler, rest, lineNo);
	} else if(state.lookingForEq || state.lookingForValue || state.inValue) {
		callAttrEnd(state, curIndex+1, handler, rest, lineNo);
	}
	magicMatch.lastIndex = 0;
};

HTMLParser.searchStartTag = function (html) {
	var closingIndex = html.indexOf('>');

	// The first closing bracket we find might be in an attribute value.
	// Move through the attributes by regexp.
	var attributeRange = attributeRegexp.exec(html.substring(1));
	var afterAttributeOffset = 1;
	// if the closing index is after the next attribute...
	while(attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {

		// prepare to move to the attribute after this one by increasing the offset
		afterAttributeOffset += attributeRange.index + attributeRange[0].length;
		// if the closing index is before the new offset, then this closing index is inside
		//  an attribute value and should be ignored.  Find the *next* closing character.
		while(closingIndex < afterAttributeOffset) {
			closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
		}

		// find the next attribute by starting from the new offset.
		attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
	}

	// if there is no closing bracket
	// <input class=
	// or if the tagName does not start with alphaNumer character
	// <_iaois>
	// it is not a startTag
	if(closingIndex === -1 || !(alphaRegex.test(html[1]))){
		return null;
	}

	var tagName, tagContent, match, rest = '', unary = '';
	var startTag = html.substring(0, closingIndex + 1);
	var isUnary = startTag[startTag.length-2] === '/';
	var spaceIndex = startTag.search(space);

	if(isUnary){
		unary = '/';
		tagContent = startTag.substring(1, startTag.length-2).trim();
	} else {
		tagContent = startTag.substring(1, startTag.length-1).trim();
	}

	if(spaceIndex === -1){
		tagName = tagContent;
	} else {
		//spaceIndex needs to shift one to the left
		spaceIndex--;
		tagName = tagContent.substring(0, spaceIndex);
		rest = tagContent.substring(spaceIndex);
	}

	match = [startTag, tagName, rest, unary];

	return {
		match: match,
		html: html.substring(startTag.length),
	};


};

module.exports = namespace.HTMLParser = HTMLParser;


/***/ }),

/***/ "./node_modules/can-view-scope/can-view-scope.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-scope/can-view-scope.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// # can-view-scope.js
//
// This provides the ability to lookup values across a higherarchy of objects.  This is similar to
// how closures work in JavaScript.
//
// This is done with the `Scope` type. It works by having a `_context` reference to
// an object whose properties can be searched for values.  It also has a `_parent` reference
// to the next Scope in which to check.  In this way, `Scope` is used to form a tree-like
// structure.  Leaves and Nodes in the tree only point to their parent.
var stacheKey = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var TemplateContext = __webpack_require__(/*! ./template-context */ "./node_modules/can-view-scope/template-context.js");
var makeComputeData = __webpack_require__(/*! ./compute_data */ "./node_modules/can-view-scope/compute_data.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canLog = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");
var defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");
var stacheHelpers = __webpack_require__(/*! can-stache-helpers */ "./node_modules/can-stache-helpers/can-stache-helpers.js");
var LetContext = __webpack_require__(/*! ./let-context */ "./node_modules/can-view-scope/let-context.js");


// ## Helpers

function canHaveProperties(obj){
	return obj != null;
}
function returnFalse(){
	return false;
}

// ## Scope
// Represents a node in the scope tree.
function Scope(context, parent, meta) {
	// The object that will be looked on for values.
	// If the type of context is TemplateContext, there will be special rules for it.
	this._context = context;
	// The next Scope object whose context should be looked on for values.
	this._parent = parent;
	// If this is a special context, it can be labeled here.
	// Options are:
	// - `viewModel` - This is a viewModel. This is mostly used by can-component to make `scope.vm` work.
	// - `notContext` - This can't be looked within using `./` and `../`. It will be skipped.
	//   This is for virtual contexts like those used by `%index`. This is very much like
	//   `variable`.  Most things should switch to `variable` in the future.
	// - `special` - This can't be looked within using `./` and `../`. It will be skipped.
	//   This is for reading properties on the scope {{scope.index}}. It's different from variable
	//   because it's never lookup up like {{key}}.
	// - `variable` - This is used to define a variable (as opposed to "normal" context). These
	//   will also be skipped when using `./` and `../`.
	this._meta = meta || {};

	// A cache that can be used to store computes used to look up within this scope.
	// For example if someone creates a compute to lookup `name`, another compute does not
	// need to be created.
	this.__cache = {};
}

var parentContextSearch = /(\.\.\/)|(\.\/)|(this[\.@])/g;

// ## Static Methods
// The following methods are exposed mostly for testing purposes.
assign(Scope, {
	// ### Scope.read
	// Scope.read was moved to can-stache-key.read
	// can-stache-key.read reads properties from a parent. A much more complex version of getObject.
	read: stacheKey.read,
	TemplateContext: TemplateContext,
	// ### keyInfo(key)
	// Returns an object that details what the `key` means with the following:
	// ```js
	// {
	//   remainingKey, // what would be read on a context (or this)
	//   isScope, // if the scope itself is being read
	//   inScope, // if a key on the scope is being read
	//   parentContextWalkCount, // how many ../
	//   isContextBased // if a "normal" context is explicitly being read
	// }
	// ```
	keyInfo: function(attr){

		if (attr === "./") {
			attr = "this";
		}

		var info = {remainingKey: attr};

		// handle scope stuff first
		info.isScope = attr === "scope";
		if(info.isScope) {
			return info;
		}
		var firstSix = attr.substr(0, 6);
		info.isInScope =
			firstSix === "scope." ||
			firstSix === "scope@";
		if(info.isInScope) {
			info.remainingKey = attr.substr(6);
			return info;
		} else if(firstSix === "scope/") {
			info.walkScope = true;
			info.remainingKey = attr.substr(6);
			return info;
		} else if(attr.substr(0, 7) === "@scope/") {
			info.walkScope = true;
			info.remainingKey = attr.substr(7);
			return info;
		}

		info.parentContextWalkCount = 0;
		// Searches for `../` and other context specifiers
		info.remainingKey = attr.replace(parentContextSearch, function(token, parentContext, dotSlash, thisContext, index){
			info.isContextBased = true;
			if(parentContext !== undefined) {
				info.parentContextWalkCount++;
			}
			return "";
		});
		// ../..
		if(info.remainingKey === "..") {
			info.parentContextWalkCount++;
			info.remainingKey = "this";
		}
		else if(info.remainingKey === "." || info.remainingKey === "") {
			info.remainingKey = "this";
		}

		if(info.remainingKey === "this") {
			info.isContextBased = true;
		}
		return info;
	},
	// ### isTemplateContextOrCanNotHaveProperties
	// Returns `true` if a template context or a `null` or `undefined`
	// context.
	isTemplateContextOrCanNotHaveProperties: function(currentScope){
		var currentContext = currentScope._context;
		if(currentContext instanceof TemplateContext) {
			return true;
		} else if( !canHaveProperties(currentContext) ) {
			return true;
		}
		return false;
	},
	// ### shouldSkipIfSpecial
	// Return `true` if special.
	shouldSkipIfSpecial: function(currentScope){
		var isSpecialContext = currentScope._meta.special === true;
		if (isSpecialContext === true) {
			return true;
		}
		if( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {
			return true;
		}
		return false;
	},
	// ### shouldSkipEverythingButSpecial
	// Return `true` if not special.
	shouldSkipEverythingButSpecial: function(currentScope){
		var isSpecialContext = currentScope._meta.special === true;
		if (isSpecialContext === false) {
			return true;
		}
		if( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {
			return true;
		}
		return false;
	},
	// ### makeShouldExitOnSecondNormalContext
	// This will keep checking until we hit a second "normal" context.
	makeShouldExitOnSecondNormalContext: function(){
		var foundNormalContext = false;
		return function shouldExitOnSecondNormalContext(currentScope){
			var isNormalContext = !currentScope.isSpecial();
			var shouldExit = isNormalContext && foundNormalContext;
			// leaks some state
			if(isNormalContext) {
				foundNormalContext = true;
			}
			return shouldExit;
		};
	},
	// ### makeShouldExitAfterFirstNormalContext
	// This will not check anything after the first normal context.
	makeShouldExitAfterFirstNormalContext: function(){
		var foundNormalContext = false;
		return function shouldExitAfterFirstNormalContext(currentScope){
			if(foundNormalContext) {
				return true;
			}
			var isNormalContext = !currentScope.isSpecial();
			// leaks some state
			if(isNormalContext) {
				foundNormalContext = true;
			}
			return false;
		};
	},
	// ### makeShouldSkipSpecialContexts
	// Skips `parentContextWalkCount` contexts. This is used to
	// walk past scopes when `../` is used.
	makeShouldSkipSpecialContexts: function(parentContextWalkCount){
		var walkCount = parentContextWalkCount || 0;
		return function shouldSkipSpecialContexts(currentScope){
			// after walking past the correct number of contexts,
			// should not skip notContext scopes
			// so that ../foo can be used to read from a notContext scope
			if (walkCount < 0 && currentScope._meta.notContext) {
				return false;
			}

			if(currentScope.isSpecial()) {
				return true;
			}
			walkCount--;

			if(walkCount < 0) {
				return false;
			}
			return true;
		};
	}
});

// ## Prototype methods
assign(Scope.prototype, {

	// ### scope.add
	// Creates a new scope and sets the current scope to be the parent.
	// ```
	// var scope = new can.view.Scope([
	//   {name:"Chris"},
	//   {name: "Justin"}
	// ]).add({name: "Brian"});
	// scope.attr("name") //-> "Brian"
	// ```
	add: function(context, meta) {
		if (context !== this._context) {
			return new this.constructor(context, this, meta);
		} else {
			return this;
		}
	},

	// ### scope.find
	// This is the equivalent of Can 3's scope walking.
	find: function(attr, options) {

		var keyReads = stacheKey.reads(attr);
		var howToRead = {
			shouldExit: returnFalse,
			shouldSkip: Scope.shouldSkipIfSpecial,
			shouldLookForHelper: true,
			read: stacheKey.read
		};
		var result = this._walk(keyReads, options, howToRead);

		return result.value;

	},
	// ### scope.readFromSpecialContext
	readFromSpecialContext: function(key) {
		return this._walk(
			[{key: key, at: false }],
			{ special: true },
			{
				shouldExit: returnFalse,
				shouldSkip: Scope.shouldSkipEverythingButSpecial,
				shouldLookForHelper: false,
				read: stacheKey.read
			}
		);
	},

	// ### scope.readFromTemplateContext
	readFromTemplateContext: function(key, readOptions) {
		var keyReads = stacheKey.reads(key);
		return stacheKey.read(this.templateContext, keyReads, readOptions);
	},

	// ### Scope.prototype.read
	// Reads from the scope chain and returns the first non-`undefined` value.
	// `read` deals mostly with setting up "context based" keys to start reading
	// from the right scope. Once the right scope is located, `_walk` is called.
	/**
	 * @hide
	 * @param {can.stache.key} attr A dot-separated path. Use `"\."` if you have a property name that includes a dot.
	 * @param {can.view.Scope.readOptions} options that configure how this gets read.
	 * @return {{}}
	 *   @option {Object} parent the value's immediate parent
	 *   @option {can.Map|can.compute} rootObserve the first observable to read from.
	 *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.
	 *   @option {*} value the found value
	 */
	read: function(attr, options) {
		options = options || {};
		return this.readKeyInfo(Scope.keyInfo(attr), options || {});
	},
	readKeyInfo: function(keyInfo, options){

		// Identify context based keys. Context based keys try to
		// specify a particular context a key should be within.
		var readValue,
			keyReads,
			howToRead = {
				read: options.read || stacheKey.read
			};

		// 1.A. Handle reading the scope itself
		if (keyInfo.isScope) {
			return { value: this };
		}
		// 1.B. Handle reading something on the scope
		else if (keyInfo.isInScope) {
			keyReads = stacheKey.reads(keyInfo.remainingKey);
			// check for a value on Scope.prototype
			readValue = stacheKey.read(this, keyReads, options);

			// otherwise, check the templateContext
			if (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {
				readValue = this.readFromTemplateContext(keyInfo.remainingKey, options);
			}

			return assign(readValue, {
				thisArg: keyReads.length > 0 ? readValue.parent : undefined
			});
		}
		// 1.C. Handle context-based reads. They should skip over special stuff.
		// this.key, ../.., .././foo
		else if (keyInfo.isContextBased) {
			// TODO: REMOVE
			// options && options.special === true && console.warn("SPECIAL!!!!");

			if(keyInfo.remainingKey !== "this") {
				keyReads = stacheKey.reads(keyInfo.remainingKey);
			} else {
				keyReads = [];
			}
			howToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();
			howToRead.shouldSkip = Scope.makeShouldSkipSpecialContexts(keyInfo.parentContextWalkCount);
			howToRead.shouldLookForHelper = true;

			return this._walk(keyReads, options, howToRead);
		}
		// 1.D. Handle scope walking with scope/key
		else if(keyInfo.walkScope) {
			howToRead.shouldExit = returnFalse;
			howToRead.shouldSkip = Scope.shouldSkipIfSpecial;
			howToRead.shouldLookForHelper = true;
			keyReads = stacheKey.reads(keyInfo.remainingKey);

			return this._walk(keyReads, options, howToRead);
		}
		// 1.E. Handle reading without context clues
		// {{foo}}
		else {
			keyReads = stacheKey.reads(keyInfo.remainingKey);

			var isSpecialRead = options && options.special === true;
			// TODO: remove
			// options && options.special === true && console.warn("SPECIAL!!!!");

			howToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();
			howToRead.shouldSkip = isSpecialRead ? Scope.shouldSkipEverythingButSpecial : Scope.shouldSkipIfSpecial;
			howToRead.shouldLookForHelper = isSpecialRead ? false : true;

			return this._walk(keyReads, options, howToRead);
		}
	},


	// ### scope._walk
	// This is used to walk up the scope chain.
	_walk: function(keyReads, options, howToRead) {
		// The current scope and context we are trying to find "keyReads" within.
		var currentScope = this,
			currentContext,

			// If no value can be found, this is a list of of every observed
			// object and property name to observe.
			undefinedObserves = [],

			// Tracks the first found observe.
			currentObserve,
			// Tracks the reads to get the value from `currentObserve`.
			currentReads,

			// Tracks the most likely observable to use as a setter.
			setObserveDepth = -1,
			currentSetReads,
			currentSetObserve,

			readOptions = assign({
				/* Store found observable, incase we want to set it as the rootObserve. */
				foundObservable: function(observe, nameIndex) {
					currentObserve = observe;
					currentReads = keyReads.slice(nameIndex);
				},
				earlyExit: function(parentValue, nameIndex) {
					var isVariableScope = currentScope._meta.variable === true,
						updateSetObservable = false;
					if(isVariableScope === true && nameIndex === 0) {
						// we MUST have pre-defined the key in a variable scope
						updateSetObservable = canReflect.hasKey( parentValue, keyReads[nameIndex].key);
					} else {
						updateSetObservable =
							// Has more matches
							nameIndex > setObserveDepth ||
							// The same number of matches but it has the key
							nameIndex === setObserveDepth && (typeof parentValue === "object" && canReflect.hasOwnKey( parentValue, keyReads[nameIndex].key));
					}
					if ( updateSetObservable ) {
						currentSetObserve = currentObserve;
						currentSetReads = currentReads;
						setObserveDepth = nameIndex;
					}
				}
			}, options);



		var isRecording = ObservationRecorder.isRecording(),
			readAContext = false;

		// Goes through each scope context provided until it finds the key (attr). Once the key is found
		// then it's value is returned along with an observe, the current scope and reads.
		// While going through each scope context searching for the key, each observable found is returned and
		// saved so that either the observable the key is found in can be returned, or in the case the key is not
		// found in an observable the closest observable can be returned.
		while (currentScope) {

			if(howToRead.shouldSkip(currentScope) === true) {
				currentScope = currentScope._parent;
				continue;
			}
			if(howToRead.shouldExit(currentScope) === true) {
				break;
			}
			readAContext = true;

			currentContext = currentScope._context;


			// Prevent computes from temporarily observing the reading of observables.
			var getObserves = ObservationRecorder.trap();

			var data = howToRead.read(currentContext, keyReads, readOptions);

			// Retrieve the observes that were read.
			var observes = getObserves();
			// If a **value was was found**, return value and location data.
			if (data.value !== undefined || data.parentHasKey) {

				if(!observes.length && isRecording) {
					// if we didn't actually observe anything
					// the reads and currentObserve don't mean anything
					// we just point to the current object so setting is fast
					currentObserve = data.parent;
					currentReads = keyReads.slice(keyReads.length - 1);
				} else {
					ObservationRecorder.addMany(observes);
				}

				return {
					scope: currentScope,
					rootObserve: currentObserve,
					value: data.value,
					reads: currentReads,
					thisArg: data.parent,
					parentHasKey: data.parentHasKey
				};
			}
			// Otherwise, save all observables that were read. If no value
			// is found, we will observe on all of them.
			else {
				undefinedObserves.push.apply(undefinedObserves, observes);
			}

			currentScope = currentScope._parent;
		}

		// The **value was not found** in the scope
		// if not looking for a "special" key, check in can-stache-helpers
		if (howToRead.shouldLookForHelper) {
			var helper = this.getHelperOrPartial(keyReads);

			if (helper && helper.value) {
				// Don't return parent so `.bind` is not used.
				return {value: helper.value};
			}
		}

		// The **value was not found**, return `undefined` for the value.
		// Make sure we listen to everything we checked for when the value becomes defined.
		// Once it becomes defined, we won't have to listen to so many things.
		ObservationRecorder.addMany(undefinedObserves);
		return {
			setRoot: currentSetObserve,
			reads: currentSetReads,
			value: undefined,
			noContextAvailable: !readAContext
		};
	},
	// ### scope.getDataForScopeSet
	// Returns an object with data needed by `.set` to figure out what to set,
	// and how.
	// {
	//   parent: what is being set
	//   key: try setting a key value
	//   how: "setValue" | "set" | "updateDeep" | "write" | "setKeyValue"
	// }
	// This works by changing how `readKeyInfo` will read individual scopes.
	// Specifically, with something like `{{foo.bar}}` it will read `{{foo}}` and
	// only check if a `bar` property exists.
	getDataForScopeSet: function getDataForScopeSet(key, options) {
		var keyInfo = Scope.keyInfo(key);
		var firstSearchedContext;

		// Overwrite the options to use this read.
		var opts = assign({
			// This read is used by `._walk` to read from the scope.
			// This will use `hasKey` on the last property instead of reading it.
			read: function(context, keys){

				// If nothing can be found with the keys we are looking for, save the
				// first possible match.  This is where we will write to.
				if(firstSearchedContext === undefined && !(context instanceof LetContext)) {
					firstSearchedContext = context;
				}
				// If we have multiple keys ...
				if(keys.length > 1) {
					// see if we can find the parent ...
					var parentKeys = keys.slice(0, keys.length-1);
					var parent = stacheKey.read(context, parentKeys, options).value;

					// If there is a parent, see if it has the last key
					if( parent != null && canReflect.hasKey(parent, keys[keys.length-1].key ) ) {
						return {
							parent: parent,
							parentHasKey: true,
							value: undefined
						};
					} else {
						return {};
					}
				}
				// If we have only one key, try to find a context with this key
				else if(keys.length === 1) {
					if( canReflect.hasKey(context, keys[0].key ) ) {
						return {
							parent: context,
							parentHasKey: true,
							value: undefined
						};
					} else {
						return {};
					}
				}
				// If we have no keys, we are reading `this`.
				else {
					return {
						value: context
					};
				}
			}
		},options);


		// Use the read above to figure out what we are probably writing to.
		var readData = this.readKeyInfo(keyInfo, opts);

		if(keyInfo.remainingKey === "this") {
			// If we are setting a context, then return that context
			return { parent: readData.value, how: "setValue" };
		}
		// Now we are trying to set a property on something.  Parent will
		// be the something we are setting a property on.
		var parent;

		var props = keyInfo.remainingKey.split(".");
		var propName = props.pop();

		// If we got a `thisArg`, that's the parent.
		if(readData.thisArg) {
			parent = readData.thisArg;
		}
		// Otherwise, we didn't find anything, use the first searched context.
		// TODO: there is likely a bug here when trying to set foo.bar where nothing in the scope
		// has a foo.
		else if(firstSearchedContext) {
			parent = firstSearchedContext;
		}

		if (parent === undefined) {
			return {
				error: "Attempting to set a value at " +
					key + " where the context is undefined."
			};
		}
		// Now we need to figure out how we would update this value.  The following does that.
		if(!canReflect.isObservableLike(parent) && canReflect.isObservableLike(parent[propName])) {
			if(canReflect.isMapLike(parent[propName])) {
				return {
					parent: parent,
					key: propName,
					how: "updateDeep",
					warn: "can-view-scope: Merging data into \"" +
						propName + "\" because its parent is non-observable"
				};
			}
			else if(canReflect.isValueLike(parent[propName])){
				return { parent: parent, key: propName, how: "setValue" };
			} else {
				return { parent: parent, how: "write", key: propName, passOptions: true };
			}
		} else {
			return { parent: parent, how: "write", key: propName, passOptions: true };
		}
	},

	// ### scope.getHelper
	// read a helper from the templateContext or global helpers list
	getHelper: function(keyReads) {
		console.warn(".getHelper is deprecated, use .getHelperOrPartial");
		return this.getHelperOrPartial(keyReads);
	},
	getHelperOrPartial: function(keyReads) {
		// try every template context
		var scope = this, context, helper;
		while (scope) {
			context = scope._context;
			if (context instanceof TemplateContext) {
				helper = stacheKey.read(context.helpers, keyReads, { proxyMethods: false });
				if(helper.value !== undefined) {
					return helper;
				}
				helper = stacheKey.read(context.partials, keyReads, { proxyMethods: false });
				if(helper.value !== undefined) {
					return helper;
				}
			}
			scope = scope._parent;
		}

		return stacheKey.read(stacheHelpers, keyReads, { proxyMethods: false });
	},

	// ### scope.get
	// Gets a value from the scope without being observable.
	get: function(key, options) {

		options = assign({
			isArgument: true
		}, options);

		var res = this.read(key, options);
		return res.value;
	},
	peek: ObservationRecorder.ignore(function(key, options) {
		return this.get(key, options);
	}),
	// TODO: Remove in 6.0
	peak: ObservationRecorder.ignore(function(key, options) {
		//!steal-remove-start
		if (true) {
			canLog.warn('peak is deprecated, please use peek instead');
		}
		//!steal-remove-end
		return this.peek(key, options);
	}),
	// ### scope.getScope
	// Returns the first scope that passes the `tester` function.
	getScope: function(tester) {
		var scope = this;
		while (scope) {
			if (tester(scope)) {
				return scope;
			}
			scope = scope._parent;
		}
	},
	// ### scope.getContext
	// Returns the first context whose scope passes the `tester` function.
	getContext: function(tester) {
		var res = this.getScope(tester);
		return res && res._context;
	},
	// ### scope.getTemplateContext
	// Returns the template context scope
	// This function isn't named right.
	getTemplateContext: function() {
		var lastScope;

		// find the first reference scope
		var templateContext = this.getScope(function(scope) {
			lastScope = scope;
			return scope._context instanceof TemplateContext;
		});

		// if there is no reference scope, add one as the root
		if(!templateContext) {
			templateContext = new Scope(new TemplateContext());

			// add templateContext to root of the scope chain so it
			// can be found using `getScope` next time it is looked up
			lastScope._parent = templateContext;
		}
		return templateContext;
	},
	addTemplateContext: function(){
		return this.add(new TemplateContext());
	},
	addLetContext: function(values){
		return this.add(new LetContext(values || {}), {variable: true});
	},
	// ### scope.getRoot
	// Returns the top most context that is not a references scope.
	// Used by `.read` to provide `%root`.
	getRoot: function() {
		var cur = this,
			child = this;

		while (cur._parent) {
			child = cur;
			cur = cur._parent;
		}

		if (cur._context instanceof TemplateContext) {
			cur = child;
		}
		return cur._context;
	},

	// first viewModel scope
	getViewModel: function() {
		var vmScope = this.getScope(function(scope) {
			return scope._meta.viewModel;
		});

		return vmScope && vmScope._context;
	},

	// _top_ viewModel scope
	getTop: function() {
		var top;

		this.getScope(function(scope) {
			if (scope._meta.viewModel) {
				top = scope;
			}

			// walk entire scope tree
			return false;
		});

		return top && top._context;
	},

	// ### scope.getPathsForKey
	// Finds all paths that will return a value for a specific key
	// NOTE: this is for development purposes only and is removed in production
	getPathsForKey: function getPathsForKey(key) {
		//!steal-remove-start
			if (true) {
			var paths = {};

			var getKeyDefinition = function(obj, key) {
				if (!obj || typeof obj !== "object") {
					return {};
				}

				var keyExistsOnObj = key in obj;
				var objHasKey = canReflect.hasKey(obj, key);

				return {
					isDefined: keyExistsOnObj || objHasKey,
					isFunction: keyExistsOnObj && typeof obj[key] === "function"
				};
			};

			// scope.foo@bar -> bar
			var reads = stacheKey.reads(key);
			var keyParts = reads.map(function(read) {
				return read.key;
			});
			var scopeIndex = keyParts.indexOf("scope");

			if (scopeIndex > -1) {
				keyParts.splice(scopeIndex, 2);
			}
			var normalizedKey = keyParts.join(".");

			// check scope.vm.<key>
			var vm = this.getViewModel();
			var vmKeyDefinition = getKeyDefinition(vm, normalizedKey);

			if (vmKeyDefinition.isDefined) {
				paths["scope.vm." + normalizedKey + (vmKeyDefinition.isFunction ? "()" : "")] = vm;
			}

			// check scope.top.<key>
			var top = this.getTop();
			var topKeyDefinition = getKeyDefinition(top, normalizedKey);

			if (topKeyDefinition.isDefined) {
				paths["scope.top." + normalizedKey + (topKeyDefinition.isFunction ? "()" : "")] = top;
			}

			// find specific paths (like ../key)
			var cur = "";

			this.getScope(function(scope) {
				// `notContext` and `special` contexts can't be read using `../`
				var canBeRead = !scope.isSpecial();

				if (canBeRead) {
					var contextKeyDefinition = getKeyDefinition(scope._context, normalizedKey);
					if (contextKeyDefinition.isDefined) {
						paths[cur + normalizedKey + (contextKeyDefinition.isFunction ? "()" : "")] = scope._context;
					}

					cur += "../";
				}

				// walk entire scope tree
				return false;
			});

			return paths;
		}
		//!steal-remove-end
	},

	// ### scope.hasKey
	// returns whether or not this scope has the key
	hasKey: function hasKey(key) {
		var reads = stacheKey.reads(key);
		var readValue;

		if (reads[0].key === "scope") {
			// read properties like `scope.vm.foo` directly from the scope
			readValue = stacheKey.read(this, reads.slice(1), key);
		} else {
			// read normal properties from the scope's context
			readValue = stacheKey.read(this._context, reads, key);
		}

		return readValue.foundLastParent && readValue.parentHasKey;
	},

	set: function(key, value, options) {
		options = options || {};

		var data = this.getDataForScopeSet(key, options);
		var parent = data.parent;

		//!steal-remove-start
		if (true) {
			if (data.error) {
				return canLog.error(data.error);
			}
		}
		//!steal-remove-end

		if (data.warn) {
			canLog.warn(data.warn);
		}

		switch (data.how) {
			case "set":
				parent.set(data.key, value, data.passOptions ? options : undefined);
				break;

			case "write":
				stacheKey.write(parent, data.key, value, options);
				break;

			case "setValue":
				canReflect.setValue("key" in data ? parent[data.key] : parent, value);
				break;

			case "setKeyValue":
				canReflect.setKeyValue(parent, data.key, value);
				break;

			case "updateDeep":
				canReflect.updateDeep(parent[data.key], value);
				break;
		}
	},

	// ### scope.attr
	// Gets or sets a value in the scope without being observable.
	attr: ObservationRecorder.ignore(function(key, value, options) {
		canLog.warn("can-view-scope::attr is deprecated, please use peek, get or set");

		options = assign({
			isArgument: true
		}, options);

		// Allow setting a value on the context
		if (arguments.length === 2) {
			return this.set(key, value, options);

		} else {
			return this.get(key, options);
		}
	}),

	// ### scope.computeData
	// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value
	// and other information about where the value was found.
	computeData: function(key, options) {
		return makeComputeData(this, key, options);
	},

	// ### scope.compute
	// Provides a get-set compute that represents a key's value.
	compute: function(key, options) {
		return this.computeData(key, options)
			.compute;
	},
	// ### scope.cloneFromRef
	//
	// This takes a scope and essentially copies its chain from
	// right before the last TemplateContext. And it does not include the ref.
	// this is a helper function to provide lexical semantics for refs.
	// This will not be needed for leakScope: false.
	cloneFromRef: function() {
		var scopes = [];
		var scope = this,
			context,
			parent;
		while (scope) {
			context = scope._context;
			if (context instanceof TemplateContext) {
				parent = scope._parent;
				break;
			}
			scopes.unshift(scope);
			scope = scope._parent;
		}
		if (parent) {
			scopes.forEach(function(scope) {
				// For performance, re-use _meta, don't copy it.
				parent = parent.add(scope._context, scope._meta);
			});
			return parent;
		} else {
			return this;
		}
	},
	isSpecial: function(){
		return this._meta.notContext || this._meta.special || (this._context instanceof TemplateContext) || this._meta.variable;
	}
});
// Legacy name for _walk.
Scope.prototype._read = Scope.prototype._walk;

canReflect.assignSymbols(Scope.prototype, {
	"can.hasKey": Scope.prototype.hasKey
});

var templateContextPrimitives = [
	"filename", "lineNumber"
];

// create getters/setters for primitives on the templateContext
// scope.filename -> scope.readFromTemplateContext("filename")
templateContextPrimitives.forEach(function(key) {
	Object.defineProperty(Scope.prototype, key, {
		get: function() {
			return this.readFromTemplateContext(key).value;
		},
		set: function(val) {
			this.templateContext[key] = val;
		}
	});
});

defineLazyValue(Scope.prototype, 'templateContext', function() {
	return this.getTemplateContext()._context;
});

defineLazyValue(Scope.prototype, 'root', function() {
	canLog.warn('`scope.root` is deprecated. Use either `scope.top`: https://canjs.com/doc/can-stache/keys/scope.html#scope_top or `scope.vm`: https://canjs.com/doc/can-stache/keys/scope.html#scope_vm instead.');
	return this.getRoot();
});

defineLazyValue(Scope.prototype, 'vm', function() {
	return this.getViewModel();
});

defineLazyValue(Scope.prototype, 'top', function() {
	return this.getTop();
});

defineLazyValue(Scope.prototype, 'helpers', function() {
	return stacheHelpers;
});

var specialKeywords = [
	'index', 'key', 'element',
	'event', 'viewModel','arguments',
	'helperOptions', 'args'
];

// create getters for "special" keys
// scope.index -> scope.readFromSpecialContext("index")
specialKeywords.forEach(function(key) {
	Object.defineProperty(Scope.prototype, key, {
		get: function() {
			return this.readFromSpecialContext(key).value;
		}
	});
});


//!steal-remove-start
if (true) {
	Scope.prototype.log = function() {
		var scope = this;
	    var indent = "";
		var contextType = "";
		while(scope) {
			contextType = scope._meta.notContext ? " (notContext)" :
				scope._meta.special ? " (special)" : "";
			console.log(indent, canReflect.getName(scope._context) + contextType, scope._context);
	        scope = scope._parent;
	        indent += " ";
	    }
	};
}
//!steal-remove-end


namespace.view = namespace.view || {};
module.exports = namespace.view.Scope = Scope;


/***/ }),

/***/ "./node_modules/can-view-scope/compute_data.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-view-scope/compute_data.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ScopeKeyData = __webpack_require__(/*! ./scope-key-data */ "./node_modules/can-view-scope/scope-key-data.js");

module.exports = function(scope, key, options){
	return new ScopeKeyData(scope, key, options || {
		args: []
	});
};


/***/ }),

/***/ "./node_modules/can-view-scope/let-context.js":
/*!****************************************************!*\
  !*** ./node_modules/can-view-scope/let-context.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SimpleMap = __webpack_require__(/*! can-simple-map */ "./node_modules/can-simple-map/can-simple-map.js");

// ### LetContext
// Instances of this are used to create a `let` variable context.

// Like Object.create, but only keeps Symbols and properties in `propertiesToKeep`
function objectCreateWithSymbolsAndSpecificProperties(obj, propertiesToKeep) {
	var newObj = {};

	// copy over all Symbols from obj
	if ("getOwnPropertySymbols" in Object) {
		Object.getOwnPropertySymbols(obj).forEach(function(key) {
			newObj[key] = obj[key];
		});
	}

	// copy over specific properties from obj (also fake Symbols properties for IE support);
	Object.getOwnPropertyNames(obj).forEach(function(key) {
		if (propertiesToKeep.indexOf(key) >= 0 || key.indexOf("@@symbol") === 0) {
			newObj[key] = obj[key];
		}
	});

	return Object.create(newObj);
}

var LetContext = SimpleMap.extend("LetContext", {});
LetContext.prototype = objectCreateWithSymbolsAndSpecificProperties(SimpleMap.prototype, [
	// SimpleMap properties
	"setup",
	"attr",
	"serialize",
	"get",
	"set",
	"log",
	// required by SimpleMap properties
	"dispatch",
	// Construct properties (not added by can-event-queue)
	"constructorExtends",
	"newInstance",
	"_inherit",
	"_defineProperty",
	"_overwrite",
	"instance",
	"extend",
	"ReturnValue",
	"setup",
	"init"
]);
LetContext.prototype.constructor = LetContext;

module.exports = LetContext;


/***/ }),

/***/ "./node_modules/can-view-scope/make-compute-like.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-view-scope/make-compute-like.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var singleReference = __webpack_require__(/*! can-single-reference */ "./node_modules/can-single-reference/can-single-reference.js");
var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");

var Compute = function(newVal){
	if(arguments.length) {
		return canReflect.setValue(this, newVal);
	} else {
		return canReflect.getValue(this);
	}
};

module.exports = function(observable) {
    var compute = Compute.bind(observable);

	//!steal-remove-start
	if (true) {
		Object.defineProperty(compute, "name", {
			value: "Compute<"+canReflect.getName(observable) + ">",
		});
	}
	//!steal-remove-end

    compute.on = compute.bind = compute.addEventListener = function(event, handler) {
        var translationHandler = function(newVal, oldVal) {
            handler.call(compute, {type:'change'}, newVal, oldVal);
        };
        singleReference.set(handler, this, translationHandler);
        observable.on(translationHandler);
    };
    compute.off = compute.unbind = compute.removeEventListener = function(event, handler) {
        observable.off( singleReference.getAndDelete(handler, this) );
    };

    canReflect.assignSymbols(compute, {
        "can.getValue": function(){
            return canReflect.getValue(observable);
        },
        "can.setValue": function(newVal){
            return canReflect.setValue(observable, newVal);
        },
        "can.onValue": function(handler, queue){
            return canReflect.onValue(observable, handler, queue);
        },
        "can.offValue": function(handler, queue){
            return canReflect.offValue(observable, handler, queue);
        },
        "can.valueHasDependencies": function(){
            return canReflect.valueHasDependencies(observable);
        },
        "can.getPriority": function(){
    		return canReflect.getPriority( observable );
    	},
    	"can.setPriority": function(newPriority){
    		canReflect.setPriority( observable, newPriority );
    	},
		"can.isValueLike": true,
		"can.isFunctionLike": false
    });
    compute.isComputed = true;
    return compute;
};


/***/ }),

/***/ "./node_modules/can-view-scope/scope-key-data.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-scope/scope-key-data.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Observation = __webpack_require__(/*! can-observation */ "./node_modules/can-observation/can-observation.js");
var observeReader = __webpack_require__(/*! can-stache-key */ "./node_modules/can-stache-key/can-stache-key.js");
var assign = __webpack_require__(/*! can-assign */ "./node_modules/can-assign/can-assign.js");

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
var makeComputeLike = __webpack_require__(/*! ./make-compute-like */ "./node_modules/can-view-scope/make-compute-like.js");
var canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
var valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ "./node_modules/can-event-queue/value/value.js");
var stacheHelpers = __webpack_require__(/*! can-stache-helpers */ "./node_modules/can-stache-helpers/can-stache-helpers.js");
var SimpleObservable = __webpack_require__(/*! can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
var dev = __webpack_require__(/*! can-log/dev/dev */ "./node_modules/can-log/dev/dev.js");

var dispatchSymbol = canSymbol.for("can.dispatch");
var setElementSymbol = canSymbol.for("can.setElement");

// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.
// If the key value is something like {{name}} and the context is a can.Map, a faster
// binding path will be used where new rebindings don't need to be looked for with every change of
// the observable property.
// However, if the property changes to a compute, then the slower `can.compute.read` method of
// observing values will be used.

// ideally, we would know the order things were read.  If the last thing read
// was something we can observe, and the value of it matched the value of the observation,
// and the key matched the key of the observation
// it's a fair bet that we can just listen to that last object.
// If the `this` is not that object ... freak out.  Though `this` is not necessarily part of it.  can-observation could make
// this work.


var getFastPathRoot = ObservationRecorder.ignore(function(computeData){
	if( computeData.reads &&
				// a single property read
				computeData.reads.length === 1 ) {
		var root = computeData.root;
		if( root && root[canSymbol.for("can.getValue")] ) {
			root = canReflect.getValue(root);
		}
		// on a map
		return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) &&
			// that isn't calling a function
			typeof root[computeData.reads[0].key] !== "function" && root;
	}
	return;
});

var isEventObject = function(obj){
	return obj && typeof obj.batchNum === "number" && typeof obj.type === "string";
};

function getMutated(scopeKeyData){
	// The _thisArg is the value before the last `.`. For example if the key was `foo.bar.zed`,
	// _thisArg would be the value at foo.bar.
	// This should be improved as `foo.bar` might not be observable.
	var value = ObservationRecorder.peekValue(scopeKeyData._thisArg);

	// Something like `string@split` would provide a primitive which can't be a mutated subject
	return !canReflect.isPrimitive(value) ? value : scopeKeyData.root;
}

function callMutateWithRightArgs(method, mutated, reads, mutator){
	if(reads.length) {
		method.call(canReflectDeps,mutated, reads[ reads.length - 1 ].key ,mutator);
	} else {
		method.call(canReflectDeps,mutated ,mutator);
	}
}




var warnOnUndefinedProperty;
//!steal-remove-start
if (true) {
	warnOnUndefinedProperty = function(options) {
		if ( options.key !== "debugger" && !options.parentHasKey) {
			var filename = options.scope.peek('scope.filename');
			var lineNumber = options.scope.peek('scope.lineNumber');

			var reads = observeReader.reads(options.key);
			var firstKey = reads[0].key;
			var key = reads.map(function(read) {
				return read.key + (read.at ? "()" : "");
			}).join(".");
			var pathsForKey = options.scope.getPathsForKey(firstKey);
			var paths = Object.keys( pathsForKey );
			var firstKeyValue = options.scope.get(firstKey);

			var includeSuggestions = paths.length && (paths.indexOf(firstKey) < 0);

			var warning = [
				(filename ? filename + ':' : '') +
					(lineNumber ? lineNumber + ': ' : '') +
					'Unable to find key "' + key + '".'
			];

			if (includeSuggestions) {
				warning[0] = warning[0] + ' Did you mean' + (paths.length > 1 ? ' one of these' : '') + '?\n';
				paths.forEach(function(path) {
					warning.push('\t"' + path + '" which will read from');
					warning.push(pathsForKey[path]);
					warning.push("\n");
				});
			} else if (firstKeyValue) {
				warning[0] = warning[0] + ' Found "' + firstKey + '" with value: %o\n';
			}

			if (firstKeyValue) {
				dev.warn.apply(dev, [warning.join("\n"), firstKeyValue]);
			} else {
				dev.warn.apply(dev,
					warning
				);
			}

		}
	};
}
//!steal-remove-end

// could we make this an observation first ... and have a getter for the compute?

// This is a fast-path enabled Observation wrapper use many places in can-stache.
// The goal of this is to:
//
// 1.  Make something that can be passed to can-view-live directly, hopefully
//     avoiding creating expensive computes.  Instead we will only be creating
//     `ScopeKeyData` which are thin wrappers.
var ScopeKeyData = function(scope, key, options){

	this.startingScope = scope;
	this.key = key;
	this.read = this.read.bind(this);
	this.dispatch = this.dispatch.bind(this);

	// special case debugger helper so that it is called with helperOtions
	// when you do {{debugger}} as it already is with {{debugger()}}
	if (key === "debugger") {
		// prevent "Unable to find key" warning
		this.startingScope = { _context: stacheHelpers };

		this.read = function() {
			var helperOptions = { scope: scope };
			var debuggerHelper = stacheHelpers["debugger"];
			return debuggerHelper(helperOptions);
		};
	}

	//!steal-remove-start
	if (true) {
		Object.defineProperty(this.read, "name", {
			value: canReflect.getName(this) + ".read",
		});
		Object.defineProperty(this.dispatch, "name", {
			value: canReflect.getName(this) + ".dispatch",
		});
	}
	//!steal-remove-end

	var observation = this.observation = new Observation(this.read, this);
	this.options = assign({ observation: this.observation }, options);

	// things added later
	this.fastPath = undefined;
	this.root = undefined;
	this.reads = undefined;
	this.setRoot = undefined;
	// This is read by call expressions so it needs to be observable
	this._thisArg = new SimpleObservable();
	this.parentHasKey = undefined;
	var valueDependencies = new Set();
	valueDependencies.add(observation);
	this.dependencies = {valueDependencies: valueDependencies};

	// This is basically what .get() should give, but it
	// isn't used to figure out the last value.
	this._latestValue = undefined;
};

valueEventBindings(ScopeKeyData.prototype);

function fastOnBoundSet_Value() {
	this._value = this.newVal;
}

function fastOnBoundSetValue() {
	this.value = this.newVal;
}

assign(ScopeKeyData.prototype, {
	constructor: ScopeKeyData,
	dispatch: function dispatch(newVal){
		var old = this.value;
		this._latestValue = this.value = newVal;
		// call the base implementation in can-event-queue
		this[dispatchSymbol].call(this, this.value, old);
	},
	onBound: function onBound(){
		this.bound = true;
		canReflect.onValue(this.observation, this.dispatch, "notify");
		// TODO: we should check this sometime in the background.
		var fastPathRoot = getFastPathRoot(this);
		if( fastPathRoot ) {
			// rewrite the observation to call its event handlers
			this.toFastPath(fastPathRoot);
		}
		this._latestValue = this.value = ObservationRecorder.peekValue(this.observation);
	},
	onUnbound: function onUnbound() {
		this.bound = false;
		canReflect.offValue(this.observation, this.dispatch, "notify");
		this.toSlowPath();
	},
	set: function(newVal){
		var root = this.root || this.setRoot;
		if(root) {
			if(this.reads.length) {
				observeReader.write(root, this.reads, newVal, this.options);
			} else {
				canReflect.setValue(root,newVal);
			}
		} else {
			this.startingScope.set(this.key, newVal, this.options);
		}
	},
	get: function() {
		if (ObservationRecorder.isRecording()) {
			ObservationRecorder.add(this);
			if (!this.bound) {
				Observation.temporarilyBind(this);
			}
		}

		if (this.bound === true && this.fastPath === true) {
			return this._latestValue;
		} else {
			return ObservationRecorder.peekValue(this.observation);
		}
	},
	toFastPath: function(fastPathRoot){
		var self = this,
			observation = this.observation;

		this.fastPath = true;

		// there won't be an event in the future ...
		observation.dependencyChange = function(target, newVal){
			if(isEventObject(newVal)) {
				throw "no event objects!";
			}
			// but I think we will be able to get at it b/c there should only be one
			// dependency we are binding to ...
			if(target === fastPathRoot && typeof newVal !== "function") {
				self._latestValue = newVal;
				this.newVal = newVal;
			} else {
				// restore
				self.toSlowPath();
			}

			return Observation.prototype.dependencyChange.apply(this, arguments);
		};

		if (observation.hasOwnProperty("_value")) {// can-observation 4.1+
			observation.onBound = fastOnBoundSet_Value;
		} else {// can-observation < 4.1
			observation.onBound = fastOnBoundSetValue;
		}
	},
	toSlowPath: function(){
		this.observation.dependencyChange = Observation.prototype.dependencyChange;
		this.observation.onBound = Observation.prototype.onBound;
		this.fastPath = false;
	},
	read: function(){
		var data;

		if (this.root) {
			// if we've figured out a root observable, start reading from there
			data = observeReader.read(this.root, this.reads, this.options);

			//!steal-remove-start
			if (true) {
				// remove old dependency
				if(this.reads.length) {
					callMutateWithRightArgs(canReflectDeps.deleteMutatedBy, getMutated(this), this.reads,this);
				}

			}
			//!steal-remove-end

			// update thisArg and add new dependency
			this.thisArg = data.parent;

			//!steal-remove-start
			if (true) {
				var valueDeps = new Set();
				valueDeps.add(this);
				callMutateWithRightArgs(canReflectDeps.addMutatedBy, data.parent || this.root, this.reads,{
					valueDependencies: valueDeps
				});
			}
			//!steal-remove-end

			return data.value;
		}
		// If the key has not already been located in a observable then we need to search the scope for the
		// key.  Once we find the key then we need to return it's value and if it is found in an observable
		// then we need to store the observable so the next time this compute is called it can grab the value
		// directly from the observable.
		data = this.startingScope.read(this.key, this.options);


		this.scope = data.scope;
		this.reads = data.reads;
		this.root = data.rootObserve;
		this.setRoot = data.setRoot;
		this.thisArg = data.thisArg;
		this.parentHasKey = data.parentHasKey;

		//!steal-remove-start
		if (true) {
			if (data.rootObserve) {
				var rootValueDeps = new Set();
				rootValueDeps.add(this);
				callMutateWithRightArgs(canReflectDeps.addMutatedBy, getMutated(this), data.reads,{
					valueDependencies: rootValueDeps
				});
			}
			if(data.value === undefined && this.options.warnOnMissingKey === true) {
				warnOnUndefinedProperty({
					scope: this.startingScope,
					key: this.key,
					parentHasKey: data.parentHasKey
				});
			}
		}
		//!steal-remove-end

		return data.value;
	},
	hasDependencies: function(){
		// ScopeKeyData is unique in that when these things are read, it will temporarily bind
		// to make sure the right value is returned. This is for can-stache.
		// Helpers warns about a missing helper.
		if (!this.bound) {
			Observation.temporarilyBind(this);
		}
		return canReflect.valueHasDependencies( this.observation );
	}
});

Object.defineProperty(ScopeKeyData.prototype, "thisArg", {
	get: function(){
		return this._thisArg.get();
	},
	set: function(newVal) {
		this._thisArg.set(newVal);
	}
});

var scopeKeyDataPrototype = {
	"can.getValue": ScopeKeyData.prototype.get,
	"can.setValue": ScopeKeyData.prototype.set,
	"can.valueHasDependencies": ScopeKeyData.prototype.hasDependencies,
	"can.getValueDependencies": function() {
		return this.dependencies;
	},
	"can.getPriority": function(){
		return canReflect.getPriority( this.observation );
	},
	"can.setPriority": function(newPriority){
		canReflect.setPriority( this.observation, newPriority );
	},
	"can.setElement": function(element) {
		this.observation[setElementSymbol](element);
	}
};

//!steal-remove-start
if (true) {
	scopeKeyDataPrototype["can.getName"] = function() {
		return canReflect.getName(this.constructor) + "{{" + this.key + "}}";
	};
}
//!steal-remove-end
canReflect.assignSymbols(ScopeKeyData.prototype, scopeKeyDataPrototype);

// Creates a compute-like for legacy reasons ...
Object.defineProperty(ScopeKeyData.prototype, "compute", {
	get: function(){
		var compute = makeComputeLike(this);

		Object.defineProperty(this, "compute", {
			value: compute,
			writable: false,
			configurable: false
		});
		return compute;
	},
	configurable: true
});

Object.defineProperty(ScopeKeyData.prototype, "initialValue", {
	get: function(){
		if (!this.bound) {
			Observation.temporarilyBind(this);
		}
		return ObservationRecorder.peekValue(this);
	},
	set: function(){
		throw new Error("initialValue should not be set");
	},
	configurable: true
});

module.exports = ScopeKeyData;


/***/ }),

/***/ "./node_modules/can-view-scope/template-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-scope/template-context.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SimpleMap = __webpack_require__(/*! can-simple-map */ "./node_modules/can-simple-map/can-simple-map.js");

var TemplateContext = function(options) {
	options = options || {};
	this.vars = new SimpleMap(options.vars || {});
	this.helpers = new SimpleMap(options.helpers || {});
	this.partials = new SimpleMap(options.partials || {});
	this.tags = new SimpleMap(options.tags || {});
};

module.exports = TemplateContext;


/***/ }),

/***/ "./node_modules/can-view-target/can-view-target.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-target/can-view-target.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* jshint maxdepth:7 */
/* jshint latedef:false */
var getDocument = __webpack_require__(/*! can-globals/document/document */ "./node_modules/can-globals/document/document.js");
var domMutate = __webpack_require__(/*! can-dom-mutate/node */ "./node_modules/can-dom-mutate/node.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");
var MUTATION_OBSERVER = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ "./node_modules/can-globals/mutation-observer/mutation-observer.js");

// if an object or a function
// convert into what it should look like
// then the modification can happen in place
// but it has to have more than the current node
// blah!
var processNodes = function(nodes, paths, location, document){
	var frag = document.createDocumentFragment();

	for(var i = 0, len = nodes.length; i < len; i++) {
		var node = nodes[i];
		frag.appendChild( processNode(node,paths,location.concat(i), document) );
	}
	return frag;
},
	keepsTextNodes =  typeof document !== "undefined" && (function(){
		var testFrag = document.createDocumentFragment();
		var div = document.createElement("div");

		div.appendChild(document.createTextNode(""));
		div.appendChild(document.createTextNode(""));
		testFrag.appendChild(div);

		var cloned  = testFrag.cloneNode(true);

		return cloned.firstChild.childNodes.length === 2;
	})(),
	clonesWork = typeof document !== "undefined" && (function(){
		// Since html5shiv is required to support custom elements, assume cloning
		// works in any browser that doesn't have html5shiv

		// Clone an element containing a custom tag to see if the innerHTML is what we
		// expect it to be, or if not it probably was created outside of the document's
		// namespace.
		var el = document.createElement('a');
		el.innerHTML = "<xyz></xyz>";
		var clone = el.cloneNode(true);
		var works = clone.innerHTML === "<xyz></xyz>";
		var MO, observer;

		if(works) {
			// Cloning text nodes with dashes seems to create multiple nodes in IE11 when
			// MutationObservers of subtree modifications are used on the documentElement.
			// Since this is not what we expect we have to include detecting it here as well.
			el = document.createDocumentFragment();
			el.appendChild(document.createTextNode('foo-bar'));

			MO = MUTATION_OBSERVER();

			if (MO) {
				observer = new MO(function() {});
				observer.observe(document.documentElement, { childList: true, subtree: true });

				clone = el.cloneNode(true);

				observer.disconnect();
			} else {
				clone = el.cloneNode(true);
			}

			return clone.childNodes.length === 1;
		}

		return works;
	})(),
	namespacesWork = typeof document !== "undefined" && !!document.createElementNS;

/**
 * @function cloneNode
 * @hide
 *
 * A custom cloneNode function to be used in browsers that properly support cloning
 * of custom tags (IE8 for example). Fixes it by doing some manual cloning that
 * uses innerHTML instead, which has been shimmed.
 *
 * @param {DocumentFragment} frag A document fragment to clone
 * @return {DocumentFragment} a new fragment that is a clone of the provided argument
 */
var cloneNode = clonesWork ?
	function(el){
		return el.cloneNode(true);
	} :
	function(node){
		var document = node.ownerDocument;
		var copy;

		if(node.nodeType === 1) {
			if(node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
				copy = document.createElementNS(node.namespaceURI, node.nodeName);
			}
			else {
				copy = document.createElement(node.nodeName);
			}
		} else if(node.nodeType === 3){
			copy = document.createTextNode(node.nodeValue);
		} else if(node.nodeType === 8) {
			copy = document.createComment(node.nodeValue);
		} else if(node.nodeType === 11) {
			copy = document.createDocumentFragment();
		}

		if(node.attributes) {
			var attributes = node.attributes;
			for (var i = 0; i < attributes.length; i++) {
				var attribute = attributes[i];
				if (attribute && attribute.specified) {
					// If the attribute has a namespace set the namespace 
					// otherwise it will be set to null
					if (attribute.namespaceURI) {
						copy.setAttributeNS(attribute.namespaceURI, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
					} else {
						copy.setAttribute(attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
					}
				}
			}
		}

		if(node && node.firstChild) {
			var child = node.firstChild;

			while(child) {
				copy.appendChild( cloneNode(child) );
				child = child.nextSibling;
			}
		}

		return copy;
	};

function processNode(node, paths, location, document){
	var callback,
		loc = location,
		nodeType = typeof node,
		el,
		p,
		i , len;
	var getCallback = function(){
		if(!callback) {
			callback  = {
				path: location,
				callbacks: []
			};
			paths.push(callback);
			loc = [];
		}
		return callback;
	};

	if(nodeType === "object") {
		if( node.tag ) {
			if(namespacesWork && node.namespace) {
				el = document.createElementNS(node.namespace, node.tag);
			} else {
				el = document.createElement(node.tag);
			}

			if(node.attrs) {
				for(var attrName in node.attrs) {
					var value = node.attrs[attrName];
					if(typeof value === "function"){
						getCallback().callbacks.push({
							callback:  value
						});
					} else if (value !== null && typeof value === "object" && value.namespaceURI) {
						el.setAttributeNS(value.namespaceURI,attrName,value.value);
					} else {
						domMutate.setAttribute.call(el, attrName, value);
					}
				}
			}
			if(node.attributes) {
				for(i = 0, len = node.attributes.length; i < len; i++ ) {
					getCallback().callbacks.push({callback: node.attributes[i]});
				}
			}
			if(node.children && node.children.length) {
				// add paths
				if(callback) {
					p = callback.paths = [];
				} else {
					p = paths;
				}

				el.appendChild( processNodes(node.children, p, loc, document) );
			}
		} else if(node.comment) {
			el = document.createComment(node.comment);

			if(node.callbacks) {
				for(i = 0, len = node.callbacks.length; i < len; i++ ) {
					getCallback().callbacks.push({callback: node.callbacks[i]});
				}
			}
		}


	} else if(nodeType === "string"){

		el = document.createTextNode(node);

	} else if(nodeType === "function") {

		if(keepsTextNodes) {
			el = document.createTextNode("");
			getCallback().callbacks.push({
				callback: node
			});
		} else {
			el = document.createComment("~");
			getCallback().callbacks.push({
				callback: function(){
					var el = document.createTextNode("");
					domMutate.replaceChild.call(this.parentNode, el, this);
					return node.apply(el,arguments );
				}
			});
		}

	}
	return el;
}

function getCallbacks(el, pathData, elementCallbacks){
	var path = pathData.path,
		callbacks = pathData.callbacks,
		paths = pathData.paths,
		child = el,
		pathLength = path ? path.length : 0,
		pathsLength = paths ? paths.length : 0;

	for(var i = 0; i < pathLength; i++) {
		child = child.childNodes.item(path[i]);
	}

	for( i= 0 ; i < pathsLength; i++) {
		getCallbacks(child, paths[i], elementCallbacks);
	}

	elementCallbacks.push({element: child, callbacks: callbacks});
}

function hydrateCallbacks(callbacks, args) {
	var len = callbacks.length,
		callbacksLength,
		callbackElement,
		callbackData;

	for(var i = 0; i < len; i++) {
		callbackData = callbacks[i];
		callbacksLength = callbackData.callbacks.length;
		callbackElement = callbackData.element;
		for(var c = 0; c < callbacksLength; c++) {
			callbackData.callbacks[c].callback.apply(callbackElement, args);
		}
	}
}

function makeTarget(nodes, doc){
	var paths = [];
	var frag = processNodes(nodes, paths, [], doc || getDocument());
	return {
		paths: paths,
		clone: frag,
		hydrate: function(){
			var cloned = cloneNode(this.clone);
			var args = [];
			for (var a = 0, ref = args.length = arguments.length; a < ref; a++) {
				args[a] = arguments[a];
			} // see https://jsperf.com/nodelist-to-array

			var callbacks = [];
			for(var i = 0; i < paths.length; i++) {
				getCallbacks(cloned, paths[i], callbacks);
			}
			hydrateCallbacks(callbacks, args);

			return cloned;
		}
	};
}
makeTarget.keepsTextNodes = keepsTextNodes;
makeTarget.cloneNode = cloneNode;

namespace.view = namespace.view || {};
module.exports = namespace.view.target = makeTarget;


/***/ }),

/***/ "./node_modules/can/can.js":
/*!*********************************!*\
  !*** ./node_modules/can/can.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.AsyncObservable),
/* harmony export */   "Construct": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.Construct),
/* harmony export */   "KeyTree": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.KeyTree),
/* harmony export */   "MaybeBoolean": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.MaybeBoolean),
/* harmony export */   "MaybeDate": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.MaybeDate),
/* harmony export */   "MaybeNumber": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.MaybeNumber),
/* harmony export */   "MaybeString": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.MaybeString),
/* harmony export */   "ObservableArray": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.ObservableArray),
/* harmony export */   "ObservableObject": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.ObservableObject),
/* harmony export */   "Observation": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.Observation),
/* harmony export */   "ObservationRecorder": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.ObservationRecorder),
/* harmony export */   "QueryLogic": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.QueryLogic),
/* harmony export */   "Reflect": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.Reflect),
/* harmony export */   "ResolverObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.ResolverObservable),
/* harmony export */   "RouteHash": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.RouteHash),
/* harmony export */   "RoutePushstate": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.RoutePushstate),
/* harmony export */   "Scope": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.Scope),
/* harmony export */   "SettableObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.SettableObservable),
/* harmony export */   "SetterObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.SetterObservable),
/* harmony export */   "SimpleMap": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.SimpleMap),
/* harmony export */   "SimpleObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.SimpleObservable),
/* harmony export */   "StacheElement": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.StacheElement),
/* harmony export */   "addJQueryEvents": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.addJQueryEvents),
/* harmony export */   "ajax": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.ajax),
/* harmony export */   "assign": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.assign),
/* harmony export */   "attributeEncoder": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.attributeEncoder),
/* harmony export */   "bind": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.bind),
/* harmony export */   "can": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.can),
/* harmony export */   "childNodes": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.childNodes),
/* harmony export */   "cid": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.cid),
/* harmony export */   "connect": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.connect),
/* harmony export */   "defineLazyValue": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.defineLazyValue),
/* harmony export */   "deparam": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.deparam),
/* harmony export */   "diff": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.diff),
/* harmony export */   "domData": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.domData),
/* harmony export */   "domEvents": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.domEvents),
/* harmony export */   "domMutate": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.domMutate),
/* harmony export */   "domMutateDomEvents": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.domMutateDomEvents),
/* harmony export */   "domMutateNode": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.domMutateNode),
/* harmony export */   "fixture": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.fixture),
/* harmony export */   "fragment": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.fragment),
/* harmony export */   "fromAttribute": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.fromAttribute),
/* harmony export */   "globals": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.globals),
/* harmony export */   "key": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.key),
/* harmony export */   "keyObservable": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.keyObservable),
/* harmony export */   "localStore": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.localStore),
/* harmony export */   "makeInterfaceValidator": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.makeInterfaceValidator),
/* harmony export */   "makeMap": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.makeMap),
/* harmony export */   "mapEventBindings": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.mapEventBindings),
/* harmony export */   "memoryStore": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.memoryStore),
/* harmony export */   "param": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.param),
/* harmony export */   "parseURI": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.parseURI),
/* harmony export */   "queues": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.queues),
/* harmony export */   "realtimeRestModel": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.realtimeRestModel),
/* harmony export */   "reflectDependencies": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.reflectDependencies),
/* harmony export */   "reflectPromise": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.reflectPromise),
/* harmony export */   "restModel": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.restModel),
/* harmony export */   "route": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.route),
/* harmony export */   "stache": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.stache),
/* harmony export */   "stacheBindings": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.stacheBindings),
/* harmony export */   "stacheRouteHelpers": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.stacheRouteHelpers),
/* harmony export */   "string": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.string),
/* harmony export */   "stringToAny": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.stringToAny),
/* harmony export */   "target": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.target),
/* harmony export */   "type": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.type),
/* harmony export */   "value": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.value),
/* harmony export */   "valueEventBindings": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.valueEventBindings),
/* harmony export */   "viewCallbacks": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.viewCallbacks),
/* harmony export */   "viewLive": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.viewLive),
/* harmony export */   "viewModel": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.viewModel),
/* harmony export */   "viewParser": () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.viewParser),
/* harmony export */   "DeepObservable": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.DeepObservable),
/* harmony export */   "Kefir": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.Kefir),
/* harmony export */   "RouteMock": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.RouteMock),
/* harmony export */   "connectCanSession": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.connectCanSession),
/* harmony export */   "connectNDJSON": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.connectNDJSON),
/* harmony export */   "connectTag": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.connectTag),
/* harmony export */   "constructSuper": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.constructSuper),
/* harmony export */   "debug": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.debug),
/* harmony export */   "defineBackup": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.defineBackup),
/* harmony export */   "defineMixin": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.defineMixin),
/* harmony export */   "defineStream": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.defineStream),
/* harmony export */   "defineStreamKefir": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.defineStreamKefir),
/* harmony export */   "enterEvent": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.enterEvent),
/* harmony export */   "fixtureSocket": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.fixtureSocket),
/* harmony export */   "kefir": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.kefir),
/* harmony export */   "makeMapCompat": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.makeMapCompat),
/* harmony export */   "ndjsonStream": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.ndjsonStream),
/* harmony export */   "observableMixin": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.observableMixin),
/* harmony export */   "observe": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.observe),
/* harmony export */   "radioChangeEvent": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.radioChangeEvent),
/* harmony export */   "stacheConverters": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.stacheConverters),
/* harmony export */   "stream": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.stream),
/* harmony export */   "streamKefir": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.streamKefir),
/* harmony export */   "superModel": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.superModel),
/* harmony export */   "validate": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.validate),
/* harmony export */   "validateValidatejs": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.validateValidatejs),
/* harmony export */   "viewAutorender": () => (/* reexport safe */ _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__.viewAutorender),
/* harmony export */   "CanList": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.CanList),
/* harmony export */   "CanMap": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.CanMap),
/* harmony export */   "Component": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.Component),
/* harmony export */   "Control": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.Control),
/* harmony export */   "DefineList": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.DefineList),
/* harmony export */   "DefineMap": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.DefineMap),
/* harmony export */   "canMapDefine": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.canMapDefine),
/* harmony export */   "compute": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.compute),
/* harmony export */   "define": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.define),
/* harmony export */   "defineRealtimeRestModel": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.defineRealtimeRestModel),
/* harmony export */   "defineRestModel": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.defineRestModel),
/* harmony export */   "set": () => (/* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_2__.set)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/can/core.js");
/* harmony import */ var _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecosystem.js */ "./node_modules/can/ecosystem.js");
/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legacy.js */ "./node_modules/can/legacy.js");





/***/ }),

/***/ "./node_modules/can/core.js":
/*!**********************************!*\
  !*** ./node_modules/can/core.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "value": () => (/* reexport default from dynamic */ _es_can_value__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "Observation": () => (/* reexport default from dynamic */ _es_can_observation__WEBPACK_IMPORTED_MODULE_1___default.a),
/* harmony export */   "ObservationRecorder": () => (/* reexport default from dynamic */ _es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   "SimpleMap": () => (/* reexport default from dynamic */ _es_can_simple_map__WEBPACK_IMPORTED_MODULE_3___default.a),
/* harmony export */   "ObservableObject": () => (/* reexport default from dynamic */ _es_can_observable_object__WEBPACK_IMPORTED_MODULE_4___default.a),
/* harmony export */   "ObservableArray": () => (/* reexport default from dynamic */ _es_can_observable_array__WEBPACK_IMPORTED_MODULE_5___default.a),
/* harmony export */   "fromAttribute": () => (/* reexport safe */ can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__.fromAttribute),
/* harmony export */   "bind": () => (/* reexport default from dynamic */ _es_can_bind__WEBPACK_IMPORTED_MODULE_7___default.a),
/* harmony export */   "mapEventBindings": () => (/* reexport default from dynamic */ _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8___default.a),
/* harmony export */   "valueEventBindings": () => (/* reexport default from dynamic */ _es_can_event_queue__WEBPACK_IMPORTED_MODULE_9___default.a),
/* harmony export */   "SimpleObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_10___default.a),
/* harmony export */   "AsyncObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_11___default.a),
/* harmony export */   "keyObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_12___default.a),
/* harmony export */   "ResolverObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_13___default.a),
/* harmony export */   "SettableObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_14___default.a),
/* harmony export */   "SetterObservable": () => (/* reexport default from dynamic */ _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_15___default.a),
/* harmony export */   "StacheElement": () => (/* reexport default from dynamic */ _es_can_stache_element__WEBPACK_IMPORTED_MODULE_16___default.a),
/* harmony export */   "stache": () => (/* reexport default from dynamic */ _es_can_stache__WEBPACK_IMPORTED_MODULE_17___default.a),
/* harmony export */   "stacheBindings": () => (/* reexport default from dynamic */ _es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_18___default.a),
/* harmony export */   "stacheRouteHelpers": () => (/* reexport default from dynamic */ _es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_19___default.a),
/* harmony export */   "viewCallbacks": () => (/* reexport default from dynamic */ _es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_20___default.a),
/* harmony export */   "viewLive": () => (/* reexport default from dynamic */ _es_can_view_live__WEBPACK_IMPORTED_MODULE_21___default.a),
/* harmony export */   "viewModel": () => (/* reexport default from dynamic */ _es_can_view_model__WEBPACK_IMPORTED_MODULE_22___default.a),
/* harmony export */   "viewParser": () => (/* reexport default from dynamic */ _es_can_view_parser__WEBPACK_IMPORTED_MODULE_23___default.a),
/* harmony export */   "Scope": () => (/* reexport default from dynamic */ _es_can_view_scope__WEBPACK_IMPORTED_MODULE_24___default.a),
/* harmony export */   "target": () => (/* reexport default from dynamic */ _es_can_view_target__WEBPACK_IMPORTED_MODULE_25___default.a),
/* harmony export */   "fixture": () => (/* reexport default from dynamic */ _es_can_fixture__WEBPACK_IMPORTED_MODULE_26___default.a),
/* harmony export */   "QueryLogic": () => (/* reexport default from dynamic */ _es_can_query_logic__WEBPACK_IMPORTED_MODULE_27___default.a),
/* harmony export */   "realtimeRestModel": () => (/* reexport default from dynamic */ _es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_28___default.a),
/* harmony export */   "restModel": () => (/* reexport default from dynamic */ _es_can_rest_model__WEBPACK_IMPORTED_MODULE_29___default.a),
/* harmony export */   "connect": () => (/* reexport default from dynamic */ _es_can_connect__WEBPACK_IMPORTED_MODULE_30___default.a),
/* harmony export */   "localStore": () => (/* reexport default from dynamic */ _es_can_local_store__WEBPACK_IMPORTED_MODULE_31___default.a),
/* harmony export */   "memoryStore": () => (/* reexport default from dynamic */ _es_can_memory_store__WEBPACK_IMPORTED_MODULE_32___default.a),
/* harmony export */   "route": () => (/* reexport default from dynamic */ _es_can_route__WEBPACK_IMPORTED_MODULE_33___default.a),
/* harmony export */   "RouteHash": () => (/* reexport default from dynamic */ _es_can_route_hash__WEBPACK_IMPORTED_MODULE_34___default.a),
/* harmony export */   "RoutePushstate": () => (/* reexport default from dynamic */ _es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_35___default.a),
/* harmony export */   "param": () => (/* reexport default from dynamic */ _es_can_param__WEBPACK_IMPORTED_MODULE_36___default.a),
/* harmony export */   "deparam": () => (/* reexport default from dynamic */ _es_can_deparam__WEBPACK_IMPORTED_MODULE_37___default.a),
/* harmony export */   "assign": () => (/* reexport default from dynamic */ _es_can_assign__WEBPACK_IMPORTED_MODULE_38___default.a),
/* harmony export */   "defineLazyValue": () => (/* reexport default from dynamic */ _es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_39___default.a),
/* harmony export */   "diff": () => (/* reexport default from dynamic */ _es_can_diff__WEBPACK_IMPORTED_MODULE_40___default.a),
/* harmony export */   "globals": () => (/* reexport default from dynamic */ _es_can_globals__WEBPACK_IMPORTED_MODULE_41___default.a),
/* harmony export */   "key": () => (/* reexport default from dynamic */ _es_can_key__WEBPACK_IMPORTED_MODULE_42___default.a),
/* harmony export */   "KeyTree": () => (/* reexport default from dynamic */ _es_can_key_tree__WEBPACK_IMPORTED_MODULE_43___default.a),
/* harmony export */   "makeMap": () => (/* reexport default from dynamic */ _es_can_make_map__WEBPACK_IMPORTED_MODULE_44___default.a),
/* harmony export */   "parseURI": () => (/* reexport default from dynamic */ _es_can_parse_uri__WEBPACK_IMPORTED_MODULE_45___default.a),
/* harmony export */   "queues": () => (/* reexport default from dynamic */ _es_can_queues__WEBPACK_IMPORTED_MODULE_46___default.a),
/* harmony export */   "string": () => (/* reexport default from dynamic */ _es_can_string__WEBPACK_IMPORTED_MODULE_47___default.a),
/* harmony export */   "stringToAny": () => (/* reexport default from dynamic */ _es_can_string_to_any__WEBPACK_IMPORTED_MODULE_48___default.a),
/* harmony export */   "ajax": () => (/* reexport default from dynamic */ _es_can_ajax__WEBPACK_IMPORTED_MODULE_49___default.a),
/* harmony export */   "attributeEncoder": () => (/* reexport default from dynamic */ _es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_50___default.a),
/* harmony export */   "childNodes": () => (/* reexport default from dynamic */ _es_can_child_nodes__WEBPACK_IMPORTED_MODULE_51___default.a),
/* harmony export */   "domData": () => (/* reexport default from dynamic */ _es_can_dom_data__WEBPACK_IMPORTED_MODULE_52___default.a),
/* harmony export */   "domEvents": () => (/* reexport default from dynamic */ _es_can_dom_events__WEBPACK_IMPORTED_MODULE_53___default.a),
/* harmony export */   "addJQueryEvents": () => (/* reexport default from dynamic */ _es_can_dom_events__WEBPACK_IMPORTED_MODULE_54___default.a),
/* harmony export */   "domMutate": () => (/* reexport default from dynamic */ _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_55___default.a),
/* harmony export */   "domMutateNode": () => (/* reexport default from dynamic */ _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_56___default.a),
/* harmony export */   "domMutateDomEvents": () => (/* reexport default from dynamic */ _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_57___default.a),
/* harmony export */   "fragment": () => (/* reexport default from dynamic */ _es_can_fragment__WEBPACK_IMPORTED_MODULE_58___default.a),
/* harmony export */   "makeInterfaceValidator": () => (/* reexport default from dynamic */ _es_can_validate_interface__WEBPACK_IMPORTED_MODULE_59___default.a),
/* harmony export */   "cid": () => (/* reexport default from dynamic */ can_cid__WEBPACK_IMPORTED_MODULE_60___default.a),
/* harmony export */   "Construct": () => (/* reexport default from dynamic */ can_construct__WEBPACK_IMPORTED_MODULE_61___default.a),
/* harmony export */   "MaybeBoolean": () => (/* reexport default from dynamic */ _es_can_data_types__WEBPACK_IMPORTED_MODULE_62___default.a),
/* harmony export */   "MaybeDate": () => (/* reexport default from dynamic */ _es_can_data_types__WEBPACK_IMPORTED_MODULE_63___default.a),
/* harmony export */   "MaybeNumber": () => (/* reexport default from dynamic */ _es_can_data_types__WEBPACK_IMPORTED_MODULE_64___default.a),
/* harmony export */   "MaybeString": () => (/* reexport default from dynamic */ _es_can_data_types__WEBPACK_IMPORTED_MODULE_65___default.a),
/* harmony export */   "default": () => (/* reexport default from dynamic */ _es_can_namespace__WEBPACK_IMPORTED_MODULE_66___default.a),
/* harmony export */   "can": () => (/* reexport default from dynamic */ _es_can_namespace__WEBPACK_IMPORTED_MODULE_66___default.a),
/* harmony export */   "Reflect": () => (/* reexport default from dynamic */ _es_can_reflect__WEBPACK_IMPORTED_MODULE_67___default.a),
/* harmony export */   "reflectDependencies": () => (/* reexport default from dynamic */ _es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_68___default.a),
/* harmony export */   "reflectPromise": () => (/* reexport default from dynamic */ _es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_69___default.a),
/* harmony export */   "type": () => (/* reexport default from dynamic */ _es_can_type__WEBPACK_IMPORTED_MODULE_70___default.a)
/* harmony export */ });
/* harmony import */ var _es_can_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-value */ "./node_modules/can-value/can-value.js");
/* harmony import */ var _es_can_value__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_es_can_value__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _es_can_observation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-observation */ "./node_modules/can-observation/can-observation.js");
/* harmony import */ var _es_can_observation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_es_can_observation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-observation-recorder */ "./node_modules/can-observation-recorder/can-observation-recorder.js");
/* harmony import */ var _es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _es_can_simple_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-simple-map */ "./node_modules/can-simple-map/can-simple-map.js");
/* harmony import */ var _es_can_simple_map__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_map__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _es_can_observable_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-observable-object */ "./node_modules/can-observable-object/dist/can-observable-object.js");
/* harmony import */ var _es_can_observable_object__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_es_can_observable_object__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _es_can_observable_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-observable-array */ "./node_modules/can-observable-array/dist/can-observable-array.js");
/* harmony import */ var _es_can_observable_array__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_es_can_observable_array__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! can-observable-bindings */ "./node_modules/can-observable-bindings/can-observable-bindings.js");
/* harmony import */ var can_observable_bindings__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _es_can_bind__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-bind */ "./node_modules/can-bind/can-bind.js");
/* harmony import */ var _es_can_bind__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_es_can_bind__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-event-queue */ "./node_modules/can-event-queue/map/map.js");
/* harmony import */ var _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_es_can_event_queue__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _es_can_event_queue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-event-queue */ "./node_modules/can-event-queue/value/value.js");
/* harmony import */ var _es_can_event_queue__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_es_can_event_queue__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/can-simple-observable.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/async/async.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/key/key.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/resolver/resolver.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/settable/settable.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./es/can-simple-observable */ "./node_modules/can-simple-observable/setter/setter.js");
/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_es_can_simple_observable__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _es_can_stache_element__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./es/can-stache-element */ "./node_modules/can-stache-element/dist/can-stache-element.js");
/* harmony import */ var _es_can_stache_element__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_es_can_stache_element__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _es_can_stache__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./es/can-stache */ "./node_modules/can-stache/can-stache.js");
/* harmony import */ var _es_can_stache__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_es_can_stache__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./es/can-stache-bindings */ "./node_modules/can-stache-bindings/can-stache-bindings.js");
/* harmony import */ var _es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./es/can-stache-route-helpers */ "./node_modules/can-stache-route-helpers/can-stache-route-helpers.js");
/* harmony import */ var _es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./es/can-view-callbacks */ "./node_modules/can-view-callbacks/can-view-callbacks.js");
/* harmony import */ var _es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _es_can_view_live__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./es/can-view-live */ "./node_modules/can-view-live/can-view-live.js");
/* harmony import */ var _es_can_view_live__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_live__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _es_can_view_model__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./es/can-view-model */ "./node_modules/can-view-model/can-view-model.js");
/* harmony import */ var _es_can_view_model__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_model__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _es_can_view_parser__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./es/can-view-parser */ "./node_modules/can-view-parser/can-view-parser.js");
/* harmony import */ var _es_can_view_parser__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_parser__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _es_can_view_scope__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./es/can-view-scope */ "./node_modules/can-view-scope/can-view-scope.js");
/* harmony import */ var _es_can_view_scope__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_scope__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _es_can_view_target__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./es/can-view-target */ "./node_modules/can-view-target/can-view-target.js");
/* harmony import */ var _es_can_view_target__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_target__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _es_can_fixture__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./es/can-fixture */ "./node_modules/can-fixture/fixture.js");
/* harmony import */ var _es_can_fixture__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_es_can_fixture__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _es_can_query_logic__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./es/can-query-logic */ "./node_modules/can-query-logic/can-query-logic.js");
/* harmony import */ var _es_can_query_logic__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_es_can_query_logic__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./es/can-realtime-rest-model */ "./node_modules/can-realtime-rest-model/can-realtime-rest-model.js");
/* harmony import */ var _es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _es_can_rest_model__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./es/can-rest-model */ "./node_modules/can-rest-model/can-rest-model.js");
/* harmony import */ var _es_can_rest_model__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_es_can_rest_model__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _es_can_connect__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./es/can-connect */ "./node_modules/can-connect/all.js");
/* harmony import */ var _es_can_connect__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_es_can_connect__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _es_can_local_store__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./es/can-local-store */ "./node_modules/can-local-store/can-local-store.js");
/* harmony import */ var _es_can_local_store__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_es_can_local_store__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var _es_can_memory_store__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./es/can-memory-store */ "./node_modules/can-memory-store/can-memory-store.js");
/* harmony import */ var _es_can_memory_store__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(_es_can_memory_store__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var _es_can_route__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./es/can-route */ "./node_modules/can-route/can-route.js");
/* harmony import */ var _es_can_route__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(_es_can_route__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var _es_can_route_hash__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./es/can-route-hash */ "./node_modules/can-route-hash/can-route-hash.js");
/* harmony import */ var _es_can_route_hash__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(_es_can_route_hash__WEBPACK_IMPORTED_MODULE_34__);
/* harmony import */ var _es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./es/can-route-pushstate */ "./node_modules/can-route-pushstate/can-route-pushstate.js");
/* harmony import */ var _es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(_es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_35__);
/* harmony import */ var _es_can_param__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./es/can-param */ "./node_modules/can-param/can-param.js");
/* harmony import */ var _es_can_param__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/__webpack_require__.n(_es_can_param__WEBPACK_IMPORTED_MODULE_36__);
/* harmony import */ var _es_can_deparam__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./es/can-deparam */ "./node_modules/can-deparam/can-deparam.js");
/* harmony import */ var _es_can_deparam__WEBPACK_IMPORTED_MODULE_37___default = /*#__PURE__*/__webpack_require__.n(_es_can_deparam__WEBPACK_IMPORTED_MODULE_37__);
/* harmony import */ var _es_can_assign__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./es/can-assign */ "./node_modules/can-assign/can-assign.js");
/* harmony import */ var _es_can_assign__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(_es_can_assign__WEBPACK_IMPORTED_MODULE_38__);
/* harmony import */ var _es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./es/can-define-lazy-value */ "./node_modules/can-define-lazy-value/define-lazy-value.js");
/* harmony import */ var _es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_39__);
/* harmony import */ var _es_can_diff__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./es/can-diff */ "./node_modules/can-diff/can-diff.js");
/* harmony import */ var _es_can_diff__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(_es_can_diff__WEBPACK_IMPORTED_MODULE_40__);
/* harmony import */ var _es_can_globals__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./es/can-globals */ "./node_modules/can-globals/can-globals.js");
/* harmony import */ var _es_can_globals__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(_es_can_globals__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var _es_can_key__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./es/can-key */ "./node_modules/can-key/can-key.js");
/* harmony import */ var _es_can_key__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(_es_can_key__WEBPACK_IMPORTED_MODULE_42__);
/* harmony import */ var _es_can_key_tree__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./es/can-key-tree */ "./node_modules/can-key-tree/can-key-tree.js");
/* harmony import */ var _es_can_key_tree__WEBPACK_IMPORTED_MODULE_43___default = /*#__PURE__*/__webpack_require__.n(_es_can_key_tree__WEBPACK_IMPORTED_MODULE_43__);
/* harmony import */ var _es_can_make_map__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./es/can-make-map */ "./node_modules/can-make-map/can-make-map.js");
/* harmony import */ var _es_can_make_map__WEBPACK_IMPORTED_MODULE_44___default = /*#__PURE__*/__webpack_require__.n(_es_can_make_map__WEBPACK_IMPORTED_MODULE_44__);
/* harmony import */ var _es_can_parse_uri__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./es/can-parse-uri */ "./node_modules/can-parse-uri/can-parse-uri.js");
/* harmony import */ var _es_can_parse_uri__WEBPACK_IMPORTED_MODULE_45___default = /*#__PURE__*/__webpack_require__.n(_es_can_parse_uri__WEBPACK_IMPORTED_MODULE_45__);
/* harmony import */ var _es_can_queues__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./es/can-queues */ "./node_modules/can-queues/can-queues.js");
/* harmony import */ var _es_can_queues__WEBPACK_IMPORTED_MODULE_46___default = /*#__PURE__*/__webpack_require__.n(_es_can_queues__WEBPACK_IMPORTED_MODULE_46__);
/* harmony import */ var _es_can_string__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./es/can-string */ "./node_modules/can-string/can-string.js");
/* harmony import */ var _es_can_string__WEBPACK_IMPORTED_MODULE_47___default = /*#__PURE__*/__webpack_require__.n(_es_can_string__WEBPACK_IMPORTED_MODULE_47__);
/* harmony import */ var _es_can_string_to_any__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./es/can-string-to-any */ "./node_modules/can-string-to-any/can-string-to-any.js");
/* harmony import */ var _es_can_string_to_any__WEBPACK_IMPORTED_MODULE_48___default = /*#__PURE__*/__webpack_require__.n(_es_can_string_to_any__WEBPACK_IMPORTED_MODULE_48__);
/* harmony import */ var _es_can_ajax__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./es/can-ajax */ "./node_modules/can-ajax/can-ajax.js");
/* harmony import */ var _es_can_ajax__WEBPACK_IMPORTED_MODULE_49___default = /*#__PURE__*/__webpack_require__.n(_es_can_ajax__WEBPACK_IMPORTED_MODULE_49__);
/* harmony import */ var _es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./es/can-attribute-encoder */ "./node_modules/can-attribute-encoder/can-attribute-encoder.js");
/* harmony import */ var _es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_50___default = /*#__PURE__*/__webpack_require__.n(_es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_50__);
/* harmony import */ var _es_can_child_nodes__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./es/can-child-nodes */ "./node_modules/can-child-nodes/can-child-nodes.js");
/* harmony import */ var _es_can_child_nodes__WEBPACK_IMPORTED_MODULE_51___default = /*#__PURE__*/__webpack_require__.n(_es_can_child_nodes__WEBPACK_IMPORTED_MODULE_51__);
/* harmony import */ var _es_can_dom_data__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./es/can-dom-data */ "./node_modules/can-dom-data/can-dom-data.js");
/* harmony import */ var _es_can_dom_data__WEBPACK_IMPORTED_MODULE_52___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_data__WEBPACK_IMPORTED_MODULE_52__);
/* harmony import */ var _es_can_dom_events__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./es/can-dom-events */ "./node_modules/can-dom-events/can-dom-events.js");
/* harmony import */ var _es_can_dom_events__WEBPACK_IMPORTED_MODULE_53___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_events__WEBPACK_IMPORTED_MODULE_53__);
/* harmony import */ var _es_can_dom_events__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./es/can-dom-events */ "./node_modules/can-dom-events/helpers/add-jquery-events.js");
/* harmony import */ var _es_can_dom_events__WEBPACK_IMPORTED_MODULE_54___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_events__WEBPACK_IMPORTED_MODULE_54__);
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./es/can-dom-mutate */ "./node_modules/can-dom-mutate/can-dom-mutate.js");
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_55___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_55__);
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./es/can-dom-mutate */ "./node_modules/can-dom-mutate/node.js");
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_56___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_56__);
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./es/can-dom-mutate */ "./node_modules/can-dom-mutate/dom-events.js");
/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_57___default = /*#__PURE__*/__webpack_require__.n(_es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_57__);
/* harmony import */ var _es_can_fragment__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./es/can-fragment */ "./node_modules/can-fragment/can-fragment.js");
/* harmony import */ var _es_can_fragment__WEBPACK_IMPORTED_MODULE_58___default = /*#__PURE__*/__webpack_require__.n(_es_can_fragment__WEBPACK_IMPORTED_MODULE_58__);
/* harmony import */ var _es_can_validate_interface__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./es/can-validate-interface */ "./node_modules/can-validate-interface/index.js");
/* harmony import */ var _es_can_validate_interface__WEBPACK_IMPORTED_MODULE_59___default = /*#__PURE__*/__webpack_require__.n(_es_can_validate_interface__WEBPACK_IMPORTED_MODULE_59__);
/* harmony import */ var can_cid__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! can-cid */ "./node_modules/can-cid/can-cid.js");
/* harmony import */ var can_cid__WEBPACK_IMPORTED_MODULE_60___default = /*#__PURE__*/__webpack_require__.n(can_cid__WEBPACK_IMPORTED_MODULE_60__);
/* harmony import */ var can_construct__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! can-construct */ "./node_modules/can-construct/can-construct.js");
/* harmony import */ var can_construct__WEBPACK_IMPORTED_MODULE_61___default = /*#__PURE__*/__webpack_require__.n(can_construct__WEBPACK_IMPORTED_MODULE_61__);
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./es/can-data-types */ "./node_modules/can-data-types/maybe-boolean/maybe-boolean.js");
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_62___default = /*#__PURE__*/__webpack_require__.n(_es_can_data_types__WEBPACK_IMPORTED_MODULE_62__);
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./es/can-data-types */ "./node_modules/can-data-types/maybe-date/maybe-date.js");
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_63___default = /*#__PURE__*/__webpack_require__.n(_es_can_data_types__WEBPACK_IMPORTED_MODULE_63__);
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./es/can-data-types */ "./node_modules/can-data-types/maybe-number/maybe-number.js");
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_64___default = /*#__PURE__*/__webpack_require__.n(_es_can_data_types__WEBPACK_IMPORTED_MODULE_64__);
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./es/can-data-types */ "./node_modules/can-data-types/maybe-string/maybe-string.js");
/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_65___default = /*#__PURE__*/__webpack_require__.n(_es_can_data_types__WEBPACK_IMPORTED_MODULE_65__);
/* harmony import */ var _es_can_namespace__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./es/can-namespace */ "./node_modules/can-namespace/can-namespace.js");
/* harmony import */ var _es_can_namespace__WEBPACK_IMPORTED_MODULE_66___default = /*#__PURE__*/__webpack_require__.n(_es_can_namespace__WEBPACK_IMPORTED_MODULE_66__);
/* harmony import */ var _es_can_reflect__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./es/can-reflect */ "./node_modules/can-reflect/can-reflect.js");
/* harmony import */ var _es_can_reflect__WEBPACK_IMPORTED_MODULE_67___default = /*#__PURE__*/__webpack_require__.n(_es_can_reflect__WEBPACK_IMPORTED_MODULE_67__);
/* harmony import */ var _es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./es/can-reflect-dependencies */ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js");
/* harmony import */ var _es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_68___default = /*#__PURE__*/__webpack_require__.n(_es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_68__);
/* harmony import */ var _es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./es/can-reflect-promise */ "./node_modules/can-reflect-promise/can-reflect-promise.js");
/* harmony import */ var _es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_69___default = /*#__PURE__*/__webpack_require__.n(_es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_69__);
/* harmony import */ var _es_can_type__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./es/can-type */ "./node_modules/can/node_modules/can-type/can-type.js");
/* harmony import */ var _es_can_type__WEBPACK_IMPORTED_MODULE_70___default = /*#__PURE__*/__webpack_require__.n(_es_can_type__WEBPACK_IMPORTED_MODULE_70__);
// __ Observables __

// -> Core








// -> Infrastruture





// __ Views __


// -> Core




// -> Infrastruture








// __ Data Models __

// -> Core





// -> Infrastruture





// __ Routing __

// -> Core




// -> Infrastruture




// __ JS Utilities __

// -> Infrastruture













// __ DOM Utilities __

// -> Infrastruture









// __ Data Validation

// -> Infrastruture



// __ Typed Data __

// -> Infrastruture








// __ Data Validation__
// -> Core


// __ Enable Devtools __
//!steal-remove-start

//!steal-remove-end


/***/ }),

/***/ "./node_modules/can/ecosystem.js":
/*!***************************************!*\
  !*** ./node_modules/can/ecosystem.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* reexport default from dynamic */ _es_can_debug__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "defineBackup": () => (/* reexport default from dynamic */ _es_can_define_backup__WEBPACK_IMPORTED_MODULE_1___default.a),
/* harmony export */   "defineStream": () => (/* reexport default from dynamic */ _es_can_define_stream__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   "defineStreamKefir": () => (/* reexport default from dynamic */ _es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3___default.a),
/* harmony export */   "kefir": () => (/* reexport default from dynamic */ _es_can_kefir__WEBPACK_IMPORTED_MODULE_4___default.a),
/* harmony export */   "Kefir": () => (/* reexport default from dynamic */ _es_can_kefir__WEBPACK_IMPORTED_MODULE_4___default.a),
/* harmony export */   "observe": () => (/* reexport default from dynamic */ _es_can_observe__WEBPACK_IMPORTED_MODULE_5___default.a),
/* harmony export */   "stream": () => (/* reexport default from dynamic */ _es_can_stream__WEBPACK_IMPORTED_MODULE_6___default.a),
/* harmony export */   "streamKefir": () => (/* reexport default from dynamic */ _es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7___default.a),
/* harmony export */   "makeMapCompat": () => (/* reexport default from dynamic */ _es_can_map_compat__WEBPACK_IMPORTED_MODULE_8___default.a),
/* harmony export */   "stacheConverters": () => (/* reexport default from dynamic */ _es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9___default.a),
/* harmony export */   "viewAutorender": () => (/* reexport default from dynamic */ _es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10___default.a),
/* harmony export */   "superModel": () => (/* reexport default from dynamic */ _es_can_super_model__WEBPACK_IMPORTED_MODULE_11___default.a),
/* harmony export */   "connectTag": () => (/* reexport default from dynamic */ _es_can_connect_tag__WEBPACK_IMPORTED_MODULE_12___default.a),
/* harmony export */   "fixtureSocket": () => (/* reexport default from dynamic */ _es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_13___default.a),
/* harmony export */   "ndjsonStream": () => (/* reexport default from dynamic */ _es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_14___default.a),
/* harmony export */   "connectNDJSON": () => (/* reexport default from dynamic */ _es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_15___default.a),
/* harmony export */   "connectCanSession": () => (/* reexport default from dynamic */ _es_can_connect_session__WEBPACK_IMPORTED_MODULE_16___default.a),
/* harmony export */   "constructSuper": () => (/* reexport default from dynamic */ _es_can_construct_super__WEBPACK_IMPORTED_MODULE_17___default.a),
/* harmony export */   "RouteMock": () => (/* reexport default from dynamic */ _es_can_route_mock__WEBPACK_IMPORTED_MODULE_18___default.a),
/* harmony export */   "validate": () => (/* reexport default from dynamic */ _es_can_validate__WEBPACK_IMPORTED_MODULE_19___default.a),
/* harmony export */   "validateValidatejs": () => (/* reexport default from dynamic */ _es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_20___default.a),
/* harmony export */   "DeepObservable": () => (/* reexport default from dynamic */ _es_can_deep_observable__WEBPACK_IMPORTED_MODULE_21___default.a),
/* harmony export */   "radioChangeEvent": () => (/* reexport default from dynamic */ _es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_22___default.a),
/* harmony export */   "enterEvent": () => (/* reexport default from dynamic */ _es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_23___default.a),
/* harmony export */   "observableMixin": () => (/* reexport default export from named module */ _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_24__),
/* harmony export */   "defineMixin": () => (/* reexport default export from named module */ _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_24__)
/* harmony export */ });
/* harmony import */ var _es_can_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-debug */ "./node_modules/can-debug/can-debug.js");
/* harmony import */ var _es_can_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_es_can_debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _es_can_define_backup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-define-backup */ "./node_modules/can-define-backup/can-define-backup.js");
/* harmony import */ var _es_can_define_backup__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_backup__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _es_can_define_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-define-stream */ "./node_modules/can-define-stream/can-define-stream.js");
/* harmony import */ var _es_can_define_stream__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_stream__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-define-stream-kefir */ "./node_modules/can-define-stream-kefir/can-define-stream-kefir.js");
/* harmony import */ var _es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _es_can_kefir__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-kefir */ "./node_modules/can-kefir/can-kefir.js");
/* harmony import */ var _es_can_kefir__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_es_can_kefir__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _es_can_observe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-observe */ "./node_modules/can-observe/can-observe.js");
/* harmony import */ var _es_can_observe__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_es_can_observe__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _es_can_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./es/can-stream */ "./node_modules/can-stream/can-stream.js");
/* harmony import */ var _es_can_stream__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_es_can_stream__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-stream-kefir */ "./node_modules/can-stream-kefir/can-stream-kefir.js");
/* harmony import */ var _es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _es_can_map_compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-map-compat */ "./node_modules/can-map-compat/can-map-compat.js");
/* harmony import */ var _es_can_map_compat__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_es_can_map_compat__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-stache-converters */ "./node_modules/can-stache-converters/can-stache-converters.js");
/* harmony import */ var _es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./es/can-view-autorender */ "./node_modules/can-view-autorender/can-view-autorender.js");
/* harmony import */ var _es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _es_can_super_model__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./es/can-super-model */ "./node_modules/can-super-model/can-super-model.js");
/* harmony import */ var _es_can_super_model__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_es_can_super_model__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _es_can_connect_tag__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./es/can-connect-tag */ "./node_modules/can-connect-tag/can-connect-tag.js");
/* harmony import */ var _es_can_connect_tag__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_es_can_connect_tag__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./es/can-fixture-socket */ "./node_modules/can-fixture-socket/can-fixture-socket.js");
/* harmony import */ var _es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./es/can-ndjson-stream */ "./node_modules/can-ndjson-stream/can-ndjson-stream.js");
/* harmony import */ var _es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./es/can-connect-ndjson */ "./node_modules/can-connect-ndjson/can-connect-ndjson.js");
/* harmony import */ var _es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _es_can_connect_session__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./es/can-connect-session */ "./node_modules/can-connect/can/session/session.js");
/* harmony import */ var _es_can_connect_session__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_es_can_connect_session__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _es_can_construct_super__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./es/can-construct-super */ "./node_modules/can-construct-super/can-construct-super.js");
/* harmony import */ var _es_can_construct_super__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_es_can_construct_super__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _es_can_route_mock__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./es/can-route-mock */ "./node_modules/can-route-mock/can-route-mock.js");
/* harmony import */ var _es_can_route_mock__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_es_can_route_mock__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _es_can_validate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./es/can-validate */ "./node_modules/can-validate/can-validate.js");
/* harmony import */ var _es_can_validate__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_es_can_validate__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./es/can-validate-validatejs */ "./node_modules/can-validate-validatejs/can-validate-validatejs.js");
/* harmony import */ var _es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _es_can_deep_observable__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./es/can-deep-observable */ "./node_modules/can-deep-observable/can-deep-observable.js");
/* harmony import */ var _es_can_deep_observable__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_es_can_deep_observable__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./es/can-event-dom-radiochange */ "./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js");
/* harmony import */ var _es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./es/can-event-dom-enter */ "./node_modules/can-event-dom-enter/can-event-dom-enter.js");
/* harmony import */ var _es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./es/can-observable-mixin */ "./node_modules/can-observable-mixin/dist/mixins.js");
// Observables










// Views




// Data Modeling







// Typed Data


// Routing



// Data Validation




// DOM Utilities



 // legacy


/***/ }),

/***/ "./node_modules/can/legacy.js":
/*!************************************!*\
  !*** ./node_modules/can/legacy.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "define": () => (/* reexport default from dynamic */ _es_can_define__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "DefineMap": () => (/* reexport default from dynamic */ _es_can_define__WEBPACK_IMPORTED_MODULE_1___default.a),
/* harmony export */   "DefineList": () => (/* reexport default from dynamic */ _es_can_define__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   "defineRealtimeRestModel": () => (/* reexport default from dynamic */ _es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_3___default.a),
/* harmony export */   "defineRestModel": () => (/* reexport default from dynamic */ _es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_4___default.a),
/* harmony export */   "compute": () => (/* reexport default from dynamic */ _es_can_compute__WEBPACK_IMPORTED_MODULE_5___default.a),
/* harmony export */   "CanMap": () => (/* reexport default from dynamic */ _es_can_map__WEBPACK_IMPORTED_MODULE_6___default.a),
/* harmony export */   "CanList": () => (/* reexport default from dynamic */ _es_can_list__WEBPACK_IMPORTED_MODULE_7___default.a),
/* harmony export */   "canMapDefine": () => (/* reexport default from dynamic */ _es_can_map_define__WEBPACK_IMPORTED_MODULE_8___default.a),
/* harmony export */   "Component": () => (/* reexport default from dynamic */ _es_can_component__WEBPACK_IMPORTED_MODULE_9___default.a),
/* harmony export */   "set": () => (/* reexport default from dynamic */ _es_can_set_legacy__WEBPACK_IMPORTED_MODULE_10___default.a),
/* harmony export */   "Control": () => (/* reexport default from dynamic */ _es_can_control__WEBPACK_IMPORTED_MODULE_11___default.a)
/* harmony export */ });
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-define */ "./node_modules/can-define/can-define.js");
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_es_can_define__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-define */ "./node_modules/can-define/map/map.js");
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_es_can_define__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-define */ "./node_modules/can-define/list/list.js");
/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_es_can_define__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-define-realtime-rest-model */ "./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js");
/* harmony import */ var _es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-define-rest-model */ "./node_modules/can-define-rest-model/can-define-rest-model.js");
/* harmony import */ var _es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _es_can_compute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-compute */ "./node_modules/can-compute/can-compute.js");
/* harmony import */ var _es_can_compute__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_es_can_compute__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _es_can_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./es/can-map */ "./node_modules/can-map/can-map.js");
/* harmony import */ var _es_can_map__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_es_can_map__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _es_can_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-list */ "./node_modules/can-list/can-list.js");
/* harmony import */ var _es_can_list__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_es_can_list__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _es_can_map_define__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-map-define */ "./node_modules/can-map-define/can-map-define.js");
/* harmony import */ var _es_can_map_define__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_es_can_map_define__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _es_can_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-component */ "./node_modules/can-component/can-component.js");
/* harmony import */ var _es_can_component__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_es_can_component__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _es_can_set_legacy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./es/can-set-legacy */ "./node_modules/can-set-legacy/can-set-legacy.js");
/* harmony import */ var _es_can_set_legacy__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_es_can_set_legacy__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _es_can_control__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./es/can-control */ "./node_modules/can-control/can-control.js");
/* harmony import */ var _es_can_control__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_es_can_control__WEBPACK_IMPORTED_MODULE_11__);
// Observables








// Views


// Data Models


// DOM Utilities



/***/ }),

/***/ "./node_modules/can/node_modules/can-type/can-type.js":
/*!************************************************************!*\
  !*** ./node_modules/can/node_modules/can-type/can-type.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var canReflect = __webpack_require__(/*! can-reflect */ "./node_modules/can-reflect/can-reflect.js");
var canSymbol = __webpack_require__(/*! can-symbol */ "./node_modules/can-symbol/can-symbol.js");
var canString = __webpack_require__(/*! can-string */ "./node_modules/can-string/can-string.js");
var namespace = __webpack_require__(/*! can-namespace */ "./node_modules/can-namespace/can-namespace.js");

var isMemberSymbol = canSymbol.for("can.isMember");
var newSymbol = canSymbol.for("can.new");
var getSchemaSymbol = canSymbol.for("can.getSchema");
var baseTypeSymbol = canSymbol.for("can.baseType");
var strictTypeOfSymbol = canSymbol.for("can.strictTypeOf");

var type = exports;

function makeSchema(values) {
	return function(){
		return {
			type: "Or",
			values: values
		};
	};
}

// Default "can.new"
function canNew(value) {
	if(this[isMemberSymbol](value)) {
		return value;
	}

	return canReflect.convert(value, this[baseTypeSymbol]);
}

function strictNew(value) {
	var isMember = this[isMemberSymbol](value);
	if(!isMember) {
		return check(this[baseTypeSymbol], value);
	}
	return value;
}

// "can.new" for Booleans
function booleanNew(value) {
	if (value === "false" || value=== "0") {
		return false;
	}
	return Boolean(value);
}

var maybeValues = Object.freeze([null, undefined]);

function check(Type, val) {
	var valueType = canString.capitalize(typeof val);
	var error = new Error('Type value ' + typeof val === "string" ? '"' + val + '"' : val + ' (' + valueType + ') is not of type ' + canReflect.getName(Type) + '.'	);
	error.type = 'can-type-error';
	throw error;
}

function makeIsMember(Type) {
	if(isMemberSymbol in Type) {
		return Type[isMemberSymbol];
	}
	return function(value) {
		return value instanceof Type;
	};
}

function makeBaseType(Type) {
	var typeObject = {};
	typeObject[newSymbol] = canNew;
	typeObject[isMemberSymbol] = makeIsMember(Type);
	typeObject[baseTypeSymbol] = Type;
	typeObject[getSchemaSymbol] = makeSchema([Type]);
	Type[strictTypeOfSymbol] = typeObject[strictTypeOfSymbol] = typeObject;
	return typeObject;
}

function makePrimitiveType(Type, typeString) {
	var typeObject = makeBaseType(Type);
	if(Type === Boolean) {
		typeObject[newSymbol] = booleanNew;
		typeObject[getSchemaSymbol] = makeSchema([true, false]);
	}
	typeObject[isMemberSymbol] = function(value) {
		return typeof value === typeString;
	};
	return typeObject;
}

function getBaseType(Type) {
	if(typeof Type === "function") {
		if(canReflect.hasOwnKey(Type, strictTypeOfSymbol)) {
			return Type[strictTypeOfSymbol];
		}
	} else if(strictTypeOfSymbol in Type) {
		return Type[strictTypeOfSymbol];
	}
	return makeBaseType(Type);
}

function makeMaybe(Type) {
	var isMember = Type[isMemberSymbol];
	return function(value) {
		return value == null || isMember.call(this, value);
	};
}

function makeMaybeSchema(baseType) {
	var baseSchema = canReflect.getSchema(baseType);
	var allValues = baseSchema.values.concat(maybeValues);
	return makeSchema(allValues);
}

function inheritFrom(o, Type, property) {
	if(property in Type) {
		o[property] = Type[property];
	}
}

function wrapName(wrapper, Type) {
	var baseName = canReflect.getName(Type);
	return "type." + wrapper + "(" + baseName + ")";
}

canReflect.each({
	"boolean": Boolean,
	"number": Number,
	"string": String
}, function(Type, typeString) {
	makePrimitiveType(Type, typeString);
});

function isTypeObject(Type) {
	if(canReflect.isPrimitive(Type)) {
		return false;
	}

	return (newSymbol in Type) && (isMemberSymbol in Type);
}

function normalize(Type) {
	if(canReflect.isPrimitive(Type)) {
		throw new Error("can-type: Unable to normalize primitive values.");
	} else if(isTypeObject(Type)) {
		return Type;
	} else {
		return type.check(Type);
	}
}

function late(fn) {
	var lateType = {};
	var underlyingType;
	var unwrap = function() {
		underlyingType = type.normalize(fn());
		unwrap = function() { return underlyingType; };
		return underlyingType;
	};
	return canReflect.assignSymbols(lateType, {
		"can.new": function(val) {
			return canReflect.new(unwrap(), val);
		},
		"can.isMember": function(val) {
			return unwrap()[isMemberSymbol](val);
		}
	});
}

var Any = canReflect.assignSymbols({}, {
	"can.new": function(val) { return val; },
	"can.isMember": function() { return true; }
});

function all(typeFn, Type) {
	var typeObject = typeFn(Type);
	typeObject[getSchemaSymbol] = function() {
		var parentSchema = canReflect.getSchema(Type);
		var schema = canReflect.assignMap({}, parentSchema);
		schema.keys = {};
		canReflect.eachKey(parentSchema.keys, function(value, key) {
			schema.keys[key] = typeFn(value);
		});
		return schema;
	};

	function Constructor(values) {
		var schema = canReflect.getSchema(this);
		var keys = schema.keys;
		var convertedValues = {};
		canReflect.eachKey(values || {}, function(value, key) {
			convertedValues[key] = canReflect.convert(value, keys[key]);
		});
		return canReflect.new(Type, convertedValues);
	}

	canReflect.setName(Constructor, "Converted<" + canReflect.getName(Type) + ">");
	Constructor.prototype = typeObject;

	return Constructor;
}

var Integer = {};
Integer[newSymbol] = function(value) {
	// parseInt(notANumber) returns NaN
	// Since we always want an integer returned
	// using |0 instead.
	return value | 0;
};
Integer[isMemberSymbol] = function(value) {
	// “polyfill” for Number.isInteger because it’s not supported in IE11
	return typeof value === "number" && isFinite(value) &&
		Math.floor(value) === value;
};
Integer[getSchemaSymbol] = makeSchema([Number]);
canReflect.setName(Integer, "Integer");

function makeCache(fn) {
	var cache = new WeakMap();
	return function(Type) {
		if(cache.has(Type)) {
			return cache.get(Type);
		}
		var typeObject = fn.call(this, Type);
		cache.set(Type, typeObject);
		return typeObject;
	};
}

exports.check = makeCache(function(Type) {
	var o = Object.create(getBaseType(Type));
	o[newSymbol] = strictNew;
	inheritFrom(o, Type, isMemberSymbol);
	inheritFrom(o, Type, getSchemaSymbol);
	canReflect.setName(o, wrapName("check", Type));
	return o;
});

exports.convert = makeCache(function(Type) {
	var o = Object.create(getBaseType(Type));
	inheritFrom(o, Type, isMemberSymbol);
	inheritFrom(o, Type, getSchemaSymbol);
	canReflect.setName(o, wrapName("convert", Type));
	return o;
});

exports.maybe = makeCache(function(Type) {
	var baseType = getBaseType(Type);
	var desc = {};
	desc[newSymbol] = {
		value: strictNew
	};
	desc[isMemberSymbol] = {
		value: makeMaybe(baseType)
	};
	desc[getSchemaSymbol] = {
		value: makeMaybeSchema(baseType)
	};
	var o = Object.create(baseType, desc);
	canReflect.setName(o, wrapName("maybe", Type));
	return o;
});

exports.maybeConvert = makeCache(function(Type) {
	var baseType = getBaseType(Type);
	var desc = {};
	desc[isMemberSymbol] = {
		value: makeMaybe(baseType)
	};
	desc[getSchemaSymbol] = {
		value: makeMaybeSchema(baseType)
	};
	var o = Object.create(baseType, desc);
	canReflect.setName(o, wrapName("maybeConvert", Type));
	return o;
});

//!steal-remove-start
// type checking should not throw in production
if(false) {}
//!steal-remove-end

exports.Any = Any;
exports.Integer = Integer;

exports.late = late;
exports.isTypeObject = isTypeObject;
exports.normalize = normalize;
exports.all = all;
exports.convertAll = all.bind(null, exports.convert);
namespace.type = exports;


/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#index*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.store = exports.remember = exports.page = exports.inertia = exports.InertiaLink = exports.Link = exports.InertiaApp = exports.App = undefined;
var _inertiaApp = __webpack_require__(/*! ./inertia-app.js */ "./node_modules/inertia-can/dist/cjs/inertia-app.js");
Object.defineProperty(exports, "App", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_inertiaApp).default;
    }
}));
Object.defineProperty(exports, "InertiaApp", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_inertiaApp).default;
    }
}));
var _link = __webpack_require__(/*! ./link.js */ "./node_modules/inertia-can/dist/cjs/link.js");
Object.defineProperty(exports, "Link", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_link).default;
    }
}));
Object.defineProperty(exports, "InertiaLink", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_link).default;
    }
}));
Object.defineProperty(exports, "inertia", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_link).default;
    }
}));
var _page = __webpack_require__(/*! ./page.js */ "./node_modules/inertia-can/dist/cjs/page.js");
Object.defineProperty(exports, "page", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_page).default;
    }
}));
var _remember = __webpack_require__(/*! ./remember.js */ "./node_modules/inertia-can/dist/cjs/remember.js");
Object.defineProperty(exports, "remember", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_remember).default;
    }
}));
var _store = __webpack_require__(/*! ./store.js */ "./node_modules/inertia-can/dist/cjs/store.js");
Object.defineProperty(exports, "store", ({
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_store).default;
    }
}));
__webpack_require__(/*! ./ziggy-helper.js */ "./node_modules/inertia-can/dist/cjs/ziggy-helper.js");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/inertia-app.js":
/*!**********************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/inertia-app.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#inertia-app*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _inertia = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
var _store = __webpack_require__(/*! ./store.js */ "./node_modules/inertia-can/dist/cjs/store.js");
var _store2 = _interopRequireDefault(_store);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
function _asyncToGenerator(fn) {
    return function () {
        var gen = fn.apply(this, arguments);
        return new Promise(function (resolve, reject) {
            function step(key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                } else {
                    return Promise.resolve(value).then(function (value) {
                        step('next', value);
                    }, function (err) {
                        step('throw', err);
                    });
                }
            }
            return step('next');
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
    }
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var InertiaApp = function (_StacheElement) {
    _inherits(InertiaApp, _StacheElement);
    function InertiaApp() {
        _classCallCheck(this, InertiaApp);
        return _possibleConstructorReturn(this, (InertiaApp.__proto__ || Object.getPrototypeOf(InertiaApp)).apply(this, arguments));
    }
    _createClass(InertiaApp, [
        {
            key: 'connected',
            value: function connected() {
                var _this2 = this;
                _inertia.Inertia.init({
                    initialPage: this.initialPage,
                    resolveComponent: this.resolveComponent,
                    transformProps: this.transformProps,
                    swapComponent: function () {
                        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref) {
                            var component = _ref.component, page = _ref.page, preserveState = _ref.preserveState;
                            return regeneratorRuntime.wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                    case 0:
                                        _this2.preserveState = preserveState;
                                        _can.queues.batch.start();
                                        _can.Reflect.update(_store2.default, {
                                            component: preserveState && _store2.default.component instanceof component ? _store2.default.component : new component(),
                                            page: page,
                                            key: preserveState ? _store2.default.key : Date.now()
                                        });
                                        _can.Reflect.eachKey(page.props, function (val, prop) {
                                            _can.Reflect.setKeyValue(_store2.default.component, prop, val);
                                        });
                                        _can.queues.batch.stop();
                                    case 5:
                                    case 'end':
                                        return _context.stop();
                                    }
                                }
                            }, _callee, _this2);
                        }));
                        function swapComponent(_x) {
                            return _ref2.apply(this, arguments);
                        }
                        return swapComponent;
                    }()
                });
            }
        },
        {
            key: 'component',
            get: function get() {
                return _store2.default.component && _store2.default.component.layout || _store2.default.component;
            }
        }
    ]);
    return InertiaApp;
}(_can.StacheElement);
InertiaApp.view = '\n            {{# if (this.component) }}\n                {{ this.component }}\n            {{/ if }}\n        ';
InertiaApp.props = {
    initialPage: {
        type: Object,
        required: true
    },
    resolveComponent: {
        type: Function,
        required: true
    },
    transformProps: {
        type: Function,
        default: function _default(props) {
            return props;
        }
    }
};
exports.default = InertiaApp;
customElements.define('inertia-app', InertiaApp);
//# sourceMappingURL=inertia-app.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/link.js":
/*!***************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/link.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#link*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _inertia = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
    }
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Link = function (_StacheElement) {
    _inherits(Link, _StacheElement);
    function Link() {
        _classCallCheck(this, Link);
        return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
    }
    _createClass(Link, [
        {
            key: 'visit',
            value: function visit(event) {
                this.dispatch('click', [event]);
                if ((0, _inertia.shouldIntercept)(event)) {
                    event.preventDefault();
                    _inertia.Inertia.visit(this.href, {
                        data: this.data,
                        method: this.method,
                        preserveScroll: this.preserveScroll,
                        preserveState: this.preserveState,
                        replace: this.replace,
                        only: this.only,
                        headers: this.headers
                    });
                }
            }
        },
        {
            key: 'hasClasses',
            value: function hasClasses() {
                return typeof this.classname === 'string';
            }
        }
    ]);
    return Link;
}(_can.StacheElement);
Link.view = '\n            <a\n                href="{{this.href}}"\n                on:el:click="this.visit(scope.event)"\n                {{# if (this.hasClasses()) }}\n                    class:from="this.classname"\n                {{/ if }}\n            >\n                {{ this.linkTemplate() }}\n            </a>\n    ';
Link.pros = {
    data: { type: _can.type.maybeConvert(_can.DeepObservable) },
    href: { type: String },
    method: {
        type: String,
        default: 'get'
    },
    replace: {
        type: Boolean,
        default: false
    },
    preserveScroll: {
        type: Boolean,
        default: false
    },
    preserveState: {
        type: Boolean,
        default: false
    },
    only: { type: _can.type.maybeConvert(_can.DeepObservable) },
    headers: { type: _can.type.maybeConvert(_can.DeepObservable) },
    linkTemplate: {
        type: Function,
        required: true
    },
    classname: { type: _can.type.maybeConvert(String) }
};
exports.default = Link;
customElements.define('inertia-link', Link);
//# sourceMappingURL=link.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/page.js":
/*!***************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/page.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#page*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
var _store = __webpack_require__(/*! ./store.js */ "./node_modules/inertia-can/dist/cjs/store.js");
var _store2 = _interopRequireDefault(_store);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
var page = new _can.Observation(function observeProps() {
    return _store2.default.page;
});
exports.default = page;
//# sourceMappingURL=page.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/remember.js":
/*!*******************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/remember.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#remember*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
var _inertia = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
var remember = function remember(initialState, key) {
    var restored = _inertia.Inertia.restore(key);
    var store = _can.Reflect.new(_can.DeepObservable, restored !== undefined ? restored : initialState);
    _can.Reflect.onPatches(store, function (patches) {
        var state = _can.Reflect.unwrap(store);
        _inertia.Inertia.remember(state, key);
    });
    return store;
};
exports.default = remember;
//# sourceMappingURL=remember.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/store.js":
/*!****************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/store.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#store*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
var store = _can.Reflect.new(_can.DeepObservable, {
    component: null,
    page: {},
    key: null
});
exports.default = store;
//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./node_modules/inertia-can/dist/cjs/ziggy-helper.js":
/*!***********************************************************!*\
  !*** ./node_modules/inertia-can/dist/cjs/ziggy-helper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*inertia-can@0.0.4#ziggy-helper*/

var _can = __webpack_require__(/*! can */ "./node_modules/can/can.js");
if (window && window.route) {
    _can.stache.addHelper('ziggyRoute', function (name, params, absolute) {
        return route(name, params, absolute);
    });
}
//# sourceMappingURL=ziggy-helper.js.map

/***/ }),

/***/ "./node_modules/kefir/dist/kefir.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/kefir/dist/kefir.esm.js ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dissableDeprecationWarnings": () => (/* binding */ dissableDeprecationWarnings),
/* harmony export */   "Kefir": () => (/* binding */ Kefir),
/* harmony export */   "Observable": () => (/* binding */ Observable),
/* harmony export */   "Stream": () => (/* binding */ Stream),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "never": () => (/* binding */ never),
/* harmony export */   "later": () => (/* binding */ later),
/* harmony export */   "interval": () => (/* binding */ interval),
/* harmony export */   "sequentially": () => (/* binding */ sequentially),
/* harmony export */   "fromPoll": () => (/* binding */ fromPoll),
/* harmony export */   "withInterval": () => (/* binding */ withInterval),
/* harmony export */   "fromCallback": () => (/* binding */ fromCallback),
/* harmony export */   "fromNodeCallback": () => (/* binding */ fromNodeCallback),
/* harmony export */   "fromEvents": () => (/* binding */ fromEvents),
/* harmony export */   "stream": () => (/* binding */ stream),
/* harmony export */   "constant": () => (/* binding */ constant),
/* harmony export */   "constantError": () => (/* binding */ constantError),
/* harmony export */   "fromPromise": () => (/* binding */ fromPromise),
/* harmony export */   "fromESObservable": () => (/* binding */ fromESObservable),
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "zip": () => (/* binding */ zip),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "concat": () => (/* binding */ concat$1),
/* harmony export */   "Pool": () => (/* binding */ Pool),
/* harmony export */   "pool": () => (/* binding */ pool),
/* harmony export */   "repeat": () => (/* binding */ repeat),
/* harmony export */   "staticLand": () => (/* binding */ staticLand),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/*! Kefir.js v3.8.8
 *  https://github.com/kefirjs/kefir
 */

function createObj(proto) {
  var F = function () {};
  F.prototype = proto;
  return new F();
}

function extend(target /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0,
      prop = void 0;
  for (i = 1; i < length; i++) {
    for (prop in arguments[i]) {
      target[prop] = arguments[i][prop];
    }
  }
  return target;
}

function inherit(Child, Parent /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0;
  Child.prototype = createObj(Parent.prototype);
  Child.prototype.constructor = Child;
  for (i = 2; i < length; i++) {
    extend(Child.prototype, arguments[i]);
  }
  return Child;
}

var NOTHING = ['<nothing>'];
var END = 'end';
var VALUE = 'value';
var ERROR = 'error';
var ANY = 'any';

function concat(a, b) {
  var result = void 0,
      length = void 0,
      i = void 0,
      j = void 0;
  if (a.length === 0) {
    return b;
  }
  if (b.length === 0) {
    return a;
  }
  j = 0;
  result = new Array(a.length + b.length);
  length = a.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = a[i];
  }
  length = b.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = b[i];
  }
  return result;
}

function find(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (arr[i] === value) {
      return i;
    }
  }
  return -1;
}

function findByPred(arr, pred) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
}

function cloneArray(input) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = input[i];
  }
  return result;
}

function remove(input, index) {
  var length = input.length,
      result = void 0,
      i = void 0,
      j = void 0;
  if (index >= 0 && index < length) {
    if (length === 1) {
      return [];
    } else {
      result = new Array(length - 1);
      for (i = 0, j = 0; i < length; i++) {
        if (i !== index) {
          result[j] = input[i];
          j++;
        }
      }
      return result;
    }
  } else {
    return input;
  }
}

function map(input, fn) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = fn(input[i]);
  }
  return result;
}

function forEach(arr, fn) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    fn(arr[i]);
  }
}

function fillArray(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    arr[i] = value;
  }
}

function contains(arr, value) {
  return find(arr, value) !== -1;
}

function slide(cur, next, max) {
  var length = Math.min(max, cur.length + 1),
      offset = cur.length - length + 1,
      result = new Array(length),
      i = void 0;
  for (i = offset; i < length; i++) {
    result[i - offset] = cur[i];
  }
  result[length - 1] = next;
  return result;
}

function callSubscriber(type, fn, event) {
  if (type === ANY) {
    fn(event);
  } else if (type === event.type) {
    if (type === VALUE || type === ERROR) {
      fn(event.value);
    } else {
      fn();
    }
  }
}

function Dispatcher() {
  this._items = [];
  this._spies = [];
  this._inLoop = 0;
  this._removedItems = null;
}

extend(Dispatcher.prototype, {
  add: function (type, fn) {
    this._items = concat(this._items, [{ type: type, fn: fn }]);
    return this._items.length;
  },
  remove: function (type, fn) {
    var index = findByPred(this._items, function (x) {
      return x.type === type && x.fn === fn;
    });

    // if we're currently in a notification loop,
    // remember this subscriber was removed
    if (this._inLoop !== 0 && index !== -1) {
      if (this._removedItems === null) {
        this._removedItems = [];
      }
      this._removedItems.push(this._items[index]);
    }

    this._items = remove(this._items, index);
    return this._items.length;
  },
  addSpy: function (fn) {
    this._spies = concat(this._spies, [fn]);
    return this._spies.length;
  },


  // Because spies are only ever a function that perform logging as
  // their only side effect, we don't need the same complicated
  // removal logic like in remove()
  removeSpy: function (fn) {
    this._spies = remove(this._spies, this._spies.indexOf(fn));
    return this._spies.length;
  },
  dispatch: function (event) {
    this._inLoop++;
    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
      spies[i](event);
    }

    for (var _i = 0, items = this._items; _i < items.length; _i++) {
      // cleanup was called
      if (this._items === null) {
        break;
      }

      // this subscriber was removed
      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
        continue;
      }

      callSubscriber(items[_i].type, items[_i].fn, event);
    }
    this._inLoop--;
    if (this._inLoop === 0) {
      this._removedItems = null;
    }
  },
  cleanup: function () {
    this._items = null;
    this._spies = null;
  }
});

function Observable() {
  this._dispatcher = new Dispatcher();
  this._active = false;
  this._alive = true;
  this._activating = false;
  this._logHandlers = null;
  this._spyHandlers = null;
}

extend(Observable.prototype, {
  _name: 'observable',

  _onActivation: function () {},
  _onDeactivation: function () {},
  _setActive: function (active) {
    if (this._active !== active) {
      this._active = active;
      if (active) {
        this._activating = true;
        this._onActivation();
        this._activating = false;
      } else {
        this._onDeactivation();
      }
    }
  },
  _clear: function () {
    this._setActive(false);
    this._dispatcher.cleanup();
    this._dispatcher = null;
    this._logHandlers = null;
  },
  _emit: function (type, x) {
    switch (type) {
      case VALUE:
        return this._emitValue(x);
      case ERROR:
        return this._emitError(x);
      case END:
        return this._emitEnd();
    }
  },
  _emitValue: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: VALUE, value: value });
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: ERROR, value: value });
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      this._dispatcher.dispatch({ type: END });
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    } else {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  _off: function (type, fn) {
    if (this._alive) {
      var count = this._dispatcher.remove(type, fn);
      if (count === 0) {
        this._setActive(false);
      }
    }
    return this;
  },
  onValue: function (fn) {
    return this._on(VALUE, fn);
  },
  onError: function (fn) {
    return this._on(ERROR, fn);
  },
  onEnd: function (fn) {
    return this._on(END, fn);
  },
  onAny: function (fn) {
    return this._on(ANY, fn);
  },
  offValue: function (fn) {
    return this._off(VALUE, fn);
  },
  offError: function (fn) {
    return this._off(ERROR, fn);
  },
  offEnd: function (fn) {
    return this._off(END, fn);
  },
  offAny: function (fn) {
    return this._off(ANY, fn);
  },
  observe: function (observerOrOnValue, onError, onEnd) {
    var _this = this;
    var closed = false;

    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;

    var handler = function (event) {
      if (event.type === END) {
        closed = true;
      }
      if (event.type === VALUE && observer.value) {
        observer.value(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.end) {
        observer.end(event.value);
      }
    };

    this.onAny(handler);

    return {
      unsubscribe: function () {
        if (!closed) {
          _this.offAny(handler);
          closed = true;
        }
      },

      get closed() {
        return closed;
      }
    };
  },


  // A and B must be subclasses of Stream and Property (order doesn't matter)
  _ofSameType: function (A, B) {
    return A.prototype.getType() === this.getType() ? A : B;
  },
  setName: function (sourceObs /* optional */, selfName) {
    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
    return this;
  },
  log: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var isCurrent = void 0;
    var handler = function (event) {
      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };

    if (this._alive) {
      if (!this._logHandlers) {
        this._logHandlers = [];
      }
      this._logHandlers.push({ name: name, handler: handler });
    }

    isCurrent = true;
    this.onAny(handler);
    isCurrent = false;

    return this;
  },
  offLog: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._logHandlers) {
      var handlerIndex = findByPred(this._logHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this.offAny(this._logHandlers[handlerIndex].handler);
        this._logHandlers.splice(handlerIndex, 1);
      }
    }

    return this;
  },
  spy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var handler = function (event) {
      var type = '<' + event.type + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };
    if (this._alive) {
      if (!this._spyHandlers) {
        this._spyHandlers = [];
      }
      this._spyHandlers.push({ name: name, handler: handler });
      this._dispatcher.addSpy(handler);
    }
    return this;
  },
  offSpy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._spyHandlers) {
      var handlerIndex = findByPred(this._spyHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
        this._spyHandlers.splice(handlerIndex, 1);
      }
    }
    return this;
  }
});

// extend() can't handle `toString` in IE8
Observable.prototype.toString = function () {
  return '[' + this._name + ']';
};

function Stream() {
  Observable.call(this);
}

inherit(Stream, Observable, {
  _name: 'stream',

  getType: function () {
    return 'stream';
  }
});

function Property() {
  Observable.call(this);
  this._currentEvent = null;
}

inherit(Property, Observable, {
  _name: 'property',

  _emitValue: function (value) {
    if (this._alive) {
      this._currentEvent = { type: VALUE, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: VALUE, value: value });
      }
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._currentEvent = { type: ERROR, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: ERROR, value: value });
      }
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      if (!this._activating) {
        this._dispatcher.dispatch({ type: END });
      }
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    }
    if (this._currentEvent !== null) {
      callSubscriber(type, fn, this._currentEvent);
    }
    if (!this._alive) {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  getType: function () {
    return 'property';
  }
});

var neverS = new Stream();
neverS._emitEnd();
neverS._name = 'never';

function never() {
  return neverS;
}

function timeBased(mixin) {
  function AnonymousStream(wait, options) {
    var _this = this;

    Stream.call(this);
    this._wait = wait;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._onTick();
    };
    this._init(options);
  }

  inherit(AnonymousStream, Stream, {
    _init: function () {},
    _free: function () {},
    _onTick: function () {},
    _onActivation: function () {
      this._intervalId = setInterval(this._$onTick, this._wait);
    },
    _onDeactivation: function () {
      if (this._intervalId !== null) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    },
    _clear: function () {
      Stream.prototype._clear.call(this);
      this._$onTick = null;
      this._free();
    }
  }, mixin);

  return AnonymousStream;
}

var S = timeBased({
  _name: 'later',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
    this._emitEnd();
  }
});

function later(wait, x) {
  return new S(wait, { x: x });
}

var S$1 = timeBased({
  _name: 'interval',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
  }
});

function interval(wait, x) {
  return new S$1(wait, { x: x });
}

var S$2 = timeBased({
  _name: 'sequentially',

  _init: function (_ref) {
    var xs = _ref.xs;

    this._xs = cloneArray(xs);
  },
  _free: function () {
    this._xs = null;
  },
  _onTick: function () {
    if (this._xs.length === 1) {
      this._emitValue(this._xs[0]);
      this._emitEnd();
    } else {
      this._emitValue(this._xs.shift());
    }
  }
});

function sequentially(wait, xs) {
  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
}

var S$3 = timeBased({
  _name: 'fromPoll',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _onTick: function () {
    var fn = this._fn;
    this._emitValue(fn());
  }
});

function fromPoll(wait, fn) {
  return new S$3(wait, { fn: fn });
}

function emitter(obs) {
  function value(x) {
    obs._emitValue(x);
    return obs._active;
  }

  function error(x) {
    obs._emitError(x);
    return obs._active;
  }

  function end() {
    obs._emitEnd();
    return obs._active;
  }

  function event(e) {
    obs._emit(e.type, e.value);
    return obs._active;
  }

  return {
    value: value,
    error: error,
    end: end,
    event: event,

    // legacy
    emit: value,
    emitEvent: event
  };
}

var S$4 = timeBased({
  _name: 'withInterval',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._fn = null;
    this._emitter = null;
  },
  _onTick: function () {
    var fn = this._fn;
    fn(this._emitter);
  }
});

function withInterval(wait, fn) {
  return new S$4(wait, { fn: fn });
}

function S$5(fn) {
  Stream.call(this);
  this._fn = fn;
  this._unsubscribe = null;
}

inherit(S$5, Stream, {
  _name: 'stream',

  _onActivation: function () {
    var fn = this._fn;
    var unsubscribe = fn(emitter(this));
    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;

    // fix https://github.com/kefirjs/kefir/issues/35
    if (!this._active) {
      this._callUnsubscribe();
    }
  },
  _callUnsubscribe: function () {
    if (this._unsubscribe !== null) {
      this._unsubscribe();
      this._unsubscribe = null;
    }
  },
  _onDeactivation: function () {
    this._callUnsubscribe();
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._fn = null;
  }
});

function stream(fn) {
  return new S$5(fn);
}

function fromCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (x) {
        emitter.emit(x);
        emitter.end();
      });
      called = true;
    }
  }).setName('fromCallback');
}

function fromNodeCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (error, x) {
        if (error) {
          emitter.error(error);
        } else {
          emitter.emit(x);
        }
        emitter.end();
      });
      called = true;
    }
  }).setName('fromNodeCallback');
}

function spread(fn, length) {
  switch (length) {
    case 0:
      return function () {
        return fn();
      };
    case 1:
      return function (a) {
        return fn(a[0]);
      };
    case 2:
      return function (a) {
        return fn(a[0], a[1]);
      };
    case 3:
      return function (a) {
        return fn(a[0], a[1], a[2]);
      };
    case 4:
      return function (a) {
        return fn(a[0], a[1], a[2], a[3]);
      };
    default:
      return function (a) {
        return fn.apply(null, a);
      };
  }
}

function apply(fn, c, a) {
  var aLength = a ? a.length : 0;
  if (c == null) {
    switch (aLength) {
      case 0:
        return fn();
      case 1:
        return fn(a[0]);
      case 2:
        return fn(a[0], a[1]);
      case 3:
        return fn(a[0], a[1], a[2]);
      case 4:
        return fn(a[0], a[1], a[2], a[3]);
      default:
        return fn.apply(null, a);
    }
  } else {
    switch (aLength) {
      case 0:
        return fn.call(c);
      default:
        return fn.apply(c, a);
    }
  }
}

function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {
  return stream(function (emitter) {
    var handler = transformer ? function () {
      emitter.emit(apply(transformer, this, arguments));
    } : function (x) {
      emitter.emit(x);
    };

    sub(handler);
    return function () {
      return unsub(handler);
    };
  }).setName('fromSubUnsub');
}

var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];

function fromEvents(target, eventName, transformer) {
  var sub = void 0,
      unsub = void 0;

  for (var i = 0; i < pairs.length; i++) {
    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
      sub = pairs[i][0];
      unsub = pairs[i][1];
      break;
    }
  }

  if (sub === undefined) {
    throw new Error("target don't support any of " + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
  }

  return fromSubUnsub(function (handler) {
    return target[sub](eventName, handler);
  }, function (handler) {
    return target[unsub](eventName, handler);
  }, transformer).setName('fromEvents');
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P(value) {
  this._currentEvent = { type: 'value', value: value, current: true };
}

inherit(P, Property, {
  _name: 'constant',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constant(x) {
  return new P(x);
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P$1(value) {
  this._currentEvent = { type: 'error', value: value, current: true };
}

inherit(P$1, Property, {
  _name: 'constantError',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constantError(x) {
  return new P$1(x);
}

function createConstructor(BaseClass, name) {
  return function AnonymousObservable(source, options) {
    var _this = this;

    BaseClass.call(this);
    this._source = source;
    this._name = source._name + '.' + name;
    this._init(options);
    this._$handleAny = function (event) {
      return _this._handleAny(event);
    };
  };
}

function createClassMethods(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handleValue: function (x) {
      this._emitValue(x);
    },
    _handleError: function (x) {
      this._emitError(x);
    },
    _handleEnd: function () {
      this._emitEnd();
    },
    _handleAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleValue(event.value);
        case ERROR:
          return this._handleError(event.value);
        case END:
          return this._handleEnd();
      }
    },
    _onActivation: function () {
      this._source.onAny(this._$handleAny);
    },
    _onDeactivation: function () {
      this._source.offAny(this._$handleAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._source = null;
      this._$handleAny = null;
      this._free();
    }
  };
}

function createStream(name, mixin) {
  var S = createConstructor(Stream, name);
  inherit(S, Stream, createClassMethods(Stream), mixin);
  return S;
}

function createProperty(name, mixin) {
  var P = createConstructor(Property, name);
  inherit(P, Property, createClassMethods(Property), mixin);
  return P;
}

var P$2 = createProperty('toProperty', {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._getInitialCurrent = fn;
  },
  _onActivation: function () {
    if (this._getInitialCurrent !== null) {
      var getInitial = this._getInitialCurrent;
      this._emitValue(getInitial());
    }
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  }
});

function toProperty(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (fn !== null && typeof fn !== 'function') {
    throw new Error('You should call toProperty() with a function or no arguments.');
  }
  return new P$2(obs, { fn: fn });
}

var S$6 = createStream('changes', {
  _handleValue: function (x) {
    if (!this._activating) {
      this._emitValue(x);
    }
  },
  _handleError: function (x) {
    if (!this._activating) {
      this._emitError(x);
    }
  }
});

function changes(obs) {
  return new S$6(obs);
}

function fromPromise(promise) {
  var called = false;

  var result = stream(function (emitter) {
    if (!called) {
      var onValue = function (x) {
        emitter.emit(x);
        emitter.end();
      };
      var onError = function (x) {
        emitter.error(x);
        emitter.end();
      };
      var _promise = promise.then(onValue, onError);

      // prevent libraries like 'Q' or 'when' from swallowing exceptions
      if (_promise && typeof _promise.done === 'function') {
        _promise.done();
      }

      called = true;
    }
  });

  return toProperty(result, null).setName('fromPromise');
}

function getGlodalPromise() {
  if (typeof Promise === 'function') {
    return Promise;
  } else {
    throw new Error("There isn't default Promise, use shim or parameter");
  }
}

var toPromise = function (obs) {
  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();

  var last = null;
  return new Promise(function (resolve, reject) {
    obs.onAny(function (event) {
      if (event.type === END && last !== null) {
        (last.type === VALUE ? resolve : reject)(last.value);
        last = null;
      } else {
        last = event;
      }
    });
  });
};

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result = symbolObservablePonyfill(root);

// this file contains some hot JS modules systems stuff

var $$observable = result.default ? result.default : result;

function fromESObservable(_observable) {
  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
  return stream(function (emitter) {
    var unsub = observable.subscribe({
      error: function (error) {
        emitter.error(error);
        emitter.end();
      },
      next: function (value) {
        emitter.emit(value);
      },
      complete: function () {
        emitter.end();
      }
    });

    if (unsub.unsubscribe) {
      return function () {
        unsub.unsubscribe();
      };
    } else {
      return unsub;
    }
  }).setName('fromESObservable');
}

function ESObservable(observable) {
  this._observable = observable.takeErrors(1);
}

extend(ESObservable.prototype, {
  subscribe: function (observerOrOnNext, onError, onComplete) {
    var _this = this;

    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;

    var fn = function (event) {
      if (event.type === END) {
        closed = true;
      }

      if (event.type === VALUE && observer.next) {
        observer.next(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.complete) {
        observer.complete(event.value);
      }
    };

    this._observable.onAny(fn);
    var closed = false;

    var subscription = {
      unsubscribe: function () {
        closed = true;
        _this._observable.offAny(fn);
      },
      get closed() {
        return closed;
      }
    };
    return subscription;
  }
});

// Need to assign directly b/c Symbols aren't enumerable.
ESObservable.prototype[$$observable] = function () {
  return this;
};

function toESObservable() {
  return new ESObservable(this);
}

function collect(source, keys, values) {
  for (var prop in source) {
    if (source.hasOwnProperty(prop)) {
      keys.push(prop);
      values.push(source[prop]);
    }
  }
}

function defaultErrorsCombinator(errors) {
  var latestError = void 0;
  for (var i = 0; i < errors.length; i++) {
    if (errors[i] !== undefined) {
      if (latestError === undefined || latestError.index < errors[i].index) {
        latestError = errors[i];
      }
    }
  }
  return latestError.error;
}

function Combine(active, passive, combinator) {
  var _this = this;

  Stream.call(this);
  this._activeCount = active.length;
  this._sources = concat(active, passive);
  this._combinator = combinator;
  this._aliveCount = 0;
  this._latestValues = new Array(this._sources.length);
  this._latestErrors = new Array(this._sources.length);
  fillArray(this._latestValues, NOTHING);
  this._emitAfterActivation = false;
  this._endAfterActivation = false;
  this._latestErrorIndex = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Combine, Stream, {
  _name: 'combine',

  _onActivation: function () {
    this._aliveCount = this._activeCount;

    // we need to suscribe to _passive_ sources before _active_
    // (see https://github.com/kefirjs/kefir/issues/98)
    for (var i = this._activeCount; i < this._sources.length; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
    for (var _i = 0; _i < this._activeCount; _i++) {
      this._sources[_i].onAny(this._$handlers[_i]);
    }

    if (this._emitAfterActivation) {
      this._emitAfterActivation = false;
      this._emitIfFull();
    }
    if (this._endAfterActivation) {
      this._emitEnd();
    }
  },
  _onDeactivation: function () {
    var length = this._sources.length,
        i = void 0;
    for (i = 0; i < length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emitIfFull: function () {
    var hasAllValues = true;
    var hasErrors = false;
    var length = this._latestValues.length;
    var valuesCopy = new Array(length);
    var errorsCopy = new Array(length);

    for (var i = 0; i < length; i++) {
      valuesCopy[i] = this._latestValues[i];
      errorsCopy[i] = this._latestErrors[i];

      if (valuesCopy[i] === NOTHING) {
        hasAllValues = false;
      }

      if (errorsCopy[i] !== undefined) {
        hasErrors = true;
      }
    }

    if (hasAllValues) {
      var combinator = this._combinator;
      this._emitValue(combinator(valuesCopy));
    }
    if (hasErrors) {
      this._emitError(defaultErrorsCombinator(errorsCopy));
    }
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE || event.type === ERROR) {
      if (event.type === VALUE) {
        this._latestValues[i] = event.value;
        this._latestErrors[i] = undefined;
      }
      if (event.type === ERROR) {
        this._latestValues[i] = NOTHING;
        this._latestErrors[i] = {
          index: this._latestErrorIndex++,
          error: event.value
        };
      }

      if (i < this._activeCount) {
        if (this._activating) {
          this._emitAfterActivation = true;
        } else {
          this._emitIfFull();
        }
      }
    } else {
      // END

      if (i < this._activeCount) {
        this._aliveCount--;
        if (this._aliveCount === 0) {
          if (this._activating) {
            this._endAfterActivation = true;
          } else {
            this._emitEnd();
          }
        }
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._latestValues = null;
    this._latestErrors = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function combineAsArray(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var combinator = arguments[2];

  if (!Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
    return x;
  };
  return active.length === 0 ? never() : new Combine(active, passive, combinator);
}

function combineAsObject(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var combinator = arguments[2];

  if (typeof passive !== 'object' || Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  var keys = [],
      activeObservables = [],
      passiveObservables = [];

  collect(active, keys, activeObservables);
  collect(passive, keys, passiveObservables);

  var objectify = function (values) {
    var event = {};
    for (var i = values.length - 1; 0 <= i; i--) {
      event[keys[i]] = values[i];
    }
    return combinator ? combinator(event) : event;
  };

  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
}

function combine(active, passive, combinator) {
  if (typeof passive === 'function') {
    combinator = passive;
    passive = undefined;
  }

  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
}

var Observable$2 = {
  empty: function () {
    return never();
  },


  // Monoid based on merge() seems more useful than one based on concat().
  concat: function (a, b) {
    return a.merge(b);
  },
  of: function (x) {
    return constant(x);
  },
  map: function (fn, obs) {
    return obs.map(fn);
  },
  bimap: function (fnErr, fnVal, obs) {
    return obs.mapErrors(fnErr).map(fnVal);
  },


  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get
  // different (not very useful) behavior. But spec requires that if method can be derived
  // it must have the same behavior as hand-written method. We intentionally violate the spec
  // in hope that it won't cause many troubles in practice. And in return we have more useful type.
  ap: function (obsFn, obsVal) {
    return combine([obsFn, obsVal], function (fn, val) {
      return fn(val);
    });
  },
  chain: function (fn, obs) {
    return obs.flatMap(fn);
  }
};



var staticLand = Object.freeze({
	Observable: Observable$2
});

var mixin = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    this._emitValue(fn(x));
  }
};

var S$7 = createStream('map', mixin);
var P$3 = createProperty('map', mixin);

var id = function (x) {
  return x;
};

function map$1(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;

  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
}

var mixin$1 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    }
  }
};

var S$8 = createStream('filter', mixin$1);
var P$4 = createProperty('filter', mixin$1);

var id$1 = function (x) {
  return x;
};

function filter(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;

  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
}

var mixin$2 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitValue(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$9 = createStream('take', mixin$2);
var P$5 = createProperty('take', mixin$2);

function take(obs, n) {
  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
}

var mixin$3 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleError: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitError(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$10 = createStream('takeErrors', mixin$3);
var P$6 = createProperty('takeErrors', mixin$3);

function takeErrors(obs, n) {
  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
}

var mixin$4 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    } else {
      this._emitEnd();
    }
  }
};

var S$11 = createStream('takeWhile', mixin$4);
var P$7 = createProperty('takeWhile', mixin$4);

var id$2 = function (x) {
  return x;
};

function takeWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;

  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
}

var mixin$5 = {
  _init: function () {
    this._lastValue = NOTHING;
  },
  _free: function () {
    this._lastValue = null;
  },
  _handleValue: function (x) {
    this._lastValue = x;
  },
  _handleEnd: function () {
    if (this._lastValue !== NOTHING) {
      this._emitValue(this._lastValue);
    }
    this._emitEnd();
  }
};

var S$12 = createStream('last', mixin$5);
var P$8 = createProperty('last', mixin$5);

function last(obs) {
  return new (obs._ofSameType(S$12, P$8))(obs);
}

var mixin$6 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = Math.max(0, n);
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      this._emitValue(x);
    } else {
      this._n--;
    }
  }
};

var S$13 = createStream('skip', mixin$6);
var P$9 = createProperty('skip', mixin$6);

function skip(obs, n) {
  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
}

var mixin$7 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._fn !== null && !fn(x)) {
      this._fn = null;
    }
    if (this._fn === null) {
      this._emitValue(x);
    }
  }
};

var S$14 = createStream('skipWhile', mixin$7);
var P$10 = createProperty('skipWhile', mixin$7);

var id$3 = function (x) {
  return x;
};

function skipWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;

  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
}

var mixin$8 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._prev = NOTHING;
  },
  _free: function () {
    this._fn = null;
    this._prev = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._prev === NOTHING || !fn(this._prev, x)) {
      this._prev = x;
      this._emitValue(x);
    }
  }
};

var S$15 = createStream('skipDuplicates', mixin$8);
var P$11 = createProperty('skipDuplicates', mixin$8);

var eq = function (a, b) {
  return a === b;
};

function skipDuplicates(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;

  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
}

var mixin$9 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._prev = seed;
  },
  _free: function () {
    this._prev = null;
    this._fn = null;
  },
  _handleValue: function (x) {
    if (this._prev !== NOTHING) {
      var fn = this._fn;
      this._emitValue(fn(this._prev, x));
    }
    this._prev = x;
  }
};

var S$16 = createStream('diff', mixin$9);
var P$12 = createProperty('diff', mixin$9);

function defaultFn(a, b) {
  return [a, b];
}

function diff(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });
}

var P$13 = createProperty('scan', {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._seed = seed;
    if (seed !== NOTHING) {
      this._emitValue(seed);
    }
  },
  _free: function () {
    this._fn = null;
    this._seed = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._currentEvent === null || this._currentEvent.type === ERROR) {
      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
    } else {
      this._emitValue(fn(this._currentEvent.value, x));
    }
  }
});

function scan(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new P$13(obs, { fn: fn, seed: seed });
}

var mixin$10 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var xs = fn(x);
    for (var i = 0; i < xs.length; i++) {
      this._emitValue(xs[i]);
    }
  }
};

var S$17 = createStream('flatten', mixin$10);

var id$4 = function (x) {
  return x;
};

function flatten(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;

  return new S$17(obs, { fn: fn });
}

var END_MARKER = {};

var mixin$11 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait;

    this._wait = Math.max(0, wait);
    this._buff = [];
    this._$shiftBuff = function () {
      var value = _this._buff.shift();
      if (value === END_MARKER) {
        _this._emitEnd();
      } else {
        _this._emitValue(value);
      }
    };
  },
  _free: function () {
    this._buff = null;
    this._$shiftBuff = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._buff.push(x);
      setTimeout(this._$shiftBuff, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      this._buff.push(END_MARKER);
      setTimeout(this._$shiftBuff, this._wait);
    }
  }
};

var S$18 = createStream('delay', mixin$11);
var P$14 = createProperty('delay', mixin$11);

function delay(obs, wait) {
  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
}

var now = Date.now ? function () {
  return Date.now();
} : function () {
  return new Date().getTime();
};

var mixin$12 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        leading = _ref.leading,
        trailing = _ref.trailing;

    this._wait = Math.max(0, wait);
    this._leading = leading;
    this._trailing = trailing;
    this._trailingValue = null;
    this._timeoutId = null;
    this._endLater = false;
    this._lastCallTime = 0;
    this._$trailingCall = function () {
      return _this._trailingCall();
    };
  },
  _free: function () {
    this._trailingValue = null;
    this._$trailingCall = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      var curTime = now();
      if (this._lastCallTime === 0 && !this._leading) {
        this._lastCallTime = curTime;
      }
      var remaining = this._wait - (curTime - this._lastCallTime);
      if (remaining <= 0) {
        this._cancelTrailing();
        this._lastCallTime = curTime;
        this._emitValue(x);
      } else if (this._trailing) {
        this._cancelTrailing();
        this._trailingValue = x;
        this._timeoutId = setTimeout(this._$trailingCall, remaining);
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _cancelTrailing: function () {
    if (this._timeoutId !== null) {
      clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  },
  _trailingCall: function () {
    this._emitValue(this._trailingValue);
    this._timeoutId = null;
    this._trailingValue = null;
    this._lastCallTime = !this._leading ? 0 : now();
    if (this._endLater) {
      this._emitEnd();
    }
  }
};

var S$19 = createStream('throttle', mixin$12);
var P$15 = createProperty('throttle', mixin$12);

function throttle(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$leading = _ref2.leading,
      leading = _ref2$leading === undefined ? true : _ref2$leading,
      _ref2$trailing = _ref2.trailing,
      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;

  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });
}

var mixin$13 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        immediate = _ref.immediate;

    this._wait = Math.max(0, wait);
    this._immediate = immediate;
    this._lastAttempt = 0;
    this._timeoutId = null;
    this._laterValue = null;
    this._endLater = false;
    this._$later = function () {
      return _this._later();
    };
  },
  _free: function () {
    this._laterValue = null;
    this._$later = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._lastAttempt = now();
      if (this._immediate && !this._timeoutId) {
        this._emitValue(x);
      }
      if (!this._timeoutId) {
        this._timeoutId = setTimeout(this._$later, this._wait);
      }
      if (!this._immediate) {
        this._laterValue = x;
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId && !this._immediate) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _later: function () {
    var last = now() - this._lastAttempt;
    if (last < this._wait && last >= 0) {
      this._timeoutId = setTimeout(this._$later, this._wait - last);
    } else {
      this._timeoutId = null;
      if (!this._immediate) {
        var _laterValue = this._laterValue;
        this._laterValue = null;
        this._emitValue(_laterValue);
      }
      if (this._endLater) {
        this._emitEnd();
      }
    }
  }
};

var S$20 = createStream('debounce', mixin$13);
var P$16 = createProperty('debounce', mixin$13);

function debounce(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$immediate = _ref2.immediate,
      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;

  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });
}

var mixin$14 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    this._emitError(fn(x));
  }
};

var S$21 = createStream('mapErrors', mixin$14);
var P$17 = createProperty('mapErrors', mixin$14);

var id$5 = function (x) {
  return x;
};

function mapErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;

  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
}

var mixin$15 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitError(x);
    }
  }
};

var S$22 = createStream('filterErrors', mixin$15);
var P$18 = createProperty('filterErrors', mixin$15);

var id$6 = function (x) {
  return x;
};

function filterErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;

  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
}

var mixin$16 = {
  _handleValue: function () {}
};

var S$23 = createStream('ignoreValues', mixin$16);
var P$19 = createProperty('ignoreValues', mixin$16);

function ignoreValues(obs) {
  return new (obs._ofSameType(S$23, P$19))(obs);
}

var mixin$17 = {
  _handleError: function () {}
};

var S$24 = createStream('ignoreErrors', mixin$17);
var P$20 = createProperty('ignoreErrors', mixin$17);

function ignoreErrors(obs) {
  return new (obs._ofSameType(S$24, P$20))(obs);
}

var mixin$18 = {
  _handleEnd: function () {}
};

var S$25 = createStream('ignoreEnd', mixin$18);
var P$21 = createProperty('ignoreEnd', mixin$18);

function ignoreEnd(obs) {
  return new (obs._ofSameType(S$25, P$21))(obs);
}

var mixin$19 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleEnd: function () {
    var fn = this._fn;
    this._emitValue(fn());
    this._emitEnd();
  }
};

var S$26 = createStream('beforeEnd', mixin$19);
var P$22 = createProperty('beforeEnd', mixin$19);

function beforeEnd(obs, fn) {
  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
}

var mixin$20 = {
  _init: function (_ref) {
    var min = _ref.min,
        max = _ref.max;

    this._max = max;
    this._min = min;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _handleValue: function (x) {
    this._buff = slide(this._buff, x, this._max);
    if (this._buff.length >= this._min) {
      this._emitValue(this._buff);
    }
  }
};

var S$27 = createStream('slidingWindow', mixin$20);
var P$23 = createProperty('slidingWindow', mixin$20);

function slidingWindow(obs, max) {
  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });
}

var mixin$21 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        flushOnEnd = _ref.flushOnEnd;

    this._fn = fn;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    var fn = this._fn;
    if (!fn(x)) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$28 = createStream('bufferWhile', mixin$21);
var P$24 = createProperty('bufferWhile', mixin$21);

var id$7 = function (x) {
  return x;
};

function bufferWhile(obs, fn) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });
}

var mixin$22 = {
  _init: function (_ref) {
    var count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$29 = createStream('bufferWithCount', mixin$22);
var P$25 = createProperty('bufferWithCount', mixin$22);

function bufferWhile$1(obs, count) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });
}

var mixin$23 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._wait = wait;
    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._flush();
    };
    this._buff = [];
  },
  _free: function () {
    this._$onTick = null;
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      clearInterval(this._intervalId);
      this._flush();
      this._intervalId = setInterval(this._$onTick, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd && this._buff.length !== 0) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._intervalId = setInterval(this._$onTick, this._wait);
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  },
  _onDeactivation: function () {
    if (this._intervalId !== null) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
    this._source.offAny(this._$handleAny); // copied from patterns/one-source
  }
};

var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);

function bufferWithTimeOrCount(obs, wait, count) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });
}

function xformForObs(obs) {
  return {
    '@@transducer/step': function (res, input) {
      obs._emitValue(input);
      return null;
    },
    '@@transducer/result': function () {
      obs._emitEnd();
      return null;
    }
  };
}

var mixin$24 = {
  _init: function (_ref) {
    var transducer = _ref.transducer;

    this._xform = transducer(xformForObs(this));
  },
  _free: function () {
    this._xform = null;
  },
  _handleValue: function (x) {
    if (this._xform['@@transducer/step'](null, x) !== null) {
      this._xform['@@transducer/result'](null);
    }
  },
  _handleEnd: function () {
    this._xform['@@transducer/result'](null);
  }
};

var S$31 = createStream('transduce', mixin$24);
var P$27 = createProperty('transduce', mixin$24);

function transduce(obs, transducer) {
  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
}

var mixin$25 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._handler = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._handler = null;
    this._emitter = null;
  },
  _handleAny: function (event) {
    this._handler(this._emitter, event);
  }
};

var S$32 = createStream('withHandler', mixin$25);
var P$28 = createProperty('withHandler', mixin$25);

function withHandler(obs, fn) {
  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
}

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function Zip(sources, combinator) {
  var _this = this;

  Stream.call(this);

  this._buffers = map(sources, function (source) {
    return isArray(source) ? cloneArray(source) : [];
  });
  this._sources = map(sources, function (source) {
    return isArray(source) ? never() : source;
  });

  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
    return x;
  };
  this._aliveCount = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Zip, Stream, {
  _name: 'zip',

  _onActivation: function () {
    // if all sources are arrays
    while (this._isFull()) {
      this._emit();
    }

    var length = this._sources.length;
    this._aliveCount = length;
    for (var i = 0; i < length && this._active; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0; i < this._sources.length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emit: function () {
    var values = new Array(this._buffers.length);
    for (var i = 0; i < this._buffers.length; i++) {
      values[i] = this._buffers[i].shift();
    }
    var combinator = this._combinator;
    this._emitValue(combinator(values));
  },
  _isFull: function () {
    for (var i = 0; i < this._buffers.length; i++) {
      if (this._buffers[i].length === 0) {
        return false;
      }
    }
    return true;
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE) {
      this._buffers[i].push(event.value);
      if (this._isFull()) {
        this._emit();
      }
    }
    if (event.type === ERROR) {
      this._emitError(event.value);
    }
    if (event.type === END) {
      this._aliveCount--;
      if (this._aliveCount === 0) {
        this._emitEnd();
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._buffers = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function zip(observables, combinator /* Function | falsey */) {
  return observables.length === 0 ? never() : new Zip(observables, combinator);
}

var id$8 = function (x) {
  return x;
};

function AbstractPool() {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$queueLim = _ref.queueLim,
      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,
      _ref$concurLim = _ref.concurLim,
      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,
      _ref$drop = _ref.drop,
      drop = _ref$drop === undefined ? 'new' : _ref$drop;

  Stream.call(this);

  this._queueLim = queueLim < 0 ? -1 : queueLim;
  this._concurLim = concurLim < 0 ? -1 : concurLim;
  this._drop = drop;
  this._queue = [];
  this._curSources = [];
  this._$handleSubAny = function (event) {
    return _this._handleSubAny(event);
  };
  this._$endHandlers = [];
  this._currentlyAdding = null;

  if (this._concurLim === 0) {
    this._emitEnd();
  }
}

inherit(AbstractPool, Stream, {
  _name: 'abstractPool',

  _add: function (obj, toObs /* Function | falsey */) {
    toObs = toObs || id$8;
    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
      this._addToCur(toObs(obj));
    } else {
      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
        this._addToQueue(toObs(obj));
      } else if (this._drop === 'old') {
        this._removeOldest();
        this._add(obj, toObs);
      }
    }
  },
  _addAll: function (obss) {
    var _this2 = this;

    forEach(obss, function (obs) {
      return _this2._add(obs);
    });
  },
  _remove: function (obs) {
    if (this._removeCur(obs) === -1) {
      this._removeQueue(obs);
    }
  },
  _addToQueue: function (obs) {
    this._queue = concat(this._queue, [obs]);
  },
  _addToCur: function (obs) {
    if (this._active) {
      // HACK:
      //
      // We have two optimizations for cases when `obs` is ended. We don't want
      // to add such observable to the list, but only want to emit events
      // from it (if it has some).
      //
      // Instead of this hacks, we could just did following,
      // but it would be 5-8 times slower:
      //
      //     this._curSources = concat(this._curSources, [obs]);
      //     this._subscribe(obs);
      //

      // #1
      // This one for cases when `obs` already ended
      // e.g., Kefir.constant() or Kefir.never()
      if (!obs._alive) {
        if (obs._currentEvent) {
          this._emit(obs._currentEvent.type, obs._currentEvent.value);
        }
        // The _emit above could have caused this stream to end.
        if (this._active) {
          if (this._queue.length !== 0) {
            this._pullQueue();
          } else if (this._curSources.length === 0) {
            this._onEmpty();
          }
        }
        return;
      }

      // #2
      // This one is for cases when `obs` going to end synchronously on
      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})
      this._currentlyAdding = obs;
      obs.onAny(this._$handleSubAny);
      this._currentlyAdding = null;
      if (obs._alive) {
        this._curSources = concat(this._curSources, [obs]);
        if (this._active) {
          this._subToEnd(obs);
        }
      } else {
        if (this._queue.length !== 0) {
          this._pullQueue();
        } else if (this._curSources.length === 0) {
          this._onEmpty();
        }
      }
    } else {
      this._curSources = concat(this._curSources, [obs]);
    }
  },
  _subToEnd: function (obs) {
    var _this3 = this;

    var onEnd = function () {
      return _this3._removeCur(obs);
    };
    this._$endHandlers.push({ obs: obs, handler: onEnd });
    obs.onEnd(onEnd);
  },
  _subscribe: function (obs) {
    obs.onAny(this._$handleSubAny);

    // it can become inactive in responce of subscribing to `obs.onAny` above
    if (this._active) {
      this._subToEnd(obs);
    }
  },
  _unsubscribe: function (obs) {
    obs.offAny(this._$handleSubAny);

    var onEndI = findByPred(this._$endHandlers, function (obj) {
      return obj.obs === obs;
    });
    if (onEndI !== -1) {
      obs.offEnd(this._$endHandlers[onEndI].handler);
      this._$endHandlers.splice(onEndI, 1);
    }
  },
  _handleSubAny: function (event) {
    if (event.type === VALUE) {
      this._emitValue(event.value);
    } else if (event.type === ERROR) {
      this._emitError(event.value);
    }
  },
  _removeQueue: function (obs) {
    var index = find(this._queue, obs);
    this._queue = remove(this._queue, index);
    return index;
  },
  _removeCur: function (obs) {
    if (this._active) {
      this._unsubscribe(obs);
    }
    var index = find(this._curSources, obs);
    this._curSources = remove(this._curSources, index);
    if (index !== -1) {
      if (this._queue.length !== 0) {
        this._pullQueue();
      } else if (this._curSources.length === 0) {
        this._onEmpty();
      }
    }
    return index;
  },
  _removeOldest: function () {
    this._removeCur(this._curSources[0]);
  },
  _pullQueue: function () {
    if (this._queue.length !== 0) {
      this._queue = cloneArray(this._queue);
      this._addToCur(this._queue.shift());
    }
  },
  _onActivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
      this._subscribe(sources[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length; i++) {
      this._unsubscribe(sources[i]);
    }
    if (this._currentlyAdding !== null) {
      this._unsubscribe(this._currentlyAdding);
    }
  },
  _isEmpty: function () {
    return this._curSources.length === 0;
  },
  _onEmpty: function () {},
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._queue = null;
    this._curSources = null;
    this._$handleSubAny = null;
    this._$endHandlers = null;
  }
});

function Merge(sources) {
  AbstractPool.call(this);
  this._addAll(sources);
  this._initialised = true;
}

inherit(Merge, AbstractPool, {
  _name: 'merge',

  _onEmpty: function () {
    if (this._initialised) {
      this._emitEnd();
    }
  }
});

function merge(observables) {
  return observables.length === 0 ? never() : new Merge(observables);
}

function S$33(generator) {
  var _this = this;

  Stream.call(this);
  this._generator = generator;
  this._source = null;
  this._inLoop = false;
  this._iteration = 0;
  this._$handleAny = function (event) {
    return _this._handleAny(event);
  };
}

inherit(S$33, Stream, {
  _name: 'repeat',

  _handleAny: function (event) {
    if (event.type === END) {
      this._source = null;
      this._getSource();
    } else {
      this._emit(event.type, event.value);
    }
  },
  _getSource: function () {
    if (!this._inLoop) {
      this._inLoop = true;
      var generator = this._generator;
      while (this._source === null && this._alive && this._active) {
        this._source = generator(this._iteration++);
        if (this._source) {
          this._source.onAny(this._$handleAny);
        } else {
          this._emitEnd();
        }
      }
      this._inLoop = false;
    }
  },
  _onActivation: function () {
    if (this._source) {
      this._source.onAny(this._$handleAny);
    } else {
      this._getSource();
    }
  },
  _onDeactivation: function () {
    if (this._source) {
      this._source.offAny(this._$handleAny);
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._generator = null;
    this._source = null;
    this._$handleAny = null;
  }
});

var repeat = function (generator) {
  return new S$33(generator);
};

function concat$1(observables) {
  return repeat(function (index) {
    return observables.length > index ? observables[index] : false;
  }).setName('concat');
}

function Pool() {
  AbstractPool.call(this);
}

inherit(Pool, AbstractPool, {
  _name: 'pool',

  plug: function (obs) {
    this._add(obs);
    return this;
  },
  unplug: function (obs) {
    this._remove(obs);
    return this;
  }
});

function FlatMap(source, fn, options) {
  var _this = this;

  AbstractPool.call(this, options);
  this._source = source;
  this._fn = fn;
  this._mainEnded = false;
  this._lastCurrent = null;
  this._$handleMain = function (event) {
    return _this._handleMain(event);
  };
}

inherit(FlatMap, AbstractPool, {
  _onActivation: function () {
    AbstractPool.prototype._onActivation.call(this);
    if (this._active) {
      this._source.onAny(this._$handleMain);
    }
  },
  _onDeactivation: function () {
    AbstractPool.prototype._onDeactivation.call(this);
    this._source.offAny(this._$handleMain);
    this._hadNoEvSinceDeact = true;
  },
  _handleMain: function (event) {
    if (event.type === VALUE) {
      // Is latest value before deactivation survived, and now is 'current' on this activation?
      // We don't want to handle such values, to prevent to constantly add
      // same observale on each activation/deactivation when our main source
      // is a `Kefir.conatant()` for example.
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === ERROR) {
      this._emitError(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  },
  _onEmpty: function () {
    if (this._mainEnded) {
      this._emitEnd();
    }
  },
  _clear: function () {
    AbstractPool.prototype._clear.call(this);
    this._source = null;
    this._lastCurrent = null;
    this._$handleMain = null;
  }
});

function FlatMapErrors(source, fn) {
  FlatMap.call(this, source, fn);
}

inherit(FlatMapErrors, FlatMap, {
  // Same as in FlatMap, only VALUE/ERROR flipped
  _handleMain: function (event) {
    if (event.type === ERROR) {
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === VALUE) {
      this._emitValue(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  }
});

function createConstructor$1(BaseClass, name) {
  return function AnonymousObservable(primary, secondary, options) {
    var _this = this;

    BaseClass.call(this);
    this._primary = primary;
    this._secondary = secondary;
    this._name = primary._name + '.' + name;
    this._lastSecondary = NOTHING;
    this._$handleSecondaryAny = function (event) {
      return _this._handleSecondaryAny(event);
    };
    this._$handlePrimaryAny = function (event) {
      return _this._handlePrimaryAny(event);
    };
    this._init(options);
  };
}

function createClassMethods$1(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handlePrimaryValue: function (x) {
      this._emitValue(x);
    },
    _handlePrimaryError: function (x) {
      this._emitError(x);
    },
    _handlePrimaryEnd: function () {
      this._emitEnd();
    },
    _handleSecondaryValue: function (x) {
      this._lastSecondary = x;
    },
    _handleSecondaryError: function (x) {
      this._emitError(x);
    },
    _handleSecondaryEnd: function () {},
    _handlePrimaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handlePrimaryValue(event.value);
        case ERROR:
          return this._handlePrimaryError(event.value);
        case END:
          return this._handlePrimaryEnd(event.value);
      }
    },
    _handleSecondaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleSecondaryValue(event.value);
        case ERROR:
          return this._handleSecondaryError(event.value);
        case END:
          this._handleSecondaryEnd(event.value);
          this._removeSecondary();
      }
    },
    _removeSecondary: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
        this._$handleSecondaryAny = null;
        this._secondary = null;
      }
    },
    _onActivation: function () {
      if (this._secondary !== null) {
        this._secondary.onAny(this._$handleSecondaryAny);
      }
      if (this._active) {
        this._primary.onAny(this._$handlePrimaryAny);
      }
    },
    _onDeactivation: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
      }
      this._primary.offAny(this._$handlePrimaryAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._primary = null;
      this._secondary = null;
      this._lastSecondary = null;
      this._$handleSecondaryAny = null;
      this._$handlePrimaryAny = null;
      this._free();
    }
  };
}

function createStream$1(name, mixin) {
  var S = createConstructor$1(Stream, name);
  inherit(S, Stream, createClassMethods$1(Stream), mixin);
  return S;
}

function createProperty$1(name, mixin) {
  var P = createConstructor$1(Property, name);
  inherit(P, Property, createClassMethods$1(Property), mixin);
  return P;
}

var mixin$26 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
      this._emitEnd();
    }
  }
};

var S$34 = createStream$1('filterBy', mixin$26);
var P$29 = createProperty$1('filterBy', mixin$26);

function filterBy(primary, secondary) {
  return new (primary._ofSameType(S$34, P$29))(primary, secondary);
}

var id2 = function (_, x) {
  return x;
};

function sampledBy(passive, active, combinator) {
  var _combinator = combinator ? function (a, b) {
    return combinator(b, a);
  } : id2;
  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
}

var mixin$27 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING) {
      this._emitEnd();
    }
  }
};

var S$35 = createStream$1('skipUntilBy', mixin$27);
var P$30 = createProperty$1('skipUntilBy', mixin$27);

function skipUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$35, P$30))(primary, secondary);
}

var mixin$28 = {
  _handleSecondaryValue: function () {
    this._emitEnd();
  }
};

var S$36 = createStream$1('takeUntilBy', mixin$28);
var P$31 = createProperty$1('takeUntilBy', mixin$28);

function takeUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$36, P$31))(primary, secondary);
}

var mixin$29 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._primary.onAny(this._$handlePrimaryAny);
    if (this._alive && this._secondary !== null) {
      this._secondary.onAny(this._$handleSecondaryAny);
    }
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
  },
  _handleSecondaryValue: function () {
    this._flush();
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd) {
      this._emitEnd();
    }
  }
};

var S$37 = createStream$1('bufferBy', mixin$29);
var P$32 = createProperty$1('bufferBy', mixin$29);

function bufferBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
}

var mixin$30 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,
        _ref$flushOnChange = _ref.flushOnChange,
        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
    this._flushOnChange = flushOnChange;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
      this._flush();
    }
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
      this._emitEnd();
    }
  },
  _handleSecondaryValue: function (x) {
    if (this._flushOnChange && !x) {
      this._flush();
    }

    // from default _handleSecondaryValue
    this._lastSecondary = x;
  }
};

var S$38 = createStream$1('bufferWhileBy', mixin$30);
var P$33 = createProperty$1('bufferWhileBy', mixin$30);

function bufferWhileBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
}

var f = function () {
  return false;
};
var t = function () {
  return true;
};

function awaiting(a, b) {
  var result = merge([map$1(a, t), map$1(b, f)]);
  result = skipDuplicates(result);
  result = toProperty(result, f);
  return result.setName(a, 'awaiting');
}

var mixin$31 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitError(result.error);
    } else {
      this._emitValue(x);
    }
  }
};

var S$39 = createStream('valuesToErrors', mixin$31);
var P$34 = createProperty('valuesToErrors', mixin$31);

var defFn = function (x) {
  return { convert: true, error: x };
};

function valuesToErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;

  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
}

var mixin$32 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitValue(result.value);
    } else {
      this._emitError(x);
    }
  }
};

var S$40 = createStream('errorsToValues', mixin$32);
var P$35 = createProperty('errorsToValues', mixin$32);

var defFn$1 = function (x) {
  return { convert: true, value: x };
};

function errorsToValues(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;

  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
}

var mixin$33 = {
  _handleError: function (x) {
    this._emitError(x);
    this._emitEnd();
  }
};

var S$41 = createStream('endOnError', mixin$33);
var P$36 = createProperty('endOnError', mixin$33);

function endOnError(obs) {
  return new (obs._ofSameType(S$41, P$36))(obs);
}

// Create a stream
// -----------------------------------------------------------------------------

// () -> Stream
// (number, any) -> Stream
// (number, any) -> Stream
// (number, Array<any>) -> Stream
// (number, Function) -> Stream
// (number, Function) -> Stream
// (Function) -> Stream
// (Function) -> Stream
// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}
// (Target, string, Function|undefined) -> Stream
// (Function) -> Stream
// Create a property
// -----------------------------------------------------------------------------

// (any) -> Property
// (any) -> Property
// Convert observables
// -----------------------------------------------------------------------------

// (Stream|Property, Function|undefined) -> Property
Observable.prototype.toProperty = function (fn) {
  return toProperty(this, fn);
};

// (Stream|Property) -> Stream
Observable.prototype.changes = function () {
  return changes(this);
};

// Interoperation with other implimentations
// -----------------------------------------------------------------------------

// (Promise) -> Property
// (Stream|Property, Function|undefined) -> Promise
Observable.prototype.toPromise = function (Promise) {
  return toPromise(this, Promise);
};

// (ESObservable) -> Stream
// (Stream|Property) -> ES7 Observable
Observable.prototype.toESObservable = toESObservable;
Observable.prototype[$$observable] = toESObservable;

// Modify an observable
// -----------------------------------------------------------------------------

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.map = function (fn) {
  return map$1(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filter = function (fn) {
  return filter(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.take = function (n) {
  return take(this, n);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.takeErrors = function (n) {
  return takeErrors(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.takeWhile = function (fn) {
  return takeWhile(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.last = function () {
  return last(this);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.skip = function (n) {
  return skip(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipWhile = function (fn) {
  return skipWhile(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipDuplicates = function (fn) {
  return skipDuplicates(this, fn);
};

// (Stream, Function|falsey, any|undefined) -> Stream
// (Property, Function|falsey, any|undefined) -> Property
Observable.prototype.diff = function (fn, seed) {
  return diff(this, fn, seed);
};

// (Stream|Property, Function, any|undefined) -> Property
Observable.prototype.scan = function (fn, seed) {
  return scan(this, fn, seed);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.flatten = function (fn) {
  return flatten(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.delay = function (wait) {
  return delay(this, wait);
};

// Options = {leading: boolean|undefined, trailing: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.throttle = function (wait, options) {
  return throttle(this, wait, options);
};

// Options = {immediate: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.debounce = function (wait, options) {
  return debounce(this, wait, options);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.mapErrors = function (fn) {
  return mapErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filterErrors = function (fn) {
  return filterErrors(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreValues = function () {
  return ignoreValues(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreErrors = function () {
  return ignoreErrors(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreEnd = function () {
  return ignoreEnd(this);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.beforeEnd = function (fn) {
  return beforeEnd(this, fn);
};

// (Stream, number, number|undefined) -> Stream
// (Property, number, number|undefined) -> Property
Observable.prototype.slidingWindow = function (max, min) {
  return slidingWindow(this, max, min);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Function|falsey, Options|undefined) -> Stream
// (Property, Function|falsey, Options|undefined) -> Property
Observable.prototype.bufferWhile = function (fn, options) {
  return bufferWhile(this, fn, options);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.bufferWithCount = function (count, options) {
  return bufferWhile$1(this, count, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, number, number, Options|undefined) -> Stream
// (Property, number, number, Options|undefined) -> Property
Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
  return bufferWithTimeOrCount(this, wait, count, options);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.transduce = function (transducer) {
  return transduce(this, transducer);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.withHandler = function (fn) {
  return withHandler(this, fn);
};

// (Stream, Stream -> a) -> a
// (Property, Property -> a) -> a
Observable.prototype.thru = function (fn) {
  return fn(this);
};

// Combine observables
// -----------------------------------------------------------------------------

// (Array<Stream|Property>, Function|undefiend) -> Stream
// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.combine = function (other, combinator) {
  return combine([this, other], combinator);
};

// (Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.zip = function (other, combinator) {
  return zip([this, other], combinator);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.merge = function (other) {
  return merge([this, other]);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.concat = function (other) {
  return concat$1([this, other]);
};

// () -> Pool
var pool = function () {
  return new Pool();
};

// (Function) -> Stream
// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}
// (Stream|Property, Function|falsey, Options|undefined) -> Stream
Observable.prototype.flatMap = function (fn) {
  return new FlatMap(this, fn).setName(this, 'flatMap');
};
Observable.prototype.flatMapLatest = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');
};
Observable.prototype.flatMapFirst = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
};
Observable.prototype.flatMapConcat = function (fn) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');
};
Observable.prototype.flatMapConcurLimit = function (fn, limit) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');
};

// (Stream|Property, Function|falsey) -> Stream
Observable.prototype.flatMapErrors = function (fn) {
  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
};

// Combine two observables
// -----------------------------------------------------------------------------

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.filterBy = function (other) {
  return filterBy(this, other);
};

// (Stream, Stream|Property, Function|undefiend) -> Stream
// (Property, Stream|Property, Function|undefiend) -> Property
Observable.prototype.sampledBy = function (other, combinator) {
  return sampledBy(this, other, combinator);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.skipUntilBy = function (other) {
  return skipUntilBy(this, other);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.takeUntilBy = function (other) {
  return takeUntilBy(this, other);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferBy = function (other, options) {
  return bufferBy(this, other, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferWhileBy = function (other, options) {
  return bufferWhileBy(this, other, options);
};

// Deprecated
// -----------------------------------------------------------------------------

var DEPRECATION_WARNINGS = true;
function dissableDeprecationWarnings() {
  DEPRECATION_WARNINGS = false;
}

function warn(msg) {
  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
    var msg2 = '\nHere is an Error object for you containing the call stack:';
    console.warn(msg, msg2, new Error());
  }
}

// (Stream|Property, Stream|Property) -> Property
Observable.prototype.awaiting = function (other) {
  warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');
  return awaiting(this, other);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.valuesToErrors = function (fn) {
  warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');
  return valuesToErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.errorsToValues = function (fn) {
  warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');
  return errorsToValues(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.endOnError = function () {
  warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');
  return endOnError(this);
};

// Exports
// --------------------------------------------------------------------------

var Kefir = {
  Observable: Observable,
  Stream: Stream,
  Property: Property,
  never: never,
  later: later,
  interval: interval,
  sequentially: sequentially,
  fromPoll: fromPoll,
  withInterval: withInterval,
  fromCallback: fromCallback,
  fromNodeCallback: fromNodeCallback,
  fromEvents: fromEvents,
  stream: stream,
  constant: constant,
  constantError: constantError,
  fromPromise: fromPromise,
  fromESObservable: fromESObservable,
  combine: combine,
  zip: zip,
  merge: merge,
  concat: concat$1,
  Pool: Pool,
  pool: pool,
  repeat: repeat,
  staticLand: staticLand
};

Kefir.Kefir = Kefir;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Kefir);


/***/ }),

/***/ "./assets/css/app.css":
/*!****************************!*\
  !*** ./assets/css/app.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */

;(function(root, factory) {

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

})(this, function() {
  var NProgress = {};

  NProgress.version = '0.2.0';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;

    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;

      $promise.always(function() {
        current--;
        if (current === 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });

      return this;
    };

  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});



/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/validate.js/validate.js":
/*!**********************************************!*\
  !*** ./node_modules/validate.js/validate.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
/*!
 * validate.js 0.11.1
 *
 * (c) 2013-2016 Nicklas Ansman, 2013 Wrapp
 * Validate.js may be freely distributed under the MIT license.
 * For all details and documentation:
 * http://validatejs.org/
 */

(function(exports, module, define) {
  "use strict";

  // The main function that calls the validators specified by the constraints.
  // The options are the following:
  //   - format (string) - An option that controls how the returned value is formatted
  //     * flat - Returns a flat array of just the error messages
  //     * grouped - Returns the messages grouped by attribute (default)
  //     * detailed - Returns an array of the raw validation data
  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.
  //
  // Please note that the options are also passed to each validator.
  var validate = function(attributes, constraints, options) {
    options = v.extend({}, v.options, options);

    var results = v.runValidations(attributes, constraints, options)
      , attr
      , validator;

    for (attr in results) {
      for (validator in results[attr]) {
        if (v.isPromise(results[attr][validator])) {
          throw new Error("Use validate.async if you want support for promises");
        }
      }
    }
    return validate.processValidationResults(results, options);
  };

  var v = validate;

  // Copies over attributes from one or more sources to a single destination.
  // Very much similar to underscore's extend.
  // The first argument is the target object and the remaining arguments will be
  // used as sources.
  v.extend = function(obj) {
    [].slice.call(arguments, 1).forEach(function(source) {
      for (var attr in source) {
        obj[attr] = source[attr];
      }
    });
    return obj;
  };

  v.extend(validate, {
    // This is the version of the library as a semver.
    // The toString function will allow it to be coerced into a string
    version: {
      major: 0,
      minor: 11,
      patch: 1,
      metadata: null,
      toString: function() {
        var version = v.format("%{major}.%{minor}.%{patch}", v.version);
        if (!v.isEmpty(v.version.metadata)) {
          version += "+" + v.version.metadata;
        }
        return version;
      }
    },

    // Below is the dependencies that are used in validate.js

    // The constructor of the Promise implementation.
    // If you are using Q.js, RSVP or any other A+ compatible implementation
    // override this attribute to be the constructor of that promise.
    // Since jQuery promises aren't A+ compatible they won't work.
    Promise: typeof Promise !== "undefined" ? Promise : /* istanbul ignore next */ null,

    EMPTY_STRING_REGEXP: /^\s*$/,

    // Runs the validators specified by the constraints object.
    // Will return an array of the format:
    //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
    runValidations: function(attributes, constraints, options) {
      var results = []
        , attr
        , validatorName
        , value
        , validators
        , validator
        , validatorOptions
        , error;

      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
        attributes = v.collectFormValues(attributes);
      }

      // Loops through each constraints, finds the correct validator and run it.
      for (attr in constraints) {
        value = v.getDeepObjectValue(attributes, attr);
        // This allows the constraints for an attribute to be a function.
        // The function will be called with the value, attribute name, the complete dict of
        // attributes as well as the options and constraints passed in.
        // This is useful when you want to have different
        // validations depending on the attribute value.
        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);

        for (validatorName in validators) {
          validator = v.validators[validatorName];

          if (!validator) {
            error = v.format("Unknown validator %{name}", {name: validatorName});
            throw new Error(error);
          }

          validatorOptions = validators[validatorName];
          // This allows the options to be a function. The function will be
          // called with the value, attribute name, the complete dict of
          // attributes as well as the options and constraints passed in.
          // This is useful when you want to have different
          // validations depending on the attribute value.
          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
          if (!validatorOptions) {
            continue;
          }
          results.push({
            attribute: attr,
            value: value,
            validator: validatorName,
            globalOptions: options,
            attributes: attributes,
            options: validatorOptions,
            error: validator.call(validator,
                value,
                validatorOptions,
                attr,
                attributes,
                options)
          });
        }
      }

      return results;
    },

    // Takes the output from runValidations and converts it to the correct
    // output format.
    processValidationResults: function(errors, options) {
      errors = v.pruneEmptyErrors(errors, options);
      errors = v.expandMultipleErrors(errors, options);
      errors = v.convertErrorMessages(errors, options);

      var format = options.format || "grouped";

      if (typeof v.formatters[format] === 'function') {
        errors = v.formatters[format](errors);
      } else {
        throw new Error(v.format("Unknown format %{format}", options));
      }

      return v.isEmpty(errors) ? undefined : errors;
    },

    // Runs the validations with support for promises.
    // This function will return a promise that is settled when all the
    // validation promises have been completed.
    // It can be called even if no validations returned a promise.
    async: function(attributes, constraints, options) {
      options = v.extend({}, v.async.options, options);

      var WrapErrors = options.wrapErrors || function(errors) {
        return errors;
      };

      // Removes unknown attributes
      if (options.cleanAttributes !== false) {
        attributes = v.cleanAttributes(attributes, constraints);
      }

      var results = v.runValidations(attributes, constraints, options);

      return new v.Promise(function(resolve, reject) {
        v.waitForResults(results).then(function() {
          var errors = v.processValidationResults(results, options);
          if (errors) {
            reject(new WrapErrors(errors, options, attributes, constraints));
          } else {
            resolve(attributes);
          }
        }, function(err) {
          reject(err);
        });
      });
    },

    single: function(value, constraints, options) {
      options = v.extend({}, v.single.options, options, {
        format: "flat",
        fullMessages: false
      });
      return v({single: value}, {single: constraints}, options);
    },

    // Returns a promise that is resolved when all promises in the results array
    // are settled. The promise returned from this function is always resolved,
    // never rejected.
    // This function modifies the input argument, it replaces the promises
    // with the value returned from the promise.
    waitForResults: function(results) {
      // Create a sequence of all the results starting with a resolved promise.
      return results.reduce(function(memo, result) {
        // If this result isn't a promise skip it in the sequence.
        if (!v.isPromise(result.error)) {
          return memo;
        }

        return memo.then(function() {
          return result.error.then(function(error) {
            result.error = error || null;
          });
        });
      }, new v.Promise(function(r) { r(); })); // A resolved promise
    },

    // If the given argument is a call: function the and: function return the value
    // otherwise just return the value. Additional arguments will be passed as
    // arguments to the function.
    // Example:
    // ```
    // result('foo') // 'foo'
    // result(Math.max, 1, 2) // 2
    // ```
    result: function(value) {
      var args = [].slice.call(arguments, 1);
      if (typeof value === 'function') {
        value = value.apply(null, args);
      }
      return value;
    },

    // Checks if the value is a number. This function does not consider NaN a
    // number like many other `isNumber` functions do.
    isNumber: function(value) {
      return typeof value === 'number' && !isNaN(value);
    },

    // Returns false if the object is not a function
    isFunction: function(value) {
      return typeof value === 'function';
    },

    // A simple check to verify that the value is an integer. Uses `isNumber`
    // and a simple modulo check.
    isInteger: function(value) {
      return v.isNumber(value) && value % 1 === 0;
    },

    // Checks if the value is a boolean
    isBoolean: function(value) {
      return typeof value === 'boolean';
    },

    // Uses the `Object` function to check if the given argument is an object.
    isObject: function(obj) {
      return obj === Object(obj);
    },

    // Simply checks if the object is an instance of a date
    isDate: function(obj) {
      return obj instanceof Date;
    },

    // Returns false if the object is `null` of `undefined`
    isDefined: function(obj) {
      return obj !== null && obj !== undefined;
    },

    // Checks if the given argument is a promise. Anything with a `then`
    // function is considered a promise.
    isPromise: function(p) {
      return !!p && v.isFunction(p.then);
    },

    isJqueryElement: function(o) {
      return o && v.isString(o.jquery);
    },

    isDomElement: function(o) {
      if (!o) {
        return false;
      }

      if (!o.querySelectorAll || !o.querySelector) {
        return false;
      }

      if (v.isObject(document) && o === document) {
        return true;
      }

      // http://stackoverflow.com/a/384380/699304
      /* istanbul ignore else */
      if (typeof HTMLElement === "object") {
        return o instanceof HTMLElement;
      } else {
        return o &&
          typeof o === "object" &&
          o !== null &&
          o.nodeType === 1 &&
          typeof o.nodeName === "string";
      }
    },

    isEmpty: function(value) {
      var attr;

      // Null and undefined are empty
      if (!v.isDefined(value)) {
        return true;
      }

      // functions are non empty
      if (v.isFunction(value)) {
        return false;
      }

      // Whitespace only strings are empty
      if (v.isString(value)) {
        return v.EMPTY_STRING_REGEXP.test(value);
      }

      // For arrays we use the length property
      if (v.isArray(value)) {
        return value.length === 0;
      }

      // Dates have no attributes but aren't empty
      if (v.isDate(value)) {
        return false;
      }

      // If we find at least one property we consider it non empty
      if (v.isObject(value)) {
        for (attr in value) {
          return false;
        }
        return true;
      }

      return false;
    },

    // Formats the specified strings with the given values like so:
    // ```
    // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
    // ```
    // If you want to write %{...} without having it replaced simply
    // prefix it with % like this `Foo: %%{foo}` and it will be returned
    // as `"Foo: %{foo}"`
    format: v.extend(function(str, vals) {
      if (!v.isString(str)) {
        return str;
      }
      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
        if (m1 === '%') {
          return "%{" + m2 + "}";
        } else {
          return String(vals[m2]);
        }
      });
    }, {
      // Finds %{key} style patterns in the given string
      FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
    }),

    // "Prettifies" the given string.
    // Prettifying means replacing [.\_-] with spaces as well as splitting
    // camel case words.
    prettify: function(str) {
      if (v.isNumber(str)) {
        // If there are more than 2 decimals round it to two
        if ((str * 100) % 1 === 0) {
          return "" + str;
        } else {
          return parseFloat(Math.round(str * 100) / 100).toFixed(2);
        }
      }

      if (v.isArray(str)) {
        return str.map(function(s) { return v.prettify(s); }).join(", ");
      }

      if (v.isObject(str)) {
        return str.toString();
      }

      // Ensure the string is actually a string
      str = "" + str;

      return str
        // Splits keys separated by periods
        .replace(/([^\s])\.([^\s])/g, '$1 $2')
        // Removes backslashes
        .replace(/\\+/g, '')
        // Replaces - and - with space
        .replace(/[_-]/g, ' ')
        // Splits camel cased words
        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
          return "" + m1 + " " + m2.toLowerCase();
        })
        .toLowerCase();
    },

    stringifyValue: function(value) {
      return v.prettify(value);
    },

    isString: function(value) {
      return typeof value === 'string';
    },

    isArray: function(value) {
      return {}.toString.call(value) === '[object Array]';
    },

    // Checks if the object is a hash, which is equivalent to an object that
    // is neither an array nor a function.
    isHash: function(value) {
      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
    },

    contains: function(obj, value) {
      if (!v.isDefined(obj)) {
        return false;
      }
      if (v.isArray(obj)) {
        return obj.indexOf(value) !== -1;
      }
      return value in obj;
    },

    unique: function(array) {
      if (!v.isArray(array)) {
        return array;
      }
      return array.filter(function(el, index, array) {
        return array.indexOf(el) == index;
      });
    },

    forEachKeyInKeypath: function(object, keypath, callback) {
      if (!v.isString(keypath)) {
        return undefined;
      }

      var key = ""
        , i
        , escape = false;

      for (i = 0; i < keypath.length; ++i) {
        switch (keypath[i]) {
          case '.':
            if (escape) {
              escape = false;
              key += '.';
            } else {
              object = callback(object, key, false);
              key = "";
            }
            break;

          case '\\':
            if (escape) {
              escape = false;
              key += '\\';
            } else {
              escape = true;
            }
            break;

          default:
            escape = false;
            key += keypath[i];
            break;
        }
      }

      return callback(object, key, true);
    },

    getDeepObjectValue: function(obj, keypath) {
      if (!v.isObject(obj)) {
        return undefined;
      }

      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {
        if (v.isObject(obj)) {
          return obj[key];
        }
      });
    },

    // This returns an object with all the values of the form.
    // It uses the input name as key and the value as value
    // So for example this:
    // <input type="text" name="email" value="foo@bar.com" />
    // would return:
    // {email: "foo@bar.com"}
    collectFormValues: function(form, options) {
      var values = {}
        , i
        , j
        , input
        , inputs
        , option
        , value;

      if (v.isJqueryElement(form)) {
        form = form[0];
      }

      if (!form) {
        return values;
      }

      options = options || {};

      inputs = form.querySelectorAll("input[name], textarea[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);

        if (v.isDefined(input.getAttribute("data-ignored"))) {
          continue;
        }

        value = v.sanitizeFormValue(input.value, options);
        if (input.type === "number") {
          value = value ? +value : null;
        } else if (input.type === "checkbox") {
          if (input.attributes.value) {
            if (!input.checked) {
              value = values[input.name] || null;
            }
          } else {
            value = input.checked;
          }
        } else if (input.type === "radio") {
          if (!input.checked) {
            value = values[input.name] || null;
          }
        }
        values[input.name] = value;
      }

      inputs = form.querySelectorAll("select[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);
        if (input.multiple) {
          value = [];
          for (j in input.options) {
            option = input.options[j];
            if (option.selected) {
              value.push(v.sanitizeFormValue(option.value, options));
            }
          }
        } else {
          value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
        }
        values[input.name] = value;
      }

      return values;
    },

    sanitizeFormValue: function(value, options) {
      if (options.trim && v.isString(value)) {
        value = value.trim();
      }

      if (options.nullify !== false && value === "") {
        return null;
      }
      return value;
    },

    capitalize: function(str) {
      if (!v.isString(str)) {
        return str;
      }
      return str[0].toUpperCase() + str.slice(1);
    },

    // Remove all errors who's error attribute is empty (null or undefined)
    pruneEmptyErrors: function(errors) {
      return errors.filter(function(error) {
        return !v.isEmpty(error.error);
      });
    },

    // In
    // [{error: ["err1", "err2"], ...}]
    // Out
    // [{error: "err1", ...}, {error: "err2", ...}]
    //
    // All attributes in an error with multiple messages are duplicated
    // when expanding the errors.
    expandMultipleErrors: function(errors) {
      var ret = [];
      errors.forEach(function(error) {
        // Removes errors without a message
        if (v.isArray(error.error)) {
          error.error.forEach(function(msg) {
            ret.push(v.extend({}, error, {error: msg}));
          });
        } else {
          ret.push(error);
        }
      });
      return ret;
    },

    // Converts the error mesages by prepending the attribute name unless the
    // message is prefixed by ^
    convertErrorMessages: function(errors, options) {
      options = options || {};

      var ret = [];
      errors.forEach(function(errorInfo) {
        var error = v.result(errorInfo.error,
            errorInfo.value,
            errorInfo.attribute,
            errorInfo.options,
            errorInfo.attributes,
            errorInfo.globalOptions);

        if (!v.isString(error)) {
          ret.push(errorInfo);
          return;
        }

        if (error[0] === '^') {
          error = error.slice(1);
        } else if (options.fullMessages !== false) {
          error = v.capitalize(v.prettify(errorInfo.attribute)) + " " + error;
        }
        error = error.replace(/\\\^/g, "^");
        error = v.format(error, {value: v.stringifyValue(errorInfo.value)});
        ret.push(v.extend({}, errorInfo, {error: error}));
      });
      return ret;
    },

    // In:
    // [{attribute: "<attributeName>", ...}]
    // Out:
    // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
    groupErrorsByAttribute: function(errors) {
      var ret = {};
      errors.forEach(function(error) {
        var list = ret[error.attribute];
        if (list) {
          list.push(error);
        } else {
          ret[error.attribute] = [error];
        }
      });
      return ret;
    },

    // In:
    // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
    // Out:
    // ["<message 1>", "<message 2>"]
    flattenErrorsToArray: function(errors) {
      return errors
        .map(function(error) { return error.error; })
        .filter(function(value, index, self) {
          return self.indexOf(value) === index;
        });
    },

    cleanAttributes: function(attributes, whitelist) {
      function whitelistCreator(obj, key, last) {
        if (v.isObject(obj[key])) {
          return obj[key];
        }
        return (obj[key] = last ? true : {});
      }

      function buildObjectWhitelist(whitelist) {
        var ow = {}
          , lastObject
          , attr;
        for (attr in whitelist) {
          if (!whitelist[attr]) {
            continue;
          }
          v.forEachKeyInKeypath(ow, attr, whitelistCreator);
        }
        return ow;
      }

      function cleanRecursive(attributes, whitelist) {
        if (!v.isObject(attributes)) {
          return attributes;
        }

        var ret = v.extend({}, attributes)
          , w
          , attribute;

        for (attribute in attributes) {
          w = whitelist[attribute];

          if (v.isObject(w)) {
            ret[attribute] = cleanRecursive(ret[attribute], w);
          } else if (!w) {
            delete ret[attribute];
          }
        }
        return ret;
      }

      if (!v.isObject(whitelist) || !v.isObject(attributes)) {
        return {};
      }

      whitelist = buildObjectWhitelist(whitelist);
      return cleanRecursive(attributes, whitelist);
    },

    exposeModule: function(validate, root, exports, module, define) {
      if (exports) {
        if (module && module.exports) {
          exports = module.exports = validate;
        }
        exports.validate = validate;
      } else {
        root.validate = validate;
        if (validate.isFunction(define) && define.amd) {
          define([], function () { return validate; });
        }
      }
    },

    warn: function(msg) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("[validate.js] " + msg);
      }
    },

    error: function(msg) {
      if (typeof console !== "undefined" && console.error) {
        console.error("[validate.js] " + msg);
      }
    }
  });

  validate.validators = {
    // Presence validates that the value isn't empty
    presence: function(value, options) {
      options = v.extend({}, this.options, options);
      if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
        return options.message || this.message || "can't be blank";
      }
    },
    length: function(value, options, attribute) {
      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var is = options.is
        , maximum = options.maximum
        , minimum = options.minimum
        , tokenizer = options.tokenizer || function(val) { return val; }
        , err
        , errors = [];

      value = tokenizer(value);
      var length = value.length;
      if(!v.isNumber(length)) {
        v.error(v.format("Attribute %{attr} has a non numeric value for `length`", {attr: attribute}));
        return options.message || this.notValid || "has an incorrect length";
      }

      // Is checks
      if (v.isNumber(is) && length !== is) {
        err = options.wrongLength ||
          this.wrongLength ||
          "is the wrong length (should be %{count} characters)";
        errors.push(v.format(err, {count: is}));
      }

      if (v.isNumber(minimum) && length < minimum) {
        err = options.tooShort ||
          this.tooShort ||
          "is too short (minimum is %{count} characters)";
        errors.push(v.format(err, {count: minimum}));
      }

      if (v.isNumber(maximum) && length > maximum) {
        err = options.tooLong ||
          this.tooLong ||
          "is too long (maximum is %{count} characters)";
        errors.push(v.format(err, {count: maximum}));
      }

      if (errors.length > 0) {
        return options.message || errors;
      }
    },
    numericality: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var errors = []
        , name
        , count
        , checks = {
            greaterThan:          function(v, c) { return v > c; },
            greaterThanOrEqualTo: function(v, c) { return v >= c; },
            equalTo:              function(v, c) { return v === c; },
            lessThan:             function(v, c) { return v < c; },
            lessThanOrEqualTo:    function(v, c) { return v <= c; },
            divisibleBy:          function(v, c) { return v % c === 0; }
          };

      // Strict will check that it is a valid looking number
      if (v.isString(value) && options.strict) {
        var pattern = "^(0|[1-9]\\d*)";
        if (!options.onlyInteger) {
          pattern += "(\\.\\d+)?";
        }
        pattern += "$";

        if (!(new RegExp(pattern).test(value))) {
          return options.message ||
            options.notValid ||
            this.notValid ||
            this.message ||
            "must be a valid number";
        }
      }

      // Coerce the value to a number unless we're being strict.
      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
        value = +value;
      }

      // If it's not a number we shouldn't continue since it will compare it.
      if (!v.isNumber(value)) {
        return options.message ||
          options.notValid ||
          this.notValid ||
          this.message ||
          "is not a number";
      }

      // Same logic as above, sort of. Don't bother with comparisons if this
      // doesn't pass.
      if (options.onlyInteger && !v.isInteger(value)) {
        return options.message ||
          options.notInteger ||
          this.notInteger ||
          this.message ||
          "must be an integer";
      }

      for (name in checks) {
        count = options[name];
        if (v.isNumber(count) && !checks[name](value, count)) {
          // This picks the default message if specified
          // For example the greaterThan check uses the message from
          // this.notGreaterThan so we capitalize the name and prepend "not"
          var key = "not" + v.capitalize(name);
          var msg = options[key] ||
            this[key] ||
            this.message ||
            "must be %{type} %{count}";

          errors.push(v.format(msg, {
            count: count,
            type: v.prettify(name)
          }));
        }
      }

      if (options.odd && value % 2 !== 1) {
        errors.push(options.notOdd ||
            this.notOdd ||
            this.message ||
            "must be odd");
      }
      if (options.even && value % 2 !== 0) {
        errors.push(options.notEven ||
            this.notEven ||
            this.message ||
            "must be even");
      }

      if (errors.length) {
        return options.message || errors;
      }
    },
    datetime: v.extend(function(value, options) {
      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
        throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
      }

      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var err
        , errors = []
        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN
        , latest = options.latest ? this.parse(options.latest, options) : NaN;

      value = this.parse(value, options);

      // 86400000 is the number of seconds in a day, this is used to remove
      // the time from the date
      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
        err = options.notValid ||
          options.message ||
          this.notValid ||
          "must be a valid date";
        return v.format(err, {value: arguments[0]});
      }

      if (!isNaN(earliest) && value < earliest) {
        err = options.tooEarly ||
          options.message ||
          this.tooEarly ||
          "must be no earlier than %{date}";
        err = v.format(err, {
          value: this.format(value, options),
          date: this.format(earliest, options)
        });
        errors.push(err);
      }

      if (!isNaN(latest) && value > latest) {
        err = options.tooLate ||
          options.message ||
          this.tooLate ||
          "must be no later than %{date}";
        err = v.format(err, {
          date: this.format(latest, options),
          value: this.format(value, options)
        });
        errors.push(err);
      }

      if (errors.length) {
        return v.unique(errors);
      }
    }, {
      parse: null,
      format: null
    }),
    date: function(value, options) {
      options = v.extend({}, options, {dateOnly: true});
      return v.validators.datetime.call(v.validators.datetime, value, options);
    },
    format: function(value, options) {
      if (v.isString(options) || (options instanceof RegExp)) {
        options = {pattern: options};
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is invalid"
        , pattern = options.pattern
        , match;

      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }

      if (v.isString(pattern)) {
        pattern = new RegExp(options.pattern, options.flags);
      }
      match = pattern.exec(value);
      if (!match || match[0].length != value.length) {
        return message;
      }
    },
    inclusion: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (v.contains(options.within, value)) {
        return;
      }
      var message = options.message ||
        this.message ||
        "^%{value} is not included in the list";
      return v.format(message, {value: value});
    },
    exclusion: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (!v.contains(options.within, value)) {
        return;
      }
      var message = options.message || this.message || "^%{value} is restricted";
      return v.format(message, {value: value});
    },
    email: v.extend(function(value, options) {
      options = v.extend({}, this.options, options);
      var message = options.message || this.message || "is not a valid email";
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }
      if (!this.PATTERN.exec(value)) {
        return message;
      }
    }, {
      PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i
    }),
    equality: function(value, options, attribute, attributes) {
      if (!v.isDefined(value)) {
        return;
      }

      if (v.isString(options)) {
        options = {attribute: options};
      }
      options = v.extend({}, this.options, options);
      var message = options.message ||
        this.message ||
        "is not equal to %{attribute}";

      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
        throw new Error("The attribute must be a non empty string");
      }

      var otherValue = v.getDeepObjectValue(attributes, options.attribute)
        , comparator = options.comparator || function(v1, v2) {
          return v1 === v2;
        };

      if (!comparator(value, otherValue, options, attribute, attributes)) {
        return v.format(message, {attribute: v.prettify(options.attribute)});
      }
    },

    // A URL validator that is used to validate URLs with the ability to
    // restrict schemes and some domains.
    url: function(value, options) {
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is not a valid url"
        , schemes = options.schemes || this.schemes || ['http', 'https']
        , allowLocal = options.allowLocal || this.allowLocal || false;

      if (!v.isString(value)) {
        return message;
      }

      // https://gist.github.com/dperini/729294
      var regex =
        "^" +
        // protocol identifier
        "(?:(?:" + schemes.join("|") + ")://)" +
        // user:pass authentication
        "(?:\\S+(?::\\S*)?@)?" +
        "(?:";

      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";

      if (allowLocal) {
        tld += "?";
      } else {
        regex +=
          // IP address exclusion
          // private & local networks
          "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
          "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
          "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})";
      }

      regex +=
          // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
        "|" +
          // host name
          "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
          // domain name
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
          tld +
        ")" +
        // port number
        "(?::\\d{2,5})?" +
        // resource path
        "(?:[/?#]\\S*)?" +
      "$";

      var PATTERN = new RegExp(regex, 'i');
      if (!PATTERN.exec(value)) {
        return message;
      }
    }
  };

  validate.formatters = {
    detailed: function(errors) {return errors;},
    flat: v.flattenErrorsToArray,
    grouped: function(errors) {
      var attr;

      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = v.flattenErrorsToArray(errors[attr]);
      }
      return errors;
    },
    constraint: function(errors) {
      var attr;
      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = errors[attr].map(function(result) {
          return result.validator;
        }).sort();
      }
      return errors;
    }
  };

  validate.exposeModule(validate, this, exports, module, __webpack_require__.amdD);
}).call(this,
         true ? /* istanbul ignore next */ exports : 0,
         true ? /* istanbul ignore next */ module : 0,
        __webpack_require__.amdD);


/***/ })

},
0,[["./assets/js/app.js","runtime"]]]);